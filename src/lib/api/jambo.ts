import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
const defaultOptions = {} as const;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  BigFloat: { input: any; output: any; }
  Cursor: { input: any; output: any; }
  Datetime: { input: string; output: string; }
  UUID: { input: any; output: any; }
};

export type AcceptQuoteInput = {
  date: Scalars['String']['input'];
  email: Scalars['String']['input'];
  key: Scalars['String']['input'];
  name: Scalars['String']['input'];
  source: Scalars['String']['input'];
};

export type Account = {
  __typename?: 'Account';
  created: Scalars['Datetime']['output'];
  details?: Maybe<Scalars['String']['output']>;
  id: Scalars['UUID']['output'];
  institution?: Maybe<Scalars['String']['output']>;
  modified: Scalars['Datetime']['output'];
  name?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `TransactionImportBatch`. */
  transactionImportBatches: TransactionImportBatchesConnection;
  /** Reads and enables pagination through a set of `Transaction`. */
  transactions: TransactionsConnection;
};


export type AccountTransactionImportBatchesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TransactionImportBatchCondition>;
  filter?: InputMaybe<TransactionImportBatchFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TransactionImportBatchesOrderBy>>;
};


export type AccountTransactionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TransactionCondition>;
  filter?: InputMaybe<TransactionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TransactionsOrderBy>>;
};

/** A condition to be used against `Account` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type AccountCondition = {
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `details` field. */
  details?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `institution` field. */
  institution?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `Account` object types. All fields are combined with a logical ‘and.’ */
export type AccountFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<AccountFilter>>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `details` field. */
  details?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `institution` field. */
  institution?: InputMaybe<StringFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<AccountFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<AccountFilter>>;
  /** Filter by the object’s `transactionImportBatches` relation. */
  transactionImportBatches?: InputMaybe<AccountToManyTransactionImportBatchFilter>;
  /** Some related `transactionImportBatches` exist. */
  transactionImportBatchesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `transactions` relation. */
  transactions?: InputMaybe<AccountToManyTransactionFilter>;
  /** Some related `transactions` exist. */
  transactionsExist?: InputMaybe<Scalars['Boolean']['input']>;
};

/** An input for mutations affecting `Account` */
export type AccountInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  details?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  institution?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  transactionImportBatchesUsingId?: InputMaybe<FkTransactionImportBatchAccountAccountIdInverseInput>;
  transactionsUsingId?: InputMaybe<FkTransactionAccountAccountIdInverseInput>;
};

/** The fields on `account` to look up the row to update. */
export type AccountOnTransactionForFkTransactionAccountAccountIdUsingPkAccountUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `account` being updated. */
  patch: UpdateAccountOnTransactionForFkTransactionAccountAccountIdPatch;
};

/** The fields on `account` to look up the row to update. */
export type AccountOnTransactionImportBatchForFkTransactionImportBatchAccountAccountIdUsingPkAccountUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `account` being updated. */
  patch: UpdateAccountOnTransactionImportBatchForFkTransactionImportBatchAccountAccountIdPatch;
};

/** Represents an update to a `Account`. Fields that are set will be updated. */
export type AccountPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  details?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  institution?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  transactionImportBatchesUsingId?: InputMaybe<FkTransactionImportBatchAccountAccountIdInverseInput>;
  transactionsUsingId?: InputMaybe<FkTransactionAccountAccountIdInverseInput>;
};

/** The fields on `account` to look up the row to connect. */
export type AccountPkAccountConnect = {
  id: Scalars['UUID']['input'];
};

/** The fields on `account` to look up the row to delete. */
export type AccountPkAccountDelete = {
  id: Scalars['UUID']['input'];
};

/** A filter to be used against many `Transaction` object types. All fields are combined with a logical ‘and.’ */
export type AccountToManyTransactionFilter = {
  /** Every related `Transaction` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<TransactionFilter>;
  /** No related `Transaction` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<TransactionFilter>;
  /** Some related `Transaction` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<TransactionFilter>;
};

/** A filter to be used against many `TransactionImportBatch` object types. All fields are combined with a logical ‘and.’ */
export type AccountToManyTransactionImportBatchFilter = {
  /** Every related `TransactionImportBatch` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<TransactionImportBatchFilter>;
  /** No related `TransactionImportBatch` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<TransactionImportBatchFilter>;
  /** Some related `TransactionImportBatch` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<TransactionImportBatchFilter>;
};

/** A connection to a list of `Account` values. */
export type AccountsConnection = {
  __typename?: 'AccountsConnection';
  /** A list of edges which contains the `Account` and cursor to aid in pagination. */
  edges: Array<AccountsEdge>;
  /** A list of `Account` objects. */
  nodes: Array<Maybe<Account>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Account` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Account` edge in the connection. */
export type AccountsEdge = {
  __typename?: 'AccountsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Account` at the end of the edge. */
  node?: Maybe<Account>;
};

/** Methods to use when ordering `Account`. */
export enum AccountsOrderBy {
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  DetailsAsc = 'DETAILS_ASC',
  DetailsDesc = 'DETAILS_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  InstitutionAsc = 'INSTITUTION_ASC',
  InstitutionDesc = 'INSTITUTION_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TransactionsByAccountIdCountAsc = 'TRANSACTIONS_BY_ACCOUNT_ID__COUNT_ASC',
  TransactionsByAccountIdCountDesc = 'TRANSACTIONS_BY_ACCOUNT_ID__COUNT_DESC',
  TransactionImportBatchesByAccountIdCountAsc = 'TRANSACTION_IMPORT_BATCHES_BY_ACCOUNT_ID__COUNT_ASC',
  TransactionImportBatchesByAccountIdCountDesc = 'TRANSACTION_IMPORT_BATCHES_BY_ACCOUNT_ID__COUNT_DESC'
}

/** A connection to a list of `Agency` values. */
export type AgenciesConnection = {
  __typename?: 'AgenciesConnection';
  /** A list of edges which contains the `Agency` and cursor to aid in pagination. */
  edges: Array<AgenciesEdge>;
  /** A list of `Agency` objects. */
  nodes: Array<Maybe<Agency>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Agency` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Agency` edge in the connection. */
export type AgenciesEdge = {
  __typename?: 'AgenciesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Agency` at the end of the edge. */
  node?: Maybe<Agency>;
};

/** Methods to use when ordering `Agency`. */
export enum AgenciesOrderBy {
  AgencyMembersByAgencyIdCountAsc = 'AGENCY_MEMBERS_BY_AGENCY_ID__COUNT_ASC',
  AgencyMembersByAgencyIdCountDesc = 'AGENCY_MEMBERS_BY_AGENCY_ID__COUNT_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LogoIdAsc = 'LOGO_ID_ASC',
  LogoIdDesc = 'LOGO_ID_DESC',
  MediaItemByLogoIdContentTypeAsc = 'MEDIA_ITEM_BY_LOGO_ID__CONTENT_TYPE_ASC',
  MediaItemByLogoIdContentTypeDesc = 'MEDIA_ITEM_BY_LOGO_ID__CONTENT_TYPE_DESC',
  MediaItemByLogoIdCreatedAsc = 'MEDIA_ITEM_BY_LOGO_ID__CREATED_ASC',
  MediaItemByLogoIdCreatedDesc = 'MEDIA_ITEM_BY_LOGO_ID__CREATED_DESC',
  MediaItemByLogoIdFileNameAsc = 'MEDIA_ITEM_BY_LOGO_ID__FILE_NAME_ASC',
  MediaItemByLogoIdFileNameDesc = 'MEDIA_ITEM_BY_LOGO_ID__FILE_NAME_DESC',
  MediaItemByLogoIdHashAsc = 'MEDIA_ITEM_BY_LOGO_ID__HASH_ASC',
  MediaItemByLogoIdHashDesc = 'MEDIA_ITEM_BY_LOGO_ID__HASH_DESC',
  MediaItemByLogoIdIdAsc = 'MEDIA_ITEM_BY_LOGO_ID__ID_ASC',
  MediaItemByLogoIdIdDesc = 'MEDIA_ITEM_BY_LOGO_ID__ID_DESC',
  MediaItemByLogoIdModifiedAsc = 'MEDIA_ITEM_BY_LOGO_ID__MODIFIED_ASC',
  MediaItemByLogoIdModifiedDesc = 'MEDIA_ITEM_BY_LOGO_ID__MODIFIED_DESC',
  MediaItemByLogoIdNameAsc = 'MEDIA_ITEM_BY_LOGO_ID__NAME_ASC',
  MediaItemByLogoIdNameDesc = 'MEDIA_ITEM_BY_LOGO_ID__NAME_DESC',
  MediaItemByLogoIdSummaryAsc = 'MEDIA_ITEM_BY_LOGO_ID__SUMMARY_ASC',
  MediaItemByLogoIdSummaryDesc = 'MEDIA_ITEM_BY_LOGO_ID__SUMMARY_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SupplierBySupplierIdBankDetailsAsc = 'SUPPLIER_BY_SUPPLIER_ID__BANK_DETAILS_ASC',
  SupplierBySupplierIdBankDetailsDesc = 'SUPPLIER_BY_SUPPLIER_ID__BANK_DETAILS_DESC',
  SupplierBySupplierIdContactEmailAsc = 'SUPPLIER_BY_SUPPLIER_ID__CONTACT_EMAIL_ASC',
  SupplierBySupplierIdContactEmailDesc = 'SUPPLIER_BY_SUPPLIER_ID__CONTACT_EMAIL_DESC',
  SupplierBySupplierIdContactNumberAsc = 'SUPPLIER_BY_SUPPLIER_ID__CONTACT_NUMBER_ASC',
  SupplierBySupplierIdContactNumberDesc = 'SUPPLIER_BY_SUPPLIER_ID__CONTACT_NUMBER_DESC',
  SupplierBySupplierIdCreatedAsc = 'SUPPLIER_BY_SUPPLIER_ID__CREATED_ASC',
  SupplierBySupplierIdCreatedDesc = 'SUPPLIER_BY_SUPPLIER_ID__CREATED_DESC',
  SupplierBySupplierIdGalleryIdAsc = 'SUPPLIER_BY_SUPPLIER_ID__GALLERY_ID_ASC',
  SupplierBySupplierIdGalleryIdDesc = 'SUPPLIER_BY_SUPPLIER_ID__GALLERY_ID_DESC',
  SupplierBySupplierIdIdAsc = 'SUPPLIER_BY_SUPPLIER_ID__ID_ASC',
  SupplierBySupplierIdIdDesc = 'SUPPLIER_BY_SUPPLIER_ID__ID_DESC',
  SupplierBySupplierIdModifiedAsc = 'SUPPLIER_BY_SUPPLIER_ID__MODIFIED_ASC',
  SupplierBySupplierIdModifiedDesc = 'SUPPLIER_BY_SUPPLIER_ID__MODIFIED_DESC',
  SupplierBySupplierIdNameAsc = 'SUPPLIER_BY_SUPPLIER_ID__NAME_ASC',
  SupplierBySupplierIdNameDesc = 'SUPPLIER_BY_SUPPLIER_ID__NAME_DESC',
  SupplierBySupplierIdRegionAsc = 'SUPPLIER_BY_SUPPLIER_ID__REGION_ASC',
  SupplierBySupplierIdRegionDesc = 'SUPPLIER_BY_SUPPLIER_ID__REGION_DESC',
  SupplierBySupplierIdUrlAsc = 'SUPPLIER_BY_SUPPLIER_ID__URL_ASC',
  SupplierBySupplierIdUrlDesc = 'SUPPLIER_BY_SUPPLIER_ID__URL_DESC',
  SupplierIdAsc = 'SUPPLIER_ID_ASC',
  SupplierIdDesc = 'SUPPLIER_ID_DESC',
  TripsByAgencyIdCountAsc = 'TRIPS_BY_AGENCY_ID__COUNT_ASC',
  TripsByAgencyIdCountDesc = 'TRIPS_BY_AGENCY_ID__COUNT_DESC'
}

export type Agency = {
  __typename?: 'Agency';
  /** Reads and enables pagination through a set of `AgencyMember`. */
  agencyMembers: AgencyMembersConnection;
  created: Scalars['Datetime']['output'];
  id: Scalars['UUID']['output'];
  /** Reads a single `MediaItem` that is related to this `Agency`. */
  logo?: Maybe<MediaItem>;
  logoId?: Maybe<Scalars['UUID']['output']>;
  modified: Scalars['Datetime']['output'];
  name?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Supplier` that is related to this `Agency`. */
  supplier?: Maybe<Supplier>;
  supplierId?: Maybe<Scalars['UUID']['output']>;
  /** Reads and enables pagination through a set of `Trip`. */
  trips: TripsConnection;
};


export type AgencyAgencyMembersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AgencyMemberCondition>;
  filter?: InputMaybe<AgencyMemberFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AgencyMembersOrderBy>>;
};


export type AgencyTripsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TripCondition>;
  filter?: InputMaybe<TripFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TripsOrderBy>>;
};

/** A condition to be used against `Agency` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type AgencyCondition = {
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `logoId` field. */
  logoId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `supplierId` field. */
  supplierId?: InputMaybe<Scalars['UUID']['input']>;
};

/** A filter to be used against `Agency` object types. All fields are combined with a logical ‘and.’ */
export type AgencyFilter = {
  /** Filter by the object’s `agencyMembers` relation. */
  agencyMembers?: InputMaybe<AgencyToManyAgencyMemberFilter>;
  /** Some related `agencyMembers` exist. */
  agencyMembersExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<AgencyFilter>>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `logo` relation. */
  logo?: InputMaybe<MediaItemFilter>;
  /** A related `logo` exists. */
  logoExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `logoId` field. */
  logoId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<AgencyFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<AgencyFilter>>;
  /** Filter by the object’s `supplier` relation. */
  supplier?: InputMaybe<SupplierFilter>;
  /** A related `supplier` exists. */
  supplierExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `supplierId` field. */
  supplierId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `trips` relation. */
  trips?: InputMaybe<AgencyToManyTripFilter>;
  /** Some related `trips` exist. */
  tripsExist?: InputMaybe<Scalars['Boolean']['input']>;
};

/** An input for mutations affecting `Agency` */
export type AgencyInput = {
  agencyMembersUsingId?: InputMaybe<FkAgencyMemberAgencyAgencyIdInverseInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  logoId?: InputMaybe<Scalars['UUID']['input']>;
  mediaItemToLogoId?: InputMaybe<FkAgencyMediaItemLogoIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  supplierId?: InputMaybe<Scalars['UUID']['input']>;
  supplierToSupplierId?: InputMaybe<FkAgencySupplierInput>;
  tripsUsingId?: InputMaybe<FkTripAgencyAgencyIdInverseInput>;
};

export type AgencyMember = {
  __typename?: 'AgencyMember';
  /** Reads a single `Agency` that is related to this `AgencyMember`. */
  agency?: Maybe<Agency>;
  agencyId: Scalars['UUID']['output'];
  created: Scalars['Datetime']['output'];
  email?: Maybe<Scalars['String']['output']>;
  firstName?: Maybe<Scalars['String']['output']>;
  genderPreposition?: Maybe<Scalars['String']['output']>;
  id: Scalars['UUID']['output'];
  lastName?: Maybe<Scalars['String']['output']>;
  modified: Scalars['Datetime']['output'];
  phone?: Maybe<Scalars['String']['output']>;
  skype?: Maybe<Scalars['String']['output']>;
  title?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `Trip`. */
  trips: TripsConnection;
};


export type AgencyMemberTripsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TripCondition>;
  filter?: InputMaybe<TripFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TripsOrderBy>>;
};

/**
 * A condition to be used against `AgencyMember` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type AgencyMemberCondition = {
  /** Checks for equality with the object’s `agencyId` field. */
  agencyId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `email` field. */
  email?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `firstName` field. */
  firstName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `genderPreposition` field. */
  genderPreposition?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `lastName` field. */
  lastName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `phone` field. */
  phone?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `skype` field. */
  skype?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `title` field. */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `AgencyMember` object types. All fields are combined with a logical ‘and.’ */
export type AgencyMemberFilter = {
  /** Filter by the object’s `agency` relation. */
  agency?: InputMaybe<AgencyFilter>;
  /** Filter by the object’s `agencyId` field. */
  agencyId?: InputMaybe<UuidFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<AgencyMemberFilter>>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `email` field. */
  email?: InputMaybe<StringFilter>;
  /** Filter by the object’s `firstName` field. */
  firstName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `genderPreposition` field. */
  genderPreposition?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `lastName` field. */
  lastName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<AgencyMemberFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<AgencyMemberFilter>>;
  /** Filter by the object’s `phone` field. */
  phone?: InputMaybe<StringFilter>;
  /** Filter by the object’s `skype` field. */
  skype?: InputMaybe<StringFilter>;
  /** Filter by the object’s `title` field. */
  title?: InputMaybe<StringFilter>;
  /** Filter by the object’s `trips` relation. */
  trips?: InputMaybe<AgencyMemberToManyTripFilter>;
  /** Some related `trips` exist. */
  tripsExist?: InputMaybe<Scalars['Boolean']['input']>;
};

/** An input for mutations affecting `AgencyMember` */
export type AgencyMemberInput = {
  agencyId?: InputMaybe<Scalars['UUID']['input']>;
  agencyToAgencyId?: InputMaybe<FkAgencyMemberAgencyAgencyIdInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  genderPreposition?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  skype?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  tripsUsingId?: InputMaybe<FkTripAgencyMemberAgencyMemberIdInverseInput>;
};

/** The fields on `agencyMember` to look up the row to update. */
export type AgencyMemberOnAgencyMemberForFkAgencyMemberAgencyAgencyIdUsingPkAgencyMemberUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `agencyMember` being updated. */
  patch: UpdateAgencyMemberOnAgencyMemberForFkAgencyMemberAgencyAgencyIdPatch;
};

/** The fields on `agencyMember` to look up the row to update. */
export type AgencyMemberOnTripForFkTripAgencyMemberAgencyMemberIdUsingPkAgencyMemberUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `agencyMember` being updated. */
  patch: UpdateAgencyMemberOnTripForFkTripAgencyMemberAgencyMemberIdPatch;
};

/** Represents an update to a `AgencyMember`. Fields that are set will be updated. */
export type AgencyMemberPatch = {
  agencyId?: InputMaybe<Scalars['UUID']['input']>;
  agencyToAgencyId?: InputMaybe<FkAgencyMemberAgencyAgencyIdInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  genderPreposition?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  skype?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  tripsUsingId?: InputMaybe<FkTripAgencyMemberAgencyMemberIdInverseInput>;
};

/** The fields on `agencyMember` to look up the row to connect. */
export type AgencyMemberPkAgencyMemberConnect = {
  id: Scalars['UUID']['input'];
};

/** The fields on `agencyMember` to look up the row to delete. */
export type AgencyMemberPkAgencyMemberDelete = {
  id: Scalars['UUID']['input'];
};

/** A filter to be used against many `Trip` object types. All fields are combined with a logical ‘and.’ */
export type AgencyMemberToManyTripFilter = {
  /** Every related `Trip` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<TripFilter>;
  /** No related `Trip` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<TripFilter>;
  /** Some related `Trip` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<TripFilter>;
};

/** A connection to a list of `AgencyMember` values. */
export type AgencyMembersConnection = {
  __typename?: 'AgencyMembersConnection';
  /** A list of edges which contains the `AgencyMember` and cursor to aid in pagination. */
  edges: Array<AgencyMembersEdge>;
  /** A list of `AgencyMember` objects. */
  nodes: Array<Maybe<AgencyMember>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `AgencyMember` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `AgencyMember` edge in the connection. */
export type AgencyMembersEdge = {
  __typename?: 'AgencyMembersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `AgencyMember` at the end of the edge. */
  node?: Maybe<AgencyMember>;
};

/** Methods to use when ordering `AgencyMember`. */
export enum AgencyMembersOrderBy {
  AgencyByAgencyIdCreatedAsc = 'AGENCY_BY_AGENCY_ID__CREATED_ASC',
  AgencyByAgencyIdCreatedDesc = 'AGENCY_BY_AGENCY_ID__CREATED_DESC',
  AgencyByAgencyIdIdAsc = 'AGENCY_BY_AGENCY_ID__ID_ASC',
  AgencyByAgencyIdIdDesc = 'AGENCY_BY_AGENCY_ID__ID_DESC',
  AgencyByAgencyIdLogoIdAsc = 'AGENCY_BY_AGENCY_ID__LOGO_ID_ASC',
  AgencyByAgencyIdLogoIdDesc = 'AGENCY_BY_AGENCY_ID__LOGO_ID_DESC',
  AgencyByAgencyIdModifiedAsc = 'AGENCY_BY_AGENCY_ID__MODIFIED_ASC',
  AgencyByAgencyIdModifiedDesc = 'AGENCY_BY_AGENCY_ID__MODIFIED_DESC',
  AgencyByAgencyIdNameAsc = 'AGENCY_BY_AGENCY_ID__NAME_ASC',
  AgencyByAgencyIdNameDesc = 'AGENCY_BY_AGENCY_ID__NAME_DESC',
  AgencyByAgencyIdSupplierIdAsc = 'AGENCY_BY_AGENCY_ID__SUPPLIER_ID_ASC',
  AgencyByAgencyIdSupplierIdDesc = 'AGENCY_BY_AGENCY_ID__SUPPLIER_ID_DESC',
  AgencyIdAsc = 'AGENCY_ID_ASC',
  AgencyIdDesc = 'AGENCY_ID_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  EmailAsc = 'EMAIL_ASC',
  EmailDesc = 'EMAIL_DESC',
  FirstNameAsc = 'FIRST_NAME_ASC',
  FirstNameDesc = 'FIRST_NAME_DESC',
  GenderPrepositionAsc = 'GENDER_PREPOSITION_ASC',
  GenderPrepositionDesc = 'GENDER_PREPOSITION_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LastNameAsc = 'LAST_NAME_ASC',
  LastNameDesc = 'LAST_NAME_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  Natural = 'NATURAL',
  PhoneAsc = 'PHONE_ASC',
  PhoneDesc = 'PHONE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SkypeAsc = 'SKYPE_ASC',
  SkypeDesc = 'SKYPE_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC',
  TripsByAgencyMemberIdCountAsc = 'TRIPS_BY_AGENCY_MEMBER_ID__COUNT_ASC',
  TripsByAgencyMemberIdCountDesc = 'TRIPS_BY_AGENCY_MEMBER_ID__COUNT_DESC'
}

/** The fields on `agency` to look up the row to update. */
export type AgencyOnAgencyForFkAgencyMediaItemLogoIdUsingPkAgencyUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `agency` being updated. */
  patch: UpdateAgencyOnAgencyForFkAgencyMediaItemLogoIdPatch;
};

/** The fields on `agency` to look up the row to update. */
export type AgencyOnAgencyForFkAgencySupplierUsingPkAgencyUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `agency` being updated. */
  patch: UpdateAgencyOnAgencyForFkAgencySupplierPatch;
};

/** The fields on `agency` to look up the row to update. */
export type AgencyOnAgencyMemberForFkAgencyMemberAgencyAgencyIdUsingPkAgencyUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `agency` being updated. */
  patch: UpdateAgencyOnAgencyMemberForFkAgencyMemberAgencyAgencyIdPatch;
};

/** The fields on `agency` to look up the row to update. */
export type AgencyOnTripForFkTripAgencyAgencyIdUsingPkAgencyUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `agency` being updated. */
  patch: UpdateAgencyOnTripForFkTripAgencyAgencyIdPatch;
};

/** Represents an update to a `Agency`. Fields that are set will be updated. */
export type AgencyPatch = {
  agencyMembersUsingId?: InputMaybe<FkAgencyMemberAgencyAgencyIdInverseInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  logoId?: InputMaybe<Scalars['UUID']['input']>;
  mediaItemToLogoId?: InputMaybe<FkAgencyMediaItemLogoIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  supplierId?: InputMaybe<Scalars['UUID']['input']>;
  supplierToSupplierId?: InputMaybe<FkAgencySupplierInput>;
  tripsUsingId?: InputMaybe<FkTripAgencyAgencyIdInverseInput>;
};

/** The fields on `agency` to look up the row to connect. */
export type AgencyPkAgencyConnect = {
  id: Scalars['UUID']['input'];
};

/** The fields on `agency` to look up the row to delete. */
export type AgencyPkAgencyDelete = {
  id: Scalars['UUID']['input'];
};

/** A filter to be used against many `AgencyMember` object types. All fields are combined with a logical ‘and.’ */
export type AgencyToManyAgencyMemberFilter = {
  /** Every related `AgencyMember` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<AgencyMemberFilter>;
  /** No related `AgencyMember` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<AgencyMemberFilter>;
  /** Some related `AgencyMember` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<AgencyMemberFilter>;
};

/** A filter to be used against many `Trip` object types. All fields are combined with a logical ‘and.’ */
export type AgencyToManyTripFilter = {
  /** Every related `Trip` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<TripFilter>;
  /** No related `Trip` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<TripFilter>;
  /** Some related `Trip` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<TripFilter>;
};

export type Airport = {
  __typename?: 'Airport';
  city?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Country` that is related to this `Airport`. */
  country?: Maybe<Country>;
  countryId: Scalars['UUID']['output'];
  created: Scalars['Datetime']['output'];
  displayName?: Maybe<Scalars['String']['output']>;
  iata?: Maybe<Scalars['String']['output']>;
  icao?: Maybe<Scalars['String']['output']>;
  id: Scalars['UUID']['output'];
  latitude: Scalars['Float']['output'];
  longitude: Scalars['Float']['output'];
  modified: Scalars['Datetime']['output'];
  name?: Maybe<Scalars['String']['output']>;
  timezone?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `TripFlight`. */
  tripFlightsByArrivalAirportId: TripFlightsConnection;
  /** Reads and enables pagination through a set of `TripFlight`. */
  tripFlightsByDepartureAirportId: TripFlightsConnection;
};


export type AirportTripFlightsByArrivalAirportIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TripFlightCondition>;
  filter?: InputMaybe<TripFlightFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TripFlightsOrderBy>>;
};


export type AirportTripFlightsByDepartureAirportIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TripFlightCondition>;
  filter?: InputMaybe<TripFlightFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TripFlightsOrderBy>>;
};

/** A condition to be used against `Airport` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type AirportCondition = {
  /** Checks for equality with the object’s `city` field. */
  city?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `countryId` field. */
  countryId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `displayName` field. */
  displayName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `iata` field. */
  iata?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `icao` field. */
  icao?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `latitude` field. */
  latitude?: InputMaybe<Scalars['Float']['input']>;
  /** Checks for equality with the object’s `longitude` field. */
  longitude?: InputMaybe<Scalars['Float']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `timezone` field. */
  timezone?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `Airport` object types. All fields are combined with a logical ‘and.’ */
export type AirportFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<AirportFilter>>;
  /** Filter by the object’s `city` field. */
  city?: InputMaybe<StringFilter>;
  /** Filter by the object’s `country` relation. */
  country?: InputMaybe<CountryFilter>;
  /** Filter by the object’s `countryId` field. */
  countryId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `displayName` field. */
  displayName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `iata` field. */
  iata?: InputMaybe<StringFilter>;
  /** Filter by the object’s `icao` field. */
  icao?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `latitude` field. */
  latitude?: InputMaybe<FloatFilter>;
  /** Filter by the object’s `longitude` field. */
  longitude?: InputMaybe<FloatFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<AirportFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<AirportFilter>>;
  /** Filter by the object’s `timezone` field. */
  timezone?: InputMaybe<StringFilter>;
  /** Filter by the object’s `tripFlightsByArrivalAirportId` relation. */
  tripFlightsByArrivalAirportId?: InputMaybe<AirportToManyTripFlightFilter>;
  /** Some related `tripFlightsByArrivalAirportId` exist. */
  tripFlightsByArrivalAirportIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `tripFlightsByDepartureAirportId` relation. */
  tripFlightsByDepartureAirportId?: InputMaybe<AirportToManyTripFlightFilter>;
  /** Some related `tripFlightsByDepartureAirportId` exist. */
  tripFlightsByDepartureAirportIdExist?: InputMaybe<Scalars['Boolean']['input']>;
};

/** An input for mutations affecting `Airport` */
export type AirportInput = {
  city?: InputMaybe<Scalars['String']['input']>;
  countryId?: InputMaybe<Scalars['UUID']['input']>;
  countryToCountryId?: InputMaybe<FkAirportCountryCountryIdInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  displayName?: InputMaybe<Scalars['String']['input']>;
  iata?: InputMaybe<Scalars['String']['input']>;
  icao?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  latitude: Scalars['Float']['input'];
  longitude: Scalars['Float']['input'];
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  timezone?: InputMaybe<Scalars['String']['input']>;
  tripFlightsToArrivalAirportIdUsingId?: InputMaybe<TripFlightArrivalAirport2IdFkeyInverseInput>;
  tripFlightsToDepartureAirportIdUsingId?: InputMaybe<TripFlightDepartureAirport2IdFkeyInverseInput>;
};

/** The fields on `airport` to look up the row to update. */
export type AirportOnAirportForFkAirportCountryCountryIdUsingPkAirportUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `airport` being updated. */
  patch: UpdateAirportOnAirportForFkAirportCountryCountryIdPatch;
};

/** The fields on `airport` to look up the row to update. */
export type AirportOnTripFlightForTripFlightArrivalAirport2IdFkeyUsingPkAirportUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `airport` being updated. */
  patch: UpdateAirportOnTripFlightForTripFlightArrivalAirport2IdFkeyPatch;
};

/** The fields on `airport` to look up the row to update. */
export type AirportOnTripFlightForTripFlightDepartureAirport2IdFkeyUsingPkAirportUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `airport` being updated. */
  patch: UpdateAirportOnTripFlightForTripFlightDepartureAirport2IdFkeyPatch;
};

/** Represents an update to a `Airport`. Fields that are set will be updated. */
export type AirportPatch = {
  city?: InputMaybe<Scalars['String']['input']>;
  countryId?: InputMaybe<Scalars['UUID']['input']>;
  countryToCountryId?: InputMaybe<FkAirportCountryCountryIdInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  displayName?: InputMaybe<Scalars['String']['input']>;
  iata?: InputMaybe<Scalars['String']['input']>;
  icao?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  latitude?: InputMaybe<Scalars['Float']['input']>;
  longitude?: InputMaybe<Scalars['Float']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  timezone?: InputMaybe<Scalars['String']['input']>;
  tripFlightsToArrivalAirportIdUsingId?: InputMaybe<TripFlightArrivalAirport2IdFkeyInverseInput>;
  tripFlightsToDepartureAirportIdUsingId?: InputMaybe<TripFlightDepartureAirport2IdFkeyInverseInput>;
};

/** The fields on `airport` to look up the row to connect. */
export type AirportPkAirportConnect = {
  id: Scalars['UUID']['input'];
};

/** The fields on `airport` to look up the row to delete. */
export type AirportPkAirportDelete = {
  id: Scalars['UUID']['input'];
};

/** A filter to be used against many `TripFlight` object types. All fields are combined with a logical ‘and.’ */
export type AirportToManyTripFlightFilter = {
  /** Every related `TripFlight` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<TripFlightFilter>;
  /** No related `TripFlight` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<TripFlightFilter>;
  /** Some related `TripFlight` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<TripFlightFilter>;
};

/** A connection to a list of `Airport` values. */
export type AirportsConnection = {
  __typename?: 'AirportsConnection';
  /** A list of edges which contains the `Airport` and cursor to aid in pagination. */
  edges: Array<AirportsEdge>;
  /** A list of `Airport` objects. */
  nodes: Array<Maybe<Airport>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Airport` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Airport` edge in the connection. */
export type AirportsEdge = {
  __typename?: 'AirportsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Airport` at the end of the edge. */
  node?: Maybe<Airport>;
};

/** Methods to use when ordering `Airport`. */
export enum AirportsOrderBy {
  CityAsc = 'CITY_ASC',
  CityDesc = 'CITY_DESC',
  CountryByCountryIdCreatedAsc = 'COUNTRY_BY_COUNTRY_ID__CREATED_ASC',
  CountryByCountryIdCreatedDesc = 'COUNTRY_BY_COUNTRY_ID__CREATED_DESC',
  CountryByCountryIdIdAsc = 'COUNTRY_BY_COUNTRY_ID__ID_ASC',
  CountryByCountryIdIdDesc = 'COUNTRY_BY_COUNTRY_ID__ID_DESC',
  CountryByCountryIdIso2Asc = 'COUNTRY_BY_COUNTRY_ID__ISO2_ASC',
  CountryByCountryIdIso2Desc = 'COUNTRY_BY_COUNTRY_ID__ISO2_DESC',
  CountryByCountryIdIso3Asc = 'COUNTRY_BY_COUNTRY_ID__ISO3_ASC',
  CountryByCountryIdIso3Desc = 'COUNTRY_BY_COUNTRY_ID__ISO3_DESC',
  CountryByCountryIdModifiedAsc = 'COUNTRY_BY_COUNTRY_ID__MODIFIED_ASC',
  CountryByCountryIdModifiedDesc = 'COUNTRY_BY_COUNTRY_ID__MODIFIED_DESC',
  CountryByCountryIdNameAsc = 'COUNTRY_BY_COUNTRY_ID__NAME_ASC',
  CountryByCountryIdNameDesc = 'COUNTRY_BY_COUNTRY_ID__NAME_DESC',
  CountryIdAsc = 'COUNTRY_ID_ASC',
  CountryIdDesc = 'COUNTRY_ID_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  DisplayNameAsc = 'DISPLAY_NAME_ASC',
  DisplayNameDesc = 'DISPLAY_NAME_DESC',
  IataAsc = 'IATA_ASC',
  IataDesc = 'IATA_DESC',
  IcaoAsc = 'ICAO_ASC',
  IcaoDesc = 'ICAO_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LatitudeAsc = 'LATITUDE_ASC',
  LatitudeDesc = 'LATITUDE_DESC',
  LongitudeAsc = 'LONGITUDE_ASC',
  LongitudeDesc = 'LONGITUDE_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TimezoneAsc = 'TIMEZONE_ASC',
  TimezoneDesc = 'TIMEZONE_DESC',
  TripFlightsByArrivalAirportIdCountAsc = 'TRIP_FLIGHTS_BY_ARRIVAL_AIRPORT_ID__COUNT_ASC',
  TripFlightsByArrivalAirportIdCountDesc = 'TRIP_FLIGHTS_BY_ARRIVAL_AIRPORT_ID__COUNT_DESC',
  TripFlightsByDepartureAirportIdCountAsc = 'TRIP_FLIGHTS_BY_DEPARTURE_AIRPORT_ID__COUNT_ASC',
  TripFlightsByDepartureAirportIdCountDesc = 'TRIP_FLIGHTS_BY_DEPARTURE_AIRPORT_ID__COUNT_DESC'
}

/** A filter to be used against BigFloat fields. All fields are combined with a logical ‘and.’ */
export type BigFloatFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['BigFloat']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['BigFloat']['input']>>;
};

/** A filter to be used against Boolean fields. All fields are combined with a logical ‘and.’ */
export type BooleanFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['Boolean']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['Boolean']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['Boolean']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['Boolean']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['Boolean']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['Boolean']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['Boolean']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['Boolean']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['Boolean']['input']>>;
};

/** A connection to a list of `Country` values. */
export type CountriesConnection = {
  __typename?: 'CountriesConnection';
  /** A list of edges which contains the `Country` and cursor to aid in pagination. */
  edges: Array<CountriesEdge>;
  /** A list of `Country` objects. */
  nodes: Array<Maybe<Country>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Country` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Country` edge in the connection. */
export type CountriesEdge = {
  __typename?: 'CountriesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Country` at the end of the edge. */
  node?: Maybe<Country>;
};

/** Methods to use when ordering `Country`. */
export enum CountriesOrderBy {
  AirportsByCountryIdCountAsc = 'AIRPORTS_BY_COUNTRY_ID__COUNT_ASC',
  AirportsByCountryIdCountDesc = 'AIRPORTS_BY_COUNTRY_ID__COUNT_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  DestinationsByCountryIdCountAsc = 'DESTINATIONS_BY_COUNTRY_ID__COUNT_ASC',
  DestinationsByCountryIdCountDesc = 'DESTINATIONS_BY_COUNTRY_ID__COUNT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Iso2Asc = 'ISO2_ASC',
  Iso2Desc = 'ISO2_DESC',
  Iso3Asc = 'ISO3_ASC',
  Iso3Desc = 'ISO3_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PassportsByCountryIdCountAsc = 'PASSPORTS_BY_COUNTRY_ID__COUNT_ASC',
  PassportsByCountryIdCountDesc = 'PASSPORTS_BY_COUNTRY_ID__COUNT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  PropertiesByCountryIdCountAsc = 'PROPERTIES_BY_COUNTRY_ID__COUNT_ASC',
  PropertiesByCountryIdCountDesc = 'PROPERTIES_BY_COUNTRY_ID__COUNT_DESC'
}

export type Country = {
  __typename?: 'Country';
  /** Reads and enables pagination through a set of `Airport`. */
  airports: AirportsConnection;
  created: Scalars['Datetime']['output'];
  /** Reads and enables pagination through a set of `Destination`. */
  destinations: DestinationsConnection;
  id: Scalars['UUID']['output'];
  iso2?: Maybe<Scalars['String']['output']>;
  iso3?: Maybe<Scalars['String']['output']>;
  modified: Scalars['Datetime']['output'];
  name?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `Passport`. */
  passports: PassportsConnection;
  /** Reads and enables pagination through a set of `Property`. */
  properties: PropertiesConnection;
};


export type CountryAirportsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AirportCondition>;
  filter?: InputMaybe<AirportFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AirportsOrderBy>>;
};


export type CountryDestinationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DestinationCondition>;
  filter?: InputMaybe<DestinationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DestinationsOrderBy>>;
};


export type CountryPassportsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PassportCondition>;
  filter?: InputMaybe<PassportFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PassportsOrderBy>>;
};


export type CountryPropertiesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PropertyCondition>;
  filter?: InputMaybe<PropertyFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PropertiesOrderBy>>;
};

/** A condition to be used against `Country` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type CountryCondition = {
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `iso2` field. */
  iso2?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `iso3` field. */
  iso3?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `Country` object types. All fields are combined with a logical ‘and.’ */
export type CountryFilter = {
  /** Filter by the object’s `airports` relation. */
  airports?: InputMaybe<CountryToManyAirportFilter>;
  /** Some related `airports` exist. */
  airportsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<CountryFilter>>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `destinations` relation. */
  destinations?: InputMaybe<CountryToManyDestinationFilter>;
  /** Some related `destinations` exist. */
  destinationsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `iso2` field. */
  iso2?: InputMaybe<StringFilter>;
  /** Filter by the object’s `iso3` field. */
  iso3?: InputMaybe<StringFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<CountryFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<CountryFilter>>;
  /** Filter by the object’s `passports` relation. */
  passports?: InputMaybe<CountryToManyPassportFilter>;
  /** Some related `passports` exist. */
  passportsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `properties` relation. */
  properties?: InputMaybe<CountryToManyPropertyFilter>;
  /** Some related `properties` exist. */
  propertiesExist?: InputMaybe<Scalars['Boolean']['input']>;
};

/** An input for mutations affecting `Country` */
export type CountryInput = {
  airportsUsingId?: InputMaybe<FkAirportCountryCountryIdInverseInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationsUsingId?: InputMaybe<FkDestinationCountryCountryIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  iso2?: InputMaybe<Scalars['String']['input']>;
  iso3?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  passportsUsingId?: InputMaybe<PassportCountry2IdFkeyInverseInput>;
  propertiesUsingId?: InputMaybe<FkPropertyCountryCountryIdInverseInput>;
};

/** The fields on `country` to look up the row to update. */
export type CountryOnAirportForFkAirportCountryCountryIdUsingPkCountryUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `country` being updated. */
  patch: UpdateCountryOnAirportForFkAirportCountryCountryIdPatch;
};

/** The fields on `country` to look up the row to update. */
export type CountryOnDestinationForFkDestinationCountryCountryIdUsingPkCountryUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `country` being updated. */
  patch: UpdateCountryOnDestinationForFkDestinationCountryCountryIdPatch;
};

/** The fields on `country` to look up the row to update. */
export type CountryOnPassportForPassportCountry2IdFkeyUsingPkCountryUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `country` being updated. */
  patch: UpdateCountryOnPassportForPassportCountry2IdFkeyPatch;
};

/** The fields on `country` to look up the row to update. */
export type CountryOnPropertyForFkPropertyCountryCountryIdUsingPkCountryUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `country` being updated. */
  patch: UpdateCountryOnPropertyForFkPropertyCountryCountryIdPatch;
};

/** Represents an update to a `Country`. Fields that are set will be updated. */
export type CountryPatch = {
  airportsUsingId?: InputMaybe<FkAirportCountryCountryIdInverseInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationsUsingId?: InputMaybe<FkDestinationCountryCountryIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  iso2?: InputMaybe<Scalars['String']['input']>;
  iso3?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  passportsUsingId?: InputMaybe<PassportCountry2IdFkeyInverseInput>;
  propertiesUsingId?: InputMaybe<FkPropertyCountryCountryIdInverseInput>;
};

/** The fields on `country` to look up the row to connect. */
export type CountryPkCountryConnect = {
  id: Scalars['UUID']['input'];
};

/** The fields on `country` to look up the row to delete. */
export type CountryPkCountryDelete = {
  id: Scalars['UUID']['input'];
};

/** A filter to be used against many `Airport` object types. All fields are combined with a logical ‘and.’ */
export type CountryToManyAirportFilter = {
  /** Every related `Airport` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<AirportFilter>;
  /** No related `Airport` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<AirportFilter>;
  /** Some related `Airport` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<AirportFilter>;
};

/** A filter to be used against many `Destination` object types. All fields are combined with a logical ‘and.’ */
export type CountryToManyDestinationFilter = {
  /** Every related `Destination` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<DestinationFilter>;
  /** No related `Destination` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<DestinationFilter>;
  /** Some related `Destination` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<DestinationFilter>;
};

/** A filter to be used against many `Passport` object types. All fields are combined with a logical ‘and.’ */
export type CountryToManyPassportFilter = {
  /** Every related `Passport` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<PassportFilter>;
  /** No related `Passport` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<PassportFilter>;
  /** Some related `Passport` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<PassportFilter>;
};

/** A filter to be used against many `Property` object types. All fields are combined with a logical ‘and.’ */
export type CountryToManyPropertyFilter = {
  /** Every related `Property` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<PropertyFilter>;
  /** No related `Property` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<PropertyFilter>;
  /** Some related `Property` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<PropertyFilter>;
};

/** All input for the create `Account` mutation. */
export type CreateAccountInput = {
  /** The `Account` to be created by this mutation. */
  account: AccountInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `Account` mutation. */
export type CreateAccountPayload = {
  __typename?: 'CreateAccountPayload';
  /** The `Account` that was created by this mutation. */
  account?: Maybe<Account>;
  /** An edge for our `Account`. May be used by Relay 1. */
  accountEdge?: Maybe<AccountsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `Account` mutation. */
export type CreateAccountPayloadAccountEdgeArgs = {
  orderBy?: InputMaybe<Array<AccountsOrderBy>>;
};

/** All input for the create `Agency` mutation. */
export type CreateAgencyInput = {
  /** The `Agency` to be created by this mutation. */
  agency: AgencyInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** All input for the create `AgencyMember` mutation. */
export type CreateAgencyMemberInput = {
  /** The `AgencyMember` to be created by this mutation. */
  agencyMember: AgencyMemberInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `AgencyMember` mutation. */
export type CreateAgencyMemberPayload = {
  __typename?: 'CreateAgencyMemberPayload';
  /** Reads a single `Agency` that is related to this `AgencyMember`. */
  agency?: Maybe<Agency>;
  /** The `AgencyMember` that was created by this mutation. */
  agencyMember?: Maybe<AgencyMember>;
  /** An edge for our `AgencyMember`. May be used by Relay 1. */
  agencyMemberEdge?: Maybe<AgencyMembersEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `AgencyMember` mutation. */
export type CreateAgencyMemberPayloadAgencyMemberEdgeArgs = {
  orderBy?: InputMaybe<Array<AgencyMembersOrderBy>>;
};

/** The output of our create `Agency` mutation. */
export type CreateAgencyPayload = {
  __typename?: 'CreateAgencyPayload';
  /** The `Agency` that was created by this mutation. */
  agency?: Maybe<Agency>;
  /** An edge for our `Agency`. May be used by Relay 1. */
  agencyEdge?: Maybe<AgenciesEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `MediaItem` that is related to this `Agency`. */
  logo?: Maybe<MediaItem>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Supplier` that is related to this `Agency`. */
  supplier?: Maybe<Supplier>;
};


/** The output of our create `Agency` mutation. */
export type CreateAgencyPayloadAgencyEdgeArgs = {
  orderBy?: InputMaybe<Array<AgenciesOrderBy>>;
};

/** All input for the create `Airport` mutation. */
export type CreateAirportInput = {
  /** The `Airport` to be created by this mutation. */
  airport: AirportInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `Airport` mutation. */
export type CreateAirportPayload = {
  __typename?: 'CreateAirportPayload';
  /** The `Airport` that was created by this mutation. */
  airport?: Maybe<Airport>;
  /** An edge for our `Airport`. May be used by Relay 1. */
  airportEdge?: Maybe<AirportsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Country` that is related to this `Airport`. */
  country?: Maybe<Country>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `Airport` mutation. */
export type CreateAirportPayloadAirportEdgeArgs = {
  orderBy?: InputMaybe<Array<AirportsOrderBy>>;
};

/** All input for the create `Country` mutation. */
export type CreateCountryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Country` to be created by this mutation. */
  country: CountryInput;
};

/** The output of our create `Country` mutation. */
export type CreateCountryPayload = {
  __typename?: 'CreateCountryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Country` that was created by this mutation. */
  country?: Maybe<Country>;
  /** An edge for our `Country`. May be used by Relay 1. */
  countryEdge?: Maybe<CountriesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `Country` mutation. */
export type CreateCountryPayloadCountryEdgeArgs = {
  orderBy?: InputMaybe<Array<CountriesOrderBy>>;
};

/** All input for the create `Customer` mutation. */
export type CreateCustomerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Customer` to be created by this mutation. */
  customer: CustomerInput;
};

/** The output of our create `Customer` mutation. */
export type CreateCustomerPayload = {
  __typename?: 'CreateCustomerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Customer` that was created by this mutation. */
  customer?: Maybe<Customer>;
  /** An edge for our `Customer`. May be used by Relay 1. */
  customerEdge?: Maybe<CustomersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `Customer` mutation. */
export type CreateCustomerPayloadCustomerEdgeArgs = {
  orderBy?: InputMaybe<Array<CustomersOrderBy>>;
};

/** All input for the create `CustomerTraveller` mutation. */
export type CreateCustomerTravellerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `CustomerTraveller` to be created by this mutation. */
  customerTraveller: CustomerTravellerInput;
};

/** The output of our create `CustomerTraveller` mutation. */
export type CreateCustomerTravellerPayload = {
  __typename?: 'CreateCustomerTravellerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Customer` that is related to this `CustomerTraveller`. */
  customer?: Maybe<Customer>;
  /** The `CustomerTraveller` that was created by this mutation. */
  customerTraveller?: Maybe<CustomerTraveller>;
  /** An edge for our `CustomerTraveller`. May be used by Relay 1. */
  customerTravellerEdge?: Maybe<CustomerTravellersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Traveller` that is related to this `CustomerTraveller`. */
  traveller?: Maybe<Traveller>;
};


/** The output of our create `CustomerTraveller` mutation. */
export type CreateCustomerTravellerPayloadCustomerTravellerEdgeArgs = {
  orderBy?: InputMaybe<Array<CustomerTravellersOrderBy>>;
};

/** All input for the create `DestinationFeature` mutation. */
export type CreateDestinationFeatureInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `DestinationFeature` to be created by this mutation. */
  destinationFeature: DestinationFeatureInput;
};

/** The output of our create `DestinationFeature` mutation. */
export type CreateDestinationFeaturePayload = {
  __typename?: 'CreateDestinationFeaturePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Destination` that is related to this `DestinationFeature`. */
  destination?: Maybe<Destination>;
  /** The `DestinationFeature` that was created by this mutation. */
  destinationFeature?: Maybe<DestinationFeature>;
  /** An edge for our `DestinationFeature`. May be used by Relay 1. */
  destinationFeatureEdge?: Maybe<DestinationFeaturesEdge>;
  /** Reads a single `MediaGallery` that is related to this `DestinationFeature`. */
  gallery?: Maybe<MediaGallery>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `DestinationFeature` mutation. */
export type CreateDestinationFeaturePayloadDestinationFeatureEdgeArgs = {
  orderBy?: InputMaybe<Array<DestinationFeaturesOrderBy>>;
};

/** All input for the create `DestinationGuide` mutation. */
export type CreateDestinationGuideInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `DestinationGuide` to be created by this mutation. */
  destinationGuide: DestinationGuideInput;
};

/** The output of our create `DestinationGuide` mutation. */
export type CreateDestinationGuidePayload = {
  __typename?: 'CreateDestinationGuidePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Destination` that is related to this `DestinationGuide`. */
  destination?: Maybe<Destination>;
  /** The `DestinationGuide` that was created by this mutation. */
  destinationGuide?: Maybe<DestinationGuide>;
  /** An edge for our `DestinationGuide`. May be used by Relay 1. */
  destinationGuideEdge?: Maybe<DestinationGuidesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `DestinationGuide` mutation. */
export type CreateDestinationGuidePayloadDestinationGuideEdgeArgs = {
  orderBy?: InputMaybe<Array<DestinationGuidesOrderBy>>;
};

/** All input for the create `Destination` mutation. */
export type CreateDestinationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Destination` to be created by this mutation. */
  destination: DestinationInput;
};

/** The output of our create `Destination` mutation. */
export type CreateDestinationPayload = {
  __typename?: 'CreateDestinationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Country` that is related to this `Destination`. */
  country?: Maybe<Country>;
  /** The `Destination` that was created by this mutation. */
  destination?: Maybe<Destination>;
  /** An edge for our `Destination`. May be used by Relay 1. */
  destinationEdge?: Maybe<DestinationsEdge>;
  /** Reads a single `MediaGallery` that is related to this `Destination`. */
  gallery?: Maybe<MediaGallery>;
  /** Reads a single `MediaItem` that is related to this `Destination`. */
  heroMedia?: Maybe<MediaItem>;
  /** Reads a single `Destination` that is related to this `Destination`. */
  parent?: Maybe<Destination>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `Destination` mutation. */
export type CreateDestinationPayloadDestinationEdgeArgs = {
  orderBy?: InputMaybe<Array<DestinationsOrderBy>>;
};

/** All input for the create `Email` mutation. */
export type CreateEmailInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Email` to be created by this mutation. */
  email: EmailInput;
};

/** The output of our create `Email` mutation. */
export type CreateEmailPayload = {
  __typename?: 'CreateEmailPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Customer` that is related to this `Email`. */
  customer?: Maybe<Customer>;
  /** The `Email` that was created by this mutation. */
  email?: Maybe<Email>;
  /** An edge for our `Email`. May be used by Relay 1. */
  emailEdge?: Maybe<EmailsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Quote` that is related to this `Email`. */
  quote?: Maybe<Quote>;
  /** Reads a single `Trip` that is related to this `Email`. */
  trip?: Maybe<Trip>;
  /** Reads a single `User` that is related to this `Email`. */
  user?: Maybe<User>;
};


/** The output of our create `Email` mutation. */
export type CreateEmailPayloadEmailEdgeArgs = {
  orderBy?: InputMaybe<Array<EmailsOrderBy>>;
};

/** All input for the create `Enquiry` mutation. */
export type CreateEnquiryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Enquiry` to be created by this mutation. */
  enquiry: EnquiryInput;
};

/** The output of our create `Enquiry` mutation. */
export type CreateEnquiryPayload = {
  __typename?: 'CreateEnquiryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Customer` that is related to this `Enquiry`. */
  customer?: Maybe<Customer>;
  /** The `Enquiry` that was created by this mutation. */
  enquiry?: Maybe<Enquiry>;
  /** An edge for our `Enquiry`. May be used by Relay 1. */
  enquiryEdge?: Maybe<EnquiriesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Trip` that is related to this `Enquiry`. */
  trip?: Maybe<Trip>;
};


/** The output of our create `Enquiry` mutation. */
export type CreateEnquiryPayloadEnquiryEdgeArgs = {
  orderBy?: InputMaybe<Array<EnquiriesOrderBy>>;
};

/** All input for the create `Expense` mutation. */
export type CreateExpenseInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Expense` to be created by this mutation. */
  expense: ExpenseInput;
};

/** The output of our create `Expense` mutation. */
export type CreateExpensePayload = {
  __typename?: 'CreateExpensePayload';
  /** Reads a single `FinanceCategory` that is related to this `Expense`. */
  category?: Maybe<FinanceCategory>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Expense` that was created by this mutation. */
  expense?: Maybe<Expense>;
  /** An edge for our `Expense`. May be used by Relay 1. */
  expenseEdge?: Maybe<ExpensesEdge>;
  /** Reads a single `Invoice` that is related to this `Expense`. */
  invoice?: Maybe<Invoice>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Supplier` that is related to this `Expense`. */
  supplier?: Maybe<Supplier>;
  /** Reads a single `SupplierInvoice` that is related to this `Expense`. */
  supplierInvoice?: Maybe<SupplierInvoice>;
  /** Reads a single `Trip` that is related to this `Expense`. */
  trip?: Maybe<Trip>;
};


/** The output of our create `Expense` mutation. */
export type CreateExpensePayloadExpenseEdgeArgs = {
  orderBy?: InputMaybe<Array<ExpensesOrderBy>>;
};

/** All input for the create `Feature` mutation. */
export type CreateFeatureInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Feature` to be created by this mutation. */
  feature: FeatureInput;
};

/** The output of our create `Feature` mutation. */
export type CreateFeaturePayload = {
  __typename?: 'CreateFeaturePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Feature` that was created by this mutation. */
  feature?: Maybe<Feature>;
  /** An edge for our `Feature`. May be used by Relay 1. */
  featureEdge?: Maybe<FeaturesEdge>;
  /** Reads a single `MediaGallery` that is related to this `Feature`. */
  gallery?: Maybe<MediaGallery>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `Feature` mutation. */
export type CreateFeaturePayloadFeatureEdgeArgs = {
  orderBy?: InputMaybe<Array<FeaturesOrderBy>>;
};

/** All input for the create `FinanceCategory` mutation. */
export type CreateFinanceCategoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `FinanceCategory` to be created by this mutation. */
  financeCategory: FinanceCategoryInput;
};

/** The output of our create `FinanceCategory` mutation. */
export type CreateFinanceCategoryPayload = {
  __typename?: 'CreateFinanceCategoryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `FinanceCategory` that was created by this mutation. */
  financeCategory?: Maybe<FinanceCategory>;
  /** An edge for our `FinanceCategory`. May be used by Relay 1. */
  financeCategoryEdge?: Maybe<FinanceCategoriesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `FinanceCategory` mutation. */
export type CreateFinanceCategoryPayloadFinanceCategoryEdgeArgs = {
  orderBy?: InputMaybe<Array<FinanceCategoriesOrderBy>>;
};

/** All input for the create `Invoice` mutation. */
export type CreateInvoiceInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Invoice` to be created by this mutation. */
  invoice: InvoiceInput;
};

/** The output of our create `Invoice` mutation. */
export type CreateInvoicePayload = {
  __typename?: 'CreateInvoicePayload';
  /** Reads a single `FinanceCategory` that is related to this `Invoice`. */
  category?: Maybe<FinanceCategory>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Invoice` that was created by this mutation. */
  invoice?: Maybe<Invoice>;
  /** An edge for our `Invoice`. May be used by Relay 1. */
  invoiceEdge?: Maybe<InvoicesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Quote` that is related to this `Invoice`. */
  quote?: Maybe<Quote>;
  /** Reads a single `Trip` that is related to this `Invoice`. */
  trip?: Maybe<Trip>;
};


/** The output of our create `Invoice` mutation. */
export type CreateInvoicePayloadInvoiceEdgeArgs = {
  orderBy?: InputMaybe<Array<InvoicesOrderBy>>;
};

/** All input for the create `LegalDocument` mutation. */
export type CreateLegalDocumentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `LegalDocument` to be created by this mutation. */
  legalDocument: LegalDocumentInput;
};

/** The output of our create `LegalDocument` mutation. */
export type CreateLegalDocumentPayload = {
  __typename?: 'CreateLegalDocumentPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `LegalFolder` that is related to this `LegalDocument`. */
  folder?: Maybe<LegalFolder>;
  /** The `LegalDocument` that was created by this mutation. */
  legalDocument?: Maybe<LegalDocument>;
  /** An edge for our `LegalDocument`. May be used by Relay 1. */
  legalDocumentEdge?: Maybe<LegalDocumentsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `LegalDocument` mutation. */
export type CreateLegalDocumentPayloadLegalDocumentEdgeArgs = {
  orderBy?: InputMaybe<Array<LegalDocumentsOrderBy>>;
};

/** All input for the create `LegalFolder` mutation. */
export type CreateLegalFolderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `LegalFolder` to be created by this mutation. */
  legalFolder: LegalFolderInput;
};

/** The output of our create `LegalFolder` mutation. */
export type CreateLegalFolderPayload = {
  __typename?: 'CreateLegalFolderPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `LegalFolder` that was created by this mutation. */
  legalFolder?: Maybe<LegalFolder>;
  /** An edge for our `LegalFolder`. May be used by Relay 1. */
  legalFolderEdge?: Maybe<LegalFoldersEdge>;
  /** Reads a single `LegalFolder` that is related to this `LegalFolder`. */
  parent?: Maybe<LegalFolder>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `LegalFolder` mutation. */
export type CreateLegalFolderPayloadLegalFolderEdgeArgs = {
  orderBy?: InputMaybe<Array<LegalFoldersOrderBy>>;
};

/** All input for the create `MapPoint` mutation. */
export type CreateMapPointInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `MapPoint` to be created by this mutation. */
  mapPoint: MapPointInput;
};

/** The output of our create `MapPoint` mutation. */
export type CreateMapPointPayload = {
  __typename?: 'CreateMapPointPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `MapPoint` that was created by this mutation. */
  mapPoint?: Maybe<MapPoint>;
  /** An edge for our `MapPoint`. May be used by Relay 1. */
  mapPointEdge?: Maybe<MapPointsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `MapPoint` mutation. */
export type CreateMapPointPayloadMapPointEdgeArgs = {
  orderBy?: InputMaybe<Array<MapPointsOrderBy>>;
};

/** All input for the create `MediaGallery` mutation. */
export type CreateMediaGalleryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `MediaGallery` to be created by this mutation. */
  mediaGallery: MediaGalleryInput;
};

/** All input for the create `MediaGalleryItem` mutation. */
export type CreateMediaGalleryItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `MediaGalleryItem` to be created by this mutation. */
  mediaGalleryItem: MediaGalleryItemInput;
};

/** The output of our create `MediaGalleryItem` mutation. */
export type CreateMediaGalleryItemPayload = {
  __typename?: 'CreateMediaGalleryItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `MediaGallery` that is related to this `MediaGalleryItem`. */
  mediaGallery?: Maybe<MediaGallery>;
  /** The `MediaGalleryItem` that was created by this mutation. */
  mediaGalleryItem?: Maybe<MediaGalleryItem>;
  /** An edge for our `MediaGalleryItem`. May be used by Relay 1. */
  mediaGalleryItemEdge?: Maybe<MediaGalleryItemsEdge>;
  /** Reads a single `MediaItem` that is related to this `MediaGalleryItem`. */
  mediaItem?: Maybe<MediaItem>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `MediaGalleryItem` mutation. */
export type CreateMediaGalleryItemPayloadMediaGalleryItemEdgeArgs = {
  orderBy?: InputMaybe<Array<MediaGalleryItemsOrderBy>>;
};

/** The output of our create `MediaGallery` mutation. */
export type CreateMediaGalleryPayload = {
  __typename?: 'CreateMediaGalleryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `MediaGallery` that was created by this mutation. */
  mediaGallery?: Maybe<MediaGallery>;
  /** An edge for our `MediaGallery`. May be used by Relay 1. */
  mediaGalleryEdge?: Maybe<MediaGalleriesEdge>;
  /** Reads a single `MediaGallery` that is related to this `MediaGallery`. */
  parent?: Maybe<MediaGallery>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `MediaGallery` mutation. */
export type CreateMediaGalleryPayloadMediaGalleryEdgeArgs = {
  orderBy?: InputMaybe<Array<MediaGalleriesOrderBy>>;
};

/** All input for the create `MediaItem` mutation. */
export type CreateMediaItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `MediaItem` to be created by this mutation. */
  mediaItem: MediaItemInput;
};

/** The output of our create `MediaItem` mutation. */
export type CreateMediaItemPayload = {
  __typename?: 'CreateMediaItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `MediaItem` that was created by this mutation. */
  mediaItem?: Maybe<MediaItem>;
  /** An edge for our `MediaItem`. May be used by Relay 1. */
  mediaItemEdge?: Maybe<MediaItemsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `MediaItem` mutation. */
export type CreateMediaItemPayloadMediaItemEdgeArgs = {
  orderBy?: InputMaybe<Array<MediaItemsOrderBy>>;
};

/** All input for the create `Note` mutation. */
export type CreateNoteInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Note` to be created by this mutation. */
  note: NoteInput;
};

/** The output of our create `Note` mutation. */
export type CreateNotePayload = {
  __typename?: 'CreateNotePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Note` that was created by this mutation. */
  note?: Maybe<Note>;
  /** An edge for our `Note`. May be used by Relay 1. */
  noteEdge?: Maybe<NotesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Trip` that is related to this `Note`. */
  trip?: Maybe<Trip>;
  /** Reads a single `User` that is related to this `Note`. */
  user?: Maybe<User>;
};


/** The output of our create `Note` mutation. */
export type CreateNotePayloadNoteEdgeArgs = {
  orderBy?: InputMaybe<Array<NotesOrderBy>>;
};

/** All input for the create `Passport` mutation. */
export type CreatePassportInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Passport` to be created by this mutation. */
  passport: PassportInput;
};

/** The output of our create `Passport` mutation. */
export type CreatePassportPayload = {
  __typename?: 'CreatePassportPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Country` that is related to this `Passport`. */
  country?: Maybe<Country>;
  /** The `Passport` that was created by this mutation. */
  passport?: Maybe<Passport>;
  /** An edge for our `Passport`. May be used by Relay 1. */
  passportEdge?: Maybe<PassportsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Traveller` that is related to this `Passport`. */
  traveller?: Maybe<Traveller>;
};


/** The output of our create `Passport` mutation. */
export type CreatePassportPayloadPassportEdgeArgs = {
  orderBy?: InputMaybe<Array<PassportsOrderBy>>;
};

/** All input for the create `Payment` mutation. */
export type CreatePaymentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Payment` to be created by this mutation. */
  payment: PaymentInput;
};

/** The output of our create `Payment` mutation. */
export type CreatePaymentPayload = {
  __typename?: 'CreatePaymentPayload';
  /** Reads a single `FinanceCategory` that is related to this `Payment`. */
  category?: Maybe<FinanceCategory>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Invoice` that is related to this `Payment`. */
  invoice?: Maybe<Invoice>;
  /** The `Payment` that was created by this mutation. */
  payment?: Maybe<Payment>;
  /** An edge for our `Payment`. May be used by Relay 1. */
  paymentEdge?: Maybe<PaymentsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Trip` that is related to this `Payment`. */
  trip?: Maybe<Trip>;
};


/** The output of our create `Payment` mutation. */
export type CreatePaymentPayloadPaymentEdgeArgs = {
  orderBy?: InputMaybe<Array<PaymentsOrderBy>>;
};

/** All input for the create `Property` mutation. */
export type CreatePropertyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Property` to be created by this mutation. */
  property: PropertyInput;
};

/** The output of our create `Property` mutation. */
export type CreatePropertyPayload = {
  __typename?: 'CreatePropertyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Country` that is related to this `Property`. */
  country?: Maybe<Country>;
  /** Reads a single `Destination` that is related to this `Property`. */
  destination?: Maybe<Destination>;
  /** Reads a single `MediaGallery` that is related to this `Property`. */
  gallery?: Maybe<MediaGallery>;
  /** Reads a single `MediaItem` that is related to this `Property`. */
  heroMedia?: Maybe<MediaItem>;
  /** Reads a single `MapPoint` that is related to this `Property`. */
  mapPoint?: Maybe<MapPoint>;
  /** The `Property` that was created by this mutation. */
  property?: Maybe<Property>;
  /** An edge for our `Property`. May be used by Relay 1. */
  propertyEdge?: Maybe<PropertiesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `Property` mutation. */
export type CreatePropertyPayloadPropertyEdgeArgs = {
  orderBy?: InputMaybe<Array<PropertiesOrderBy>>;
};

/** All input for the create `QuoteAcceptance` mutation. */
export type CreateQuoteAcceptanceInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `QuoteAcceptance` to be created by this mutation. */
  quoteAcceptance: QuoteAcceptanceInput;
};

/** The output of our create `QuoteAcceptance` mutation. */
export type CreateQuoteAcceptancePayload = {
  __typename?: 'CreateQuoteAcceptancePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Quote` that is related to this `QuoteAcceptance`. */
  quote?: Maybe<Quote>;
  /** The `QuoteAcceptance` that was created by this mutation. */
  quoteAcceptance?: Maybe<QuoteAcceptance>;
  /** An edge for our `QuoteAcceptance`. May be used by Relay 1. */
  quoteAcceptanceEdge?: Maybe<QuoteAcceptancesEdge>;
};


/** The output of our create `QuoteAcceptance` mutation. */
export type CreateQuoteAcceptancePayloadQuoteAcceptanceEdgeArgs = {
  orderBy?: InputMaybe<Array<QuoteAcceptancesOrderBy>>;
};

/** All input for the create `QuoteAccommodationDetail` mutation. */
export type CreateQuoteAccommodationDetailInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `QuoteAccommodationDetail` to be created by this mutation. */
  quoteAccommodationDetail: QuoteAccommodationDetailInput;
};

/** The output of our create `QuoteAccommodationDetail` mutation. */
export type CreateQuoteAccommodationDetailPayload = {
  __typename?: 'CreateQuoteAccommodationDetailPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Property` that is related to this `QuoteAccommodationDetail`. */
  property?: Maybe<Property>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Quote` that is related to this `QuoteAccommodationDetail`. */
  quote?: Maybe<Quote>;
  /** The `QuoteAccommodationDetail` that was created by this mutation. */
  quoteAccommodationDetail?: Maybe<QuoteAccommodationDetail>;
  /** An edge for our `QuoteAccommodationDetail`. May be used by Relay 1. */
  quoteAccommodationDetailEdge?: Maybe<QuoteAccommodationDetailsEdge>;
  /** Reads a single `QuotePublic` that is related to this `QuoteAccommodationDetail`. */
  quotePublic?: Maybe<QuotePublic>;
};


/** The output of our create `QuoteAccommodationDetail` mutation. */
export type CreateQuoteAccommodationDetailPayloadQuoteAccommodationDetailEdgeArgs = {
  orderBy?: InputMaybe<Array<QuoteAccommodationDetailsOrderBy>>;
};

/** All input for the create `QuoteCurrency` mutation. */
export type CreateQuoteCurrencyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `QuoteCurrency` to be created by this mutation. */
  quoteCurrency: QuoteCurrencyInput;
};

/** The output of our create `QuoteCurrency` mutation. */
export type CreateQuoteCurrencyPayload = {
  __typename?: 'CreateQuoteCurrencyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Quote` that is related to this `QuoteCurrency`. */
  quote?: Maybe<Quote>;
  /** The `QuoteCurrency` that was created by this mutation. */
  quoteCurrency?: Maybe<QuoteCurrency>;
  /** An edge for our `QuoteCurrency`. May be used by Relay 1. */
  quoteCurrencyEdge?: Maybe<QuoteCurrenciesEdge>;
};


/** The output of our create `QuoteCurrency` mutation. */
export type CreateQuoteCurrencyPayloadQuoteCurrencyEdgeArgs = {
  orderBy?: InputMaybe<Array<QuoteCurrenciesOrderBy>>;
};

/** All input for the create `QuoteDayDestination` mutation. */
export type CreateQuoteDayDestinationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `QuoteDayDestination` to be created by this mutation. */
  quoteDayDestination: QuoteDayDestinationInput;
};

/** The output of our create `QuoteDayDestination` mutation. */
export type CreateQuoteDayDestinationPayload = {
  __typename?: 'CreateQuoteDayDestinationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `QuoteDay` that is related to this `QuoteDayDestination`. */
  day?: Maybe<QuoteDay>;
  /** Reads a single `Destination` that is related to this `QuoteDayDestination`. */
  destination?: Maybe<Destination>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `QuoteDayDestination` that was created by this mutation. */
  quoteDayDestination?: Maybe<QuoteDayDestination>;
  /** An edge for our `QuoteDayDestination`. May be used by Relay 1. */
  quoteDayDestinationEdge?: Maybe<QuoteDayDestinationsEdge>;
};


/** The output of our create `QuoteDayDestination` mutation. */
export type CreateQuoteDayDestinationPayloadQuoteDayDestinationEdgeArgs = {
  orderBy?: InputMaybe<Array<QuoteDayDestinationsOrderBy>>;
};

/** All input for the create `QuoteDay` mutation. */
export type CreateQuoteDayInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `QuoteDay` to be created by this mutation. */
  quoteDay: QuoteDayInput;
};

/** The output of our create `QuoteDay` mutation. */
export type CreateQuoteDayPayload = {
  __typename?: 'CreateQuoteDayPayload';
  /** Reads a single `QuoteAccommodationDetail` that is related to this `QuoteDay`. */
  accommodation?: Maybe<QuoteAccommodationDetail>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Property` that is related to this `QuoteDay`. */
  property?: Maybe<Property>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Quote` that is related to this `QuoteDay`. */
  quote?: Maybe<Quote>;
  /** The `QuoteDay` that was created by this mutation. */
  quoteDay?: Maybe<QuoteDay>;
  /** An edge for our `QuoteDay`. May be used by Relay 1. */
  quoteDayEdge?: Maybe<QuoteDaysEdge>;
  /** Reads a single `QuotePublic` that is related to this `QuoteDay`. */
  quotePublic?: Maybe<QuotePublic>;
};


/** The output of our create `QuoteDay` mutation. */
export type CreateQuoteDayPayloadQuoteDayEdgeArgs = {
  orderBy?: InputMaybe<Array<QuoteDaysOrderBy>>;
};

/** All input for the create `QuoteFinanceLineItem` mutation. */
export type CreateQuoteFinanceLineItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `QuoteFinanceLineItem` to be created by this mutation. */
  quoteFinanceLineItem: QuoteFinanceLineItemInput;
};

/** The output of our create `QuoteFinanceLineItem` mutation. */
export type CreateQuoteFinanceLineItemPayload = {
  __typename?: 'CreateQuoteFinanceLineItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Quote` that is related to this `QuoteFinanceLineItem`. */
  quote?: Maybe<Quote>;
  /** The `QuoteFinanceLineItem` that was created by this mutation. */
  quoteFinanceLineItem?: Maybe<QuoteFinanceLineItem>;
  /** An edge for our `QuoteFinanceLineItem`. May be used by Relay 1. */
  quoteFinanceLineItemEdge?: Maybe<QuoteFinanceLineItemsEdge>;
  /** Reads a single `Supplier` that is related to this `QuoteFinanceLineItem`. */
  supplier?: Maybe<Supplier>;
};


/** The output of our create `QuoteFinanceLineItem` mutation. */
export type CreateQuoteFinanceLineItemPayloadQuoteFinanceLineItemEdgeArgs = {
  orderBy?: InputMaybe<Array<QuoteFinanceLineItemsOrderBy>>;
};

/** All input for the create `QuoteHero` mutation. */
export type CreateQuoteHeroInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `QuoteHero` to be created by this mutation. */
  quoteHero: QuoteHeroInput;
};

/** The output of our create `QuoteHero` mutation. */
export type CreateQuoteHeroPayload = {
  __typename?: 'CreateQuoteHeroPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `MediaItem` that is related to this `QuoteHero`. */
  image?: Maybe<MediaItem>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `QuoteHero` that was created by this mutation. */
  quoteHero?: Maybe<QuoteHero>;
  /** An edge for our `QuoteHero`. May be used by Relay 1. */
  quoteHeroEdge?: Maybe<QuoteHeroesEdge>;
};


/** The output of our create `QuoteHero` mutation. */
export type CreateQuoteHeroPayloadQuoteHeroEdgeArgs = {
  orderBy?: InputMaybe<Array<QuoteHeroesOrderBy>>;
};

/** All input for the create `Quote` mutation. */
export type CreateQuoteInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Quote` to be created by this mutation. */
  quote: QuoteInput;
};

/** All input for the create `QuoteLegalDocument` mutation. */
export type CreateQuoteLegalDocumentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `QuoteLegalDocument` to be created by this mutation. */
  quoteLegalDocument: QuoteLegalDocumentInput;
};

/** The output of our create `QuoteLegalDocument` mutation. */
export type CreateQuoteLegalDocumentPayload = {
  __typename?: 'CreateQuoteLegalDocumentPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `LegalDocument` that is related to this `QuoteLegalDocument`. */
  legalDocument?: Maybe<LegalDocument>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Quote` that is related to this `QuoteLegalDocument`. */
  quote?: Maybe<Quote>;
  /** The `QuoteLegalDocument` that was created by this mutation. */
  quoteLegalDocument?: Maybe<QuoteLegalDocument>;
  /** An edge for our `QuoteLegalDocument`. May be used by Relay 1. */
  quoteLegalDocumentEdge?: Maybe<QuoteLegalDocumentsEdge>;
  /** Reads a single `QuotePublic` that is related to this `QuoteLegalDocument`. */
  quotePublic?: Maybe<QuotePublic>;
};


/** The output of our create `QuoteLegalDocument` mutation. */
export type CreateQuoteLegalDocumentPayloadQuoteLegalDocumentEdgeArgs = {
  orderBy?: InputMaybe<Array<QuoteLegalDocumentsOrderBy>>;
};

/** The output of our create `Quote` mutation. */
export type CreateQuotePayload = {
  __typename?: 'CreateQuotePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `QuoteHero` that is related to this `Quote`. */
  hero?: Maybe<QuoteHero>;
  /** Reads a single `MediaItem` that is related to this `Quote`. */
  heroImage?: Maybe<MediaItem>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Quote` that was created by this mutation. */
  quote?: Maybe<Quote>;
  /** An edge for our `Quote`. May be used by Relay 1. */
  quoteEdge?: Maybe<QuotesEdge>;
  /** Reads a single `QuoteStatus` that is related to this `Quote`. */
  quoteStatusByStatus?: Maybe<QuoteStatus>;
  /** Reads a single `Trip` that is related to this `Quote`. */
  trip?: Maybe<Trip>;
  /** Reads a single `User` that is related to this `Quote`. */
  user?: Maybe<User>;
};


/** The output of our create `Quote` mutation. */
export type CreateQuotePayloadQuoteEdgeArgs = {
  orderBy?: InputMaybe<Array<QuotesOrderBy>>;
};

/** All input for the create `QuotePublic` mutation. */
export type CreateQuotePublicInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `QuotePublic` to be created by this mutation. */
  quotePublic: QuotePublicInput;
};

/** The output of our create `QuotePublic` mutation. */
export type CreateQuotePublicPayload = {
  __typename?: 'CreateQuotePublicPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `QuoteHero` that is related to this `QuotePublic`. */
  hero?: Maybe<QuoteHero>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `QuotePublic` that was created by this mutation. */
  quotePublic?: Maybe<QuotePublic>;
  /** An edge for our `QuotePublic`. May be used by Relay 1. */
  quotePublicEdge?: Maybe<QuotePublicsEdge>;
  /** Reads a single `Trip` that is related to this `QuotePublic`. */
  trip?: Maybe<Trip>;
  /** Reads a single `User` that is related to this `QuotePublic`. */
  user?: Maybe<User>;
};


/** The output of our create `QuotePublic` mutation. */
export type CreateQuotePublicPayloadQuotePublicEdgeArgs = {
  orderBy?: InputMaybe<Array<QuotePublicsOrderBy>>;
};

/** All input for the create `QuoteStatus` mutation. */
export type CreateQuoteStatusInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `QuoteStatus` to be created by this mutation. */
  quoteStatus: QuoteStatusInput;
};

/** The output of our create `QuoteStatus` mutation. */
export type CreateQuoteStatusPayload = {
  __typename?: 'CreateQuoteStatusPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `QuoteStatus` that was created by this mutation. */
  quoteStatus?: Maybe<QuoteStatus>;
  /** An edge for our `QuoteStatus`. May be used by Relay 1. */
  quoteStatusEdge?: Maybe<QuoteStatusesEdge>;
};


/** The output of our create `QuoteStatus` mutation. */
export type CreateQuoteStatusPayloadQuoteStatusEdgeArgs = {
  orderBy?: InputMaybe<Array<QuoteStatusesOrderBy>>;
};

/** All input for the create `QuoteView` mutation. */
export type CreateQuoteViewInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `QuoteView` to be created by this mutation. */
  quoteView: QuoteViewInput;
};

/** The output of our create `QuoteView` mutation. */
export type CreateQuoteViewPayload = {
  __typename?: 'CreateQuoteViewPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Quote` that is related to this `QuoteView`. */
  quote?: Maybe<Quote>;
  /** The `QuoteView` that was created by this mutation. */
  quoteView?: Maybe<QuoteView>;
  /** An edge for our `QuoteView`. May be used by Relay 1. */
  quoteViewEdge?: Maybe<QuoteViewsEdge>;
};


/** The output of our create `QuoteView` mutation. */
export type CreateQuoteViewPayloadQuoteViewEdgeArgs = {
  orderBy?: InputMaybe<Array<QuoteViewsOrderBy>>;
};

/** All input for the create `Reminder` mutation. */
export type CreateReminderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Reminder` to be created by this mutation. */
  reminder: ReminderInput;
};

/** The output of our create `Reminder` mutation. */
export type CreateReminderPayload = {
  __typename?: 'CreateReminderPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Reminder` that was created by this mutation. */
  reminder?: Maybe<Reminder>;
  /** An edge for our `Reminder`. May be used by Relay 1. */
  reminderEdge?: Maybe<RemindersEdge>;
  /** Reads a single `User` that is related to this `Reminder`. */
  user?: Maybe<User>;
};


/** The output of our create `Reminder` mutation. */
export type CreateReminderPayloadReminderEdgeArgs = {
  orderBy?: InputMaybe<Array<RemindersOrderBy>>;
};

export type CreateStripeInvoiceInput = {
  id: Scalars['String']['input'];
};

/** All input for the create `Supplier` mutation. */
export type CreateSupplierInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Supplier` to be created by this mutation. */
  supplier: SupplierInput;
};

/** All input for the create `SupplierInvoice` mutation. */
export type CreateSupplierInvoiceInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `SupplierInvoice` to be created by this mutation. */
  supplierInvoice: SupplierInvoiceInput;
};

/** The output of our create `SupplierInvoice` mutation. */
export type CreateSupplierInvoicePayload = {
  __typename?: 'CreateSupplierInvoicePayload';
  /** Reads a single `FinanceCategory` that is related to this `SupplierInvoice`. */
  category?: Maybe<FinanceCategory>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `MediaItem` that is related to this `SupplierInvoice`. */
  mediaItem?: Maybe<MediaItem>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Supplier` that is related to this `SupplierInvoice`. */
  supplier?: Maybe<Supplier>;
  /** The `SupplierInvoice` that was created by this mutation. */
  supplierInvoice?: Maybe<SupplierInvoice>;
  /** An edge for our `SupplierInvoice`. May be used by Relay 1. */
  supplierInvoiceEdge?: Maybe<SupplierInvoicesEdge>;
  /** Reads a single `Trip` that is related to this `SupplierInvoice`. */
  trip?: Maybe<Trip>;
};


/** The output of our create `SupplierInvoice` mutation. */
export type CreateSupplierInvoicePayloadSupplierInvoiceEdgeArgs = {
  orderBy?: InputMaybe<Array<SupplierInvoicesOrderBy>>;
};

/** The output of our create `Supplier` mutation. */
export type CreateSupplierPayload = {
  __typename?: 'CreateSupplierPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `MediaGallery` that is related to this `Supplier`. */
  gallery?: Maybe<MediaGallery>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Supplier` that was created by this mutation. */
  supplier?: Maybe<Supplier>;
  /** An edge for our `Supplier`. May be used by Relay 1. */
  supplierEdge?: Maybe<SuppliersEdge>;
};


/** The output of our create `Supplier` mutation. */
export type CreateSupplierPayloadSupplierEdgeArgs = {
  orderBy?: InputMaybe<Array<SuppliersOrderBy>>;
};

/** All input for the create `Testimonial` mutation. */
export type CreateTestimonialInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Testimonial` to be created by this mutation. */
  testimonial: TestimonialInput;
};

/** The output of our create `Testimonial` mutation. */
export type CreateTestimonialPayload = {
  __typename?: 'CreateTestimonialPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Testimonial` that was created by this mutation. */
  testimonial?: Maybe<Testimonial>;
  /** An edge for our `Testimonial`. May be used by Relay 1. */
  testimonialEdge?: Maybe<TestimonialsEdge>;
  /** Reads a single `Trip` that is related to this `Testimonial`. */
  trip?: Maybe<Trip>;
};


/** The output of our create `Testimonial` mutation. */
export type CreateTestimonialPayloadTestimonialEdgeArgs = {
  orderBy?: InputMaybe<Array<TestimonialsOrderBy>>;
};

/** All input for the create `Timezone` mutation. */
export type CreateTimezoneInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Timezone` to be created by this mutation. */
  timezone: TimezoneInput;
};

/** The output of our create `Timezone` mutation. */
export type CreateTimezonePayload = {
  __typename?: 'CreateTimezonePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Timezone` that was created by this mutation. */
  timezone?: Maybe<Timezone>;
  /** An edge for our `Timezone`. May be used by Relay 1. */
  timezoneEdge?: Maybe<TimezonesEdge>;
};


/** The output of our create `Timezone` mutation. */
export type CreateTimezonePayloadTimezoneEdgeArgs = {
  orderBy?: InputMaybe<Array<TimezonesOrderBy>>;
};

/** All input for the create `TransactionImportBatch` mutation. */
export type CreateTransactionImportBatchInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `TransactionImportBatch` to be created by this mutation. */
  transactionImportBatch: TransactionImportBatchInput;
};

/** The output of our create `TransactionImportBatch` mutation. */
export type CreateTransactionImportBatchPayload = {
  __typename?: 'CreateTransactionImportBatchPayload';
  /** Reads a single `Account` that is related to this `TransactionImportBatch`. */
  account?: Maybe<Account>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `TransactionImportBatch` that was created by this mutation. */
  transactionImportBatch?: Maybe<TransactionImportBatch>;
  /** An edge for our `TransactionImportBatch`. May be used by Relay 1. */
  transactionImportBatchEdge?: Maybe<TransactionImportBatchesEdge>;
};


/** The output of our create `TransactionImportBatch` mutation. */
export type CreateTransactionImportBatchPayloadTransactionImportBatchEdgeArgs = {
  orderBy?: InputMaybe<Array<TransactionImportBatchesOrderBy>>;
};

/** All input for the create `Transaction` mutation. */
export type CreateTransactionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Transaction` to be created by this mutation. */
  transaction: TransactionInput;
};

/** All input for the create `TransactionLink` mutation. */
export type CreateTransactionLinkInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `TransactionLink` to be created by this mutation. */
  transactionLink: TransactionLinkInput;
};

/** The output of our create `TransactionLink` mutation. */
export type CreateTransactionLinkPayload = {
  __typename?: 'CreateTransactionLinkPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Expense` that is related to this `TransactionLink`. */
  expense?: Maybe<Expense>;
  /** Reads a single `Invoice` that is related to this `TransactionLink`. */
  invoice?: Maybe<Invoice>;
  /** Reads a single `Payment` that is related to this `TransactionLink`. */
  payment?: Maybe<Payment>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `SupplierInvoice` that is related to this `TransactionLink`. */
  supplierInvoice?: Maybe<SupplierInvoice>;
  /** Reads a single `Transaction` that is related to this `TransactionLink`. */
  transaction?: Maybe<Transaction>;
  /** The `TransactionLink` that was created by this mutation. */
  transactionLink?: Maybe<TransactionLink>;
  /** An edge for our `TransactionLink`. May be used by Relay 1. */
  transactionLinkEdge?: Maybe<TransactionLinksEdge>;
};


/** The output of our create `TransactionLink` mutation. */
export type CreateTransactionLinkPayloadTransactionLinkEdgeArgs = {
  orderBy?: InputMaybe<Array<TransactionLinksOrderBy>>;
};

/** All input for the create `TransactionNote` mutation. */
export type CreateTransactionNoteInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `TransactionNote` to be created by this mutation. */
  transactionNote: TransactionNoteInput;
};

/** The output of our create `TransactionNote` mutation. */
export type CreateTransactionNotePayload = {
  __typename?: 'CreateTransactionNotePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Transaction` that is related to this `TransactionNote`. */
  transaction?: Maybe<Transaction>;
  /** The `TransactionNote` that was created by this mutation. */
  transactionNote?: Maybe<TransactionNote>;
  /** An edge for our `TransactionNote`. May be used by Relay 1. */
  transactionNoteEdge?: Maybe<TransactionNotesEdge>;
  /** Reads a single `User` that is related to this `TransactionNote`. */
  user?: Maybe<User>;
};


/** The output of our create `TransactionNote` mutation. */
export type CreateTransactionNotePayloadTransactionNoteEdgeArgs = {
  orderBy?: InputMaybe<Array<TransactionNotesOrderBy>>;
};

/** The output of our create `Transaction` mutation. */
export type CreateTransactionPayload = {
  __typename?: 'CreateTransactionPayload';
  /** Reads a single `Account` that is related to this `Transaction`. */
  account?: Maybe<Account>;
  /** Reads a single `FinanceCategory` that is related to this `Transaction`. */
  category?: Maybe<FinanceCategory>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Transaction` that is related to this `Transaction`. */
  reverseTransaction?: Maybe<Transaction>;
  /** The `Transaction` that was created by this mutation. */
  transaction?: Maybe<Transaction>;
  /** An edge for our `Transaction`. May be used by Relay 1. */
  transactionEdge?: Maybe<TransactionsEdge>;
  /** Reads a single `TransactionImportBatch` that is related to this `Transaction`. */
  transactionImportBatch?: Maybe<TransactionImportBatch>;
};


/** The output of our create `Transaction` mutation. */
export type CreateTransactionPayloadTransactionEdgeArgs = {
  orderBy?: InputMaybe<Array<TransactionsOrderBy>>;
};

/** All input for the create `Traveller` mutation. */
export type CreateTravellerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Traveller` to be created by this mutation. */
  traveller: TravellerInput;
};

/** The output of our create `Traveller` mutation. */
export type CreateTravellerPayload = {
  __typename?: 'CreateTravellerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Traveller` that was created by this mutation. */
  traveller?: Maybe<Traveller>;
  /** An edge for our `Traveller`. May be used by Relay 1. */
  travellerEdge?: Maybe<TravellersEdge>;
};


/** The output of our create `Traveller` mutation. */
export type CreateTravellerPayloadTravellerEdgeArgs = {
  orderBy?: InputMaybe<Array<TravellersOrderBy>>;
};

/** All input for the create `TripFlight` mutation. */
export type CreateTripFlightInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `TripFlight` to be created by this mutation. */
  tripFlight: TripFlightInput;
};

/** The output of our create `TripFlight` mutation. */
export type CreateTripFlightPayload = {
  __typename?: 'CreateTripFlightPayload';
  /** Reads a single `Airport` that is related to this `TripFlight`. */
  arrivalAirport?: Maybe<Airport>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Airport` that is related to this `TripFlight`. */
  departureAirport?: Maybe<Airport>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Trip` that is related to this `TripFlight`. */
  trip?: Maybe<Trip>;
  /** The `TripFlight` that was created by this mutation. */
  tripFlight?: Maybe<TripFlight>;
  /** An edge for our `TripFlight`. May be used by Relay 1. */
  tripFlightEdge?: Maybe<TripFlightsEdge>;
};


/** The output of our create `TripFlight` mutation. */
export type CreateTripFlightPayloadTripFlightEdgeArgs = {
  orderBy?: InputMaybe<Array<TripFlightsOrderBy>>;
};

/** All input for the create `Trip` mutation. */
export type CreateTripInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Trip` to be created by this mutation. */
  trip: TripInput;
};

/** The output of our create `Trip` mutation. */
export type CreateTripPayload = {
  __typename?: 'CreateTripPayload';
  /** Reads a single `Quote` that is related to this `Trip`. */
  activeQuote?: Maybe<Quote>;
  /** Reads a single `Agency` that is related to this `Trip`. */
  agency?: Maybe<Agency>;
  /** Reads a single `AgencyMember` that is related to this `Trip`. */
  agencyMember?: Maybe<AgencyMember>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Customer` that is related to this `Trip`. */
  customer?: Maybe<Customer>;
  /** Reads a single `MediaGallery` that is related to this `Trip`. */
  mediaGallery?: Maybe<MediaGallery>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Trip` that was created by this mutation. */
  trip?: Maybe<Trip>;
  /** An edge for our `Trip`. May be used by Relay 1. */
  tripEdge?: Maybe<TripsEdge>;
  /** Reads a single `User` that is related to this `Trip`. */
  user?: Maybe<User>;
};


/** The output of our create `Trip` mutation. */
export type CreateTripPayloadTripEdgeArgs = {
  orderBy?: InputMaybe<Array<TripsOrderBy>>;
};

/** All input for the create `TripTraveller` mutation. */
export type CreateTripTravellerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `TripTraveller` to be created by this mutation. */
  tripTraveller: TripTravellerInput;
};

/** The output of our create `TripTraveller` mutation. */
export type CreateTripTravellerPayload = {
  __typename?: 'CreateTripTravellerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Traveller` that is related to this `TripTraveller`. */
  traveller?: Maybe<Traveller>;
  /** Reads a single `Trip` that is related to this `TripTraveller`. */
  trip?: Maybe<Trip>;
  /** The `TripTraveller` that was created by this mutation. */
  tripTraveller?: Maybe<TripTraveller>;
  /** An edge for our `TripTraveller`. May be used by Relay 1. */
  tripTravellerEdge?: Maybe<TripTravellersEdge>;
};


/** The output of our create `TripTraveller` mutation. */
export type CreateTripTravellerPayloadTripTravellerEdgeArgs = {
  orderBy?: InputMaybe<Array<TripTravellersOrderBy>>;
};

/** All input for the create `User` mutation. */
export type CreateUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `User` to be created by this mutation. */
  user: UserInput;
};

/** The output of our create `User` mutation. */
export type CreateUserPayload = {
  __typename?: 'CreateUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `User` that was created by this mutation. */
  user?: Maybe<User>;
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge?: Maybe<UsersEdge>;
};


/** The output of our create `User` mutation. */
export type CreateUserPayloadUserEdgeArgs = {
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

/** All input for the create `VisaRequirement` mutation. */
export type CreateVisaRequirementInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `VisaRequirement` to be created by this mutation. */
  visaRequirement: VisaRequirementInput;
};

/** The output of our create `VisaRequirement` mutation. */
export type CreateVisaRequirementPayload = {
  __typename?: 'CreateVisaRequirementPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `VisaRequirement` that was created by this mutation. */
  visaRequirement?: Maybe<VisaRequirement>;
  /** An edge for our `VisaRequirement`. May be used by Relay 1. */
  visaRequirementEdge?: Maybe<VisaRequirementsEdge>;
};


/** The output of our create `VisaRequirement` mutation. */
export type CreateVisaRequirementPayloadVisaRequirementEdgeArgs = {
  orderBy?: InputMaybe<Array<VisaRequirementsOrderBy>>;
};

export type Customer = {
  __typename?: 'Customer';
  created: Scalars['Datetime']['output'];
  /** Reads and enables pagination through a set of `CustomerTraveller`. */
  customerTravellers: CustomerTravellersConnection;
  email?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `Email`. */
  emails: EmailsConnection;
  /** Reads and enables pagination through a set of `Enquiry`. */
  enquiries: EnquiriesConnection;
  id: Scalars['UUID']['output'];
  modified: Scalars['Datetime']['output'];
  name?: Maybe<Scalars['String']['output']>;
  phone?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `Trip`. */
  trips: TripsConnection;
};


export type CustomerCustomerTravellersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CustomerTravellerCondition>;
  filter?: InputMaybe<CustomerTravellerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CustomerTravellersOrderBy>>;
};


export type CustomerEmailsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EmailCondition>;
  filter?: InputMaybe<EmailFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EmailsOrderBy>>;
};


export type CustomerEnquiriesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EnquiryCondition>;
  filter?: InputMaybe<EnquiryFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EnquiriesOrderBy>>;
};


export type CustomerTripsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TripCondition>;
  filter?: InputMaybe<TripFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TripsOrderBy>>;
};

/**
 * A condition to be used against `Customer` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type CustomerCondition = {
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `email` field. */
  email?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `phone` field. */
  phone?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `Customer` object types. All fields are combined with a logical ‘and.’ */
export type CustomerFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<CustomerFilter>>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `customerTravellers` relation. */
  customerTravellers?: InputMaybe<CustomerToManyCustomerTravellerFilter>;
  /** Some related `customerTravellers` exist. */
  customerTravellersExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `email` field. */
  email?: InputMaybe<StringFilter>;
  /** Filter by the object’s `emails` relation. */
  emails?: InputMaybe<CustomerToManyEmailFilter>;
  /** Some related `emails` exist. */
  emailsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `enquiries` relation. */
  enquiries?: InputMaybe<CustomerToManyEnquiryFilter>;
  /** Some related `enquiries` exist. */
  enquiriesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<CustomerFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<CustomerFilter>>;
  /** Filter by the object’s `phone` field. */
  phone?: InputMaybe<StringFilter>;
  /** Filter by the object’s `trips` relation. */
  trips?: InputMaybe<CustomerToManyTripFilter>;
  /** Some related `trips` exist. */
  tripsExist?: InputMaybe<Scalars['Boolean']['input']>;
};

/** An input for mutations affecting `Customer` */
export type CustomerInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerTravellersUsingId?: InputMaybe<FkCustomerTravellerCustomerCustomerIdInverseInput>;
  email?: InputMaybe<Scalars['String']['input']>;
  emailsUsingId?: InputMaybe<FkEmailCustomerCustomerIdInverseInput>;
  enquiriesUsingId?: InputMaybe<FkEnquiryCustomerCustomerIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  tripsUsingId?: InputMaybe<FkTripCustomerCustomerIdInverseInput>;
};

/** The fields on `customer` to look up the row to update. */
export type CustomerOnCustomerTravellerForFkCustomerTravellerCustomerCustomerIdUsingPkCustomerUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `customer` being updated. */
  patch: UpdateCustomerOnCustomerTravellerForFkCustomerTravellerCustomerCustomerIdPatch;
};

/** The fields on `customer` to look up the row to update. */
export type CustomerOnEmailForFkEmailCustomerCustomerIdUsingPkCustomerUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `customer` being updated. */
  patch: UpdateCustomerOnEmailForFkEmailCustomerCustomerIdPatch;
};

/** The fields on `customer` to look up the row to update. */
export type CustomerOnEnquiryForFkEnquiryCustomerCustomerIdUsingPkCustomerUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `customer` being updated. */
  patch: UpdateCustomerOnEnquiryForFkEnquiryCustomerCustomerIdPatch;
};

/** The fields on `customer` to look up the row to update. */
export type CustomerOnTripForFkTripCustomerCustomerIdUsingPkCustomerUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `customer` being updated. */
  patch: UpdateCustomerOnTripForFkTripCustomerCustomerIdPatch;
};

/** Represents an update to a `Customer`. Fields that are set will be updated. */
export type CustomerPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerTravellersUsingId?: InputMaybe<FkCustomerTravellerCustomerCustomerIdInverseInput>;
  email?: InputMaybe<Scalars['String']['input']>;
  emailsUsingId?: InputMaybe<FkEmailCustomerCustomerIdInverseInput>;
  enquiriesUsingId?: InputMaybe<FkEnquiryCustomerCustomerIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  tripsUsingId?: InputMaybe<FkTripCustomerCustomerIdInverseInput>;
};

/** The fields on `customer` to look up the row to connect. */
export type CustomerPkCustomerConnect = {
  id: Scalars['UUID']['input'];
};

/** The fields on `customer` to look up the row to delete. */
export type CustomerPkCustomerDelete = {
  id: Scalars['UUID']['input'];
};

/** A filter to be used against many `CustomerTraveller` object types. All fields are combined with a logical ‘and.’ */
export type CustomerToManyCustomerTravellerFilter = {
  /** Every related `CustomerTraveller` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<CustomerTravellerFilter>;
  /** No related `CustomerTraveller` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<CustomerTravellerFilter>;
  /** Some related `CustomerTraveller` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<CustomerTravellerFilter>;
};

/** A filter to be used against many `Email` object types. All fields are combined with a logical ‘and.’ */
export type CustomerToManyEmailFilter = {
  /** Every related `Email` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<EmailFilter>;
  /** No related `Email` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<EmailFilter>;
  /** Some related `Email` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<EmailFilter>;
};

/** A filter to be used against many `Enquiry` object types. All fields are combined with a logical ‘and.’ */
export type CustomerToManyEnquiryFilter = {
  /** Every related `Enquiry` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<EnquiryFilter>;
  /** No related `Enquiry` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<EnquiryFilter>;
  /** Some related `Enquiry` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<EnquiryFilter>;
};

/** A filter to be used against many `Trip` object types. All fields are combined with a logical ‘and.’ */
export type CustomerToManyTripFilter = {
  /** Every related `Trip` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<TripFilter>;
  /** No related `Trip` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<TripFilter>;
  /** Some related `Trip` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<TripFilter>;
};

export type CustomerTraveller = {
  __typename?: 'CustomerTraveller';
  created: Scalars['Datetime']['output'];
  /** Reads a single `Customer` that is related to this `CustomerTraveller`. */
  customer?: Maybe<Customer>;
  customerId: Scalars['UUID']['output'];
  id: Scalars['UUID']['output'];
  modified: Scalars['Datetime']['output'];
  /** Reads a single `Traveller` that is related to this `CustomerTraveller`. */
  traveller?: Maybe<Traveller>;
  travellerId: Scalars['UUID']['output'];
};

/**
 * A condition to be used against `CustomerTraveller` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type CustomerTravellerCondition = {
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `customerId` field. */
  customerId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `travellerId` field. */
  travellerId?: InputMaybe<Scalars['UUID']['input']>;
};

/** A filter to be used against `CustomerTraveller` object types. All fields are combined with a logical ‘and.’ */
export type CustomerTravellerFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<CustomerTravellerFilter>>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `customer` relation. */
  customer?: InputMaybe<CustomerFilter>;
  /** Filter by the object’s `customerId` field. */
  customerId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<CustomerTravellerFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<CustomerTravellerFilter>>;
  /** Filter by the object’s `traveller` relation. */
  traveller?: InputMaybe<TravellerFilter>;
  /** Filter by the object’s `travellerId` field. */
  travellerId?: InputMaybe<UuidFilter>;
};

/** An input for mutations affecting `CustomerTraveller` */
export type CustomerTravellerInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerId?: InputMaybe<Scalars['UUID']['input']>;
  customerToCustomerId?: InputMaybe<FkCustomerTravellerCustomerCustomerIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  travellerId?: InputMaybe<Scalars['UUID']['input']>;
  travellerToTravellerId?: InputMaybe<FkCustomerTravellerTravellerTravellerIdInput>;
};

/** The fields on `customerTraveller` to look up the row to update. */
export type CustomerTravellerOnCustomerTravellerForFkCustomerTravellerCustomerCustomerIdUsingPkCustomerTravellerUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `customerTraveller` being updated. */
  patch: UpdateCustomerTravellerOnCustomerTravellerForFkCustomerTravellerCustomerCustomerIdPatch;
};

/** The fields on `customerTraveller` to look up the row to update. */
export type CustomerTravellerOnCustomerTravellerForFkCustomerTravellerTravellerTravellerIdUsingPkCustomerTravellerUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `customerTraveller` being updated. */
  patch: UpdateCustomerTravellerOnCustomerTravellerForFkCustomerTravellerTravellerTravellerIdPatch;
};

/** Represents an update to a `CustomerTraveller`. Fields that are set will be updated. */
export type CustomerTravellerPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerId?: InputMaybe<Scalars['UUID']['input']>;
  customerToCustomerId?: InputMaybe<FkCustomerTravellerCustomerCustomerIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  travellerId?: InputMaybe<Scalars['UUID']['input']>;
  travellerToTravellerId?: InputMaybe<FkCustomerTravellerTravellerTravellerIdInput>;
};

/** The fields on `customerTraveller` to look up the row to connect. */
export type CustomerTravellerPkCustomerTravellerConnect = {
  id: Scalars['UUID']['input'];
};

/** The fields on `customerTraveller` to look up the row to delete. */
export type CustomerTravellerPkCustomerTravellerDelete = {
  id: Scalars['UUID']['input'];
};

/** A connection to a list of `CustomerTraveller` values. */
export type CustomerTravellersConnection = {
  __typename?: 'CustomerTravellersConnection';
  /** A list of edges which contains the `CustomerTraveller` and cursor to aid in pagination. */
  edges: Array<CustomerTravellersEdge>;
  /** A list of `CustomerTraveller` objects. */
  nodes: Array<Maybe<CustomerTraveller>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CustomerTraveller` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `CustomerTraveller` edge in the connection. */
export type CustomerTravellersEdge = {
  __typename?: 'CustomerTravellersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `CustomerTraveller` at the end of the edge. */
  node?: Maybe<CustomerTraveller>;
};

/** Methods to use when ordering `CustomerTraveller`. */
export enum CustomerTravellersOrderBy {
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  CustomerByCustomerIdCreatedAsc = 'CUSTOMER_BY_CUSTOMER_ID__CREATED_ASC',
  CustomerByCustomerIdCreatedDesc = 'CUSTOMER_BY_CUSTOMER_ID__CREATED_DESC',
  CustomerByCustomerIdEmailAsc = 'CUSTOMER_BY_CUSTOMER_ID__EMAIL_ASC',
  CustomerByCustomerIdEmailDesc = 'CUSTOMER_BY_CUSTOMER_ID__EMAIL_DESC',
  CustomerByCustomerIdIdAsc = 'CUSTOMER_BY_CUSTOMER_ID__ID_ASC',
  CustomerByCustomerIdIdDesc = 'CUSTOMER_BY_CUSTOMER_ID__ID_DESC',
  CustomerByCustomerIdModifiedAsc = 'CUSTOMER_BY_CUSTOMER_ID__MODIFIED_ASC',
  CustomerByCustomerIdModifiedDesc = 'CUSTOMER_BY_CUSTOMER_ID__MODIFIED_DESC',
  CustomerByCustomerIdNameAsc = 'CUSTOMER_BY_CUSTOMER_ID__NAME_ASC',
  CustomerByCustomerIdNameDesc = 'CUSTOMER_BY_CUSTOMER_ID__NAME_DESC',
  CustomerByCustomerIdPhoneAsc = 'CUSTOMER_BY_CUSTOMER_ID__PHONE_ASC',
  CustomerByCustomerIdPhoneDesc = 'CUSTOMER_BY_CUSTOMER_ID__PHONE_DESC',
  CustomerIdAsc = 'CUSTOMER_ID_ASC',
  CustomerIdDesc = 'CUSTOMER_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TravellerByTravellerIdCreatedAsc = 'TRAVELLER_BY_TRAVELLER_ID__CREATED_ASC',
  TravellerByTravellerIdCreatedDesc = 'TRAVELLER_BY_TRAVELLER_ID__CREATED_DESC',
  TravellerByTravellerIdDateOfBirthAsc = 'TRAVELLER_BY_TRAVELLER_ID__DATE_OF_BIRTH_ASC',
  TravellerByTravellerIdDateOfBirthDesc = 'TRAVELLER_BY_TRAVELLER_ID__DATE_OF_BIRTH_DESC',
  TravellerByTravellerIdDietaryRequirementsAsc = 'TRAVELLER_BY_TRAVELLER_ID__DIETARY_REQUIREMENTS_ASC',
  TravellerByTravellerIdDietaryRequirementsDesc = 'TRAVELLER_BY_TRAVELLER_ID__DIETARY_REQUIREMENTS_DESC',
  TravellerByTravellerIdEmailAsc = 'TRAVELLER_BY_TRAVELLER_ID__EMAIL_ASC',
  TravellerByTravellerIdEmailDesc = 'TRAVELLER_BY_TRAVELLER_ID__EMAIL_DESC',
  TravellerByTravellerIdEmergencyContactAsc = 'TRAVELLER_BY_TRAVELLER_ID__EMERGENCY_CONTACT_ASC',
  TravellerByTravellerIdEmergencyContactDesc = 'TRAVELLER_BY_TRAVELLER_ID__EMERGENCY_CONTACT_DESC',
  TravellerByTravellerIdFirstNameAsc = 'TRAVELLER_BY_TRAVELLER_ID__FIRST_NAME_ASC',
  TravellerByTravellerIdFirstNameDesc = 'TRAVELLER_BY_TRAVELLER_ID__FIRST_NAME_DESC',
  TravellerByTravellerIdHeightAsc = 'TRAVELLER_BY_TRAVELLER_ID__HEIGHT_ASC',
  TravellerByTravellerIdHeightDesc = 'TRAVELLER_BY_TRAVELLER_ID__HEIGHT_DESC',
  TravellerByTravellerIdIdAsc = 'TRAVELLER_BY_TRAVELLER_ID__ID_ASC',
  TravellerByTravellerIdIdDesc = 'TRAVELLER_BY_TRAVELLER_ID__ID_DESC',
  TravellerByTravellerIdInsuranceDetailsAsc = 'TRAVELLER_BY_TRAVELLER_ID__INSURANCE_DETAILS_ASC',
  TravellerByTravellerIdInsuranceDetailsDesc = 'TRAVELLER_BY_TRAVELLER_ID__INSURANCE_DETAILS_DESC',
  TravellerByTravellerIdLastNameAsc = 'TRAVELLER_BY_TRAVELLER_ID__LAST_NAME_ASC',
  TravellerByTravellerIdLastNameDesc = 'TRAVELLER_BY_TRAVELLER_ID__LAST_NAME_DESC',
  TravellerByTravellerIdMedicalConditionsAsc = 'TRAVELLER_BY_TRAVELLER_ID__MEDICAL_CONDITIONS_ASC',
  TravellerByTravellerIdMedicalConditionsDesc = 'TRAVELLER_BY_TRAVELLER_ID__MEDICAL_CONDITIONS_DESC',
  TravellerByTravellerIdMiddleNameAsc = 'TRAVELLER_BY_TRAVELLER_ID__MIDDLE_NAME_ASC',
  TravellerByTravellerIdMiddleNameDesc = 'TRAVELLER_BY_TRAVELLER_ID__MIDDLE_NAME_DESC',
  TravellerByTravellerIdModifiedAsc = 'TRAVELLER_BY_TRAVELLER_ID__MODIFIED_ASC',
  TravellerByTravellerIdModifiedDesc = 'TRAVELLER_BY_TRAVELLER_ID__MODIFIED_DESC',
  TravellerByTravellerIdNationalityAsc = 'TRAVELLER_BY_TRAVELLER_ID__NATIONALITY_ASC',
  TravellerByTravellerIdNationalityDesc = 'TRAVELLER_BY_TRAVELLER_ID__NATIONALITY_DESC',
  TravellerByTravellerIdNotesAsc = 'TRAVELLER_BY_TRAVELLER_ID__NOTES_ASC',
  TravellerByTravellerIdNotesDesc = 'TRAVELLER_BY_TRAVELLER_ID__NOTES_DESC',
  TravellerByTravellerIdPhoneAsc = 'TRAVELLER_BY_TRAVELLER_ID__PHONE_ASC',
  TravellerByTravellerIdPhoneDesc = 'TRAVELLER_BY_TRAVELLER_ID__PHONE_DESC',
  TravellerByTravellerIdWeightAsc = 'TRAVELLER_BY_TRAVELLER_ID__WEIGHT_ASC',
  TravellerByTravellerIdWeightDesc = 'TRAVELLER_BY_TRAVELLER_ID__WEIGHT_DESC',
  TravellerIdAsc = 'TRAVELLER_ID_ASC',
  TravellerIdDesc = 'TRAVELLER_ID_DESC'
}

/** A connection to a list of `Customer` values. */
export type CustomersConnection = {
  __typename?: 'CustomersConnection';
  /** A list of edges which contains the `Customer` and cursor to aid in pagination. */
  edges: Array<CustomersEdge>;
  /** A list of `Customer` objects. */
  nodes: Array<Maybe<Customer>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Customer` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Customer` edge in the connection. */
export type CustomersEdge = {
  __typename?: 'CustomersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Customer` at the end of the edge. */
  node?: Maybe<Customer>;
};

/** Methods to use when ordering `Customer`. */
export enum CustomersOrderBy {
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  CustomerTravellersByCustomerIdCountAsc = 'CUSTOMER_TRAVELLERS_BY_CUSTOMER_ID__COUNT_ASC',
  CustomerTravellersByCustomerIdCountDesc = 'CUSTOMER_TRAVELLERS_BY_CUSTOMER_ID__COUNT_DESC',
  EmailsByCustomerIdCountAsc = 'EMAILS_BY_CUSTOMER_ID__COUNT_ASC',
  EmailsByCustomerIdCountDesc = 'EMAILS_BY_CUSTOMER_ID__COUNT_DESC',
  EmailAsc = 'EMAIL_ASC',
  EmailDesc = 'EMAIL_DESC',
  EnquiriesByCustomerIdCountAsc = 'ENQUIRIES_BY_CUSTOMER_ID__COUNT_ASC',
  EnquiriesByCustomerIdCountDesc = 'ENQUIRIES_BY_CUSTOMER_ID__COUNT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PhoneAsc = 'PHONE_ASC',
  PhoneDesc = 'PHONE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TripsByCustomerIdCountAsc = 'TRIPS_BY_CUSTOMER_ID__COUNT_ASC',
  TripsByCustomerIdCountDesc = 'TRIPS_BY_CUSTOMER_ID__COUNT_DESC'
}

/** All input for the `dateWeek` mutation. */
export type DateWeekInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  date?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The output of our `dateWeek` mutation. */
export type DateWeekPayload = {
  __typename?: 'DateWeekPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  string?: Maybe<Scalars['String']['output']>;
};

/** A filter to be used against Datetime fields. All fields are combined with a logical ‘and.’ */
export type DatetimeFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['Datetime']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['Datetime']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['Datetime']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['Datetime']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['Datetime']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['Datetime']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['Datetime']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['Datetime']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['Datetime']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['Datetime']['input']>>;
};

/** All input for the `deleteAccount` mutation. */
export type DeleteAccountInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `Account` mutation. */
export type DeleteAccountPayload = {
  __typename?: 'DeleteAccountPayload';
  /** The `Account` that was deleted by this mutation. */
  account?: Maybe<Account>;
  /** An edge for our `Account`. May be used by Relay 1. */
  accountEdge?: Maybe<AccountsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedAccountNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `Account` mutation. */
export type DeleteAccountPayloadAccountEdgeArgs = {
  orderBy?: InputMaybe<Array<AccountsOrderBy>>;
};

/** All input for the `deleteAgency` mutation. */
export type DeleteAgencyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** All input for the `deleteAgencyMember` mutation. */
export type DeleteAgencyMemberInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `AgencyMember` mutation. */
export type DeleteAgencyMemberPayload = {
  __typename?: 'DeleteAgencyMemberPayload';
  /** Reads a single `Agency` that is related to this `AgencyMember`. */
  agency?: Maybe<Agency>;
  /** The `AgencyMember` that was deleted by this mutation. */
  agencyMember?: Maybe<AgencyMember>;
  /** An edge for our `AgencyMember`. May be used by Relay 1. */
  agencyMemberEdge?: Maybe<AgencyMembersEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedAgencyMemberNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `AgencyMember` mutation. */
export type DeleteAgencyMemberPayloadAgencyMemberEdgeArgs = {
  orderBy?: InputMaybe<Array<AgencyMembersOrderBy>>;
};

/** The output of our delete `Agency` mutation. */
export type DeleteAgencyPayload = {
  __typename?: 'DeleteAgencyPayload';
  /** The `Agency` that was deleted by this mutation. */
  agency?: Maybe<Agency>;
  /** An edge for our `Agency`. May be used by Relay 1. */
  agencyEdge?: Maybe<AgenciesEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedAgencyNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `MediaItem` that is related to this `Agency`. */
  logo?: Maybe<MediaItem>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Supplier` that is related to this `Agency`. */
  supplier?: Maybe<Supplier>;
};


/** The output of our delete `Agency` mutation. */
export type DeleteAgencyPayloadAgencyEdgeArgs = {
  orderBy?: InputMaybe<Array<AgenciesOrderBy>>;
};

/** All input for the `deleteAirport` mutation. */
export type DeleteAirportInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `Airport` mutation. */
export type DeleteAirportPayload = {
  __typename?: 'DeleteAirportPayload';
  /** The `Airport` that was deleted by this mutation. */
  airport?: Maybe<Airport>;
  /** An edge for our `Airport`. May be used by Relay 1. */
  airportEdge?: Maybe<AirportsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Country` that is related to this `Airport`. */
  country?: Maybe<Country>;
  deletedAirportNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `Airport` mutation. */
export type DeleteAirportPayloadAirportEdgeArgs = {
  orderBy?: InputMaybe<Array<AirportsOrderBy>>;
};

/** All input for the `deleteCountry` mutation. */
export type DeleteCountryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `Country` mutation. */
export type DeleteCountryPayload = {
  __typename?: 'DeleteCountryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Country` that was deleted by this mutation. */
  country?: Maybe<Country>;
  /** An edge for our `Country`. May be used by Relay 1. */
  countryEdge?: Maybe<CountriesEdge>;
  deletedCountryNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `Country` mutation. */
export type DeleteCountryPayloadCountryEdgeArgs = {
  orderBy?: InputMaybe<Array<CountriesOrderBy>>;
};

/** All input for the `deleteCustomer` mutation. */
export type DeleteCustomerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `Customer` mutation. */
export type DeleteCustomerPayload = {
  __typename?: 'DeleteCustomerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Customer` that was deleted by this mutation. */
  customer?: Maybe<Customer>;
  /** An edge for our `Customer`. May be used by Relay 1. */
  customerEdge?: Maybe<CustomersEdge>;
  deletedCustomerNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `Customer` mutation. */
export type DeleteCustomerPayloadCustomerEdgeArgs = {
  orderBy?: InputMaybe<Array<CustomersOrderBy>>;
};

/** All input for the `deleteCustomerTraveller` mutation. */
export type DeleteCustomerTravellerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `CustomerTraveller` mutation. */
export type DeleteCustomerTravellerPayload = {
  __typename?: 'DeleteCustomerTravellerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Customer` that is related to this `CustomerTraveller`. */
  customer?: Maybe<Customer>;
  /** The `CustomerTraveller` that was deleted by this mutation. */
  customerTraveller?: Maybe<CustomerTraveller>;
  /** An edge for our `CustomerTraveller`. May be used by Relay 1. */
  customerTravellerEdge?: Maybe<CustomerTravellersEdge>;
  deletedCustomerTravellerNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Traveller` that is related to this `CustomerTraveller`. */
  traveller?: Maybe<Traveller>;
};


/** The output of our delete `CustomerTraveller` mutation. */
export type DeleteCustomerTravellerPayloadCustomerTravellerEdgeArgs = {
  orderBy?: InputMaybe<Array<CustomerTravellersOrderBy>>;
};

/** All input for the `deleteDestinationByCountryIdAndAlias` mutation. */
export type DeleteDestinationByCountryIdAndAliasInput = {
  alias: Scalars['String']['input'];
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  countryId: Scalars['UUID']['input'];
};

/** All input for the `deleteDestinationFeature` mutation. */
export type DeleteDestinationFeatureInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `DestinationFeature` mutation. */
export type DeleteDestinationFeaturePayload = {
  __typename?: 'DeleteDestinationFeaturePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedDestinationFeatureNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Destination` that is related to this `DestinationFeature`. */
  destination?: Maybe<Destination>;
  /** The `DestinationFeature` that was deleted by this mutation. */
  destinationFeature?: Maybe<DestinationFeature>;
  /** An edge for our `DestinationFeature`. May be used by Relay 1. */
  destinationFeatureEdge?: Maybe<DestinationFeaturesEdge>;
  /** Reads a single `MediaGallery` that is related to this `DestinationFeature`. */
  gallery?: Maybe<MediaGallery>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `DestinationFeature` mutation. */
export type DeleteDestinationFeaturePayloadDestinationFeatureEdgeArgs = {
  orderBy?: InputMaybe<Array<DestinationFeaturesOrderBy>>;
};

/** All input for the `deleteDestinationGuide` mutation. */
export type DeleteDestinationGuideInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `DestinationGuide` mutation. */
export type DeleteDestinationGuidePayload = {
  __typename?: 'DeleteDestinationGuidePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedDestinationGuideNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Destination` that is related to this `DestinationGuide`. */
  destination?: Maybe<Destination>;
  /** The `DestinationGuide` that was deleted by this mutation. */
  destinationGuide?: Maybe<DestinationGuide>;
  /** An edge for our `DestinationGuide`. May be used by Relay 1. */
  destinationGuideEdge?: Maybe<DestinationGuidesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `DestinationGuide` mutation. */
export type DeleteDestinationGuidePayloadDestinationGuideEdgeArgs = {
  orderBy?: InputMaybe<Array<DestinationGuidesOrderBy>>;
};

/** All input for the `deleteDestination` mutation. */
export type DeleteDestinationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `Destination` mutation. */
export type DeleteDestinationPayload = {
  __typename?: 'DeleteDestinationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Country` that is related to this `Destination`. */
  country?: Maybe<Country>;
  deletedDestinationNodeId?: Maybe<Scalars['ID']['output']>;
  /** The `Destination` that was deleted by this mutation. */
  destination?: Maybe<Destination>;
  /** An edge for our `Destination`. May be used by Relay 1. */
  destinationEdge?: Maybe<DestinationsEdge>;
  /** Reads a single `MediaGallery` that is related to this `Destination`. */
  gallery?: Maybe<MediaGallery>;
  /** Reads a single `MediaItem` that is related to this `Destination`. */
  heroMedia?: Maybe<MediaItem>;
  /** Reads a single `Destination` that is related to this `Destination`. */
  parent?: Maybe<Destination>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `Destination` mutation. */
export type DeleteDestinationPayloadDestinationEdgeArgs = {
  orderBy?: InputMaybe<Array<DestinationsOrderBy>>;
};

/** All input for the `deleteEmail` mutation. */
export type DeleteEmailInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `Email` mutation. */
export type DeleteEmailPayload = {
  __typename?: 'DeleteEmailPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Customer` that is related to this `Email`. */
  customer?: Maybe<Customer>;
  deletedEmailNodeId?: Maybe<Scalars['ID']['output']>;
  /** The `Email` that was deleted by this mutation. */
  email?: Maybe<Email>;
  /** An edge for our `Email`. May be used by Relay 1. */
  emailEdge?: Maybe<EmailsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Quote` that is related to this `Email`. */
  quote?: Maybe<Quote>;
  /** Reads a single `Trip` that is related to this `Email`. */
  trip?: Maybe<Trip>;
  /** Reads a single `User` that is related to this `Email`. */
  user?: Maybe<User>;
};


/** The output of our delete `Email` mutation. */
export type DeleteEmailPayloadEmailEdgeArgs = {
  orderBy?: InputMaybe<Array<EmailsOrderBy>>;
};

/** All input for the `deleteEnquiry` mutation. */
export type DeleteEnquiryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `Enquiry` mutation. */
export type DeleteEnquiryPayload = {
  __typename?: 'DeleteEnquiryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Customer` that is related to this `Enquiry`. */
  customer?: Maybe<Customer>;
  deletedEnquiryNodeId?: Maybe<Scalars['ID']['output']>;
  /** The `Enquiry` that was deleted by this mutation. */
  enquiry?: Maybe<Enquiry>;
  /** An edge for our `Enquiry`. May be used by Relay 1. */
  enquiryEdge?: Maybe<EnquiriesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Trip` that is related to this `Enquiry`. */
  trip?: Maybe<Trip>;
};


/** The output of our delete `Enquiry` mutation. */
export type DeleteEnquiryPayloadEnquiryEdgeArgs = {
  orderBy?: InputMaybe<Array<EnquiriesOrderBy>>;
};

/** All input for the `deleteExpense` mutation. */
export type DeleteExpenseInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `Expense` mutation. */
export type DeleteExpensePayload = {
  __typename?: 'DeleteExpensePayload';
  /** Reads a single `FinanceCategory` that is related to this `Expense`. */
  category?: Maybe<FinanceCategory>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedExpenseNodeId?: Maybe<Scalars['ID']['output']>;
  /** The `Expense` that was deleted by this mutation. */
  expense?: Maybe<Expense>;
  /** An edge for our `Expense`. May be used by Relay 1. */
  expenseEdge?: Maybe<ExpensesEdge>;
  /** Reads a single `Invoice` that is related to this `Expense`. */
  invoice?: Maybe<Invoice>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Supplier` that is related to this `Expense`. */
  supplier?: Maybe<Supplier>;
  /** Reads a single `SupplierInvoice` that is related to this `Expense`. */
  supplierInvoice?: Maybe<SupplierInvoice>;
  /** Reads a single `Trip` that is related to this `Expense`. */
  trip?: Maybe<Trip>;
};


/** The output of our delete `Expense` mutation. */
export type DeleteExpensePayloadExpenseEdgeArgs = {
  orderBy?: InputMaybe<Array<ExpensesOrderBy>>;
};

/** All input for the `deleteFeature` mutation. */
export type DeleteFeatureInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `Feature` mutation. */
export type DeleteFeaturePayload = {
  __typename?: 'DeleteFeaturePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedFeatureNodeId?: Maybe<Scalars['ID']['output']>;
  /** The `Feature` that was deleted by this mutation. */
  feature?: Maybe<Feature>;
  /** An edge for our `Feature`. May be used by Relay 1. */
  featureEdge?: Maybe<FeaturesEdge>;
  /** Reads a single `MediaGallery` that is related to this `Feature`. */
  gallery?: Maybe<MediaGallery>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `Feature` mutation. */
export type DeleteFeaturePayloadFeatureEdgeArgs = {
  orderBy?: InputMaybe<Array<FeaturesOrderBy>>;
};

/** All input for the `deleteFinanceCategory` mutation. */
export type DeleteFinanceCategoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `FinanceCategory` mutation. */
export type DeleteFinanceCategoryPayload = {
  __typename?: 'DeleteFinanceCategoryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedFinanceCategoryNodeId?: Maybe<Scalars['ID']['output']>;
  /** The `FinanceCategory` that was deleted by this mutation. */
  financeCategory?: Maybe<FinanceCategory>;
  /** An edge for our `FinanceCategory`. May be used by Relay 1. */
  financeCategoryEdge?: Maybe<FinanceCategoriesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `FinanceCategory` mutation. */
export type DeleteFinanceCategoryPayloadFinanceCategoryEdgeArgs = {
  orderBy?: InputMaybe<Array<FinanceCategoriesOrderBy>>;
};

/** All input for the `deleteInvoice` mutation. */
export type DeleteInvoiceInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `Invoice` mutation. */
export type DeleteInvoicePayload = {
  __typename?: 'DeleteInvoicePayload';
  /** Reads a single `FinanceCategory` that is related to this `Invoice`. */
  category?: Maybe<FinanceCategory>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedInvoiceNodeId?: Maybe<Scalars['ID']['output']>;
  /** The `Invoice` that was deleted by this mutation. */
  invoice?: Maybe<Invoice>;
  /** An edge for our `Invoice`. May be used by Relay 1. */
  invoiceEdge?: Maybe<InvoicesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Quote` that is related to this `Invoice`. */
  quote?: Maybe<Quote>;
  /** Reads a single `Trip` that is related to this `Invoice`. */
  trip?: Maybe<Trip>;
};


/** The output of our delete `Invoice` mutation. */
export type DeleteInvoicePayloadInvoiceEdgeArgs = {
  orderBy?: InputMaybe<Array<InvoicesOrderBy>>;
};

/** All input for the `deleteLegalDocument` mutation. */
export type DeleteLegalDocumentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `LegalDocument` mutation. */
export type DeleteLegalDocumentPayload = {
  __typename?: 'DeleteLegalDocumentPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedLegalDocumentNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `LegalFolder` that is related to this `LegalDocument`. */
  folder?: Maybe<LegalFolder>;
  /** The `LegalDocument` that was deleted by this mutation. */
  legalDocument?: Maybe<LegalDocument>;
  /** An edge for our `LegalDocument`. May be used by Relay 1. */
  legalDocumentEdge?: Maybe<LegalDocumentsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `LegalDocument` mutation. */
export type DeleteLegalDocumentPayloadLegalDocumentEdgeArgs = {
  orderBy?: InputMaybe<Array<LegalDocumentsOrderBy>>;
};

/** All input for the `deleteLegalFolder` mutation. */
export type DeleteLegalFolderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `LegalFolder` mutation. */
export type DeleteLegalFolderPayload = {
  __typename?: 'DeleteLegalFolderPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedLegalFolderNodeId?: Maybe<Scalars['ID']['output']>;
  /** The `LegalFolder` that was deleted by this mutation. */
  legalFolder?: Maybe<LegalFolder>;
  /** An edge for our `LegalFolder`. May be used by Relay 1. */
  legalFolderEdge?: Maybe<LegalFoldersEdge>;
  /** Reads a single `LegalFolder` that is related to this `LegalFolder`. */
  parent?: Maybe<LegalFolder>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `LegalFolder` mutation. */
export type DeleteLegalFolderPayloadLegalFolderEdgeArgs = {
  orderBy?: InputMaybe<Array<LegalFoldersOrderBy>>;
};

/** All input for the `deleteMapPoint` mutation. */
export type DeleteMapPointInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `MapPoint` mutation. */
export type DeleteMapPointPayload = {
  __typename?: 'DeleteMapPointPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedMapPointNodeId?: Maybe<Scalars['ID']['output']>;
  /** The `MapPoint` that was deleted by this mutation. */
  mapPoint?: Maybe<MapPoint>;
  /** An edge for our `MapPoint`. May be used by Relay 1. */
  mapPointEdge?: Maybe<MapPointsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `MapPoint` mutation. */
export type DeleteMapPointPayloadMapPointEdgeArgs = {
  orderBy?: InputMaybe<Array<MapPointsOrderBy>>;
};

/** All input for the `deleteMediaGallery` mutation. */
export type DeleteMediaGalleryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** All input for the `deleteMediaGalleryItem` mutation. */
export type DeleteMediaGalleryItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `MediaGalleryItem` mutation. */
export type DeleteMediaGalleryItemPayload = {
  __typename?: 'DeleteMediaGalleryItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedMediaGalleryItemNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `MediaGallery` that is related to this `MediaGalleryItem`. */
  mediaGallery?: Maybe<MediaGallery>;
  /** The `MediaGalleryItem` that was deleted by this mutation. */
  mediaGalleryItem?: Maybe<MediaGalleryItem>;
  /** An edge for our `MediaGalleryItem`. May be used by Relay 1. */
  mediaGalleryItemEdge?: Maybe<MediaGalleryItemsEdge>;
  /** Reads a single `MediaItem` that is related to this `MediaGalleryItem`. */
  mediaItem?: Maybe<MediaItem>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `MediaGalleryItem` mutation. */
export type DeleteMediaGalleryItemPayloadMediaGalleryItemEdgeArgs = {
  orderBy?: InputMaybe<Array<MediaGalleryItemsOrderBy>>;
};

/** The output of our delete `MediaGallery` mutation. */
export type DeleteMediaGalleryPayload = {
  __typename?: 'DeleteMediaGalleryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedMediaGalleryNodeId?: Maybe<Scalars['ID']['output']>;
  /** The `MediaGallery` that was deleted by this mutation. */
  mediaGallery?: Maybe<MediaGallery>;
  /** An edge for our `MediaGallery`. May be used by Relay 1. */
  mediaGalleryEdge?: Maybe<MediaGalleriesEdge>;
  /** Reads a single `MediaGallery` that is related to this `MediaGallery`. */
  parent?: Maybe<MediaGallery>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `MediaGallery` mutation. */
export type DeleteMediaGalleryPayloadMediaGalleryEdgeArgs = {
  orderBy?: InputMaybe<Array<MediaGalleriesOrderBy>>;
};

/** All input for the `deleteMediaItem` mutation. */
export type DeleteMediaItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `MediaItem` mutation. */
export type DeleteMediaItemPayload = {
  __typename?: 'DeleteMediaItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedMediaItemNodeId?: Maybe<Scalars['ID']['output']>;
  /** The `MediaItem` that was deleted by this mutation. */
  mediaItem?: Maybe<MediaItem>;
  /** An edge for our `MediaItem`. May be used by Relay 1. */
  mediaItemEdge?: Maybe<MediaItemsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `MediaItem` mutation. */
export type DeleteMediaItemPayloadMediaItemEdgeArgs = {
  orderBy?: InputMaybe<Array<MediaItemsOrderBy>>;
};

/** All input for the `deleteNote` mutation. */
export type DeleteNoteInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `Note` mutation. */
export type DeleteNotePayload = {
  __typename?: 'DeleteNotePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedNoteNodeId?: Maybe<Scalars['ID']['output']>;
  /** The `Note` that was deleted by this mutation. */
  note?: Maybe<Note>;
  /** An edge for our `Note`. May be used by Relay 1. */
  noteEdge?: Maybe<NotesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Trip` that is related to this `Note`. */
  trip?: Maybe<Trip>;
  /** Reads a single `User` that is related to this `Note`. */
  user?: Maybe<User>;
};


/** The output of our delete `Note` mutation. */
export type DeleteNotePayloadNoteEdgeArgs = {
  orderBy?: InputMaybe<Array<NotesOrderBy>>;
};

/** All input for the `deletePassport` mutation. */
export type DeletePassportInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `Passport` mutation. */
export type DeletePassportPayload = {
  __typename?: 'DeletePassportPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Country` that is related to this `Passport`. */
  country?: Maybe<Country>;
  deletedPassportNodeId?: Maybe<Scalars['ID']['output']>;
  /** The `Passport` that was deleted by this mutation. */
  passport?: Maybe<Passport>;
  /** An edge for our `Passport`. May be used by Relay 1. */
  passportEdge?: Maybe<PassportsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Traveller` that is related to this `Passport`. */
  traveller?: Maybe<Traveller>;
};


/** The output of our delete `Passport` mutation. */
export type DeletePassportPayloadPassportEdgeArgs = {
  orderBy?: InputMaybe<Array<PassportsOrderBy>>;
};

/** All input for the `deletePayment` mutation. */
export type DeletePaymentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `Payment` mutation. */
export type DeletePaymentPayload = {
  __typename?: 'DeletePaymentPayload';
  /** Reads a single `FinanceCategory` that is related to this `Payment`. */
  category?: Maybe<FinanceCategory>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedPaymentNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Invoice` that is related to this `Payment`. */
  invoice?: Maybe<Invoice>;
  /** The `Payment` that was deleted by this mutation. */
  payment?: Maybe<Payment>;
  /** An edge for our `Payment`. May be used by Relay 1. */
  paymentEdge?: Maybe<PaymentsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Trip` that is related to this `Payment`. */
  trip?: Maybe<Trip>;
};


/** The output of our delete `Payment` mutation. */
export type DeletePaymentPayloadPaymentEdgeArgs = {
  orderBy?: InputMaybe<Array<PaymentsOrderBy>>;
};

/** All input for the `deleteProperty` mutation. */
export type DeletePropertyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `Property` mutation. */
export type DeletePropertyPayload = {
  __typename?: 'DeletePropertyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Country` that is related to this `Property`. */
  country?: Maybe<Country>;
  deletedPropertyNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Destination` that is related to this `Property`. */
  destination?: Maybe<Destination>;
  /** Reads a single `MediaGallery` that is related to this `Property`. */
  gallery?: Maybe<MediaGallery>;
  /** Reads a single `MediaItem` that is related to this `Property`. */
  heroMedia?: Maybe<MediaItem>;
  /** Reads a single `MapPoint` that is related to this `Property`. */
  mapPoint?: Maybe<MapPoint>;
  /** The `Property` that was deleted by this mutation. */
  property?: Maybe<Property>;
  /** An edge for our `Property`. May be used by Relay 1. */
  propertyEdge?: Maybe<PropertiesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `Property` mutation. */
export type DeletePropertyPayloadPropertyEdgeArgs = {
  orderBy?: InputMaybe<Array<PropertiesOrderBy>>;
};

/** All input for the `deleteQuoteAcceptance` mutation. */
export type DeleteQuoteAcceptanceInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `QuoteAcceptance` mutation. */
export type DeleteQuoteAcceptancePayload = {
  __typename?: 'DeleteQuoteAcceptancePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedQuoteAcceptanceNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Quote` that is related to this `QuoteAcceptance`. */
  quote?: Maybe<Quote>;
  /** The `QuoteAcceptance` that was deleted by this mutation. */
  quoteAcceptance?: Maybe<QuoteAcceptance>;
  /** An edge for our `QuoteAcceptance`. May be used by Relay 1. */
  quoteAcceptanceEdge?: Maybe<QuoteAcceptancesEdge>;
};


/** The output of our delete `QuoteAcceptance` mutation. */
export type DeleteQuoteAcceptancePayloadQuoteAcceptanceEdgeArgs = {
  orderBy?: InputMaybe<Array<QuoteAcceptancesOrderBy>>;
};

/** All input for the `deleteQuoteAccommodationDetail` mutation. */
export type DeleteQuoteAccommodationDetailInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `QuoteAccommodationDetail` mutation. */
export type DeleteQuoteAccommodationDetailPayload = {
  __typename?: 'DeleteQuoteAccommodationDetailPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedQuoteAccommodationDetailNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Property` that is related to this `QuoteAccommodationDetail`. */
  property?: Maybe<Property>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Quote` that is related to this `QuoteAccommodationDetail`. */
  quote?: Maybe<Quote>;
  /** The `QuoteAccommodationDetail` that was deleted by this mutation. */
  quoteAccommodationDetail?: Maybe<QuoteAccommodationDetail>;
  /** An edge for our `QuoteAccommodationDetail`. May be used by Relay 1. */
  quoteAccommodationDetailEdge?: Maybe<QuoteAccommodationDetailsEdge>;
  /** Reads a single `QuotePublic` that is related to this `QuoteAccommodationDetail`. */
  quotePublic?: Maybe<QuotePublic>;
};


/** The output of our delete `QuoteAccommodationDetail` mutation. */
export type DeleteQuoteAccommodationDetailPayloadQuoteAccommodationDetailEdgeArgs = {
  orderBy?: InputMaybe<Array<QuoteAccommodationDetailsOrderBy>>;
};

/** All input for the `deleteQuoteByKey` mutation. */
export type DeleteQuoteByKeyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  key: Scalars['String']['input'];
};

/** All input for the `deleteQuoteCurrency` mutation. */
export type DeleteQuoteCurrencyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `QuoteCurrency` mutation. */
export type DeleteQuoteCurrencyPayload = {
  __typename?: 'DeleteQuoteCurrencyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedQuoteCurrencyNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Quote` that is related to this `QuoteCurrency`. */
  quote?: Maybe<Quote>;
  /** The `QuoteCurrency` that was deleted by this mutation. */
  quoteCurrency?: Maybe<QuoteCurrency>;
  /** An edge for our `QuoteCurrency`. May be used by Relay 1. */
  quoteCurrencyEdge?: Maybe<QuoteCurrenciesEdge>;
};


/** The output of our delete `QuoteCurrency` mutation. */
export type DeleteQuoteCurrencyPayloadQuoteCurrencyEdgeArgs = {
  orderBy?: InputMaybe<Array<QuoteCurrenciesOrderBy>>;
};

/** All input for the `deleteQuoteDayDestination` mutation. */
export type DeleteQuoteDayDestinationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `QuoteDayDestination` mutation. */
export type DeleteQuoteDayDestinationPayload = {
  __typename?: 'DeleteQuoteDayDestinationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `QuoteDay` that is related to this `QuoteDayDestination`. */
  day?: Maybe<QuoteDay>;
  deletedQuoteDayDestinationNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Destination` that is related to this `QuoteDayDestination`. */
  destination?: Maybe<Destination>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `QuoteDayDestination` that was deleted by this mutation. */
  quoteDayDestination?: Maybe<QuoteDayDestination>;
  /** An edge for our `QuoteDayDestination`. May be used by Relay 1. */
  quoteDayDestinationEdge?: Maybe<QuoteDayDestinationsEdge>;
};


/** The output of our delete `QuoteDayDestination` mutation. */
export type DeleteQuoteDayDestinationPayloadQuoteDayDestinationEdgeArgs = {
  orderBy?: InputMaybe<Array<QuoteDayDestinationsOrderBy>>;
};

/** All input for the `deleteQuoteDay` mutation. */
export type DeleteQuoteDayInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `QuoteDay` mutation. */
export type DeleteQuoteDayPayload = {
  __typename?: 'DeleteQuoteDayPayload';
  /** Reads a single `QuoteAccommodationDetail` that is related to this `QuoteDay`. */
  accommodation?: Maybe<QuoteAccommodationDetail>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedQuoteDayNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Property` that is related to this `QuoteDay`. */
  property?: Maybe<Property>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Quote` that is related to this `QuoteDay`. */
  quote?: Maybe<Quote>;
  /** The `QuoteDay` that was deleted by this mutation. */
  quoteDay?: Maybe<QuoteDay>;
  /** An edge for our `QuoteDay`. May be used by Relay 1. */
  quoteDayEdge?: Maybe<QuoteDaysEdge>;
  /** Reads a single `QuotePublic` that is related to this `QuoteDay`. */
  quotePublic?: Maybe<QuotePublic>;
};


/** The output of our delete `QuoteDay` mutation. */
export type DeleteQuoteDayPayloadQuoteDayEdgeArgs = {
  orderBy?: InputMaybe<Array<QuoteDaysOrderBy>>;
};

/** All input for the `deleteQuoteFinanceLineItem` mutation. */
export type DeleteQuoteFinanceLineItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `QuoteFinanceLineItem` mutation. */
export type DeleteQuoteFinanceLineItemPayload = {
  __typename?: 'DeleteQuoteFinanceLineItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedQuoteFinanceLineItemNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Quote` that is related to this `QuoteFinanceLineItem`. */
  quote?: Maybe<Quote>;
  /** The `QuoteFinanceLineItem` that was deleted by this mutation. */
  quoteFinanceLineItem?: Maybe<QuoteFinanceLineItem>;
  /** An edge for our `QuoteFinanceLineItem`. May be used by Relay 1. */
  quoteFinanceLineItemEdge?: Maybe<QuoteFinanceLineItemsEdge>;
  /** Reads a single `Supplier` that is related to this `QuoteFinanceLineItem`. */
  supplier?: Maybe<Supplier>;
};


/** The output of our delete `QuoteFinanceLineItem` mutation. */
export type DeleteQuoteFinanceLineItemPayloadQuoteFinanceLineItemEdgeArgs = {
  orderBy?: InputMaybe<Array<QuoteFinanceLineItemsOrderBy>>;
};

/** All input for the `deleteQuoteHero` mutation. */
export type DeleteQuoteHeroInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `QuoteHero` mutation. */
export type DeleteQuoteHeroPayload = {
  __typename?: 'DeleteQuoteHeroPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedQuoteHeroNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `MediaItem` that is related to this `QuoteHero`. */
  image?: Maybe<MediaItem>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `QuoteHero` that was deleted by this mutation. */
  quoteHero?: Maybe<QuoteHero>;
  /** An edge for our `QuoteHero`. May be used by Relay 1. */
  quoteHeroEdge?: Maybe<QuoteHeroesEdge>;
};


/** The output of our delete `QuoteHero` mutation. */
export type DeleteQuoteHeroPayloadQuoteHeroEdgeArgs = {
  orderBy?: InputMaybe<Array<QuoteHeroesOrderBy>>;
};

/** All input for the `deleteQuote` mutation. */
export type DeleteQuoteInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** All input for the `deleteQuoteLegalDocument` mutation. */
export type DeleteQuoteLegalDocumentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `QuoteLegalDocument` mutation. */
export type DeleteQuoteLegalDocumentPayload = {
  __typename?: 'DeleteQuoteLegalDocumentPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedQuoteLegalDocumentNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `LegalDocument` that is related to this `QuoteLegalDocument`. */
  legalDocument?: Maybe<LegalDocument>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Quote` that is related to this `QuoteLegalDocument`. */
  quote?: Maybe<Quote>;
  /** The `QuoteLegalDocument` that was deleted by this mutation. */
  quoteLegalDocument?: Maybe<QuoteLegalDocument>;
  /** An edge for our `QuoteLegalDocument`. May be used by Relay 1. */
  quoteLegalDocumentEdge?: Maybe<QuoteLegalDocumentsEdge>;
  /** Reads a single `QuotePublic` that is related to this `QuoteLegalDocument`. */
  quotePublic?: Maybe<QuotePublic>;
};


/** The output of our delete `QuoteLegalDocument` mutation. */
export type DeleteQuoteLegalDocumentPayloadQuoteLegalDocumentEdgeArgs = {
  orderBy?: InputMaybe<Array<QuoteLegalDocumentsOrderBy>>;
};

/** The output of our delete `Quote` mutation. */
export type DeleteQuotePayload = {
  __typename?: 'DeleteQuotePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedQuoteNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `QuoteHero` that is related to this `Quote`. */
  hero?: Maybe<QuoteHero>;
  /** Reads a single `MediaItem` that is related to this `Quote`. */
  heroImage?: Maybe<MediaItem>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Quote` that was deleted by this mutation. */
  quote?: Maybe<Quote>;
  /** An edge for our `Quote`. May be used by Relay 1. */
  quoteEdge?: Maybe<QuotesEdge>;
  /** Reads a single `QuoteStatus` that is related to this `Quote`. */
  quoteStatusByStatus?: Maybe<QuoteStatus>;
  /** Reads a single `Trip` that is related to this `Quote`. */
  trip?: Maybe<Trip>;
  /** Reads a single `User` that is related to this `Quote`. */
  user?: Maybe<User>;
};


/** The output of our delete `Quote` mutation. */
export type DeleteQuotePayloadQuoteEdgeArgs = {
  orderBy?: InputMaybe<Array<QuotesOrderBy>>;
};

/** All input for the `deleteQuotePublic` mutation. */
export type DeleteQuotePublicInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  key: Scalars['String']['input'];
};

/** The output of our delete `QuotePublic` mutation. */
export type DeleteQuotePublicPayload = {
  __typename?: 'DeleteQuotePublicPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedQuotePublicNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `QuoteHero` that is related to this `QuotePublic`. */
  hero?: Maybe<QuoteHero>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `QuotePublic` that was deleted by this mutation. */
  quotePublic?: Maybe<QuotePublic>;
  /** An edge for our `QuotePublic`. May be used by Relay 1. */
  quotePublicEdge?: Maybe<QuotePublicsEdge>;
  /** Reads a single `Trip` that is related to this `QuotePublic`. */
  trip?: Maybe<Trip>;
  /** Reads a single `User` that is related to this `QuotePublic`. */
  user?: Maybe<User>;
};


/** The output of our delete `QuotePublic` mutation. */
export type DeleteQuotePublicPayloadQuotePublicEdgeArgs = {
  orderBy?: InputMaybe<Array<QuotePublicsOrderBy>>;
};

/** All input for the `deleteQuoteStatus` mutation. */
export type DeleteQuoteStatusInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `QuoteStatus` mutation. */
export type DeleteQuoteStatusPayload = {
  __typename?: 'DeleteQuoteStatusPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedQuoteStatusNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `QuoteStatus` that was deleted by this mutation. */
  quoteStatus?: Maybe<QuoteStatus>;
  /** An edge for our `QuoteStatus`. May be used by Relay 1. */
  quoteStatusEdge?: Maybe<QuoteStatusesEdge>;
};


/** The output of our delete `QuoteStatus` mutation. */
export type DeleteQuoteStatusPayloadQuoteStatusEdgeArgs = {
  orderBy?: InputMaybe<Array<QuoteStatusesOrderBy>>;
};

/** All input for the `deleteQuoteView` mutation. */
export type DeleteQuoteViewInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `QuoteView` mutation. */
export type DeleteQuoteViewPayload = {
  __typename?: 'DeleteQuoteViewPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedQuoteViewNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Quote` that is related to this `QuoteView`. */
  quote?: Maybe<Quote>;
  /** The `QuoteView` that was deleted by this mutation. */
  quoteView?: Maybe<QuoteView>;
  /** An edge for our `QuoteView`. May be used by Relay 1. */
  quoteViewEdge?: Maybe<QuoteViewsEdge>;
};


/** The output of our delete `QuoteView` mutation. */
export type DeleteQuoteViewPayloadQuoteViewEdgeArgs = {
  orderBy?: InputMaybe<Array<QuoteViewsOrderBy>>;
};

/** All input for the `deleteReminder` mutation. */
export type DeleteReminderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `Reminder` mutation. */
export type DeleteReminderPayload = {
  __typename?: 'DeleteReminderPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedReminderNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Reminder` that was deleted by this mutation. */
  reminder?: Maybe<Reminder>;
  /** An edge for our `Reminder`. May be used by Relay 1. */
  reminderEdge?: Maybe<RemindersEdge>;
  /** Reads a single `User` that is related to this `Reminder`. */
  user?: Maybe<User>;
};


/** The output of our delete `Reminder` mutation. */
export type DeleteReminderPayloadReminderEdgeArgs = {
  orderBy?: InputMaybe<Array<RemindersOrderBy>>;
};

/** All input for the `deleteSupplier` mutation. */
export type DeleteSupplierInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** All input for the `deleteSupplierInvoice` mutation. */
export type DeleteSupplierInvoiceInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `SupplierInvoice` mutation. */
export type DeleteSupplierInvoicePayload = {
  __typename?: 'DeleteSupplierInvoicePayload';
  /** Reads a single `FinanceCategory` that is related to this `SupplierInvoice`. */
  category?: Maybe<FinanceCategory>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedSupplierInvoiceNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `MediaItem` that is related to this `SupplierInvoice`. */
  mediaItem?: Maybe<MediaItem>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Supplier` that is related to this `SupplierInvoice`. */
  supplier?: Maybe<Supplier>;
  /** The `SupplierInvoice` that was deleted by this mutation. */
  supplierInvoice?: Maybe<SupplierInvoice>;
  /** An edge for our `SupplierInvoice`. May be used by Relay 1. */
  supplierInvoiceEdge?: Maybe<SupplierInvoicesEdge>;
  /** Reads a single `Trip` that is related to this `SupplierInvoice`. */
  trip?: Maybe<Trip>;
};


/** The output of our delete `SupplierInvoice` mutation. */
export type DeleteSupplierInvoicePayloadSupplierInvoiceEdgeArgs = {
  orderBy?: InputMaybe<Array<SupplierInvoicesOrderBy>>;
};

/** The output of our delete `Supplier` mutation. */
export type DeleteSupplierPayload = {
  __typename?: 'DeleteSupplierPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedSupplierNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `MediaGallery` that is related to this `Supplier`. */
  gallery?: Maybe<MediaGallery>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Supplier` that was deleted by this mutation. */
  supplier?: Maybe<Supplier>;
  /** An edge for our `Supplier`. May be used by Relay 1. */
  supplierEdge?: Maybe<SuppliersEdge>;
};


/** The output of our delete `Supplier` mutation. */
export type DeleteSupplierPayloadSupplierEdgeArgs = {
  orderBy?: InputMaybe<Array<SuppliersOrderBy>>;
};

/** All input for the `deleteTestimonial` mutation. */
export type DeleteTestimonialInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `Testimonial` mutation. */
export type DeleteTestimonialPayload = {
  __typename?: 'DeleteTestimonialPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedTestimonialNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Testimonial` that was deleted by this mutation. */
  testimonial?: Maybe<Testimonial>;
  /** An edge for our `Testimonial`. May be used by Relay 1. */
  testimonialEdge?: Maybe<TestimonialsEdge>;
  /** Reads a single `Trip` that is related to this `Testimonial`. */
  trip?: Maybe<Trip>;
};


/** The output of our delete `Testimonial` mutation. */
export type DeleteTestimonialPayloadTestimonialEdgeArgs = {
  orderBy?: InputMaybe<Array<TestimonialsOrderBy>>;
};

/** All input for the `deleteTimezone` mutation. */
export type DeleteTimezoneInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  ogcFid: Scalars['Int']['input'];
};

/** The output of our delete `Timezone` mutation. */
export type DeleteTimezonePayload = {
  __typename?: 'DeleteTimezonePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedTimezoneNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Timezone` that was deleted by this mutation. */
  timezone?: Maybe<Timezone>;
  /** An edge for our `Timezone`. May be used by Relay 1. */
  timezoneEdge?: Maybe<TimezonesEdge>;
};


/** The output of our delete `Timezone` mutation. */
export type DeleteTimezonePayloadTimezoneEdgeArgs = {
  orderBy?: InputMaybe<Array<TimezonesOrderBy>>;
};

/** All input for the `deleteTransactionImportBatch` mutation. */
export type DeleteTransactionImportBatchInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `TransactionImportBatch` mutation. */
export type DeleteTransactionImportBatchPayload = {
  __typename?: 'DeleteTransactionImportBatchPayload';
  /** Reads a single `Account` that is related to this `TransactionImportBatch`. */
  account?: Maybe<Account>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedTransactionImportBatchNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `TransactionImportBatch` that was deleted by this mutation. */
  transactionImportBatch?: Maybe<TransactionImportBatch>;
  /** An edge for our `TransactionImportBatch`. May be used by Relay 1. */
  transactionImportBatchEdge?: Maybe<TransactionImportBatchesEdge>;
};


/** The output of our delete `TransactionImportBatch` mutation. */
export type DeleteTransactionImportBatchPayloadTransactionImportBatchEdgeArgs = {
  orderBy?: InputMaybe<Array<TransactionImportBatchesOrderBy>>;
};

/** All input for the `deleteTransaction` mutation. */
export type DeleteTransactionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** All input for the `deleteTransactionLink` mutation. */
export type DeleteTransactionLinkInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `TransactionLink` mutation. */
export type DeleteTransactionLinkPayload = {
  __typename?: 'DeleteTransactionLinkPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedTransactionLinkNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Expense` that is related to this `TransactionLink`. */
  expense?: Maybe<Expense>;
  /** Reads a single `Invoice` that is related to this `TransactionLink`. */
  invoice?: Maybe<Invoice>;
  /** Reads a single `Payment` that is related to this `TransactionLink`. */
  payment?: Maybe<Payment>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `SupplierInvoice` that is related to this `TransactionLink`. */
  supplierInvoice?: Maybe<SupplierInvoice>;
  /** Reads a single `Transaction` that is related to this `TransactionLink`. */
  transaction?: Maybe<Transaction>;
  /** The `TransactionLink` that was deleted by this mutation. */
  transactionLink?: Maybe<TransactionLink>;
  /** An edge for our `TransactionLink`. May be used by Relay 1. */
  transactionLinkEdge?: Maybe<TransactionLinksEdge>;
};


/** The output of our delete `TransactionLink` mutation. */
export type DeleteTransactionLinkPayloadTransactionLinkEdgeArgs = {
  orderBy?: InputMaybe<Array<TransactionLinksOrderBy>>;
};

/** All input for the `deleteTransactionNote` mutation. */
export type DeleteTransactionNoteInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `TransactionNote` mutation. */
export type DeleteTransactionNotePayload = {
  __typename?: 'DeleteTransactionNotePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedTransactionNoteNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Transaction` that is related to this `TransactionNote`. */
  transaction?: Maybe<Transaction>;
  /** The `TransactionNote` that was deleted by this mutation. */
  transactionNote?: Maybe<TransactionNote>;
  /** An edge for our `TransactionNote`. May be used by Relay 1. */
  transactionNoteEdge?: Maybe<TransactionNotesEdge>;
  /** Reads a single `User` that is related to this `TransactionNote`. */
  user?: Maybe<User>;
};


/** The output of our delete `TransactionNote` mutation. */
export type DeleteTransactionNotePayloadTransactionNoteEdgeArgs = {
  orderBy?: InputMaybe<Array<TransactionNotesOrderBy>>;
};

/** The output of our delete `Transaction` mutation. */
export type DeleteTransactionPayload = {
  __typename?: 'DeleteTransactionPayload';
  /** Reads a single `Account` that is related to this `Transaction`. */
  account?: Maybe<Account>;
  /** Reads a single `FinanceCategory` that is related to this `Transaction`. */
  category?: Maybe<FinanceCategory>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedTransactionNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Transaction` that is related to this `Transaction`. */
  reverseTransaction?: Maybe<Transaction>;
  /** The `Transaction` that was deleted by this mutation. */
  transaction?: Maybe<Transaction>;
  /** An edge for our `Transaction`. May be used by Relay 1. */
  transactionEdge?: Maybe<TransactionsEdge>;
  /** Reads a single `TransactionImportBatch` that is related to this `Transaction`. */
  transactionImportBatch?: Maybe<TransactionImportBatch>;
};


/** The output of our delete `Transaction` mutation. */
export type DeleteTransactionPayloadTransactionEdgeArgs = {
  orderBy?: InputMaybe<Array<TransactionsOrderBy>>;
};

/** All input for the `deleteTraveller` mutation. */
export type DeleteTravellerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `Traveller` mutation. */
export type DeleteTravellerPayload = {
  __typename?: 'DeleteTravellerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedTravellerNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Traveller` that was deleted by this mutation. */
  traveller?: Maybe<Traveller>;
  /** An edge for our `Traveller`. May be used by Relay 1. */
  travellerEdge?: Maybe<TravellersEdge>;
};


/** The output of our delete `Traveller` mutation. */
export type DeleteTravellerPayloadTravellerEdgeArgs = {
  orderBy?: InputMaybe<Array<TravellersOrderBy>>;
};

/** All input for the `deleteTripFlight` mutation. */
export type DeleteTripFlightInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `TripFlight` mutation. */
export type DeleteTripFlightPayload = {
  __typename?: 'DeleteTripFlightPayload';
  /** Reads a single `Airport` that is related to this `TripFlight`. */
  arrivalAirport?: Maybe<Airport>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedTripFlightNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Airport` that is related to this `TripFlight`. */
  departureAirport?: Maybe<Airport>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Trip` that is related to this `TripFlight`. */
  trip?: Maybe<Trip>;
  /** The `TripFlight` that was deleted by this mutation. */
  tripFlight?: Maybe<TripFlight>;
  /** An edge for our `TripFlight`. May be used by Relay 1. */
  tripFlightEdge?: Maybe<TripFlightsEdge>;
};


/** The output of our delete `TripFlight` mutation. */
export type DeleteTripFlightPayloadTripFlightEdgeArgs = {
  orderBy?: InputMaybe<Array<TripFlightsOrderBy>>;
};

/** All input for the `deleteTrip` mutation. */
export type DeleteTripInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `Trip` mutation. */
export type DeleteTripPayload = {
  __typename?: 'DeleteTripPayload';
  /** Reads a single `Quote` that is related to this `Trip`. */
  activeQuote?: Maybe<Quote>;
  /** Reads a single `Agency` that is related to this `Trip`. */
  agency?: Maybe<Agency>;
  /** Reads a single `AgencyMember` that is related to this `Trip`. */
  agencyMember?: Maybe<AgencyMember>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Customer` that is related to this `Trip`. */
  customer?: Maybe<Customer>;
  deletedTripNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `MediaGallery` that is related to this `Trip`. */
  mediaGallery?: Maybe<MediaGallery>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Trip` that was deleted by this mutation. */
  trip?: Maybe<Trip>;
  /** An edge for our `Trip`. May be used by Relay 1. */
  tripEdge?: Maybe<TripsEdge>;
  /** Reads a single `User` that is related to this `Trip`. */
  user?: Maybe<User>;
};


/** The output of our delete `Trip` mutation. */
export type DeleteTripPayloadTripEdgeArgs = {
  orderBy?: InputMaybe<Array<TripsOrderBy>>;
};

/** All input for the `deleteTripTraveller` mutation. */
export type DeleteTripTravellerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `TripTraveller` mutation. */
export type DeleteTripTravellerPayload = {
  __typename?: 'DeleteTripTravellerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedTripTravellerNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Traveller` that is related to this `TripTraveller`. */
  traveller?: Maybe<Traveller>;
  /** Reads a single `Trip` that is related to this `TripTraveller`. */
  trip?: Maybe<Trip>;
  /** The `TripTraveller` that was deleted by this mutation. */
  tripTraveller?: Maybe<TripTraveller>;
  /** An edge for our `TripTraveller`. May be used by Relay 1. */
  tripTravellerEdge?: Maybe<TripTravellersEdge>;
};


/** The output of our delete `TripTraveller` mutation. */
export type DeleteTripTravellerPayloadTripTravellerEdgeArgs = {
  orderBy?: InputMaybe<Array<TripTravellersOrderBy>>;
};

/** All input for the `deleteUser` mutation. */
export type DeleteUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `User` mutation. */
export type DeleteUserPayload = {
  __typename?: 'DeleteUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedUserNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `User` that was deleted by this mutation. */
  user?: Maybe<User>;
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge?: Maybe<UsersEdge>;
};


/** The output of our delete `User` mutation. */
export type DeleteUserPayloadUserEdgeArgs = {
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

/** All input for the `deleteVisaRequirement` mutation. */
export type DeleteVisaRequirementInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
};

/** The output of our delete `VisaRequirement` mutation. */
export type DeleteVisaRequirementPayload = {
  __typename?: 'DeleteVisaRequirementPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedVisaRequirementNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `VisaRequirement` that was deleted by this mutation. */
  visaRequirement?: Maybe<VisaRequirement>;
  /** An edge for our `VisaRequirement`. May be used by Relay 1. */
  visaRequirementEdge?: Maybe<VisaRequirementsEdge>;
};


/** The output of our delete `VisaRequirement` mutation. */
export type DeleteVisaRequirementPayloadVisaRequirementEdgeArgs = {
  orderBy?: InputMaybe<Array<VisaRequirementsOrderBy>>;
};

export type Destination = {
  __typename?: 'Destination';
  alias: Scalars['String']['output'];
  body?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `Destination`. */
  childDestinations: DestinationsConnection;
  /** Reads a single `Country` that is related to this `Destination`. */
  country?: Maybe<Country>;
  countryId: Scalars['UUID']['output'];
  created: Scalars['Datetime']['output'];
  /** Reads and enables pagination through a set of `DestinationFeature`. */
  destinationFeatures: DestinationFeaturesConnection;
  /** Reads and enables pagination through a set of `DestinationGuide`. */
  destinationGuides: DestinationGuidesConnection;
  /** Reads a single `MediaGallery` that is related to this `Destination`. */
  gallery?: Maybe<MediaGallery>;
  galleryId?: Maybe<Scalars['UUID']['output']>;
  /** Reads a single `MediaItem` that is related to this `Destination`. */
  heroMedia?: Maybe<MediaItem>;
  heroMediaId?: Maybe<Scalars['UUID']['output']>;
  id: Scalars['UUID']['output'];
  latitude?: Maybe<Scalars['Float']['output']>;
  longitude?: Maybe<Scalars['Float']['output']>;
  modified: Scalars['Datetime']['output'];
  name?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Destination` that is related to this `Destination`. */
  parent?: Maybe<Destination>;
  parentId?: Maybe<Scalars['UUID']['output']>;
  /** Reads and enables pagination through a set of `Property`. */
  properties: PropertiesConnection;
  /** Reads and enables pagination through a set of `QuoteDayDestination`. */
  quoteDayDestinations: QuoteDayDestinationsConnection;
};


export type DestinationChildDestinationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DestinationCondition>;
  filter?: InputMaybe<DestinationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DestinationsOrderBy>>;
};


export type DestinationDestinationFeaturesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DestinationFeatureCondition>;
  filter?: InputMaybe<DestinationFeatureFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DestinationFeaturesOrderBy>>;
};


export type DestinationDestinationGuidesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DestinationGuideCondition>;
  filter?: InputMaybe<DestinationGuideFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DestinationGuidesOrderBy>>;
};


export type DestinationPropertiesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PropertyCondition>;
  filter?: InputMaybe<PropertyFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PropertiesOrderBy>>;
};


export type DestinationQuoteDayDestinationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<QuoteDayDestinationCondition>;
  filter?: InputMaybe<QuoteDayDestinationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuoteDayDestinationsOrderBy>>;
};

/**
 * A condition to be used against `Destination` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type DestinationCondition = {
  /** Checks for equality with the object’s `alias` field. */
  alias?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `body` field. */
  body?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `countryId` field. */
  countryId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `galleryId` field. */
  galleryId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `heroMediaId` field. */
  heroMediaId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `latitude` field. */
  latitude?: InputMaybe<Scalars['Float']['input']>;
  /** Checks for equality with the object’s `longitude` field. */
  longitude?: InputMaybe<Scalars['Float']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `parentId` field. */
  parentId?: InputMaybe<Scalars['UUID']['input']>;
};

export type DestinationFeature = {
  __typename?: 'DestinationFeature';
  body?: Maybe<Scalars['String']['output']>;
  created: Scalars['Datetime']['output'];
  /** Reads a single `Destination` that is related to this `DestinationFeature`. */
  destination?: Maybe<Destination>;
  destinationId: Scalars['UUID']['output'];
  /** Reads a single `MediaGallery` that is related to this `DestinationFeature`. */
  gallery?: Maybe<MediaGallery>;
  galleryId?: Maybe<Scalars['UUID']['output']>;
  id: Scalars['UUID']['output'];
  modified: Scalars['Datetime']['output'];
  title?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `DestinationFeature` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type DestinationFeatureCondition = {
  /** Checks for equality with the object’s `body` field. */
  body?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `destinationId` field. */
  destinationId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `galleryId` field. */
  galleryId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `title` field. */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `DestinationFeature` object types. All fields are combined with a logical ‘and.’ */
export type DestinationFeatureFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DestinationFeatureFilter>>;
  /** Filter by the object’s `body` field. */
  body?: InputMaybe<StringFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `destination` relation. */
  destination?: InputMaybe<DestinationFilter>;
  /** Filter by the object’s `destinationId` field. */
  destinationId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `gallery` relation. */
  gallery?: InputMaybe<MediaGalleryFilter>;
  /** A related `gallery` exists. */
  galleryExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `galleryId` field. */
  galleryId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DestinationFeatureFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DestinationFeatureFilter>>;
  /** Filter by the object’s `title` field. */
  title?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `DestinationFeature` */
export type DestinationFeatureInput = {
  body?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationId?: InputMaybe<Scalars['UUID']['input']>;
  destinationToDestinationId?: InputMaybe<FkDestinationFeatureDestinationDestinationIdInput>;
  galleryId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryToGalleryId?: InputMaybe<FkDestinationFeatureMediaGalleryGalleryIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** The fields on `destinationFeature` to look up the row to update. */
export type DestinationFeatureOnDestinationFeatureForFkDestinationFeatureDestinationDestinationIdUsingPkDestinationFeatureUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `destinationFeature` being updated. */
  patch: UpdateDestinationFeatureOnDestinationFeatureForFkDestinationFeatureDestinationDestinationIdPatch;
};

/** The fields on `destinationFeature` to look up the row to update. */
export type DestinationFeatureOnDestinationFeatureForFkDestinationFeatureMediaGalleryGalleryIdUsingPkDestinationFeatureUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `destinationFeature` being updated. */
  patch: UpdateDestinationFeatureOnDestinationFeatureForFkDestinationFeatureMediaGalleryGalleryIdPatch;
};

/** Represents an update to a `DestinationFeature`. Fields that are set will be updated. */
export type DestinationFeaturePatch = {
  body?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationId?: InputMaybe<Scalars['UUID']['input']>;
  destinationToDestinationId?: InputMaybe<FkDestinationFeatureDestinationDestinationIdInput>;
  galleryId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryToGalleryId?: InputMaybe<FkDestinationFeatureMediaGalleryGalleryIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** The fields on `destinationFeature` to look up the row to connect. */
export type DestinationFeaturePkDestinationFeatureConnect = {
  id: Scalars['UUID']['input'];
};

/** The fields on `destinationFeature` to look up the row to delete. */
export type DestinationFeaturePkDestinationFeatureDelete = {
  id: Scalars['UUID']['input'];
};

/** A connection to a list of `DestinationFeature` values. */
export type DestinationFeaturesConnection = {
  __typename?: 'DestinationFeaturesConnection';
  /** A list of edges which contains the `DestinationFeature` and cursor to aid in pagination. */
  edges: Array<DestinationFeaturesEdge>;
  /** A list of `DestinationFeature` objects. */
  nodes: Array<Maybe<DestinationFeature>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DestinationFeature` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DestinationFeature` edge in the connection. */
export type DestinationFeaturesEdge = {
  __typename?: 'DestinationFeaturesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DestinationFeature` at the end of the edge. */
  node?: Maybe<DestinationFeature>;
};

/** Methods to use when ordering `DestinationFeature`. */
export enum DestinationFeaturesOrderBy {
  BodyAsc = 'BODY_ASC',
  BodyDesc = 'BODY_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  DestinationByDestinationIdAliasAsc = 'DESTINATION_BY_DESTINATION_ID__ALIAS_ASC',
  DestinationByDestinationIdAliasDesc = 'DESTINATION_BY_DESTINATION_ID__ALIAS_DESC',
  DestinationByDestinationIdBodyAsc = 'DESTINATION_BY_DESTINATION_ID__BODY_ASC',
  DestinationByDestinationIdBodyDesc = 'DESTINATION_BY_DESTINATION_ID__BODY_DESC',
  DestinationByDestinationIdCountryIdAsc = 'DESTINATION_BY_DESTINATION_ID__COUNTRY_ID_ASC',
  DestinationByDestinationIdCountryIdDesc = 'DESTINATION_BY_DESTINATION_ID__COUNTRY_ID_DESC',
  DestinationByDestinationIdCreatedAsc = 'DESTINATION_BY_DESTINATION_ID__CREATED_ASC',
  DestinationByDestinationIdCreatedDesc = 'DESTINATION_BY_DESTINATION_ID__CREATED_DESC',
  DestinationByDestinationIdGalleryIdAsc = 'DESTINATION_BY_DESTINATION_ID__GALLERY_ID_ASC',
  DestinationByDestinationIdGalleryIdDesc = 'DESTINATION_BY_DESTINATION_ID__GALLERY_ID_DESC',
  DestinationByDestinationIdHeroMediaIdAsc = 'DESTINATION_BY_DESTINATION_ID__HERO_MEDIA_ID_ASC',
  DestinationByDestinationIdHeroMediaIdDesc = 'DESTINATION_BY_DESTINATION_ID__HERO_MEDIA_ID_DESC',
  DestinationByDestinationIdIdAsc = 'DESTINATION_BY_DESTINATION_ID__ID_ASC',
  DestinationByDestinationIdIdDesc = 'DESTINATION_BY_DESTINATION_ID__ID_DESC',
  DestinationByDestinationIdLatitudeAsc = 'DESTINATION_BY_DESTINATION_ID__LATITUDE_ASC',
  DestinationByDestinationIdLatitudeDesc = 'DESTINATION_BY_DESTINATION_ID__LATITUDE_DESC',
  DestinationByDestinationIdLongitudeAsc = 'DESTINATION_BY_DESTINATION_ID__LONGITUDE_ASC',
  DestinationByDestinationIdLongitudeDesc = 'DESTINATION_BY_DESTINATION_ID__LONGITUDE_DESC',
  DestinationByDestinationIdModifiedAsc = 'DESTINATION_BY_DESTINATION_ID__MODIFIED_ASC',
  DestinationByDestinationIdModifiedDesc = 'DESTINATION_BY_DESTINATION_ID__MODIFIED_DESC',
  DestinationByDestinationIdNameAsc = 'DESTINATION_BY_DESTINATION_ID__NAME_ASC',
  DestinationByDestinationIdNameDesc = 'DESTINATION_BY_DESTINATION_ID__NAME_DESC',
  DestinationByDestinationIdParentIdAsc = 'DESTINATION_BY_DESTINATION_ID__PARENT_ID_ASC',
  DestinationByDestinationIdParentIdDesc = 'DESTINATION_BY_DESTINATION_ID__PARENT_ID_DESC',
  DestinationIdAsc = 'DESTINATION_ID_ASC',
  DestinationIdDesc = 'DESTINATION_ID_DESC',
  GalleryIdAsc = 'GALLERY_ID_ASC',
  GalleryIdDesc = 'GALLERY_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  MediaGalleryByGalleryIdCreatedAsc = 'MEDIA_GALLERY_BY_GALLERY_ID__CREATED_ASC',
  MediaGalleryByGalleryIdCreatedDesc = 'MEDIA_GALLERY_BY_GALLERY_ID__CREATED_DESC',
  MediaGalleryByGalleryIdIdAsc = 'MEDIA_GALLERY_BY_GALLERY_ID__ID_ASC',
  MediaGalleryByGalleryIdIdDesc = 'MEDIA_GALLERY_BY_GALLERY_ID__ID_DESC',
  MediaGalleryByGalleryIdIsProtectedAsc = 'MEDIA_GALLERY_BY_GALLERY_ID__IS_PROTECTED_ASC',
  MediaGalleryByGalleryIdIsProtectedDesc = 'MEDIA_GALLERY_BY_GALLERY_ID__IS_PROTECTED_DESC',
  MediaGalleryByGalleryIdModifiedAsc = 'MEDIA_GALLERY_BY_GALLERY_ID__MODIFIED_ASC',
  MediaGalleryByGalleryIdModifiedDesc = 'MEDIA_GALLERY_BY_GALLERY_ID__MODIFIED_DESC',
  MediaGalleryByGalleryIdNameAsc = 'MEDIA_GALLERY_BY_GALLERY_ID__NAME_ASC',
  MediaGalleryByGalleryIdNameDesc = 'MEDIA_GALLERY_BY_GALLERY_ID__NAME_DESC',
  MediaGalleryByGalleryIdParentIdAsc = 'MEDIA_GALLERY_BY_GALLERY_ID__PARENT_ID_ASC',
  MediaGalleryByGalleryIdParentIdDesc = 'MEDIA_GALLERY_BY_GALLERY_ID__PARENT_ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC'
}

/** A filter to be used against `Destination` object types. All fields are combined with a logical ‘and.’ */
export type DestinationFilter = {
  /** Filter by the object’s `alias` field. */
  alias?: InputMaybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DestinationFilter>>;
  /** Filter by the object’s `body` field. */
  body?: InputMaybe<StringFilter>;
  /** Filter by the object’s `childDestinations` relation. */
  childDestinations?: InputMaybe<DestinationToManyDestinationFilter>;
  /** Some related `childDestinations` exist. */
  childDestinationsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `country` relation. */
  country?: InputMaybe<CountryFilter>;
  /** Filter by the object’s `countryId` field. */
  countryId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `destinationFeatures` relation. */
  destinationFeatures?: InputMaybe<DestinationToManyDestinationFeatureFilter>;
  /** Some related `destinationFeatures` exist. */
  destinationFeaturesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `destinationGuides` relation. */
  destinationGuides?: InputMaybe<DestinationToManyDestinationGuideFilter>;
  /** Some related `destinationGuides` exist. */
  destinationGuidesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `gallery` relation. */
  gallery?: InputMaybe<MediaGalleryFilter>;
  /** A related `gallery` exists. */
  galleryExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `galleryId` field. */
  galleryId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `heroMedia` relation. */
  heroMedia?: InputMaybe<MediaItemFilter>;
  /** A related `heroMedia` exists. */
  heroMediaExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `heroMediaId` field. */
  heroMediaId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `latitude` field. */
  latitude?: InputMaybe<FloatFilter>;
  /** Filter by the object’s `longitude` field. */
  longitude?: InputMaybe<FloatFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DestinationFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DestinationFilter>>;
  /** Filter by the object’s `parent` relation. */
  parent?: InputMaybe<DestinationFilter>;
  /** A related `parent` exists. */
  parentExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `parentId` field. */
  parentId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `properties` relation. */
  properties?: InputMaybe<DestinationToManyPropertyFilter>;
  /** Some related `properties` exist. */
  propertiesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `quoteDayDestinations` relation. */
  quoteDayDestinations?: InputMaybe<DestinationToManyQuoteDayDestinationFilter>;
  /** Some related `quoteDayDestinations` exist. */
  quoteDayDestinationsExist?: InputMaybe<Scalars['Boolean']['input']>;
};

export type DestinationGuide = {
  __typename?: 'DestinationGuide';
  body?: Maybe<Scalars['String']['output']>;
  created: Scalars['Datetime']['output'];
  /** Reads a single `Destination` that is related to this `DestinationGuide`. */
  destination?: Maybe<Destination>;
  destinationId: Scalars['UUID']['output'];
  id: Scalars['UUID']['output'];
  modified: Scalars['Datetime']['output'];
  title?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `DestinationGuide` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type DestinationGuideCondition = {
  /** Checks for equality with the object’s `body` field. */
  body?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `destinationId` field. */
  destinationId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `title` field. */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `DestinationGuide` object types. All fields are combined with a logical ‘and.’ */
export type DestinationGuideFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DestinationGuideFilter>>;
  /** Filter by the object’s `body` field. */
  body?: InputMaybe<StringFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `destination` relation. */
  destination?: InputMaybe<DestinationFilter>;
  /** Filter by the object’s `destinationId` field. */
  destinationId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DestinationGuideFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DestinationGuideFilter>>;
  /** Filter by the object’s `title` field. */
  title?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `DestinationGuide` */
export type DestinationGuideInput = {
  body?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationId?: InputMaybe<Scalars['UUID']['input']>;
  destinationToDestinationId?: InputMaybe<FkDestinationGuideDestinationDestinationIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** The fields on `destinationGuide` to look up the row to update. */
export type DestinationGuideOnDestinationGuideForFkDestinationGuideDestinationDestinationIdUsingPkDestinationGuideUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `destinationGuide` being updated. */
  patch: UpdateDestinationGuideOnDestinationGuideForFkDestinationGuideDestinationDestinationIdPatch;
};

/** Represents an update to a `DestinationGuide`. Fields that are set will be updated. */
export type DestinationGuidePatch = {
  body?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationId?: InputMaybe<Scalars['UUID']['input']>;
  destinationToDestinationId?: InputMaybe<FkDestinationGuideDestinationDestinationIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** The fields on `destinationGuide` to look up the row to connect. */
export type DestinationGuidePkDestinationGuideConnect = {
  id: Scalars['UUID']['input'];
};

/** The fields on `destinationGuide` to look up the row to delete. */
export type DestinationGuidePkDestinationGuideDelete = {
  id: Scalars['UUID']['input'];
};

/** A connection to a list of `DestinationGuide` values. */
export type DestinationGuidesConnection = {
  __typename?: 'DestinationGuidesConnection';
  /** A list of edges which contains the `DestinationGuide` and cursor to aid in pagination. */
  edges: Array<DestinationGuidesEdge>;
  /** A list of `DestinationGuide` objects. */
  nodes: Array<Maybe<DestinationGuide>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DestinationGuide` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DestinationGuide` edge in the connection. */
export type DestinationGuidesEdge = {
  __typename?: 'DestinationGuidesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DestinationGuide` at the end of the edge. */
  node?: Maybe<DestinationGuide>;
};

/** Methods to use when ordering `DestinationGuide`. */
export enum DestinationGuidesOrderBy {
  BodyAsc = 'BODY_ASC',
  BodyDesc = 'BODY_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  DestinationByDestinationIdAliasAsc = 'DESTINATION_BY_DESTINATION_ID__ALIAS_ASC',
  DestinationByDestinationIdAliasDesc = 'DESTINATION_BY_DESTINATION_ID__ALIAS_DESC',
  DestinationByDestinationIdBodyAsc = 'DESTINATION_BY_DESTINATION_ID__BODY_ASC',
  DestinationByDestinationIdBodyDesc = 'DESTINATION_BY_DESTINATION_ID__BODY_DESC',
  DestinationByDestinationIdCountryIdAsc = 'DESTINATION_BY_DESTINATION_ID__COUNTRY_ID_ASC',
  DestinationByDestinationIdCountryIdDesc = 'DESTINATION_BY_DESTINATION_ID__COUNTRY_ID_DESC',
  DestinationByDestinationIdCreatedAsc = 'DESTINATION_BY_DESTINATION_ID__CREATED_ASC',
  DestinationByDestinationIdCreatedDesc = 'DESTINATION_BY_DESTINATION_ID__CREATED_DESC',
  DestinationByDestinationIdGalleryIdAsc = 'DESTINATION_BY_DESTINATION_ID__GALLERY_ID_ASC',
  DestinationByDestinationIdGalleryIdDesc = 'DESTINATION_BY_DESTINATION_ID__GALLERY_ID_DESC',
  DestinationByDestinationIdHeroMediaIdAsc = 'DESTINATION_BY_DESTINATION_ID__HERO_MEDIA_ID_ASC',
  DestinationByDestinationIdHeroMediaIdDesc = 'DESTINATION_BY_DESTINATION_ID__HERO_MEDIA_ID_DESC',
  DestinationByDestinationIdIdAsc = 'DESTINATION_BY_DESTINATION_ID__ID_ASC',
  DestinationByDestinationIdIdDesc = 'DESTINATION_BY_DESTINATION_ID__ID_DESC',
  DestinationByDestinationIdLatitudeAsc = 'DESTINATION_BY_DESTINATION_ID__LATITUDE_ASC',
  DestinationByDestinationIdLatitudeDesc = 'DESTINATION_BY_DESTINATION_ID__LATITUDE_DESC',
  DestinationByDestinationIdLongitudeAsc = 'DESTINATION_BY_DESTINATION_ID__LONGITUDE_ASC',
  DestinationByDestinationIdLongitudeDesc = 'DESTINATION_BY_DESTINATION_ID__LONGITUDE_DESC',
  DestinationByDestinationIdModifiedAsc = 'DESTINATION_BY_DESTINATION_ID__MODIFIED_ASC',
  DestinationByDestinationIdModifiedDesc = 'DESTINATION_BY_DESTINATION_ID__MODIFIED_DESC',
  DestinationByDestinationIdNameAsc = 'DESTINATION_BY_DESTINATION_ID__NAME_ASC',
  DestinationByDestinationIdNameDesc = 'DESTINATION_BY_DESTINATION_ID__NAME_DESC',
  DestinationByDestinationIdParentIdAsc = 'DESTINATION_BY_DESTINATION_ID__PARENT_ID_ASC',
  DestinationByDestinationIdParentIdDesc = 'DESTINATION_BY_DESTINATION_ID__PARENT_ID_DESC',
  DestinationIdAsc = 'DESTINATION_ID_ASC',
  DestinationIdDesc = 'DESTINATION_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC'
}

/** The `destination` to be created by this mutation. */
export type DestinationHeroMediaIdFkeyDestinationCreateInput = {
  alias: Scalars['String']['input'];
  body?: InputMaybe<Scalars['String']['input']>;
  countryId?: InputMaybe<Scalars['UUID']['input']>;
  countryToCountryId?: InputMaybe<FkDestinationCountryCountryIdInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationFeaturesUsingId?: InputMaybe<FkDestinationFeatureDestinationDestinationIdInverseInput>;
  destinationGuidesUsingId?: InputMaybe<FkDestinationGuideDestinationDestinationIdInverseInput>;
  destinationToParentId?: InputMaybe<FkDestinationDestinationParentIdInput>;
  galleryId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  latitude?: InputMaybe<Scalars['Float']['input']>;
  longitude?: InputMaybe<Scalars['Float']['input']>;
  mediaGalleryToGalleryId?: InputMaybe<FkDestinationMediaGalleryGalleryIdInput>;
  mediaItemToHeroMediaId?: InputMaybe<DestinationHeroMediaIdFkeyInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  parentId?: InputMaybe<Scalars['UUID']['input']>;
  propertiesUsingId?: InputMaybe<FkPropertyDestinationInverseInput>;
  quoteDayDestinationsUsingId?: InputMaybe<FkQuoteDayDestinationDestinationDestinationIdInverseInput>;
};

/** Input for the nested mutation of `mediaItem` in the `DestinationInput` mutation. */
export type DestinationHeroMediaIdFkeyInput = {
  /** The primary key(s) for `mediaItem` for the far side of the relationship. */
  connectById?: InputMaybe<MediaItemPkMediaItemConnect>;
  /** A `MediaItemInput` object that will be created and connected to this object. */
  create?: InputMaybe<DestinationHeroMediaIdFkeyMediaItemCreateInput>;
  /** The primary key(s) for `mediaItem` for the far side of the relationship. */
  deleteById?: InputMaybe<MediaItemPkMediaItemDelete>;
  /** The primary key(s) and patch data for `mediaItem` for the far side of the relationship. */
  updateById?: InputMaybe<MediaItemOnDestinationForDestinationHeroMediaIdFkeyUsingPkMediaItemUpdate>;
};

/** Input for the nested mutation of `destination` in the `MediaItemInput` mutation. */
export type DestinationHeroMediaIdFkeyInverseInput = {
  /** The primary key(s) for `destination` for the far side of the relationship. */
  connectByCountryIdAndAlias?: InputMaybe<Array<DestinationUqDestinationAliasConnect>>;
  /** The primary key(s) for `destination` for the far side of the relationship. */
  connectById?: InputMaybe<Array<DestinationPkDestinationConnect>>;
  /** A `DestinationInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<DestinationHeroMediaIdFkeyDestinationCreateInput>>;
  /** The primary key(s) for `destination` for the far side of the relationship. */
  deleteByCountryIdAndAlias?: InputMaybe<Array<DestinationUqDestinationAliasDelete>>;
  /** The primary key(s) for `destination` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<DestinationPkDestinationDelete>>;
  /** Flag indicating whether all other `destination` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `destination` for the far side of the relationship. */
  updateByCountryIdAndAlias?: InputMaybe<Array<DestinationOnDestinationForDestinationHeroMediaIdFkeyUsingUqDestinationAliasUpdate>>;
  /** The primary key(s) and patch data for `destination` for the far side of the relationship. */
  updateById?: InputMaybe<Array<DestinationOnDestinationForDestinationHeroMediaIdFkeyUsingPkDestinationUpdate>>;
};

/** The `mediaItem` to be created by this mutation. */
export type DestinationHeroMediaIdFkeyMediaItemCreateInput = {
  agenciesUsingId?: InputMaybe<FkAgencyMediaItemLogoIdInverseInput>;
  contentType?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationsUsingId?: InputMaybe<DestinationHeroMediaIdFkeyInverseInput>;
  fileName?: InputMaybe<Scalars['String']['input']>;
  hash?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryItemsUsingId?: InputMaybe<FkMediaGalleryItemMediaItemMediaItemIdInverseInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  propertiesUsingId?: InputMaybe<FkPropertyMediaItemHeroMediaIdInverseInput>;
  quoteHeroesUsingId?: InputMaybe<FkQuoteHeroMediaItemImageIdInverseInput>;
  quotesUsingId?: InputMaybe<FkQuoteMediaItemHeroImageIdInverseInput>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceMediaItemMediaItemIdInverseInput>;
};

/** An input for mutations affecting `Destination` */
export type DestinationInput = {
  alias: Scalars['String']['input'];
  body?: InputMaybe<Scalars['String']['input']>;
  countryId?: InputMaybe<Scalars['UUID']['input']>;
  countryToCountryId?: InputMaybe<FkDestinationCountryCountryIdInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationFeaturesUsingId?: InputMaybe<FkDestinationFeatureDestinationDestinationIdInverseInput>;
  destinationGuidesUsingId?: InputMaybe<FkDestinationGuideDestinationDestinationIdInverseInput>;
  destinationToParentId?: InputMaybe<FkDestinationDestinationParentIdInput>;
  galleryId?: InputMaybe<Scalars['UUID']['input']>;
  heroMediaId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  latitude?: InputMaybe<Scalars['Float']['input']>;
  longitude?: InputMaybe<Scalars['Float']['input']>;
  mediaGalleryToGalleryId?: InputMaybe<FkDestinationMediaGalleryGalleryIdInput>;
  mediaItemToHeroMediaId?: InputMaybe<DestinationHeroMediaIdFkeyInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  parentId?: InputMaybe<Scalars['UUID']['input']>;
  propertiesUsingId?: InputMaybe<FkPropertyDestinationInverseInput>;
  quoteDayDestinationsUsingId?: InputMaybe<FkQuoteDayDestinationDestinationDestinationIdInverseInput>;
};

/** The fields on `destination` to look up the row to update. */
export type DestinationOnDestinationFeatureForFkDestinationFeatureDestinationDestinationIdUsingPkDestinationUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `destination` being updated. */
  patch: UpdateDestinationOnDestinationFeatureForFkDestinationFeatureDestinationDestinationIdPatch;
};

/** The fields on `destination` to look up the row to update. */
export type DestinationOnDestinationFeatureForFkDestinationFeatureDestinationDestinationIdUsingUqDestinationAliasUpdate = {
  alias: Scalars['String']['input'];
  countryId: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `destination` being updated. */
  patch: UpdateDestinationOnDestinationFeatureForFkDestinationFeatureDestinationDestinationIdPatch;
};

/** The fields on `destination` to look up the row to update. */
export type DestinationOnDestinationForDestinationHeroMediaIdFkeyUsingPkDestinationUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `destination` being updated. */
  patch: UpdateDestinationOnDestinationForDestinationHeroMediaIdFkeyPatch;
};

/** The fields on `destination` to look up the row to update. */
export type DestinationOnDestinationForDestinationHeroMediaIdFkeyUsingUqDestinationAliasUpdate = {
  alias: Scalars['String']['input'];
  countryId: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `destination` being updated. */
  patch: UpdateDestinationOnDestinationForDestinationHeroMediaIdFkeyPatch;
};

/** The fields on `destination` to look up the row to update. */
export type DestinationOnDestinationForFkDestinationCountryCountryIdUsingPkDestinationUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `destination` being updated. */
  patch: UpdateDestinationOnDestinationForFkDestinationCountryCountryIdPatch;
};

/** The fields on `destination` to look up the row to update. */
export type DestinationOnDestinationForFkDestinationCountryCountryIdUsingUqDestinationAliasUpdate = {
  alias: Scalars['String']['input'];
  countryId: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `destination` being updated. */
  patch: UpdateDestinationOnDestinationForFkDestinationCountryCountryIdPatch;
};

/** The fields on `destination` to look up the row to update. */
export type DestinationOnDestinationForFkDestinationDestinationParentIdUsingPkDestinationUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `destination` being updated. */
  patch: UpdateDestinationOnDestinationForFkDestinationDestinationParentIdPatch;
};

/** The fields on `destination` to look up the row to update. */
export type DestinationOnDestinationForFkDestinationDestinationParentIdUsingUqDestinationAliasUpdate = {
  alias: Scalars['String']['input'];
  countryId: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `destination` being updated. */
  patch: UpdateDestinationOnDestinationForFkDestinationDestinationParentIdPatch;
};

/** The fields on `destination` to look up the row to update. */
export type DestinationOnDestinationForFkDestinationMediaGalleryGalleryIdUsingPkDestinationUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `destination` being updated. */
  patch: UpdateDestinationOnDestinationForFkDestinationMediaGalleryGalleryIdPatch;
};

/** The fields on `destination` to look up the row to update. */
export type DestinationOnDestinationForFkDestinationMediaGalleryGalleryIdUsingUqDestinationAliasUpdate = {
  alias: Scalars['String']['input'];
  countryId: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `destination` being updated. */
  patch: UpdateDestinationOnDestinationForFkDestinationMediaGalleryGalleryIdPatch;
};

/** The fields on `destination` to look up the row to update. */
export type DestinationOnDestinationGuideForFkDestinationGuideDestinationDestinationIdUsingPkDestinationUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `destination` being updated. */
  patch: UpdateDestinationOnDestinationGuideForFkDestinationGuideDestinationDestinationIdPatch;
};

/** The fields on `destination` to look up the row to update. */
export type DestinationOnDestinationGuideForFkDestinationGuideDestinationDestinationIdUsingUqDestinationAliasUpdate = {
  alias: Scalars['String']['input'];
  countryId: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `destination` being updated. */
  patch: UpdateDestinationOnDestinationGuideForFkDestinationGuideDestinationDestinationIdPatch;
};

/** The fields on `destination` to look up the row to update. */
export type DestinationOnPropertyForFkPropertyDestinationUsingPkDestinationUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `destination` being updated. */
  patch: UpdateDestinationOnPropertyForFkPropertyDestinationPatch;
};

/** The fields on `destination` to look up the row to update. */
export type DestinationOnPropertyForFkPropertyDestinationUsingUqDestinationAliasUpdate = {
  alias: Scalars['String']['input'];
  countryId: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `destination` being updated. */
  patch: UpdateDestinationOnPropertyForFkPropertyDestinationPatch;
};

/** The fields on `destination` to look up the row to update. */
export type DestinationOnQuoteDayDestinationForFkQuoteDayDestinationDestinationDestinationIdUsingPkDestinationUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `destination` being updated. */
  patch: UpdateDestinationOnQuoteDayDestinationForFkQuoteDayDestinationDestinationDestinationIdPatch;
};

/** The fields on `destination` to look up the row to update. */
export type DestinationOnQuoteDayDestinationForFkQuoteDayDestinationDestinationDestinationIdUsingUqDestinationAliasUpdate = {
  alias: Scalars['String']['input'];
  countryId: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `destination` being updated. */
  patch: UpdateDestinationOnQuoteDayDestinationForFkQuoteDayDestinationDestinationDestinationIdPatch;
};

/** Represents an update to a `Destination`. Fields that are set will be updated. */
export type DestinationPatch = {
  alias?: InputMaybe<Scalars['String']['input']>;
  body?: InputMaybe<Scalars['String']['input']>;
  countryId?: InputMaybe<Scalars['UUID']['input']>;
  countryToCountryId?: InputMaybe<FkDestinationCountryCountryIdInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationFeaturesUsingId?: InputMaybe<FkDestinationFeatureDestinationDestinationIdInverseInput>;
  destinationGuidesUsingId?: InputMaybe<FkDestinationGuideDestinationDestinationIdInverseInput>;
  destinationToParentId?: InputMaybe<FkDestinationDestinationParentIdInput>;
  galleryId?: InputMaybe<Scalars['UUID']['input']>;
  heroMediaId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  latitude?: InputMaybe<Scalars['Float']['input']>;
  longitude?: InputMaybe<Scalars['Float']['input']>;
  mediaGalleryToGalleryId?: InputMaybe<FkDestinationMediaGalleryGalleryIdInput>;
  mediaItemToHeroMediaId?: InputMaybe<DestinationHeroMediaIdFkeyInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  parentId?: InputMaybe<Scalars['UUID']['input']>;
  propertiesUsingId?: InputMaybe<FkPropertyDestinationInverseInput>;
  quoteDayDestinationsUsingId?: InputMaybe<FkQuoteDayDestinationDestinationDestinationIdInverseInput>;
};

/** The fields on `destination` to look up the row to connect. */
export type DestinationPkDestinationConnect = {
  id: Scalars['UUID']['input'];
};

/** The fields on `destination` to look up the row to delete. */
export type DestinationPkDestinationDelete = {
  id: Scalars['UUID']['input'];
};

/** A filter to be used against many `DestinationFeature` object types. All fields are combined with a logical ‘and.’ */
export type DestinationToManyDestinationFeatureFilter = {
  /** Every related `DestinationFeature` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<DestinationFeatureFilter>;
  /** No related `DestinationFeature` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<DestinationFeatureFilter>;
  /** Some related `DestinationFeature` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<DestinationFeatureFilter>;
};

/** A filter to be used against many `Destination` object types. All fields are combined with a logical ‘and.’ */
export type DestinationToManyDestinationFilter = {
  /** Every related `Destination` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<DestinationFilter>;
  /** No related `Destination` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<DestinationFilter>;
  /** Some related `Destination` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<DestinationFilter>;
};

/** A filter to be used against many `DestinationGuide` object types. All fields are combined with a logical ‘and.’ */
export type DestinationToManyDestinationGuideFilter = {
  /** Every related `DestinationGuide` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<DestinationGuideFilter>;
  /** No related `DestinationGuide` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<DestinationGuideFilter>;
  /** Some related `DestinationGuide` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<DestinationGuideFilter>;
};

/** A filter to be used against many `Property` object types. All fields are combined with a logical ‘and.’ */
export type DestinationToManyPropertyFilter = {
  /** Every related `Property` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<PropertyFilter>;
  /** No related `Property` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<PropertyFilter>;
  /** Some related `Property` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<PropertyFilter>;
};

/** A filter to be used against many `QuoteDayDestination` object types. All fields are combined with a logical ‘and.’ */
export type DestinationToManyQuoteDayDestinationFilter = {
  /** Every related `QuoteDayDestination` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<QuoteDayDestinationFilter>;
  /** No related `QuoteDayDestination` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<QuoteDayDestinationFilter>;
  /** Some related `QuoteDayDestination` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<QuoteDayDestinationFilter>;
};

/** The fields on `destination` to look up the row to connect. */
export type DestinationUqDestinationAliasConnect = {
  alias: Scalars['String']['input'];
  countryId: Scalars['UUID']['input'];
};

/** The fields on `destination` to look up the row to delete. */
export type DestinationUqDestinationAliasDelete = {
  alias: Scalars['String']['input'];
  countryId: Scalars['UUID']['input'];
};

/** A connection to a list of `Destination` values. */
export type DestinationsConnection = {
  __typename?: 'DestinationsConnection';
  /** A list of edges which contains the `Destination` and cursor to aid in pagination. */
  edges: Array<DestinationsEdge>;
  /** A list of `Destination` objects. */
  nodes: Array<Maybe<Destination>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Destination` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Destination` edge in the connection. */
export type DestinationsEdge = {
  __typename?: 'DestinationsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Destination` at the end of the edge. */
  node?: Maybe<Destination>;
};

/** Methods to use when ordering `Destination`. */
export enum DestinationsOrderBy {
  AliasAsc = 'ALIAS_ASC',
  AliasDesc = 'ALIAS_DESC',
  BodyAsc = 'BODY_ASC',
  BodyDesc = 'BODY_DESC',
  CountryByCountryIdCreatedAsc = 'COUNTRY_BY_COUNTRY_ID__CREATED_ASC',
  CountryByCountryIdCreatedDesc = 'COUNTRY_BY_COUNTRY_ID__CREATED_DESC',
  CountryByCountryIdIdAsc = 'COUNTRY_BY_COUNTRY_ID__ID_ASC',
  CountryByCountryIdIdDesc = 'COUNTRY_BY_COUNTRY_ID__ID_DESC',
  CountryByCountryIdIso2Asc = 'COUNTRY_BY_COUNTRY_ID__ISO2_ASC',
  CountryByCountryIdIso2Desc = 'COUNTRY_BY_COUNTRY_ID__ISO2_DESC',
  CountryByCountryIdIso3Asc = 'COUNTRY_BY_COUNTRY_ID__ISO3_ASC',
  CountryByCountryIdIso3Desc = 'COUNTRY_BY_COUNTRY_ID__ISO3_DESC',
  CountryByCountryIdModifiedAsc = 'COUNTRY_BY_COUNTRY_ID__MODIFIED_ASC',
  CountryByCountryIdModifiedDesc = 'COUNTRY_BY_COUNTRY_ID__MODIFIED_DESC',
  CountryByCountryIdNameAsc = 'COUNTRY_BY_COUNTRY_ID__NAME_ASC',
  CountryByCountryIdNameDesc = 'COUNTRY_BY_COUNTRY_ID__NAME_DESC',
  CountryIdAsc = 'COUNTRY_ID_ASC',
  CountryIdDesc = 'COUNTRY_ID_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  DestinationsByParentIdCountAsc = 'DESTINATIONS_BY_PARENT_ID__COUNT_ASC',
  DestinationsByParentIdCountDesc = 'DESTINATIONS_BY_PARENT_ID__COUNT_DESC',
  DestinationByParentIdAliasAsc = 'DESTINATION_BY_PARENT_ID__ALIAS_ASC',
  DestinationByParentIdAliasDesc = 'DESTINATION_BY_PARENT_ID__ALIAS_DESC',
  DestinationByParentIdBodyAsc = 'DESTINATION_BY_PARENT_ID__BODY_ASC',
  DestinationByParentIdBodyDesc = 'DESTINATION_BY_PARENT_ID__BODY_DESC',
  DestinationByParentIdCountryIdAsc = 'DESTINATION_BY_PARENT_ID__COUNTRY_ID_ASC',
  DestinationByParentIdCountryIdDesc = 'DESTINATION_BY_PARENT_ID__COUNTRY_ID_DESC',
  DestinationByParentIdCreatedAsc = 'DESTINATION_BY_PARENT_ID__CREATED_ASC',
  DestinationByParentIdCreatedDesc = 'DESTINATION_BY_PARENT_ID__CREATED_DESC',
  DestinationByParentIdGalleryIdAsc = 'DESTINATION_BY_PARENT_ID__GALLERY_ID_ASC',
  DestinationByParentIdGalleryIdDesc = 'DESTINATION_BY_PARENT_ID__GALLERY_ID_DESC',
  DestinationByParentIdHeroMediaIdAsc = 'DESTINATION_BY_PARENT_ID__HERO_MEDIA_ID_ASC',
  DestinationByParentIdHeroMediaIdDesc = 'DESTINATION_BY_PARENT_ID__HERO_MEDIA_ID_DESC',
  DestinationByParentIdIdAsc = 'DESTINATION_BY_PARENT_ID__ID_ASC',
  DestinationByParentIdIdDesc = 'DESTINATION_BY_PARENT_ID__ID_DESC',
  DestinationByParentIdLatitudeAsc = 'DESTINATION_BY_PARENT_ID__LATITUDE_ASC',
  DestinationByParentIdLatitudeDesc = 'DESTINATION_BY_PARENT_ID__LATITUDE_DESC',
  DestinationByParentIdLongitudeAsc = 'DESTINATION_BY_PARENT_ID__LONGITUDE_ASC',
  DestinationByParentIdLongitudeDesc = 'DESTINATION_BY_PARENT_ID__LONGITUDE_DESC',
  DestinationByParentIdModifiedAsc = 'DESTINATION_BY_PARENT_ID__MODIFIED_ASC',
  DestinationByParentIdModifiedDesc = 'DESTINATION_BY_PARENT_ID__MODIFIED_DESC',
  DestinationByParentIdNameAsc = 'DESTINATION_BY_PARENT_ID__NAME_ASC',
  DestinationByParentIdNameDesc = 'DESTINATION_BY_PARENT_ID__NAME_DESC',
  DestinationByParentIdParentIdAsc = 'DESTINATION_BY_PARENT_ID__PARENT_ID_ASC',
  DestinationByParentIdParentIdDesc = 'DESTINATION_BY_PARENT_ID__PARENT_ID_DESC',
  DestinationFeaturesByDestinationIdCountAsc = 'DESTINATION_FEATURES_BY_DESTINATION_ID__COUNT_ASC',
  DestinationFeaturesByDestinationIdCountDesc = 'DESTINATION_FEATURES_BY_DESTINATION_ID__COUNT_DESC',
  DestinationGuidesByDestinationIdCountAsc = 'DESTINATION_GUIDES_BY_DESTINATION_ID__COUNT_ASC',
  DestinationGuidesByDestinationIdCountDesc = 'DESTINATION_GUIDES_BY_DESTINATION_ID__COUNT_DESC',
  GalleryIdAsc = 'GALLERY_ID_ASC',
  GalleryIdDesc = 'GALLERY_ID_DESC',
  HeroMediaIdAsc = 'HERO_MEDIA_ID_ASC',
  HeroMediaIdDesc = 'HERO_MEDIA_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LatitudeAsc = 'LATITUDE_ASC',
  LatitudeDesc = 'LATITUDE_DESC',
  LongitudeAsc = 'LONGITUDE_ASC',
  LongitudeDesc = 'LONGITUDE_DESC',
  MediaGalleryByGalleryIdCreatedAsc = 'MEDIA_GALLERY_BY_GALLERY_ID__CREATED_ASC',
  MediaGalleryByGalleryIdCreatedDesc = 'MEDIA_GALLERY_BY_GALLERY_ID__CREATED_DESC',
  MediaGalleryByGalleryIdIdAsc = 'MEDIA_GALLERY_BY_GALLERY_ID__ID_ASC',
  MediaGalleryByGalleryIdIdDesc = 'MEDIA_GALLERY_BY_GALLERY_ID__ID_DESC',
  MediaGalleryByGalleryIdIsProtectedAsc = 'MEDIA_GALLERY_BY_GALLERY_ID__IS_PROTECTED_ASC',
  MediaGalleryByGalleryIdIsProtectedDesc = 'MEDIA_GALLERY_BY_GALLERY_ID__IS_PROTECTED_DESC',
  MediaGalleryByGalleryIdModifiedAsc = 'MEDIA_GALLERY_BY_GALLERY_ID__MODIFIED_ASC',
  MediaGalleryByGalleryIdModifiedDesc = 'MEDIA_GALLERY_BY_GALLERY_ID__MODIFIED_DESC',
  MediaGalleryByGalleryIdNameAsc = 'MEDIA_GALLERY_BY_GALLERY_ID__NAME_ASC',
  MediaGalleryByGalleryIdNameDesc = 'MEDIA_GALLERY_BY_GALLERY_ID__NAME_DESC',
  MediaGalleryByGalleryIdParentIdAsc = 'MEDIA_GALLERY_BY_GALLERY_ID__PARENT_ID_ASC',
  MediaGalleryByGalleryIdParentIdDesc = 'MEDIA_GALLERY_BY_GALLERY_ID__PARENT_ID_DESC',
  MediaItemByHeroMediaIdContentTypeAsc = 'MEDIA_ITEM_BY_HERO_MEDIA_ID__CONTENT_TYPE_ASC',
  MediaItemByHeroMediaIdContentTypeDesc = 'MEDIA_ITEM_BY_HERO_MEDIA_ID__CONTENT_TYPE_DESC',
  MediaItemByHeroMediaIdCreatedAsc = 'MEDIA_ITEM_BY_HERO_MEDIA_ID__CREATED_ASC',
  MediaItemByHeroMediaIdCreatedDesc = 'MEDIA_ITEM_BY_HERO_MEDIA_ID__CREATED_DESC',
  MediaItemByHeroMediaIdFileNameAsc = 'MEDIA_ITEM_BY_HERO_MEDIA_ID__FILE_NAME_ASC',
  MediaItemByHeroMediaIdFileNameDesc = 'MEDIA_ITEM_BY_HERO_MEDIA_ID__FILE_NAME_DESC',
  MediaItemByHeroMediaIdHashAsc = 'MEDIA_ITEM_BY_HERO_MEDIA_ID__HASH_ASC',
  MediaItemByHeroMediaIdHashDesc = 'MEDIA_ITEM_BY_HERO_MEDIA_ID__HASH_DESC',
  MediaItemByHeroMediaIdIdAsc = 'MEDIA_ITEM_BY_HERO_MEDIA_ID__ID_ASC',
  MediaItemByHeroMediaIdIdDesc = 'MEDIA_ITEM_BY_HERO_MEDIA_ID__ID_DESC',
  MediaItemByHeroMediaIdModifiedAsc = 'MEDIA_ITEM_BY_HERO_MEDIA_ID__MODIFIED_ASC',
  MediaItemByHeroMediaIdModifiedDesc = 'MEDIA_ITEM_BY_HERO_MEDIA_ID__MODIFIED_DESC',
  MediaItemByHeroMediaIdNameAsc = 'MEDIA_ITEM_BY_HERO_MEDIA_ID__NAME_ASC',
  MediaItemByHeroMediaIdNameDesc = 'MEDIA_ITEM_BY_HERO_MEDIA_ID__NAME_DESC',
  MediaItemByHeroMediaIdSummaryAsc = 'MEDIA_ITEM_BY_HERO_MEDIA_ID__SUMMARY_ASC',
  MediaItemByHeroMediaIdSummaryDesc = 'MEDIA_ITEM_BY_HERO_MEDIA_ID__SUMMARY_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  ParentIdAsc = 'PARENT_ID_ASC',
  ParentIdDesc = 'PARENT_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  PropertiesByDestinationIdCountAsc = 'PROPERTIES_BY_DESTINATION_ID__COUNT_ASC',
  PropertiesByDestinationIdCountDesc = 'PROPERTIES_BY_DESTINATION_ID__COUNT_DESC',
  QuoteDayDestinationsByDestinationIdCountAsc = 'QUOTE_DAY_DESTINATIONS_BY_DESTINATION_ID__COUNT_ASC',
  QuoteDayDestinationsByDestinationIdCountDesc = 'QUOTE_DAY_DESTINATIONS_BY_DESTINATION_ID__COUNT_DESC'
}

export type Email = {
  __typename?: 'Email';
  body?: Maybe<Scalars['String']['output']>;
  created: Scalars['Datetime']['output'];
  /** Reads a single `Customer` that is related to this `Email`. */
  customer?: Maybe<Customer>;
  customerId: Scalars['UUID']['output'];
  id: Scalars['UUID']['output'];
  notes?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Quote` that is related to this `Email`. */
  quote?: Maybe<Quote>;
  quoteId?: Maybe<Scalars['UUID']['output']>;
  recipients?: Maybe<Scalars['String']['output']>;
  subject?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Trip` that is related to this `Email`. */
  trip?: Maybe<Trip>;
  tripId?: Maybe<Scalars['UUID']['output']>;
  /** Reads a single `User` that is related to this `Email`. */
  user?: Maybe<User>;
  userId: Scalars['UUID']['output'];
};

/** A condition to be used against `Email` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type EmailCondition = {
  /** Checks for equality with the object’s `body` field. */
  body?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `customerId` field. */
  customerId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `quoteId` field. */
  quoteId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `recipients` field. */
  recipients?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `subject` field. */
  subject?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `tripId` field. */
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['UUID']['input']>;
};

/** A filter to be used against `Email` object types. All fields are combined with a logical ‘and.’ */
export type EmailFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<EmailFilter>>;
  /** Filter by the object’s `body` field. */
  body?: InputMaybe<StringFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `customer` relation. */
  customer?: InputMaybe<CustomerFilter>;
  /** Filter by the object’s `customerId` field. */
  customerId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Negates the expression. */
  not?: InputMaybe<EmailFilter>;
  /** Filter by the object’s `notes` field. */
  notes?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<EmailFilter>>;
  /** Filter by the object’s `quote` relation. */
  quote?: InputMaybe<QuoteFilter>;
  /** A related `quote` exists. */
  quoteExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `quoteId` field. */
  quoteId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `recipients` field. */
  recipients?: InputMaybe<StringFilter>;
  /** Filter by the object’s `subject` field. */
  subject?: InputMaybe<StringFilter>;
  /** Filter by the object’s `trip` relation. */
  trip?: InputMaybe<TripFilter>;
  /** A related `trip` exists. */
  tripExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `tripId` field. */
  tripId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `user` relation. */
  user?: InputMaybe<UserFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<UuidFilter>;
};

/** An input for mutations affecting `Email` */
export type EmailInput = {
  body?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerId?: InputMaybe<Scalars['UUID']['input']>;
  customerToCustomerId?: InputMaybe<FkEmailCustomerCustomerIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  quoteId?: InputMaybe<Scalars['UUID']['input']>;
  quoteToQuoteId?: InputMaybe<FkEmailQuoteQuoteIdInput>;
  recipients?: InputMaybe<Scalars['String']['input']>;
  subject?: InputMaybe<Scalars['String']['input']>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkEmailTripTripIdInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkEmailUserUserIdInput>;
};

/** The fields on `email` to look up the row to update. */
export type EmailOnEmailForFkEmailCustomerCustomerIdUsingPkEmailUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `email` being updated. */
  patch: UpdateEmailOnEmailForFkEmailCustomerCustomerIdPatch;
};

/** The fields on `email` to look up the row to update. */
export type EmailOnEmailForFkEmailQuoteQuoteIdUsingPkEmailUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `email` being updated. */
  patch: UpdateEmailOnEmailForFkEmailQuoteQuoteIdPatch;
};

/** The fields on `email` to look up the row to update. */
export type EmailOnEmailForFkEmailTripTripIdUsingPkEmailUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `email` being updated. */
  patch: UpdateEmailOnEmailForFkEmailTripTripIdPatch;
};

/** The fields on `email` to look up the row to update. */
export type EmailOnEmailForFkEmailUserUserIdUsingPkEmailUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `email` being updated. */
  patch: UpdateEmailOnEmailForFkEmailUserUserIdPatch;
};

/** Represents an update to a `Email`. Fields that are set will be updated. */
export type EmailPatch = {
  body?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerId?: InputMaybe<Scalars['UUID']['input']>;
  customerToCustomerId?: InputMaybe<FkEmailCustomerCustomerIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  quoteId?: InputMaybe<Scalars['UUID']['input']>;
  quoteToQuoteId?: InputMaybe<FkEmailQuoteQuoteIdInput>;
  recipients?: InputMaybe<Scalars['String']['input']>;
  subject?: InputMaybe<Scalars['String']['input']>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkEmailTripTripIdInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkEmailUserUserIdInput>;
};

/** The fields on `email` to look up the row to connect. */
export type EmailPkEmailConnect = {
  id: Scalars['UUID']['input'];
};

/** The fields on `email` to look up the row to delete. */
export type EmailPkEmailDelete = {
  id: Scalars['UUID']['input'];
};

/** A connection to a list of `Email` values. */
export type EmailsConnection = {
  __typename?: 'EmailsConnection';
  /** A list of edges which contains the `Email` and cursor to aid in pagination. */
  edges: Array<EmailsEdge>;
  /** A list of `Email` objects. */
  nodes: Array<Maybe<Email>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Email` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Email` edge in the connection. */
export type EmailsEdge = {
  __typename?: 'EmailsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Email` at the end of the edge. */
  node?: Maybe<Email>;
};

/** Methods to use when ordering `Email`. */
export enum EmailsOrderBy {
  BodyAsc = 'BODY_ASC',
  BodyDesc = 'BODY_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  CustomerByCustomerIdCreatedAsc = 'CUSTOMER_BY_CUSTOMER_ID__CREATED_ASC',
  CustomerByCustomerIdCreatedDesc = 'CUSTOMER_BY_CUSTOMER_ID__CREATED_DESC',
  CustomerByCustomerIdEmailAsc = 'CUSTOMER_BY_CUSTOMER_ID__EMAIL_ASC',
  CustomerByCustomerIdEmailDesc = 'CUSTOMER_BY_CUSTOMER_ID__EMAIL_DESC',
  CustomerByCustomerIdIdAsc = 'CUSTOMER_BY_CUSTOMER_ID__ID_ASC',
  CustomerByCustomerIdIdDesc = 'CUSTOMER_BY_CUSTOMER_ID__ID_DESC',
  CustomerByCustomerIdModifiedAsc = 'CUSTOMER_BY_CUSTOMER_ID__MODIFIED_ASC',
  CustomerByCustomerIdModifiedDesc = 'CUSTOMER_BY_CUSTOMER_ID__MODIFIED_DESC',
  CustomerByCustomerIdNameAsc = 'CUSTOMER_BY_CUSTOMER_ID__NAME_ASC',
  CustomerByCustomerIdNameDesc = 'CUSTOMER_BY_CUSTOMER_ID__NAME_DESC',
  CustomerByCustomerIdPhoneAsc = 'CUSTOMER_BY_CUSTOMER_ID__PHONE_ASC',
  CustomerByCustomerIdPhoneDesc = 'CUSTOMER_BY_CUSTOMER_ID__PHONE_DESC',
  CustomerIdAsc = 'CUSTOMER_ID_ASC',
  CustomerIdDesc = 'CUSTOMER_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  NotesAsc = 'NOTES_ASC',
  NotesDesc = 'NOTES_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QuoteByQuoteIdAdjustmentAsc = 'QUOTE_BY_QUOTE_ID__ADJUSTMENT_ASC',
  QuoteByQuoteIdAdjustmentDesc = 'QUOTE_BY_QUOTE_ID__ADJUSTMENT_DESC',
  QuoteByQuoteIdAgentMarginAsc = 'QUOTE_BY_QUOTE_ID__AGENT_MARGIN_ASC',
  QuoteByQuoteIdAgentMarginDesc = 'QUOTE_BY_QUOTE_ID__AGENT_MARGIN_DESC',
  QuoteByQuoteIdArchivedAsc = 'QUOTE_BY_QUOTE_ID__ARCHIVED_ASC',
  QuoteByQuoteIdArchivedDesc = 'QUOTE_BY_QUOTE_ID__ARCHIVED_DESC',
  QuoteByQuoteIdBaseCurrencyAsc = 'QUOTE_BY_QUOTE_ID__BASE_CURRENCY_ASC',
  QuoteByQuoteIdBaseCurrencyDesc = 'QUOTE_BY_QUOTE_ID__BASE_CURRENCY_DESC',
  QuoteByQuoteIdCreatedAsc = 'QUOTE_BY_QUOTE_ID__CREATED_ASC',
  QuoteByQuoteIdCreatedDesc = 'QUOTE_BY_QUOTE_ID__CREATED_DESC',
  QuoteByQuoteIdDepositAsc = 'QUOTE_BY_QUOTE_ID__DEPOSIT_ASC',
  QuoteByQuoteIdDepositDesc = 'QUOTE_BY_QUOTE_ID__DEPOSIT_DESC',
  QuoteByQuoteIdDurationAsc = 'QUOTE_BY_QUOTE_ID__DURATION_ASC',
  QuoteByQuoteIdDurationDesc = 'QUOTE_BY_QUOTE_ID__DURATION_DESC',
  QuoteByQuoteIdExclusionsAsc = 'QUOTE_BY_QUOTE_ID__EXCLUSIONS_ASC',
  QuoteByQuoteIdExclusionsDesc = 'QUOTE_BY_QUOTE_ID__EXCLUSIONS_DESC',
  QuoteByQuoteIdExpiresAsc = 'QUOTE_BY_QUOTE_ID__EXPIRES_ASC',
  QuoteByQuoteIdExpiresDesc = 'QUOTE_BY_QUOTE_ID__EXPIRES_DESC',
  QuoteByQuoteIdHeroIdAsc = 'QUOTE_BY_QUOTE_ID__HERO_ID_ASC',
  QuoteByQuoteIdHeroIdDesc = 'QUOTE_BY_QUOTE_ID__HERO_ID_DESC',
  QuoteByQuoteIdHeroImageIdAsc = 'QUOTE_BY_QUOTE_ID__HERO_IMAGE_ID_ASC',
  QuoteByQuoteIdHeroImageIdDesc = 'QUOTE_BY_QUOTE_ID__HERO_IMAGE_ID_DESC',
  QuoteByQuoteIdIdAsc = 'QUOTE_BY_QUOTE_ID__ID_ASC',
  QuoteByQuoteIdIdDesc = 'QUOTE_BY_QUOTE_ID__ID_DESC',
  QuoteByQuoteIdInclusionsAsc = 'QUOTE_BY_QUOTE_ID__INCLUSIONS_ASC',
  QuoteByQuoteIdInclusionsDesc = 'QUOTE_BY_QUOTE_ID__INCLUSIONS_DESC',
  QuoteByQuoteIdKeyAsc = 'QUOTE_BY_QUOTE_ID__KEY_ASC',
  QuoteByQuoteIdKeyDesc = 'QUOTE_BY_QUOTE_ID__KEY_DESC',
  QuoteByQuoteIdLockedAsc = 'QUOTE_BY_QUOTE_ID__LOCKED_ASC',
  QuoteByQuoteIdLockedDesc = 'QUOTE_BY_QUOTE_ID__LOCKED_DESC',
  QuoteByQuoteIdMarginAsc = 'QUOTE_BY_QUOTE_ID__MARGIN_ASC',
  QuoteByQuoteIdMarginDesc = 'QUOTE_BY_QUOTE_ID__MARGIN_DESC',
  QuoteByQuoteIdModifiedAsc = 'QUOTE_BY_QUOTE_ID__MODIFIED_ASC',
  QuoteByQuoteIdModifiedDesc = 'QUOTE_BY_QUOTE_ID__MODIFIED_DESC',
  QuoteByQuoteIdShortDescriptionAsc = 'QUOTE_BY_QUOTE_ID__SHORT_DESCRIPTION_ASC',
  QuoteByQuoteIdShortDescriptionDesc = 'QUOTE_BY_QUOTE_ID__SHORT_DESCRIPTION_DESC',
  QuoteByQuoteIdStartAsc = 'QUOTE_BY_QUOTE_ID__START_ASC',
  QuoteByQuoteIdStartDesc = 'QUOTE_BY_QUOTE_ID__START_DESC',
  QuoteByQuoteIdStatusAsc = 'QUOTE_BY_QUOTE_ID__STATUS_ASC',
  QuoteByQuoteIdStatusDesc = 'QUOTE_BY_QUOTE_ID__STATUS_DESC',
  QuoteByQuoteIdSummaryAsc = 'QUOTE_BY_QUOTE_ID__SUMMARY_ASC',
  QuoteByQuoteIdSummaryDesc = 'QUOTE_BY_QUOTE_ID__SUMMARY_DESC',
  QuoteByQuoteIdTravellerCountAsc = 'QUOTE_BY_QUOTE_ID__TRAVELLER_COUNT_ASC',
  QuoteByQuoteIdTravellerCountDesc = 'QUOTE_BY_QUOTE_ID__TRAVELLER_COUNT_DESC',
  QuoteByQuoteIdTripIdAsc = 'QUOTE_BY_QUOTE_ID__TRIP_ID_ASC',
  QuoteByQuoteIdTripIdDesc = 'QUOTE_BY_QUOTE_ID__TRIP_ID_DESC',
  QuoteByQuoteIdUserIdAsc = 'QUOTE_BY_QUOTE_ID__USER_ID_ASC',
  QuoteByQuoteIdUserIdDesc = 'QUOTE_BY_QUOTE_ID__USER_ID_DESC',
  QuoteIdAsc = 'QUOTE_ID_ASC',
  QuoteIdDesc = 'QUOTE_ID_DESC',
  RecipientsAsc = 'RECIPIENTS_ASC',
  RecipientsDesc = 'RECIPIENTS_DESC',
  SubjectAsc = 'SUBJECT_ASC',
  SubjectDesc = 'SUBJECT_DESC',
  TripByTripIdActiveQuoteIdAsc = 'TRIP_BY_TRIP_ID__ACTIVE_QUOTE_ID_ASC',
  TripByTripIdActiveQuoteIdDesc = 'TRIP_BY_TRIP_ID__ACTIVE_QUOTE_ID_DESC',
  TripByTripIdAgencyIdAsc = 'TRIP_BY_TRIP_ID__AGENCY_ID_ASC',
  TripByTripIdAgencyIdDesc = 'TRIP_BY_TRIP_ID__AGENCY_ID_DESC',
  TripByTripIdAgencyMemberIdAsc = 'TRIP_BY_TRIP_ID__AGENCY_MEMBER_ID_ASC',
  TripByTripIdAgencyMemberIdDesc = 'TRIP_BY_TRIP_ID__AGENCY_MEMBER_ID_DESC',
  TripByTripIdArchivedAsc = 'TRIP_BY_TRIP_ID__ARCHIVED_ASC',
  TripByTripIdArchivedDesc = 'TRIP_BY_TRIP_ID__ARCHIVED_DESC',
  TripByTripIdBaseCurrencyAsc = 'TRIP_BY_TRIP_ID__BASE_CURRENCY_ASC',
  TripByTripIdBaseCurrencyDesc = 'TRIP_BY_TRIP_ID__BASE_CURRENCY_DESC',
  TripByTripIdCreatedAsc = 'TRIP_BY_TRIP_ID__CREATED_ASC',
  TripByTripIdCreatedDesc = 'TRIP_BY_TRIP_ID__CREATED_DESC',
  TripByTripIdCustomerIdAsc = 'TRIP_BY_TRIP_ID__CUSTOMER_ID_ASC',
  TripByTripIdCustomerIdDesc = 'TRIP_BY_TRIP_ID__CUSTOMER_ID_DESC',
  TripByTripIdDatesAsc = 'TRIP_BY_TRIP_ID__DATES_ASC',
  TripByTripIdDatesDesc = 'TRIP_BY_TRIP_ID__DATES_DESC',
  TripByTripIdDestinationAsc = 'TRIP_BY_TRIP_ID__DESTINATION_ASC',
  TripByTripIdDestinationDesc = 'TRIP_BY_TRIP_ID__DESTINATION_DESC',
  TripByTripIdDurationAsc = 'TRIP_BY_TRIP_ID__DURATION_ASC',
  TripByTripIdDurationDesc = 'TRIP_BY_TRIP_ID__DURATION_DESC',
  TripByTripIdIdAsc = 'TRIP_BY_TRIP_ID__ID_ASC',
  TripByTripIdIdDesc = 'TRIP_BY_TRIP_ID__ID_DESC',
  TripByTripIdMediaGalleryIdAsc = 'TRIP_BY_TRIP_ID__MEDIA_GALLERY_ID_ASC',
  TripByTripIdMediaGalleryIdDesc = 'TRIP_BY_TRIP_ID__MEDIA_GALLERY_ID_DESC',
  TripByTripIdModifiedAsc = 'TRIP_BY_TRIP_ID__MODIFIED_ASC',
  TripByTripIdModifiedDesc = 'TRIP_BY_TRIP_ID__MODIFIED_DESC',
  TripByTripIdNameAsc = 'TRIP_BY_TRIP_ID__NAME_ASC',
  TripByTripIdNameDesc = 'TRIP_BY_TRIP_ID__NAME_DESC',
  TripByTripIdStartAsc = 'TRIP_BY_TRIP_ID__START_ASC',
  TripByTripIdStartDesc = 'TRIP_BY_TRIP_ID__START_DESC',
  TripByTripIdStatusAsc = 'TRIP_BY_TRIP_ID__STATUS_ASC',
  TripByTripIdStatusDesc = 'TRIP_BY_TRIP_ID__STATUS_DESC',
  TripByTripIdSummaryAsc = 'TRIP_BY_TRIP_ID__SUMMARY_ASC',
  TripByTripIdSummaryDesc = 'TRIP_BY_TRIP_ID__SUMMARY_DESC',
  TripByTripIdUserIdAsc = 'TRIP_BY_TRIP_ID__USER_ID_ASC',
  TripByTripIdUserIdDesc = 'TRIP_BY_TRIP_ID__USER_ID_DESC',
  TripIdAsc = 'TRIP_ID_ASC',
  TripIdDesc = 'TRIP_ID_DESC',
  UserByUserIdCreatedAsc = 'USER_BY_USER_ID__CREATED_ASC',
  UserByUserIdCreatedDesc = 'USER_BY_USER_ID__CREATED_DESC',
  UserByUserIdEmailAsc = 'USER_BY_USER_ID__EMAIL_ASC',
  UserByUserIdEmailDesc = 'USER_BY_USER_ID__EMAIL_DESC',
  UserByUserIdExternalIdAsc = 'USER_BY_USER_ID__EXTERNAL_ID_ASC',
  UserByUserIdExternalIdDesc = 'USER_BY_USER_ID__EXTERNAL_ID_DESC',
  UserByUserIdFirstNameAsc = 'USER_BY_USER_ID__FIRST_NAME_ASC',
  UserByUserIdFirstNameDesc = 'USER_BY_USER_ID__FIRST_NAME_DESC',
  UserByUserIdGenderPrepositionAsc = 'USER_BY_USER_ID__GENDER_PREPOSITION_ASC',
  UserByUserIdGenderPrepositionDesc = 'USER_BY_USER_ID__GENDER_PREPOSITION_DESC',
  UserByUserIdIdAsc = 'USER_BY_USER_ID__ID_ASC',
  UserByUserIdIdDesc = 'USER_BY_USER_ID__ID_DESC',
  UserByUserIdLastNameAsc = 'USER_BY_USER_ID__LAST_NAME_ASC',
  UserByUserIdLastNameDesc = 'USER_BY_USER_ID__LAST_NAME_DESC',
  UserByUserIdModifiedAsc = 'USER_BY_USER_ID__MODIFIED_ASC',
  UserByUserIdModifiedDesc = 'USER_BY_USER_ID__MODIFIED_DESC',
  UserByUserIdNameAsc = 'USER_BY_USER_ID__NAME_ASC',
  UserByUserIdNameDesc = 'USER_BY_USER_ID__NAME_DESC',
  UserByUserIdPasswordAsc = 'USER_BY_USER_ID__PASSWORD_ASC',
  UserByUserIdPasswordDesc = 'USER_BY_USER_ID__PASSWORD_DESC',
  UserByUserIdPhoneAsc = 'USER_BY_USER_ID__PHONE_ASC',
  UserByUserIdPhoneDesc = 'USER_BY_USER_ID__PHONE_DESC',
  UserByUserIdSkypeAsc = 'USER_BY_USER_ID__SKYPE_ASC',
  UserByUserIdSkypeDesc = 'USER_BY_USER_ID__SKYPE_DESC',
  UserByUserIdTitleAsc = 'USER_BY_USER_ID__TITLE_ASC',
  UserByUserIdTitleDesc = 'USER_BY_USER_ID__TITLE_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

/** A connection to a list of `Enquiry` values. */
export type EnquiriesConnection = {
  __typename?: 'EnquiriesConnection';
  /** A list of edges which contains the `Enquiry` and cursor to aid in pagination. */
  edges: Array<EnquiriesEdge>;
  /** A list of `Enquiry` objects. */
  nodes: Array<Maybe<Enquiry>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Enquiry` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Enquiry` edge in the connection. */
export type EnquiriesEdge = {
  __typename?: 'EnquiriesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Enquiry` at the end of the edge. */
  node?: Maybe<Enquiry>;
};

/** Methods to use when ordering `Enquiry`. */
export enum EnquiriesOrderBy {
  ArchivedAsc = 'ARCHIVED_ASC',
  ArchivedDesc = 'ARCHIVED_DESC',
  CommentsAsc = 'COMMENTS_ASC',
  CommentsDesc = 'COMMENTS_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  CustomerByCustomerIdCreatedAsc = 'CUSTOMER_BY_CUSTOMER_ID__CREATED_ASC',
  CustomerByCustomerIdCreatedDesc = 'CUSTOMER_BY_CUSTOMER_ID__CREATED_DESC',
  CustomerByCustomerIdEmailAsc = 'CUSTOMER_BY_CUSTOMER_ID__EMAIL_ASC',
  CustomerByCustomerIdEmailDesc = 'CUSTOMER_BY_CUSTOMER_ID__EMAIL_DESC',
  CustomerByCustomerIdIdAsc = 'CUSTOMER_BY_CUSTOMER_ID__ID_ASC',
  CustomerByCustomerIdIdDesc = 'CUSTOMER_BY_CUSTOMER_ID__ID_DESC',
  CustomerByCustomerIdModifiedAsc = 'CUSTOMER_BY_CUSTOMER_ID__MODIFIED_ASC',
  CustomerByCustomerIdModifiedDesc = 'CUSTOMER_BY_CUSTOMER_ID__MODIFIED_DESC',
  CustomerByCustomerIdNameAsc = 'CUSTOMER_BY_CUSTOMER_ID__NAME_ASC',
  CustomerByCustomerIdNameDesc = 'CUSTOMER_BY_CUSTOMER_ID__NAME_DESC',
  CustomerByCustomerIdPhoneAsc = 'CUSTOMER_BY_CUSTOMER_ID__PHONE_ASC',
  CustomerByCustomerIdPhoneDesc = 'CUSTOMER_BY_CUSTOMER_ID__PHONE_DESC',
  CustomerIdAsc = 'CUSTOMER_ID_ASC',
  CustomerIdDesc = 'CUSTOMER_ID_DESC',
  DatesAsc = 'DATES_ASC',
  DatesDesc = 'DATES_DESC',
  DestinationAsc = 'DESTINATION_ASC',
  DestinationDesc = 'DESTINATION_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SourceAsc = 'SOURCE_ASC',
  SourceDesc = 'SOURCE_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  TravellersAsc = 'TRAVELLERS_ASC',
  TravellersDesc = 'TRAVELLERS_DESC',
  TripByTripIdActiveQuoteIdAsc = 'TRIP_BY_TRIP_ID__ACTIVE_QUOTE_ID_ASC',
  TripByTripIdActiveQuoteIdDesc = 'TRIP_BY_TRIP_ID__ACTIVE_QUOTE_ID_DESC',
  TripByTripIdAgencyIdAsc = 'TRIP_BY_TRIP_ID__AGENCY_ID_ASC',
  TripByTripIdAgencyIdDesc = 'TRIP_BY_TRIP_ID__AGENCY_ID_DESC',
  TripByTripIdAgencyMemberIdAsc = 'TRIP_BY_TRIP_ID__AGENCY_MEMBER_ID_ASC',
  TripByTripIdAgencyMemberIdDesc = 'TRIP_BY_TRIP_ID__AGENCY_MEMBER_ID_DESC',
  TripByTripIdArchivedAsc = 'TRIP_BY_TRIP_ID__ARCHIVED_ASC',
  TripByTripIdArchivedDesc = 'TRIP_BY_TRIP_ID__ARCHIVED_DESC',
  TripByTripIdBaseCurrencyAsc = 'TRIP_BY_TRIP_ID__BASE_CURRENCY_ASC',
  TripByTripIdBaseCurrencyDesc = 'TRIP_BY_TRIP_ID__BASE_CURRENCY_DESC',
  TripByTripIdCreatedAsc = 'TRIP_BY_TRIP_ID__CREATED_ASC',
  TripByTripIdCreatedDesc = 'TRIP_BY_TRIP_ID__CREATED_DESC',
  TripByTripIdCustomerIdAsc = 'TRIP_BY_TRIP_ID__CUSTOMER_ID_ASC',
  TripByTripIdCustomerIdDesc = 'TRIP_BY_TRIP_ID__CUSTOMER_ID_DESC',
  TripByTripIdDatesAsc = 'TRIP_BY_TRIP_ID__DATES_ASC',
  TripByTripIdDatesDesc = 'TRIP_BY_TRIP_ID__DATES_DESC',
  TripByTripIdDestinationAsc = 'TRIP_BY_TRIP_ID__DESTINATION_ASC',
  TripByTripIdDestinationDesc = 'TRIP_BY_TRIP_ID__DESTINATION_DESC',
  TripByTripIdDurationAsc = 'TRIP_BY_TRIP_ID__DURATION_ASC',
  TripByTripIdDurationDesc = 'TRIP_BY_TRIP_ID__DURATION_DESC',
  TripByTripIdIdAsc = 'TRIP_BY_TRIP_ID__ID_ASC',
  TripByTripIdIdDesc = 'TRIP_BY_TRIP_ID__ID_DESC',
  TripByTripIdMediaGalleryIdAsc = 'TRIP_BY_TRIP_ID__MEDIA_GALLERY_ID_ASC',
  TripByTripIdMediaGalleryIdDesc = 'TRIP_BY_TRIP_ID__MEDIA_GALLERY_ID_DESC',
  TripByTripIdModifiedAsc = 'TRIP_BY_TRIP_ID__MODIFIED_ASC',
  TripByTripIdModifiedDesc = 'TRIP_BY_TRIP_ID__MODIFIED_DESC',
  TripByTripIdNameAsc = 'TRIP_BY_TRIP_ID__NAME_ASC',
  TripByTripIdNameDesc = 'TRIP_BY_TRIP_ID__NAME_DESC',
  TripByTripIdStartAsc = 'TRIP_BY_TRIP_ID__START_ASC',
  TripByTripIdStartDesc = 'TRIP_BY_TRIP_ID__START_DESC',
  TripByTripIdStatusAsc = 'TRIP_BY_TRIP_ID__STATUS_ASC',
  TripByTripIdStatusDesc = 'TRIP_BY_TRIP_ID__STATUS_DESC',
  TripByTripIdSummaryAsc = 'TRIP_BY_TRIP_ID__SUMMARY_ASC',
  TripByTripIdSummaryDesc = 'TRIP_BY_TRIP_ID__SUMMARY_DESC',
  TripByTripIdUserIdAsc = 'TRIP_BY_TRIP_ID__USER_ID_ASC',
  TripByTripIdUserIdDesc = 'TRIP_BY_TRIP_ID__USER_ID_DESC',
  TripIdAsc = 'TRIP_ID_ASC',
  TripIdDesc = 'TRIP_ID_DESC'
}

export type Enquiry = {
  __typename?: 'Enquiry';
  archived?: Maybe<Scalars['Datetime']['output']>;
  comments?: Maybe<Scalars['String']['output']>;
  created: Scalars['Datetime']['output'];
  /** Reads a single `Customer` that is related to this `Enquiry`. */
  customer?: Maybe<Customer>;
  customerId: Scalars['UUID']['output'];
  dates?: Maybe<Scalars['String']['output']>;
  destination?: Maybe<Scalars['String']['output']>;
  id: Scalars['UUID']['output'];
  source?: Maybe<Scalars['String']['output']>;
  status: Scalars['Int']['output'];
  travellers?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Trip` that is related to this `Enquiry`. */
  trip?: Maybe<Trip>;
  tripId?: Maybe<Scalars['UUID']['output']>;
};

/** A condition to be used against `Enquiry` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type EnquiryCondition = {
  /** Checks for equality with the object’s `archived` field. */
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `comments` field. */
  comments?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `customerId` field. */
  customerId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `dates` field. */
  dates?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `destination` field. */
  destination?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `source` field. */
  source?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `travellers` field. */
  travellers?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `tripId` field. */
  tripId?: InputMaybe<Scalars['UUID']['input']>;
};

/** A filter to be used against `Enquiry` object types. All fields are combined with a logical ‘and.’ */
export type EnquiryFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<EnquiryFilter>>;
  /** Filter by the object’s `archived` field. */
  archived?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `comments` field. */
  comments?: InputMaybe<StringFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `customer` relation. */
  customer?: InputMaybe<CustomerFilter>;
  /** Filter by the object’s `customerId` field. */
  customerId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `dates` field. */
  dates?: InputMaybe<StringFilter>;
  /** Filter by the object’s `destination` field. */
  destination?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Negates the expression. */
  not?: InputMaybe<EnquiryFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<EnquiryFilter>>;
  /** Filter by the object’s `source` field. */
  source?: InputMaybe<StringFilter>;
  /** Filter by the object’s `status` field. */
  status?: InputMaybe<IntFilter>;
  /** Filter by the object’s `travellers` field. */
  travellers?: InputMaybe<StringFilter>;
  /** Filter by the object’s `trip` relation. */
  trip?: InputMaybe<TripFilter>;
  /** A related `trip` exists. */
  tripExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `tripId` field. */
  tripId?: InputMaybe<UuidFilter>;
};

/** An input for mutations affecting `Enquiry` */
export type EnquiryInput = {
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  comments?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerId?: InputMaybe<Scalars['UUID']['input']>;
  customerToCustomerId?: InputMaybe<FkEnquiryCustomerCustomerIdInput>;
  dates?: InputMaybe<Scalars['String']['input']>;
  destination?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  source?: InputMaybe<Scalars['String']['input']>;
  status: Scalars['Int']['input'];
  travellers?: InputMaybe<Scalars['String']['input']>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkEnquiryTripTripIdInput>;
};

/** The fields on `enquiry` to look up the row to update. */
export type EnquiryOnEnquiryForFkEnquiryCustomerCustomerIdUsingPkEnquiryUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `enquiry` being updated. */
  patch: UpdateEnquiryOnEnquiryForFkEnquiryCustomerCustomerIdPatch;
};

/** The fields on `enquiry` to look up the row to update. */
export type EnquiryOnEnquiryForFkEnquiryTripTripIdUsingPkEnquiryUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `enquiry` being updated. */
  patch: UpdateEnquiryOnEnquiryForFkEnquiryTripTripIdPatch;
};

/** Represents an update to a `Enquiry`. Fields that are set will be updated. */
export type EnquiryPatch = {
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  comments?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerId?: InputMaybe<Scalars['UUID']['input']>;
  customerToCustomerId?: InputMaybe<FkEnquiryCustomerCustomerIdInput>;
  dates?: InputMaybe<Scalars['String']['input']>;
  destination?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  source?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  travellers?: InputMaybe<Scalars['String']['input']>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkEnquiryTripTripIdInput>;
};

/** The fields on `enquiry` to look up the row to connect. */
export type EnquiryPkEnquiryConnect = {
  id: Scalars['UUID']['input'];
};

/** The fields on `enquiry` to look up the row to delete. */
export type EnquiryPkEnquiryDelete = {
  id: Scalars['UUID']['input'];
};

export type ExecutePaymentInput = {
  amount?: InputMaybe<Scalars['BigFloat']['input']>;
  invoice: Scalars['UUID']['input'];
  token: Scalars['String']['input'];
};

export type Expense = {
  __typename?: 'Expense';
  amount: Scalars['BigFloat']['output'];
  amountActual: Scalars['BigFloat']['output'];
  /** Reads a single `FinanceCategory` that is related to this `Expense`. */
  category?: Maybe<FinanceCategory>;
  categoryId?: Maybe<Scalars['UUID']['output']>;
  created: Scalars['Datetime']['output'];
  currency?: Maybe<Scalars['String']['output']>;
  id: Scalars['UUID']['output'];
  /** Reads a single `Invoice` that is related to this `Expense`. */
  invoice?: Maybe<Invoice>;
  invoiceId?: Maybe<Scalars['UUID']['output']>;
  modified: Scalars['Datetime']['output'];
  paid: Scalars['Datetime']['output'];
  reference?: Maybe<Scalars['String']['output']>;
  summary?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Supplier` that is related to this `Expense`. */
  supplier?: Maybe<Supplier>;
  supplierId: Scalars['UUID']['output'];
  /** Reads a single `SupplierInvoice` that is related to this `Expense`. */
  supplierInvoice?: Maybe<SupplierInvoice>;
  supplierInvoiceId?: Maybe<Scalars['UUID']['output']>;
  /** Reads and enables pagination through a set of `TransactionLink`. */
  transactionLinks: TransactionLinksConnection;
  /** Reads a single `Trip` that is related to this `Expense`. */
  trip?: Maybe<Trip>;
  tripId?: Maybe<Scalars['UUID']['output']>;
};


export type ExpenseTransactionLinksArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TransactionLinkCondition>;
  filter?: InputMaybe<TransactionLinkFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TransactionLinksOrderBy>>;
};

/** A condition to be used against `Expense` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type ExpenseCondition = {
  /** Checks for equality with the object’s `amount` field. */
  amount?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `amountActual` field. */
  amountActual?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `categoryId` field. */
  categoryId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `currency` field. */
  currency?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `invoiceId` field. */
  invoiceId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `paid` field. */
  paid?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `reference` field. */
  reference?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `summary` field. */
  summary?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `supplierId` field. */
  supplierId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `supplierInvoiceId` field. */
  supplierInvoiceId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `tripId` field. */
  tripId?: InputMaybe<Scalars['UUID']['input']>;
};

/** A filter to be used against `Expense` object types. All fields are combined with a logical ‘and.’ */
export type ExpenseFilter = {
  /** Filter by the object’s `amount` field. */
  amount?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `amountActual` field. */
  amountActual?: InputMaybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ExpenseFilter>>;
  /** Filter by the object’s `category` relation. */
  category?: InputMaybe<FinanceCategoryFilter>;
  /** A related `category` exists. */
  categoryExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `categoryId` field. */
  categoryId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `currency` field. */
  currency?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `invoice` relation. */
  invoice?: InputMaybe<InvoiceFilter>;
  /** A related `invoice` exists. */
  invoiceExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `invoiceId` field. */
  invoiceId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ExpenseFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ExpenseFilter>>;
  /** Filter by the object’s `paid` field. */
  paid?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `reference` field. */
  reference?: InputMaybe<StringFilter>;
  /** Filter by the object’s `summary` field. */
  summary?: InputMaybe<StringFilter>;
  /** Filter by the object’s `supplier` relation. */
  supplier?: InputMaybe<SupplierFilter>;
  /** Filter by the object’s `supplierId` field. */
  supplierId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `supplierInvoice` relation. */
  supplierInvoice?: InputMaybe<SupplierInvoiceFilter>;
  /** A related `supplierInvoice` exists. */
  supplierInvoiceExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `supplierInvoiceId` field. */
  supplierInvoiceId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `transactionLinks` relation. */
  transactionLinks?: InputMaybe<ExpenseToManyTransactionLinkFilter>;
  /** Some related `transactionLinks` exist. */
  transactionLinksExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `trip` relation. */
  trip?: InputMaybe<TripFilter>;
  /** A related `trip` exists. */
  tripExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `tripId` field. */
  tripId?: InputMaybe<UuidFilter>;
};

/** An input for mutations affecting `Expense` */
export type ExpenseInput = {
  amount: Scalars['BigFloat']['input'];
  amountActual: Scalars['BigFloat']['input'];
  categoryId?: InputMaybe<Scalars['UUID']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  financeCategoryToCategoryId?: InputMaybe<FkExpenseFinanceCategoryCategoryIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoiceId?: InputMaybe<Scalars['UUID']['input']>;
  invoiceToInvoiceId?: InputMaybe<FkExpenseInvoiceInvoiceIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  paid: Scalars['Datetime']['input'];
  reference?: InputMaybe<Scalars['String']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierId?: InputMaybe<Scalars['UUID']['input']>;
  supplierInvoiceId?: InputMaybe<Scalars['UUID']['input']>;
  supplierInvoiceToSupplierInvoiceId?: InputMaybe<FkExpenseSupplierInvoiceSupplierInvoiceIdInput>;
  supplierToSupplierId?: InputMaybe<FkExpenseSupplierSupplierIdInput>;
  transactionLinksUsingId?: InputMaybe<FkTransactionLinkExpenseExpenseIdInverseInput>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkExpenseTripTripIdInput>;
};

/** The fields on `expense` to look up the row to update. */
export type ExpenseOnExpenseForFkExpenseFinanceCategoryCategoryIdUsingPkExpenseUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `expense` being updated. */
  patch: UpdateExpenseOnExpenseForFkExpenseFinanceCategoryCategoryIdPatch;
};

/** The fields on `expense` to look up the row to update. */
export type ExpenseOnExpenseForFkExpenseInvoiceInvoiceIdUsingPkExpenseUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `expense` being updated. */
  patch: UpdateExpenseOnExpenseForFkExpenseInvoiceInvoiceIdPatch;
};

/** The fields on `expense` to look up the row to update. */
export type ExpenseOnExpenseForFkExpenseSupplierInvoiceSupplierInvoiceIdUsingPkExpenseUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `expense` being updated. */
  patch: UpdateExpenseOnExpenseForFkExpenseSupplierInvoiceSupplierInvoiceIdPatch;
};

/** The fields on `expense` to look up the row to update. */
export type ExpenseOnExpenseForFkExpenseSupplierSupplierIdUsingPkExpenseUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `expense` being updated. */
  patch: UpdateExpenseOnExpenseForFkExpenseSupplierSupplierIdPatch;
};

/** The fields on `expense` to look up the row to update. */
export type ExpenseOnExpenseForFkExpenseTripTripIdUsingPkExpenseUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `expense` being updated. */
  patch: UpdateExpenseOnExpenseForFkExpenseTripTripIdPatch;
};

/** The fields on `expense` to look up the row to update. */
export type ExpenseOnTransactionLinkForFkTransactionLinkExpenseExpenseIdUsingPkExpenseUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `expense` being updated. */
  patch: UpdateExpenseOnTransactionLinkForFkTransactionLinkExpenseExpenseIdPatch;
};

/** Represents an update to a `Expense`. Fields that are set will be updated. */
export type ExpensePatch = {
  amount?: InputMaybe<Scalars['BigFloat']['input']>;
  amountActual?: InputMaybe<Scalars['BigFloat']['input']>;
  categoryId?: InputMaybe<Scalars['UUID']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  financeCategoryToCategoryId?: InputMaybe<FkExpenseFinanceCategoryCategoryIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoiceId?: InputMaybe<Scalars['UUID']['input']>;
  invoiceToInvoiceId?: InputMaybe<FkExpenseInvoiceInvoiceIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  paid?: InputMaybe<Scalars['Datetime']['input']>;
  reference?: InputMaybe<Scalars['String']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierId?: InputMaybe<Scalars['UUID']['input']>;
  supplierInvoiceId?: InputMaybe<Scalars['UUID']['input']>;
  supplierInvoiceToSupplierInvoiceId?: InputMaybe<FkExpenseSupplierInvoiceSupplierInvoiceIdInput>;
  supplierToSupplierId?: InputMaybe<FkExpenseSupplierSupplierIdInput>;
  transactionLinksUsingId?: InputMaybe<FkTransactionLinkExpenseExpenseIdInverseInput>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkExpenseTripTripIdInput>;
};

/** The fields on `expense` to look up the row to connect. */
export type ExpensePkExpenseConnect = {
  id: Scalars['UUID']['input'];
};

/** The fields on `expense` to look up the row to delete. */
export type ExpensePkExpenseDelete = {
  id: Scalars['UUID']['input'];
};

/** A filter to be used against many `TransactionLink` object types. All fields are combined with a logical ‘and.’ */
export type ExpenseToManyTransactionLinkFilter = {
  /** Every related `TransactionLink` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<TransactionLinkFilter>;
  /** No related `TransactionLink` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<TransactionLinkFilter>;
  /** Some related `TransactionLink` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<TransactionLinkFilter>;
};

/** A connection to a list of `Expense` values. */
export type ExpensesConnection = {
  __typename?: 'ExpensesConnection';
  /** A list of edges which contains the `Expense` and cursor to aid in pagination. */
  edges: Array<ExpensesEdge>;
  /** A list of `Expense` objects. */
  nodes: Array<Maybe<Expense>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Expense` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Expense` edge in the connection. */
export type ExpensesEdge = {
  __typename?: 'ExpensesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Expense` at the end of the edge. */
  node?: Maybe<Expense>;
};

/** Methods to use when ordering `Expense`. */
export enum ExpensesOrderBy {
  AmountActualAsc = 'AMOUNT_ACTUAL_ASC',
  AmountActualDesc = 'AMOUNT_ACTUAL_DESC',
  AmountAsc = 'AMOUNT_ASC',
  AmountDesc = 'AMOUNT_DESC',
  CategoryIdAsc = 'CATEGORY_ID_ASC',
  CategoryIdDesc = 'CATEGORY_ID_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  CurrencyAsc = 'CURRENCY_ASC',
  CurrencyDesc = 'CURRENCY_DESC',
  FinanceCategoryByCategoryIdCodeAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__CODE_ASC',
  FinanceCategoryByCategoryIdCodeDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__CODE_DESC',
  FinanceCategoryByCategoryIdCreatedAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__CREATED_ASC',
  FinanceCategoryByCategoryIdCreatedDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__CREATED_DESC',
  FinanceCategoryByCategoryIdIdAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__ID_ASC',
  FinanceCategoryByCategoryIdIdDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__ID_DESC',
  FinanceCategoryByCategoryIdModifiedAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__MODIFIED_ASC',
  FinanceCategoryByCategoryIdModifiedDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__MODIFIED_DESC',
  FinanceCategoryByCategoryIdNameAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__NAME_ASC',
  FinanceCategoryByCategoryIdNameDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__NAME_DESC',
  FinanceCategoryByCategoryIdSummaryAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__SUMMARY_ASC',
  FinanceCategoryByCategoryIdSummaryDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__SUMMARY_DESC',
  FinanceCategoryByCategoryIdTypeAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__TYPE_ASC',
  FinanceCategoryByCategoryIdTypeDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__TYPE_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  InvoiceByInvoiceIdAmountAsc = 'INVOICE_BY_INVOICE_ID__AMOUNT_ASC',
  InvoiceByInvoiceIdAmountDesc = 'INVOICE_BY_INVOICE_ID__AMOUNT_DESC',
  InvoiceByInvoiceIdCategoryIdAsc = 'INVOICE_BY_INVOICE_ID__CATEGORY_ID_ASC',
  InvoiceByInvoiceIdCategoryIdDesc = 'INVOICE_BY_INVOICE_ID__CATEGORY_ID_DESC',
  InvoiceByInvoiceIdCreatedAsc = 'INVOICE_BY_INVOICE_ID__CREATED_ASC',
  InvoiceByInvoiceIdCreatedDesc = 'INVOICE_BY_INVOICE_ID__CREATED_DESC',
  InvoiceByInvoiceIdCurrencyAsc = 'INVOICE_BY_INVOICE_ID__CURRENCY_ASC',
  InvoiceByInvoiceIdCurrencyDesc = 'INVOICE_BY_INVOICE_ID__CURRENCY_DESC',
  InvoiceByInvoiceIdDueAsc = 'INVOICE_BY_INVOICE_ID__DUE_ASC',
  InvoiceByInvoiceIdDueDesc = 'INVOICE_BY_INVOICE_ID__DUE_DESC',
  InvoiceByInvoiceIdIdAsc = 'INVOICE_BY_INVOICE_ID__ID_ASC',
  InvoiceByInvoiceIdIdDesc = 'INVOICE_BY_INVOICE_ID__ID_DESC',
  InvoiceByInvoiceIdInvoicedAsc = 'INVOICE_BY_INVOICE_ID__INVOICED_ASC',
  InvoiceByInvoiceIdInvoicedDesc = 'INVOICE_BY_INVOICE_ID__INVOICED_DESC',
  InvoiceByInvoiceIdKeyAsc = 'INVOICE_BY_INVOICE_ID__KEY_ASC',
  InvoiceByInvoiceIdKeyDesc = 'INVOICE_BY_INVOICE_ID__KEY_DESC',
  InvoiceByInvoiceIdLockedAsc = 'INVOICE_BY_INVOICE_ID__LOCKED_ASC',
  InvoiceByInvoiceIdLockedDesc = 'INVOICE_BY_INVOICE_ID__LOCKED_DESC',
  InvoiceByInvoiceIdModifiedAsc = 'INVOICE_BY_INVOICE_ID__MODIFIED_ASC',
  InvoiceByInvoiceIdModifiedDesc = 'INVOICE_BY_INVOICE_ID__MODIFIED_DESC',
  InvoiceByInvoiceIdNoteAsc = 'INVOICE_BY_INVOICE_ID__NOTE_ASC',
  InvoiceByInvoiceIdNoteDesc = 'INVOICE_BY_INVOICE_ID__NOTE_DESC',
  InvoiceByInvoiceIdNumberAsc = 'INVOICE_BY_INVOICE_ID__NUMBER_ASC',
  InvoiceByInvoiceIdNumberDesc = 'INVOICE_BY_INVOICE_ID__NUMBER_DESC',
  InvoiceByInvoiceIdPaidAsc = 'INVOICE_BY_INVOICE_ID__PAID_ASC',
  InvoiceByInvoiceIdPaidDesc = 'INVOICE_BY_INVOICE_ID__PAID_DESC',
  InvoiceByInvoiceIdQuoteIdAsc = 'INVOICE_BY_INVOICE_ID__QUOTE_ID_ASC',
  InvoiceByInvoiceIdQuoteIdDesc = 'INVOICE_BY_INVOICE_ID__QUOTE_ID_DESC',
  InvoiceByInvoiceIdSummaryAsc = 'INVOICE_BY_INVOICE_ID__SUMMARY_ASC',
  InvoiceByInvoiceIdSummaryDesc = 'INVOICE_BY_INVOICE_ID__SUMMARY_DESC',
  InvoiceByInvoiceIdTripIdAsc = 'INVOICE_BY_INVOICE_ID__TRIP_ID_ASC',
  InvoiceByInvoiceIdTripIdDesc = 'INVOICE_BY_INVOICE_ID__TRIP_ID_DESC',
  InvoiceByInvoiceIdTypeAsc = 'INVOICE_BY_INVOICE_ID__TYPE_ASC',
  InvoiceByInvoiceIdTypeDesc = 'INVOICE_BY_INVOICE_ID__TYPE_DESC',
  InvoiceByInvoiceIdVoidedAsc = 'INVOICE_BY_INVOICE_ID__VOIDED_ASC',
  InvoiceByInvoiceIdVoidedDesc = 'INVOICE_BY_INVOICE_ID__VOIDED_DESC',
  InvoiceIdAsc = 'INVOICE_ID_ASC',
  InvoiceIdDesc = 'INVOICE_ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  Natural = 'NATURAL',
  PaidAsc = 'PAID_ASC',
  PaidDesc = 'PAID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ReferenceAsc = 'REFERENCE_ASC',
  ReferenceDesc = 'REFERENCE_DESC',
  SummaryAsc = 'SUMMARY_ASC',
  SummaryDesc = 'SUMMARY_DESC',
  SupplierBySupplierIdBankDetailsAsc = 'SUPPLIER_BY_SUPPLIER_ID__BANK_DETAILS_ASC',
  SupplierBySupplierIdBankDetailsDesc = 'SUPPLIER_BY_SUPPLIER_ID__BANK_DETAILS_DESC',
  SupplierBySupplierIdContactEmailAsc = 'SUPPLIER_BY_SUPPLIER_ID__CONTACT_EMAIL_ASC',
  SupplierBySupplierIdContactEmailDesc = 'SUPPLIER_BY_SUPPLIER_ID__CONTACT_EMAIL_DESC',
  SupplierBySupplierIdContactNumberAsc = 'SUPPLIER_BY_SUPPLIER_ID__CONTACT_NUMBER_ASC',
  SupplierBySupplierIdContactNumberDesc = 'SUPPLIER_BY_SUPPLIER_ID__CONTACT_NUMBER_DESC',
  SupplierBySupplierIdCreatedAsc = 'SUPPLIER_BY_SUPPLIER_ID__CREATED_ASC',
  SupplierBySupplierIdCreatedDesc = 'SUPPLIER_BY_SUPPLIER_ID__CREATED_DESC',
  SupplierBySupplierIdGalleryIdAsc = 'SUPPLIER_BY_SUPPLIER_ID__GALLERY_ID_ASC',
  SupplierBySupplierIdGalleryIdDesc = 'SUPPLIER_BY_SUPPLIER_ID__GALLERY_ID_DESC',
  SupplierBySupplierIdIdAsc = 'SUPPLIER_BY_SUPPLIER_ID__ID_ASC',
  SupplierBySupplierIdIdDesc = 'SUPPLIER_BY_SUPPLIER_ID__ID_DESC',
  SupplierBySupplierIdModifiedAsc = 'SUPPLIER_BY_SUPPLIER_ID__MODIFIED_ASC',
  SupplierBySupplierIdModifiedDesc = 'SUPPLIER_BY_SUPPLIER_ID__MODIFIED_DESC',
  SupplierBySupplierIdNameAsc = 'SUPPLIER_BY_SUPPLIER_ID__NAME_ASC',
  SupplierBySupplierIdNameDesc = 'SUPPLIER_BY_SUPPLIER_ID__NAME_DESC',
  SupplierBySupplierIdRegionAsc = 'SUPPLIER_BY_SUPPLIER_ID__REGION_ASC',
  SupplierBySupplierIdRegionDesc = 'SUPPLIER_BY_SUPPLIER_ID__REGION_DESC',
  SupplierBySupplierIdUrlAsc = 'SUPPLIER_BY_SUPPLIER_ID__URL_ASC',
  SupplierBySupplierIdUrlDesc = 'SUPPLIER_BY_SUPPLIER_ID__URL_DESC',
  SupplierIdAsc = 'SUPPLIER_ID_ASC',
  SupplierIdDesc = 'SUPPLIER_ID_DESC',
  SupplierInvoiceBySupplierInvoiceIdAmountActualAsc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__AMOUNT_ACTUAL_ASC',
  SupplierInvoiceBySupplierInvoiceIdAmountActualDesc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__AMOUNT_ACTUAL_DESC',
  SupplierInvoiceBySupplierInvoiceIdAmountAsc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__AMOUNT_ASC',
  SupplierInvoiceBySupplierInvoiceIdAmountDesc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__AMOUNT_DESC',
  SupplierInvoiceBySupplierInvoiceIdCategoryIdAsc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__CATEGORY_ID_ASC',
  SupplierInvoiceBySupplierInvoiceIdCategoryIdDesc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__CATEGORY_ID_DESC',
  SupplierInvoiceBySupplierInvoiceIdCreatedAsc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__CREATED_ASC',
  SupplierInvoiceBySupplierInvoiceIdCreatedDesc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__CREATED_DESC',
  SupplierInvoiceBySupplierInvoiceIdCurrencyAsc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__CURRENCY_ASC',
  SupplierInvoiceBySupplierInvoiceIdCurrencyDesc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__CURRENCY_DESC',
  SupplierInvoiceBySupplierInvoiceIdDueAsc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__DUE_ASC',
  SupplierInvoiceBySupplierInvoiceIdDueDesc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__DUE_DESC',
  SupplierInvoiceBySupplierInvoiceIdIdAsc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__ID_ASC',
  SupplierInvoiceBySupplierInvoiceIdIdDesc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__ID_DESC',
  SupplierInvoiceBySupplierInvoiceIdKeyAsc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__KEY_ASC',
  SupplierInvoiceBySupplierInvoiceIdKeyDesc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__KEY_DESC',
  SupplierInvoiceBySupplierInvoiceIdMediaItemIdAsc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__MEDIA_ITEM_ID_ASC',
  SupplierInvoiceBySupplierInvoiceIdMediaItemIdDesc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__MEDIA_ITEM_ID_DESC',
  SupplierInvoiceBySupplierInvoiceIdModifiedAsc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__MODIFIED_ASC',
  SupplierInvoiceBySupplierInvoiceIdModifiedDesc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__MODIFIED_DESC',
  SupplierInvoiceBySupplierInvoiceIdNumberAsc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__NUMBER_ASC',
  SupplierInvoiceBySupplierInvoiceIdNumberDesc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__NUMBER_DESC',
  SupplierInvoiceBySupplierInvoiceIdPaidAsc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__PAID_ASC',
  SupplierInvoiceBySupplierInvoiceIdPaidDesc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__PAID_DESC',
  SupplierInvoiceBySupplierInvoiceIdSummaryAsc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__SUMMARY_ASC',
  SupplierInvoiceBySupplierInvoiceIdSummaryDesc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__SUMMARY_DESC',
  SupplierInvoiceBySupplierInvoiceIdSupplierIdAsc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__SUPPLIER_ID_ASC',
  SupplierInvoiceBySupplierInvoiceIdSupplierIdDesc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__SUPPLIER_ID_DESC',
  SupplierInvoiceBySupplierInvoiceIdTripIdAsc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__TRIP_ID_ASC',
  SupplierInvoiceBySupplierInvoiceIdTripIdDesc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__TRIP_ID_DESC',
  SupplierInvoiceBySupplierInvoiceIdTypeAsc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__TYPE_ASC',
  SupplierInvoiceBySupplierInvoiceIdTypeDesc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__TYPE_DESC',
  SupplierInvoiceBySupplierInvoiceIdVoidedAsc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__VOIDED_ASC',
  SupplierInvoiceBySupplierInvoiceIdVoidedDesc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__VOIDED_DESC',
  SupplierInvoiceIdAsc = 'SUPPLIER_INVOICE_ID_ASC',
  SupplierInvoiceIdDesc = 'SUPPLIER_INVOICE_ID_DESC',
  TransactionLinksByExpenseIdCountAsc = 'TRANSACTION_LINKS_BY_EXPENSE_ID__COUNT_ASC',
  TransactionLinksByExpenseIdCountDesc = 'TRANSACTION_LINKS_BY_EXPENSE_ID__COUNT_DESC',
  TripByTripIdActiveQuoteIdAsc = 'TRIP_BY_TRIP_ID__ACTIVE_QUOTE_ID_ASC',
  TripByTripIdActiveQuoteIdDesc = 'TRIP_BY_TRIP_ID__ACTIVE_QUOTE_ID_DESC',
  TripByTripIdAgencyIdAsc = 'TRIP_BY_TRIP_ID__AGENCY_ID_ASC',
  TripByTripIdAgencyIdDesc = 'TRIP_BY_TRIP_ID__AGENCY_ID_DESC',
  TripByTripIdAgencyMemberIdAsc = 'TRIP_BY_TRIP_ID__AGENCY_MEMBER_ID_ASC',
  TripByTripIdAgencyMemberIdDesc = 'TRIP_BY_TRIP_ID__AGENCY_MEMBER_ID_DESC',
  TripByTripIdArchivedAsc = 'TRIP_BY_TRIP_ID__ARCHIVED_ASC',
  TripByTripIdArchivedDesc = 'TRIP_BY_TRIP_ID__ARCHIVED_DESC',
  TripByTripIdBaseCurrencyAsc = 'TRIP_BY_TRIP_ID__BASE_CURRENCY_ASC',
  TripByTripIdBaseCurrencyDesc = 'TRIP_BY_TRIP_ID__BASE_CURRENCY_DESC',
  TripByTripIdCreatedAsc = 'TRIP_BY_TRIP_ID__CREATED_ASC',
  TripByTripIdCreatedDesc = 'TRIP_BY_TRIP_ID__CREATED_DESC',
  TripByTripIdCustomerIdAsc = 'TRIP_BY_TRIP_ID__CUSTOMER_ID_ASC',
  TripByTripIdCustomerIdDesc = 'TRIP_BY_TRIP_ID__CUSTOMER_ID_DESC',
  TripByTripIdDatesAsc = 'TRIP_BY_TRIP_ID__DATES_ASC',
  TripByTripIdDatesDesc = 'TRIP_BY_TRIP_ID__DATES_DESC',
  TripByTripIdDestinationAsc = 'TRIP_BY_TRIP_ID__DESTINATION_ASC',
  TripByTripIdDestinationDesc = 'TRIP_BY_TRIP_ID__DESTINATION_DESC',
  TripByTripIdDurationAsc = 'TRIP_BY_TRIP_ID__DURATION_ASC',
  TripByTripIdDurationDesc = 'TRIP_BY_TRIP_ID__DURATION_DESC',
  TripByTripIdIdAsc = 'TRIP_BY_TRIP_ID__ID_ASC',
  TripByTripIdIdDesc = 'TRIP_BY_TRIP_ID__ID_DESC',
  TripByTripIdMediaGalleryIdAsc = 'TRIP_BY_TRIP_ID__MEDIA_GALLERY_ID_ASC',
  TripByTripIdMediaGalleryIdDesc = 'TRIP_BY_TRIP_ID__MEDIA_GALLERY_ID_DESC',
  TripByTripIdModifiedAsc = 'TRIP_BY_TRIP_ID__MODIFIED_ASC',
  TripByTripIdModifiedDesc = 'TRIP_BY_TRIP_ID__MODIFIED_DESC',
  TripByTripIdNameAsc = 'TRIP_BY_TRIP_ID__NAME_ASC',
  TripByTripIdNameDesc = 'TRIP_BY_TRIP_ID__NAME_DESC',
  TripByTripIdStartAsc = 'TRIP_BY_TRIP_ID__START_ASC',
  TripByTripIdStartDesc = 'TRIP_BY_TRIP_ID__START_DESC',
  TripByTripIdStatusAsc = 'TRIP_BY_TRIP_ID__STATUS_ASC',
  TripByTripIdStatusDesc = 'TRIP_BY_TRIP_ID__STATUS_DESC',
  TripByTripIdSummaryAsc = 'TRIP_BY_TRIP_ID__SUMMARY_ASC',
  TripByTripIdSummaryDesc = 'TRIP_BY_TRIP_ID__SUMMARY_DESC',
  TripByTripIdUserIdAsc = 'TRIP_BY_TRIP_ID__USER_ID_ASC',
  TripByTripIdUserIdDesc = 'TRIP_BY_TRIP_ID__USER_ID_DESC',
  TripIdAsc = 'TRIP_ID_ASC',
  TripIdDesc = 'TRIP_ID_DESC'
}

/** Input for the nested mutation of `quotePublic` in the `QuoteAccommodationDetailInput` mutation. */
export type FakePublicQuoteAccommodationDetailForeignKey0Input = {
  /** The primary key(s) for `quotePublic` for the far side of the relationship. */
  connectByKey?: InputMaybe<QuotePublicFakePublicQuotePublicPrimaryKeyConnect>;
  /** A `QuotePublicInput` object that will be created and connected to this object. */
  create?: InputMaybe<FakePublicQuoteAccommodationDetailForeignKey0QuotePublicCreateInput>;
  /** The primary key(s) for `quotePublic` for the far side of the relationship. */
  deleteByKey?: InputMaybe<QuotePublicFakePublicQuotePublicPrimaryKeyDelete>;
  /** The primary key(s) and patch data for `quotePublic` for the far side of the relationship. */
  updateByKey?: InputMaybe<QuotePublicOnQuoteAccommodationDetailForFakePublicQuoteAccommodationDetailForeignKey0UsingFakePublicQuotePublicPrimaryKeyUpdate>;
};

/** Input for the nested mutation of `quoteAccommodationDetail` in the `QuotePublicInput` mutation. */
export type FakePublicQuoteAccommodationDetailForeignKey0InverseInput = {
  /** The primary key(s) for `quoteAccommodationDetail` for the far side of the relationship. */
  connectById?: InputMaybe<Array<QuoteAccommodationDetailPkQuoteAccommodationDetailConnect>>;
  /** A `QuoteAccommodationDetailInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FakePublicQuoteAccommodationDetailForeignKey0QuoteAccommodationDetailCreateInput>>;
  /** The primary key(s) for `quoteAccommodationDetail` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<QuoteAccommodationDetailPkQuoteAccommodationDetailDelete>>;
  /** Flag indicating whether all other `quoteAccommodationDetail` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `quoteAccommodationDetail` for the far side of the relationship. */
  updateById?: InputMaybe<Array<QuoteAccommodationDetailOnQuoteAccommodationDetailForFakePublicQuoteAccommodationDetailForeignKey0UsingPkQuoteAccommodationDetailUpdate>>;
};

/** The `quoteAccommodationDetail` to be created by this mutation. */
export type FakePublicQuoteAccommodationDetailForeignKey0QuoteAccommodationDetailCreateInput = {
  basis?: InputMaybe<Scalars['String']['input']>;
  beverageInclusions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  confirmation?: InputMaybe<Scalars['String']['input']>;
  foodInclusions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  nights: Scalars['Int']['input'];
  notes?: InputMaybe<Scalars['String']['input']>;
  propertyId?: InputMaybe<Scalars['UUID']['input']>;
  propertyToPropertyId?: InputMaybe<FkQuoteAccommodationDetailPropertyPropertyIdInput>;
  quoteDaysUsingId?: InputMaybe<FkQuoteDayQuoteAccommodationDetailAccommodationIdInverseInput>;
  quotePublic?: InputMaybe<FakePublicQuoteAccommodationDetailForeignKey0Input>;
  quoteToQuoteId?: InputMaybe<FkQuoteAccommodationDetailQuoteQuoteIdInput>;
  roomType?: InputMaybe<Scalars['String']['input']>;
  sortOrder: Scalars['Int']['input'];
  summary?: InputMaybe<Scalars['String']['input']>;
};

/** The `quotePublic` to be created by this mutation. */
export type FakePublicQuoteAccommodationDetailForeignKey0QuotePublicCreateInput = {
  accepted?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  deposit?: InputMaybe<Scalars['BigFloat']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  exclusions?: InputMaybe<Scalars['String']['input']>;
  expires?: InputMaybe<Scalars['Datetime']['input']>;
  heroId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  inclusions?: InputMaybe<Scalars['String']['input']>;
  key: Scalars['String']['input'];
  locked?: InputMaybe<Scalars['Datetime']['input']>;
  quoteAccommodationDetailsUsingId?: InputMaybe<FakePublicQuoteAccommodationDetailForeignKey0InverseInput>;
  quoteDaysUsingId?: InputMaybe<FakePublicQuoteDayForeignKey0InverseInput>;
  quoteHeroToHeroId?: InputMaybe<FakePublicQuotePublicForeignKey1Input>;
  quoteLegalDocumentsUsingId?: InputMaybe<FakePublicQuoteLegalDocumentForeignKey0InverseInput>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  total?: InputMaybe<Scalars['BigFloat']['input']>;
  travellerCount?: InputMaybe<Scalars['Int']['input']>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FakePublicQuotePublicForeignKey0Input>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FakePublicQuotePublicForeignKey2Input>;
};

/** Input for the nested mutation of `quotePublic` in the `QuoteDayInput` mutation. */
export type FakePublicQuoteDayForeignKey0Input = {
  /** The primary key(s) for `quotePublic` for the far side of the relationship. */
  connectByKey?: InputMaybe<QuotePublicFakePublicQuotePublicPrimaryKeyConnect>;
  /** A `QuotePublicInput` object that will be created and connected to this object. */
  create?: InputMaybe<FakePublicQuoteDayForeignKey0QuotePublicCreateInput>;
  /** The primary key(s) for `quotePublic` for the far side of the relationship. */
  deleteByKey?: InputMaybe<QuotePublicFakePublicQuotePublicPrimaryKeyDelete>;
  /** The primary key(s) and patch data for `quotePublic` for the far side of the relationship. */
  updateByKey?: InputMaybe<QuotePublicOnQuoteDayForFakePublicQuoteDayForeignKey0UsingFakePublicQuotePublicPrimaryKeyUpdate>;
};

/** Input for the nested mutation of `quoteDay` in the `QuotePublicInput` mutation. */
export type FakePublicQuoteDayForeignKey0InverseInput = {
  /** The primary key(s) for `quoteDay` for the far side of the relationship. */
  connectById?: InputMaybe<Array<QuoteDayPkQuoteDayConnect>>;
  /** A `QuoteDayInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FakePublicQuoteDayForeignKey0QuoteDayCreateInput>>;
  /** The primary key(s) for `quoteDay` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<QuoteDayPkQuoteDayDelete>>;
  /** Flag indicating whether all other `quoteDay` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `quoteDay` for the far side of the relationship. */
  updateById?: InputMaybe<Array<QuoteDayOnQuoteDayForFakePublicQuoteDayForeignKey0UsingPkQuoteDayUpdate>>;
};

/** The `quoteDay` to be created by this mutation. */
export type FakePublicQuoteDayForeignKey0QuoteDayCreateInput = {
  accommodationId?: InputMaybe<Scalars['UUID']['input']>;
  activityDetail?: InputMaybe<Scalars['String']['input']>;
  activitySummary?: InputMaybe<Scalars['String']['input']>;
  date?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  propertyId?: InputMaybe<Scalars['UUID']['input']>;
  propertyToPropertyId?: InputMaybe<QuoteDayPropertyIdFkeyInput>;
  quoteAccommodationDetailToAccommodationId?: InputMaybe<FkQuoteDayQuoteAccommodationDetailAccommodationIdInput>;
  quoteDayDestinationsUsingId?: InputMaybe<FkQuoteDayDestinationQuoteDayDayIdInverseInput>;
  quotePublic?: InputMaybe<FakePublicQuoteDayForeignKey0Input>;
  quoteToQuoteId?: InputMaybe<FkQuoteDayQuoteQuoteIdInput>;
  sortOrder: Scalars['Int']['input'];
};

/** The `quotePublic` to be created by this mutation. */
export type FakePublicQuoteDayForeignKey0QuotePublicCreateInput = {
  accepted?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  deposit?: InputMaybe<Scalars['BigFloat']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  exclusions?: InputMaybe<Scalars['String']['input']>;
  expires?: InputMaybe<Scalars['Datetime']['input']>;
  heroId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  inclusions?: InputMaybe<Scalars['String']['input']>;
  key: Scalars['String']['input'];
  locked?: InputMaybe<Scalars['Datetime']['input']>;
  quoteAccommodationDetailsUsingId?: InputMaybe<FakePublicQuoteAccommodationDetailForeignKey0InverseInput>;
  quoteDaysUsingId?: InputMaybe<FakePublicQuoteDayForeignKey0InverseInput>;
  quoteHeroToHeroId?: InputMaybe<FakePublicQuotePublicForeignKey1Input>;
  quoteLegalDocumentsUsingId?: InputMaybe<FakePublicQuoteLegalDocumentForeignKey0InverseInput>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  total?: InputMaybe<Scalars['BigFloat']['input']>;
  travellerCount?: InputMaybe<Scalars['Int']['input']>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FakePublicQuotePublicForeignKey0Input>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FakePublicQuotePublicForeignKey2Input>;
};

/** Input for the nested mutation of `quotePublic` in the `QuoteLegalDocumentInput` mutation. */
export type FakePublicQuoteLegalDocumentForeignKey0Input = {
  /** The primary key(s) for `quotePublic` for the far side of the relationship. */
  connectByKey?: InputMaybe<QuotePublicFakePublicQuotePublicPrimaryKeyConnect>;
  /** A `QuotePublicInput` object that will be created and connected to this object. */
  create?: InputMaybe<FakePublicQuoteLegalDocumentForeignKey0QuotePublicCreateInput>;
  /** The primary key(s) for `quotePublic` for the far side of the relationship. */
  deleteByKey?: InputMaybe<QuotePublicFakePublicQuotePublicPrimaryKeyDelete>;
  /** The primary key(s) and patch data for `quotePublic` for the far side of the relationship. */
  updateByKey?: InputMaybe<QuotePublicOnQuoteLegalDocumentForFakePublicQuoteLegalDocumentForeignKey0UsingFakePublicQuotePublicPrimaryKeyUpdate>;
};

/** Input for the nested mutation of `quoteLegalDocument` in the `QuotePublicInput` mutation. */
export type FakePublicQuoteLegalDocumentForeignKey0InverseInput = {
  /** The primary key(s) for `quoteLegalDocument` for the far side of the relationship. */
  connectById?: InputMaybe<Array<QuoteLegalDocumentPkQuoteLegalDocumentConnect>>;
  /** A `QuoteLegalDocumentInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FakePublicQuoteLegalDocumentForeignKey0QuoteLegalDocumentCreateInput>>;
  /** The primary key(s) for `quoteLegalDocument` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<QuoteLegalDocumentPkQuoteLegalDocumentDelete>>;
  /** Flag indicating whether all other `quoteLegalDocument` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `quoteLegalDocument` for the far side of the relationship. */
  updateById?: InputMaybe<Array<QuoteLegalDocumentOnQuoteLegalDocumentForFakePublicQuoteLegalDocumentForeignKey0UsingPkQuoteLegalDocumentUpdate>>;
};

/** The `quoteLegalDocument` to be created by this mutation. */
export type FakePublicQuoteLegalDocumentForeignKey0QuoteLegalDocumentCreateInput = {
  id?: InputMaybe<Scalars['UUID']['input']>;
  legalDocumentId?: InputMaybe<Scalars['UUID']['input']>;
  legalDocumentToLegalDocumentId?: InputMaybe<FkQuoteLegalDocumentLegalDocumentInput>;
  quotePublic?: InputMaybe<FakePublicQuoteLegalDocumentForeignKey0Input>;
  quoteToQuoteId?: InputMaybe<FkQuoteLegalDocumentQuoteInput>;
  sortOrder?: InputMaybe<Scalars['Int']['input']>;
};

/** The `quotePublic` to be created by this mutation. */
export type FakePublicQuoteLegalDocumentForeignKey0QuotePublicCreateInput = {
  accepted?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  deposit?: InputMaybe<Scalars['BigFloat']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  exclusions?: InputMaybe<Scalars['String']['input']>;
  expires?: InputMaybe<Scalars['Datetime']['input']>;
  heroId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  inclusions?: InputMaybe<Scalars['String']['input']>;
  key: Scalars['String']['input'];
  locked?: InputMaybe<Scalars['Datetime']['input']>;
  quoteAccommodationDetailsUsingId?: InputMaybe<FakePublicQuoteAccommodationDetailForeignKey0InverseInput>;
  quoteDaysUsingId?: InputMaybe<FakePublicQuoteDayForeignKey0InverseInput>;
  quoteHeroToHeroId?: InputMaybe<FakePublicQuotePublicForeignKey1Input>;
  quoteLegalDocumentsUsingId?: InputMaybe<FakePublicQuoteLegalDocumentForeignKey0InverseInput>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  total?: InputMaybe<Scalars['BigFloat']['input']>;
  travellerCount?: InputMaybe<Scalars['Int']['input']>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FakePublicQuotePublicForeignKey0Input>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FakePublicQuotePublicForeignKey2Input>;
};

/** Input for the nested mutation of `trip` in the `QuotePublicInput` mutation. */
export type FakePublicQuotePublicForeignKey0Input = {
  /** The primary key(s) for `trip` for the far side of the relationship. */
  connectById?: InputMaybe<TripPkTripConnect>;
  /** A `TripInput` object that will be created and connected to this object. */
  create?: InputMaybe<FakePublicQuotePublicForeignKey0TripCreateInput>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  deleteById?: InputMaybe<TripPkTripDelete>;
  /** The primary key(s) and patch data for `trip` for the far side of the relationship. */
  updateById?: InputMaybe<TripOnQuotePublicForFakePublicQuotePublicForeignKey0UsingPkTripUpdate>;
};

/** Input for the nested mutation of `quotePublic` in the `TripInput` mutation. */
export type FakePublicQuotePublicForeignKey0InverseInput = {
  /** The primary key(s) for `quotePublic` for the far side of the relationship. */
  connectByKey?: InputMaybe<Array<QuotePublicFakePublicQuotePublicPrimaryKeyConnect>>;
  /** A `QuotePublicInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FakePublicQuotePublicForeignKey0QuotePublicCreateInput>>;
  /** The primary key(s) for `quotePublic` for the far side of the relationship. */
  deleteByKey?: InputMaybe<Array<QuotePublicFakePublicQuotePublicPrimaryKeyDelete>>;
  /** Flag indicating whether all other `quotePublic` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `quotePublic` for the far side of the relationship. */
  updateByKey?: InputMaybe<Array<QuotePublicOnQuotePublicForFakePublicQuotePublicForeignKey0UsingFakePublicQuotePublicPrimaryKeyUpdate>>;
};

/** The `quotePublic` to be created by this mutation. */
export type FakePublicQuotePublicForeignKey0QuotePublicCreateInput = {
  accepted?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  deposit?: InputMaybe<Scalars['BigFloat']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  exclusions?: InputMaybe<Scalars['String']['input']>;
  expires?: InputMaybe<Scalars['Datetime']['input']>;
  heroId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  inclusions?: InputMaybe<Scalars['String']['input']>;
  key: Scalars['String']['input'];
  locked?: InputMaybe<Scalars['Datetime']['input']>;
  quoteAccommodationDetailsUsingId?: InputMaybe<FakePublicQuoteAccommodationDetailForeignKey0InverseInput>;
  quoteDaysUsingId?: InputMaybe<FakePublicQuoteDayForeignKey0InverseInput>;
  quoteHeroToHeroId?: InputMaybe<FakePublicQuotePublicForeignKey1Input>;
  quoteLegalDocumentsUsingId?: InputMaybe<FakePublicQuoteLegalDocumentForeignKey0InverseInput>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  total?: InputMaybe<Scalars['BigFloat']['input']>;
  travellerCount?: InputMaybe<Scalars['Int']['input']>;
  tripToTripId?: InputMaybe<FakePublicQuotePublicForeignKey0Input>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FakePublicQuotePublicForeignKey2Input>;
};

/** The `trip` to be created by this mutation. */
export type FakePublicQuotePublicForeignKey0TripCreateInput = {
  activeQuoteId?: InputMaybe<Scalars['UUID']['input']>;
  agencyId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberToAgencyMemberId?: InputMaybe<FkTripAgencyMemberAgencyMemberIdInput>;
  agencyToAgencyId?: InputMaybe<FkTripAgencyAgencyIdInput>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerId?: InputMaybe<Scalars['UUID']['input']>;
  customerToCustomerId?: InputMaybe<FkTripCustomerCustomerIdInput>;
  dates?: InputMaybe<Scalars['String']['input']>;
  destination?: InputMaybe<Scalars['String']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  emailsUsingId?: InputMaybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: InputMaybe<FkEnquiryTripTripIdInverseInput>;
  expensesUsingId?: InputMaybe<FkExpenseTripTripIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceTripTripIdInverseInput>;
  mediaGalleryId?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryToMediaGalleryId?: InputMaybe<FkTripMediaGalleryMediaGalleryIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notesUsingId?: InputMaybe<FkNoteTripTripIdInverseInput>;
  paymentsUsingId?: InputMaybe<FkPaymentTripTripIdInverseInput>;
  quotePublicsUsingId?: InputMaybe<FakePublicQuotePublicForeignKey0InverseInput>;
  quoteToActiveQuoteId?: InputMaybe<FkTripQuoteActiveQuoteIdInput>;
  quotesUsingId?: InputMaybe<FkQuoteTripTripIdInverseInput>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceTripTripIdInverseInput>;
  testimonialsUsingId?: InputMaybe<FkTestimonialTripTripIdInverseInput>;
  tripFlightsUsingId?: InputMaybe<FkTripFlightTripTripIdInverseInput>;
  tripTravellersUsingId?: InputMaybe<FkTripTravellerTripTripIdInverseInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkTripUserUserIdInput>;
};

/** Input for the nested mutation of `quoteHero` in the `QuotePublicInput` mutation. */
export type FakePublicQuotePublicForeignKey1Input = {
  /** The primary key(s) for `quoteHero` for the far side of the relationship. */
  connectById?: InputMaybe<QuoteHeroPkQuoteHeroConnect>;
  /** A `QuoteHeroInput` object that will be created and connected to this object. */
  create?: InputMaybe<FakePublicQuotePublicForeignKey1QuoteHeroCreateInput>;
  /** The primary key(s) for `quoteHero` for the far side of the relationship. */
  deleteById?: InputMaybe<QuoteHeroPkQuoteHeroDelete>;
  /** The primary key(s) and patch data for `quoteHero` for the far side of the relationship. */
  updateById?: InputMaybe<QuoteHeroOnQuotePublicForFakePublicQuotePublicForeignKey1UsingPkQuoteHeroUpdate>;
};

/** Input for the nested mutation of `quotePublic` in the `QuoteHeroInput` mutation. */
export type FakePublicQuotePublicForeignKey1InverseInput = {
  /** The primary key(s) for `quotePublic` for the far side of the relationship. */
  connectByKey?: InputMaybe<Array<QuotePublicFakePublicQuotePublicPrimaryKeyConnect>>;
  /** A `QuotePublicInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FakePublicQuotePublicForeignKey1QuotePublicCreateInput>>;
  /** The primary key(s) for `quotePublic` for the far side of the relationship. */
  deleteByKey?: InputMaybe<Array<QuotePublicFakePublicQuotePublicPrimaryKeyDelete>>;
  /** Flag indicating whether all other `quotePublic` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `quotePublic` for the far side of the relationship. */
  updateByKey?: InputMaybe<Array<QuotePublicOnQuotePublicForFakePublicQuotePublicForeignKey1UsingFakePublicQuotePublicPrimaryKeyUpdate>>;
};

/** The `quoteHero` to be created by this mutation. */
export type FakePublicQuotePublicForeignKey1QuoteHeroCreateInput = {
  id?: InputMaybe<Scalars['UUID']['input']>;
  imageId?: InputMaybe<Scalars['UUID']['input']>;
  mediaItemToImageId?: InputMaybe<FkQuoteHeroMediaItemImageIdInput>;
  quotePublicsUsingId?: InputMaybe<FakePublicQuotePublicForeignKey1InverseInput>;
  quotesUsingId?: InputMaybe<FkQuoteQuoteHeroHeroIdInverseInput>;
  style?: InputMaybe<Scalars['String']['input']>;
  subtitle?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** The `quotePublic` to be created by this mutation. */
export type FakePublicQuotePublicForeignKey1QuotePublicCreateInput = {
  accepted?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  deposit?: InputMaybe<Scalars['BigFloat']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  exclusions?: InputMaybe<Scalars['String']['input']>;
  expires?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  inclusions?: InputMaybe<Scalars['String']['input']>;
  key: Scalars['String']['input'];
  locked?: InputMaybe<Scalars['Datetime']['input']>;
  quoteAccommodationDetailsUsingId?: InputMaybe<FakePublicQuoteAccommodationDetailForeignKey0InverseInput>;
  quoteDaysUsingId?: InputMaybe<FakePublicQuoteDayForeignKey0InverseInput>;
  quoteHeroToHeroId?: InputMaybe<FakePublicQuotePublicForeignKey1Input>;
  quoteLegalDocumentsUsingId?: InputMaybe<FakePublicQuoteLegalDocumentForeignKey0InverseInput>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  total?: InputMaybe<Scalars['BigFloat']['input']>;
  travellerCount?: InputMaybe<Scalars['Int']['input']>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FakePublicQuotePublicForeignKey0Input>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FakePublicQuotePublicForeignKey2Input>;
};

/** Input for the nested mutation of `user` in the `QuotePublicInput` mutation. */
export type FakePublicQuotePublicForeignKey2Input = {
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectById?: InputMaybe<UserPkUserConnect>;
  /** A `UserInput` object that will be created and connected to this object. */
  create?: InputMaybe<FakePublicQuotePublicForeignKey2UserCreateInput>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteById?: InputMaybe<UserPkUserDelete>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateById?: InputMaybe<UserOnQuotePublicForFakePublicQuotePublicForeignKey2UsingPkUserUpdate>;
};

/** Input for the nested mutation of `quotePublic` in the `UserInput` mutation. */
export type FakePublicQuotePublicForeignKey2InverseInput = {
  /** The primary key(s) for `quotePublic` for the far side of the relationship. */
  connectByKey?: InputMaybe<Array<QuotePublicFakePublicQuotePublicPrimaryKeyConnect>>;
  /** A `QuotePublicInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FakePublicQuotePublicForeignKey2QuotePublicCreateInput>>;
  /** The primary key(s) for `quotePublic` for the far side of the relationship. */
  deleteByKey?: InputMaybe<Array<QuotePublicFakePublicQuotePublicPrimaryKeyDelete>>;
  /** Flag indicating whether all other `quotePublic` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `quotePublic` for the far side of the relationship. */
  updateByKey?: InputMaybe<Array<QuotePublicOnQuotePublicForFakePublicQuotePublicForeignKey2UsingFakePublicQuotePublicPrimaryKeyUpdate>>;
};

/** The `quotePublic` to be created by this mutation. */
export type FakePublicQuotePublicForeignKey2QuotePublicCreateInput = {
  accepted?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  deposit?: InputMaybe<Scalars['BigFloat']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  exclusions?: InputMaybe<Scalars['String']['input']>;
  expires?: InputMaybe<Scalars['Datetime']['input']>;
  heroId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  inclusions?: InputMaybe<Scalars['String']['input']>;
  key: Scalars['String']['input'];
  locked?: InputMaybe<Scalars['Datetime']['input']>;
  quoteAccommodationDetailsUsingId?: InputMaybe<FakePublicQuoteAccommodationDetailForeignKey0InverseInput>;
  quoteDaysUsingId?: InputMaybe<FakePublicQuoteDayForeignKey0InverseInput>;
  quoteHeroToHeroId?: InputMaybe<FakePublicQuotePublicForeignKey1Input>;
  quoteLegalDocumentsUsingId?: InputMaybe<FakePublicQuoteLegalDocumentForeignKey0InverseInput>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  total?: InputMaybe<Scalars['BigFloat']['input']>;
  travellerCount?: InputMaybe<Scalars['Int']['input']>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FakePublicQuotePublicForeignKey0Input>;
  userToUserId?: InputMaybe<FakePublicQuotePublicForeignKey2Input>;
};

/** The `user` to be created by this mutation. */
export type FakePublicQuotePublicForeignKey2UserCreateInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  emailsUsingId?: InputMaybe<FkEmailUserUserIdInverseInput>;
  externalId?: InputMaybe<Scalars['String']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  genderPreposition?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name: Scalars['String']['input'];
  notesUsingId?: InputMaybe<FkNoteUserUserIdInverseInput>;
  password?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  quotePublicsUsingId?: InputMaybe<FakePublicQuotePublicForeignKey2InverseInput>;
  quotesUsingId?: InputMaybe<FkQuoteUserUserIdInverseInput>;
  remindersUsingId?: InputMaybe<FkReminderUserUserIdInverseInput>;
  skype?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  transactionNotesUsingId?: InputMaybe<FkTransactionNoteUserUserIdInverseInput>;
  tripsUsingId?: InputMaybe<FkTripUserUserIdInverseInput>;
};

export type Feature = {
  __typename?: 'Feature';
  body?: Maybe<Scalars['String']['output']>;
  created: Scalars['Datetime']['output'];
  /** Reads a single `MediaGallery` that is related to this `Feature`. */
  gallery?: Maybe<MediaGallery>;
  galleryId?: Maybe<Scalars['UUID']['output']>;
  id: Scalars['UUID']['output'];
  modified: Scalars['Datetime']['output'];
  name?: Maybe<Scalars['String']['output']>;
};

/** A condition to be used against `Feature` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type FeatureCondition = {
  /** Checks for equality with the object’s `body` field. */
  body?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `galleryId` field. */
  galleryId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `Feature` object types. All fields are combined with a logical ‘and.’ */
export type FeatureFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<FeatureFilter>>;
  /** Filter by the object’s `body` field. */
  body?: InputMaybe<StringFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `gallery` relation. */
  gallery?: InputMaybe<MediaGalleryFilter>;
  /** A related `gallery` exists. */
  galleryExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `galleryId` field. */
  galleryId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<FeatureFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<FeatureFilter>>;
};

/** An input for mutations affecting `Feature` */
export type FeatureInput = {
  body?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  galleryId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryToGalleryId?: InputMaybe<FkFeatureMediaGalleryGalleryIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** The fields on `feature` to look up the row to update. */
export type FeatureOnFeatureForFkFeatureMediaGalleryGalleryIdUsingPkFeatureUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `feature` being updated. */
  patch: UpdateFeatureOnFeatureForFkFeatureMediaGalleryGalleryIdPatch;
};

/** Represents an update to a `Feature`. Fields that are set will be updated. */
export type FeaturePatch = {
  body?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  galleryId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryToGalleryId?: InputMaybe<FkFeatureMediaGalleryGalleryIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** The fields on `feature` to look up the row to connect. */
export type FeaturePkFeatureConnect = {
  id: Scalars['UUID']['input'];
};

/** The fields on `feature` to look up the row to delete. */
export type FeaturePkFeatureDelete = {
  id: Scalars['UUID']['input'];
};

/** A connection to a list of `Feature` values. */
export type FeaturesConnection = {
  __typename?: 'FeaturesConnection';
  /** A list of edges which contains the `Feature` and cursor to aid in pagination. */
  edges: Array<FeaturesEdge>;
  /** A list of `Feature` objects. */
  nodes: Array<Maybe<Feature>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Feature` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Feature` edge in the connection. */
export type FeaturesEdge = {
  __typename?: 'FeaturesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Feature` at the end of the edge. */
  node?: Maybe<Feature>;
};

/** Methods to use when ordering `Feature`. */
export enum FeaturesOrderBy {
  BodyAsc = 'BODY_ASC',
  BodyDesc = 'BODY_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  GalleryIdAsc = 'GALLERY_ID_ASC',
  GalleryIdDesc = 'GALLERY_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  MediaGalleryByGalleryIdCreatedAsc = 'MEDIA_GALLERY_BY_GALLERY_ID__CREATED_ASC',
  MediaGalleryByGalleryIdCreatedDesc = 'MEDIA_GALLERY_BY_GALLERY_ID__CREATED_DESC',
  MediaGalleryByGalleryIdIdAsc = 'MEDIA_GALLERY_BY_GALLERY_ID__ID_ASC',
  MediaGalleryByGalleryIdIdDesc = 'MEDIA_GALLERY_BY_GALLERY_ID__ID_DESC',
  MediaGalleryByGalleryIdIsProtectedAsc = 'MEDIA_GALLERY_BY_GALLERY_ID__IS_PROTECTED_ASC',
  MediaGalleryByGalleryIdIsProtectedDesc = 'MEDIA_GALLERY_BY_GALLERY_ID__IS_PROTECTED_DESC',
  MediaGalleryByGalleryIdModifiedAsc = 'MEDIA_GALLERY_BY_GALLERY_ID__MODIFIED_ASC',
  MediaGalleryByGalleryIdModifiedDesc = 'MEDIA_GALLERY_BY_GALLERY_ID__MODIFIED_DESC',
  MediaGalleryByGalleryIdNameAsc = 'MEDIA_GALLERY_BY_GALLERY_ID__NAME_ASC',
  MediaGalleryByGalleryIdNameDesc = 'MEDIA_GALLERY_BY_GALLERY_ID__NAME_DESC',
  MediaGalleryByGalleryIdParentIdAsc = 'MEDIA_GALLERY_BY_GALLERY_ID__PARENT_ID_ASC',
  MediaGalleryByGalleryIdParentIdDesc = 'MEDIA_GALLERY_BY_GALLERY_ID__PARENT_ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A connection to a list of `FinanceCategory` values. */
export type FinanceCategoriesConnection = {
  __typename?: 'FinanceCategoriesConnection';
  /** A list of edges which contains the `FinanceCategory` and cursor to aid in pagination. */
  edges: Array<FinanceCategoriesEdge>;
  /** A list of `FinanceCategory` objects. */
  nodes: Array<Maybe<FinanceCategory>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FinanceCategory` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `FinanceCategory` edge in the connection. */
export type FinanceCategoriesEdge = {
  __typename?: 'FinanceCategoriesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `FinanceCategory` at the end of the edge. */
  node?: Maybe<FinanceCategory>;
};

/** Methods to use when ordering `FinanceCategory`. */
export enum FinanceCategoriesOrderBy {
  CodeAsc = 'CODE_ASC',
  CodeDesc = 'CODE_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  ExpensesByCategoryIdCountAsc = 'EXPENSES_BY_CATEGORY_ID__COUNT_ASC',
  ExpensesByCategoryIdCountDesc = 'EXPENSES_BY_CATEGORY_ID__COUNT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  InvoicesByCategoryIdCountAsc = 'INVOICES_BY_CATEGORY_ID__COUNT_ASC',
  InvoicesByCategoryIdCountDesc = 'INVOICES_BY_CATEGORY_ID__COUNT_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PaymentsByCategoryIdCountAsc = 'PAYMENTS_BY_CATEGORY_ID__COUNT_ASC',
  PaymentsByCategoryIdCountDesc = 'PAYMENTS_BY_CATEGORY_ID__COUNT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SummaryAsc = 'SUMMARY_ASC',
  SummaryDesc = 'SUMMARY_DESC',
  SupplierInvoicesByCategoryIdCountAsc = 'SUPPLIER_INVOICES_BY_CATEGORY_ID__COUNT_ASC',
  SupplierInvoicesByCategoryIdCountDesc = 'SUPPLIER_INVOICES_BY_CATEGORY_ID__COUNT_DESC',
  TransactionsByCategoryIdCountAsc = 'TRANSACTIONS_BY_CATEGORY_ID__COUNT_ASC',
  TransactionsByCategoryIdCountDesc = 'TRANSACTIONS_BY_CATEGORY_ID__COUNT_DESC',
  TypeAsc = 'TYPE_ASC',
  TypeDesc = 'TYPE_DESC'
}

export type FinanceCategory = {
  __typename?: 'FinanceCategory';
  code?: Maybe<Scalars['String']['output']>;
  created: Scalars['Datetime']['output'];
  /** Reads and enables pagination through a set of `Expense`. */
  expensesByCategoryId: ExpensesConnection;
  id: Scalars['UUID']['output'];
  /** Reads and enables pagination through a set of `Invoice`. */
  invoicesByCategoryId: InvoicesConnection;
  modified: Scalars['Datetime']['output'];
  name?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `Payment`. */
  paymentsByCategoryId: PaymentsConnection;
  summary?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `SupplierInvoice`. */
  supplierInvoicesByCategoryId: SupplierInvoicesConnection;
  /** Reads and enables pagination through a set of `Transaction`. */
  transactionsByCategoryId: TransactionsConnection;
  type: Scalars['Int']['output'];
};


export type FinanceCategoryExpensesByCategoryIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ExpenseCondition>;
  filter?: InputMaybe<ExpenseFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ExpensesOrderBy>>;
};


export type FinanceCategoryInvoicesByCategoryIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<InvoiceCondition>;
  filter?: InputMaybe<InvoiceFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<InvoicesOrderBy>>;
};


export type FinanceCategoryPaymentsByCategoryIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PaymentCondition>;
  filter?: InputMaybe<PaymentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PaymentsOrderBy>>;
};


export type FinanceCategorySupplierInvoicesByCategoryIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SupplierInvoiceCondition>;
  filter?: InputMaybe<SupplierInvoiceFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SupplierInvoicesOrderBy>>;
};


export type FinanceCategoryTransactionsByCategoryIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TransactionCondition>;
  filter?: InputMaybe<TransactionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TransactionsOrderBy>>;
};

/**
 * A condition to be used against `FinanceCategory` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type FinanceCategoryCondition = {
  /** Checks for equality with the object’s `code` field. */
  code?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `summary` field. */
  summary?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `type` field. */
  type?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `FinanceCategory` object types. All fields are combined with a logical ‘and.’ */
export type FinanceCategoryFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<FinanceCategoryFilter>>;
  /** Filter by the object’s `code` field. */
  code?: InputMaybe<StringFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `expensesByCategoryId` relation. */
  expensesByCategoryId?: InputMaybe<FinanceCategoryToManyExpenseFilter>;
  /** Some related `expensesByCategoryId` exist. */
  expensesByCategoryIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `invoicesByCategoryId` relation. */
  invoicesByCategoryId?: InputMaybe<FinanceCategoryToManyInvoiceFilter>;
  /** Some related `invoicesByCategoryId` exist. */
  invoicesByCategoryIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<FinanceCategoryFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<FinanceCategoryFilter>>;
  /** Filter by the object’s `paymentsByCategoryId` relation. */
  paymentsByCategoryId?: InputMaybe<FinanceCategoryToManyPaymentFilter>;
  /** Some related `paymentsByCategoryId` exist. */
  paymentsByCategoryIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `summary` field. */
  summary?: InputMaybe<StringFilter>;
  /** Filter by the object’s `supplierInvoicesByCategoryId` relation. */
  supplierInvoicesByCategoryId?: InputMaybe<FinanceCategoryToManySupplierInvoiceFilter>;
  /** Some related `supplierInvoicesByCategoryId` exist. */
  supplierInvoicesByCategoryIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `transactionsByCategoryId` relation. */
  transactionsByCategoryId?: InputMaybe<FinanceCategoryToManyTransactionFilter>;
  /** Some related `transactionsByCategoryId` exist. */
  transactionsByCategoryIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `type` field. */
  type?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `FinanceCategory` */
export type FinanceCategoryInput = {
  code?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  expensesUsingId?: InputMaybe<FkExpenseFinanceCategoryCategoryIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceFinanceCategoryCategoryIdInverseInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  paymentsUsingId?: InputMaybe<FkPaymentFinanceCategoryCategoryIdInverseInput>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceFinanceCategoryCategoryIdInverseInput>;
  transactionsUsingId?: InputMaybe<FkTransactionFinanceCategoryCategoryIdInverseInput>;
  type?: InputMaybe<Scalars['Int']['input']>;
};

/** The fields on `financeCategory` to look up the row to update. */
export type FinanceCategoryOnExpenseForFkExpenseFinanceCategoryCategoryIdUsingPkFinanceCategoryUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `financeCategory` being updated. */
  patch: UpdateFinanceCategoryOnExpenseForFkExpenseFinanceCategoryCategoryIdPatch;
};

/** The fields on `financeCategory` to look up the row to update. */
export type FinanceCategoryOnInvoiceForFkInvoiceFinanceCategoryCategoryIdUsingPkFinanceCategoryUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `financeCategory` being updated. */
  patch: UpdateFinanceCategoryOnInvoiceForFkInvoiceFinanceCategoryCategoryIdPatch;
};

/** The fields on `financeCategory` to look up the row to update. */
export type FinanceCategoryOnPaymentForFkPaymentFinanceCategoryCategoryIdUsingPkFinanceCategoryUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `financeCategory` being updated. */
  patch: UpdateFinanceCategoryOnPaymentForFkPaymentFinanceCategoryCategoryIdPatch;
};

/** The fields on `financeCategory` to look up the row to update. */
export type FinanceCategoryOnSupplierInvoiceForFkSupplierInvoiceFinanceCategoryCategoryIdUsingPkFinanceCategoryUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `financeCategory` being updated. */
  patch: UpdateFinanceCategoryOnSupplierInvoiceForFkSupplierInvoiceFinanceCategoryCategoryIdPatch;
};

/** The fields on `financeCategory` to look up the row to update. */
export type FinanceCategoryOnTransactionForFkTransactionFinanceCategoryCategoryIdUsingPkFinanceCategoryUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `financeCategory` being updated. */
  patch: UpdateFinanceCategoryOnTransactionForFkTransactionFinanceCategoryCategoryIdPatch;
};

/** Represents an update to a `FinanceCategory`. Fields that are set will be updated. */
export type FinanceCategoryPatch = {
  code?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  expensesUsingId?: InputMaybe<FkExpenseFinanceCategoryCategoryIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceFinanceCategoryCategoryIdInverseInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  paymentsUsingId?: InputMaybe<FkPaymentFinanceCategoryCategoryIdInverseInput>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceFinanceCategoryCategoryIdInverseInput>;
  transactionsUsingId?: InputMaybe<FkTransactionFinanceCategoryCategoryIdInverseInput>;
  type?: InputMaybe<Scalars['Int']['input']>;
};

/** The fields on `financeCategory` to look up the row to connect. */
export type FinanceCategoryPkFinanceCategoryConnect = {
  id: Scalars['UUID']['input'];
};

/** The fields on `financeCategory` to look up the row to delete. */
export type FinanceCategoryPkFinanceCategoryDelete = {
  id: Scalars['UUID']['input'];
};

/** A filter to be used against many `Expense` object types. All fields are combined with a logical ‘and.’ */
export type FinanceCategoryToManyExpenseFilter = {
  /** Every related `Expense` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ExpenseFilter>;
  /** No related `Expense` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ExpenseFilter>;
  /** Some related `Expense` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ExpenseFilter>;
};

/** A filter to be used against many `Invoice` object types. All fields are combined with a logical ‘and.’ */
export type FinanceCategoryToManyInvoiceFilter = {
  /** Every related `Invoice` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<InvoiceFilter>;
  /** No related `Invoice` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<InvoiceFilter>;
  /** Some related `Invoice` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<InvoiceFilter>;
};

/** A filter to be used against many `Payment` object types. All fields are combined with a logical ‘and.’ */
export type FinanceCategoryToManyPaymentFilter = {
  /** Every related `Payment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<PaymentFilter>;
  /** No related `Payment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<PaymentFilter>;
  /** Some related `Payment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<PaymentFilter>;
};

/** A filter to be used against many `SupplierInvoice` object types. All fields are combined with a logical ‘and.’ */
export type FinanceCategoryToManySupplierInvoiceFilter = {
  /** Every related `SupplierInvoice` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<SupplierInvoiceFilter>;
  /** No related `SupplierInvoice` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<SupplierInvoiceFilter>;
  /** Some related `SupplierInvoice` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<SupplierInvoiceFilter>;
};

/** A filter to be used against many `Transaction` object types. All fields are combined with a logical ‘and.’ */
export type FinanceCategoryToManyTransactionFilter = {
  /** Every related `Transaction` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<TransactionFilter>;
  /** No related `Transaction` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<TransactionFilter>;
  /** Some related `Transaction` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<TransactionFilter>;
};

/** The `agency` to be created by this mutation. */
export type FkAgencyMediaItemLogoIdAgencyCreateInput = {
  agencyMembersUsingId?: InputMaybe<FkAgencyMemberAgencyAgencyIdInverseInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  mediaItemToLogoId?: InputMaybe<FkAgencyMediaItemLogoIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  supplierId?: InputMaybe<Scalars['UUID']['input']>;
  supplierToSupplierId?: InputMaybe<FkAgencySupplierInput>;
  tripsUsingId?: InputMaybe<FkTripAgencyAgencyIdInverseInput>;
};

/** Input for the nested mutation of `mediaItem` in the `AgencyInput` mutation. */
export type FkAgencyMediaItemLogoIdInput = {
  /** The primary key(s) for `mediaItem` for the far side of the relationship. */
  connectById?: InputMaybe<MediaItemPkMediaItemConnect>;
  /** A `MediaItemInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkAgencyMediaItemLogoIdMediaItemCreateInput>;
  /** The primary key(s) for `mediaItem` for the far side of the relationship. */
  deleteById?: InputMaybe<MediaItemPkMediaItemDelete>;
  /** The primary key(s) and patch data for `mediaItem` for the far side of the relationship. */
  updateById?: InputMaybe<MediaItemOnAgencyForFkAgencyMediaItemLogoIdUsingPkMediaItemUpdate>;
};

/** Input for the nested mutation of `agency` in the `MediaItemInput` mutation. */
export type FkAgencyMediaItemLogoIdInverseInput = {
  /** The primary key(s) for `agency` for the far side of the relationship. */
  connectById?: InputMaybe<Array<AgencyPkAgencyConnect>>;
  /** A `AgencyInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkAgencyMediaItemLogoIdAgencyCreateInput>>;
  /** The primary key(s) for `agency` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<AgencyPkAgencyDelete>>;
  /** Flag indicating whether all other `agency` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `agency` for the far side of the relationship. */
  updateById?: InputMaybe<Array<AgencyOnAgencyForFkAgencyMediaItemLogoIdUsingPkAgencyUpdate>>;
};

/** The `mediaItem` to be created by this mutation. */
export type FkAgencyMediaItemLogoIdMediaItemCreateInput = {
  agenciesUsingId?: InputMaybe<FkAgencyMediaItemLogoIdInverseInput>;
  contentType?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationsUsingId?: InputMaybe<DestinationHeroMediaIdFkeyInverseInput>;
  fileName?: InputMaybe<Scalars['String']['input']>;
  hash?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryItemsUsingId?: InputMaybe<FkMediaGalleryItemMediaItemMediaItemIdInverseInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  propertiesUsingId?: InputMaybe<FkPropertyMediaItemHeroMediaIdInverseInput>;
  quoteHeroesUsingId?: InputMaybe<FkQuoteHeroMediaItemImageIdInverseInput>;
  quotesUsingId?: InputMaybe<FkQuoteMediaItemHeroImageIdInverseInput>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceMediaItemMediaItemIdInverseInput>;
};

/** The `agency` to be created by this mutation. */
export type FkAgencyMemberAgencyAgencyIdAgencyCreateInput = {
  agencyMembersUsingId?: InputMaybe<FkAgencyMemberAgencyAgencyIdInverseInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  logoId?: InputMaybe<Scalars['UUID']['input']>;
  mediaItemToLogoId?: InputMaybe<FkAgencyMediaItemLogoIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  supplierId?: InputMaybe<Scalars['UUID']['input']>;
  supplierToSupplierId?: InputMaybe<FkAgencySupplierInput>;
  tripsUsingId?: InputMaybe<FkTripAgencyAgencyIdInverseInput>;
};

/** The `agencyMember` to be created by this mutation. */
export type FkAgencyMemberAgencyAgencyIdAgencyMemberCreateInput = {
  agencyToAgencyId?: InputMaybe<FkAgencyMemberAgencyAgencyIdInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  genderPreposition?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  skype?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  tripsUsingId?: InputMaybe<FkTripAgencyMemberAgencyMemberIdInverseInput>;
};

/** Input for the nested mutation of `agency` in the `AgencyMemberInput` mutation. */
export type FkAgencyMemberAgencyAgencyIdInput = {
  /** The primary key(s) for `agency` for the far side of the relationship. */
  connectById?: InputMaybe<AgencyPkAgencyConnect>;
  /** A `AgencyInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkAgencyMemberAgencyAgencyIdAgencyCreateInput>;
  /** The primary key(s) for `agency` for the far side of the relationship. */
  deleteById?: InputMaybe<AgencyPkAgencyDelete>;
  /** The primary key(s) and patch data for `agency` for the far side of the relationship. */
  updateById?: InputMaybe<AgencyOnAgencyMemberForFkAgencyMemberAgencyAgencyIdUsingPkAgencyUpdate>;
};

/** Input for the nested mutation of `agencyMember` in the `AgencyInput` mutation. */
export type FkAgencyMemberAgencyAgencyIdInverseInput = {
  /** The primary key(s) for `agencyMember` for the far side of the relationship. */
  connectById?: InputMaybe<Array<AgencyMemberPkAgencyMemberConnect>>;
  /** A `AgencyMemberInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkAgencyMemberAgencyAgencyIdAgencyMemberCreateInput>>;
  /** The primary key(s) for `agencyMember` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<AgencyMemberPkAgencyMemberDelete>>;
  /** Flag indicating whether all other `agencyMember` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `agencyMember` for the far side of the relationship. */
  updateById?: InputMaybe<Array<AgencyMemberOnAgencyMemberForFkAgencyMemberAgencyAgencyIdUsingPkAgencyMemberUpdate>>;
};

/** The `agency` to be created by this mutation. */
export type FkAgencySupplierAgencyCreateInput = {
  agencyMembersUsingId?: InputMaybe<FkAgencyMemberAgencyAgencyIdInverseInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  logoId?: InputMaybe<Scalars['UUID']['input']>;
  mediaItemToLogoId?: InputMaybe<FkAgencyMediaItemLogoIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  supplierToSupplierId?: InputMaybe<FkAgencySupplierInput>;
  tripsUsingId?: InputMaybe<FkTripAgencyAgencyIdInverseInput>;
};

/** Input for the nested mutation of `supplier` in the `AgencyInput` mutation. */
export type FkAgencySupplierInput = {
  /** The primary key(s) for `supplier` for the far side of the relationship. */
  connectById?: InputMaybe<SupplierPkSupplierConnect>;
  /** A `SupplierInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkAgencySupplierSupplierCreateInput>;
  /** The primary key(s) for `supplier` for the far side of the relationship. */
  deleteById?: InputMaybe<SupplierPkSupplierDelete>;
  /** The primary key(s) and patch data for `supplier` for the far side of the relationship. */
  updateById?: InputMaybe<SupplierOnAgencyForFkAgencySupplierUsingPkSupplierUpdate>;
};

/** Input for the nested mutation of `agency` in the `SupplierInput` mutation. */
export type FkAgencySupplierInverseInput = {
  /** The primary key(s) for `agency` for the far side of the relationship. */
  connectById?: InputMaybe<Array<AgencyPkAgencyConnect>>;
  /** A `AgencyInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkAgencySupplierAgencyCreateInput>>;
  /** The primary key(s) for `agency` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<AgencyPkAgencyDelete>>;
  /** Flag indicating whether all other `agency` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `agency` for the far side of the relationship. */
  updateById?: InputMaybe<Array<AgencyOnAgencyForFkAgencySupplierUsingPkAgencyUpdate>>;
};

/** The `supplier` to be created by this mutation. */
export type FkAgencySupplierSupplierCreateInput = {
  agenciesUsingId?: InputMaybe<FkAgencySupplierInverseInput>;
  bankDetails?: InputMaybe<Scalars['String']['input']>;
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  contactNumber?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  expensesUsingId?: InputMaybe<FkExpenseSupplierSupplierIdInverseInput>;
  galleryId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryToGalleryId?: InputMaybe<FkSupplierMediaGalleryGalleryIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  quoteFinanceLineItemsUsingId?: InputMaybe<FkQuoteFinanceLineItemSupplierSupplierIdInverseInput>;
  region?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceSupplierSupplierIdInverseInput>;
  url?: InputMaybe<Scalars['String']['input']>;
};

/** The `airport` to be created by this mutation. */
export type FkAirportCountryCountryIdAirportCreateInput = {
  city?: InputMaybe<Scalars['String']['input']>;
  countryToCountryId?: InputMaybe<FkAirportCountryCountryIdInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  displayName?: InputMaybe<Scalars['String']['input']>;
  iata?: InputMaybe<Scalars['String']['input']>;
  icao?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  latitude: Scalars['Float']['input'];
  longitude: Scalars['Float']['input'];
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  timezone?: InputMaybe<Scalars['String']['input']>;
  tripFlightsToArrivalAirportIdUsingId?: InputMaybe<TripFlightArrivalAirport2IdFkeyInverseInput>;
  tripFlightsToDepartureAirportIdUsingId?: InputMaybe<TripFlightDepartureAirport2IdFkeyInverseInput>;
};

/** The `country` to be created by this mutation. */
export type FkAirportCountryCountryIdCountryCreateInput = {
  airportsUsingId?: InputMaybe<FkAirportCountryCountryIdInverseInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationsUsingId?: InputMaybe<FkDestinationCountryCountryIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  iso2?: InputMaybe<Scalars['String']['input']>;
  iso3?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  passportsUsingId?: InputMaybe<PassportCountry2IdFkeyInverseInput>;
  propertiesUsingId?: InputMaybe<FkPropertyCountryCountryIdInverseInput>;
};

/** Input for the nested mutation of `country` in the `AirportInput` mutation. */
export type FkAirportCountryCountryIdInput = {
  /** The primary key(s) for `country` for the far side of the relationship. */
  connectById?: InputMaybe<CountryPkCountryConnect>;
  /** A `CountryInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkAirportCountryCountryIdCountryCreateInput>;
  /** The primary key(s) for `country` for the far side of the relationship. */
  deleteById?: InputMaybe<CountryPkCountryDelete>;
  /** The primary key(s) and patch data for `country` for the far side of the relationship. */
  updateById?: InputMaybe<CountryOnAirportForFkAirportCountryCountryIdUsingPkCountryUpdate>;
};

/** Input for the nested mutation of `airport` in the `CountryInput` mutation. */
export type FkAirportCountryCountryIdInverseInput = {
  /** The primary key(s) for `airport` for the far side of the relationship. */
  connectById?: InputMaybe<Array<AirportPkAirportConnect>>;
  /** A `AirportInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkAirportCountryCountryIdAirportCreateInput>>;
  /** The primary key(s) for `airport` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<AirportPkAirportDelete>>;
  /** Flag indicating whether all other `airport` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `airport` for the far side of the relationship. */
  updateById?: InputMaybe<Array<AirportOnAirportForFkAirportCountryCountryIdUsingPkAirportUpdate>>;
};

/** The `customer` to be created by this mutation. */
export type FkCustomerTravellerCustomerCustomerIdCustomerCreateInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerTravellersUsingId?: InputMaybe<FkCustomerTravellerCustomerCustomerIdInverseInput>;
  email?: InputMaybe<Scalars['String']['input']>;
  emailsUsingId?: InputMaybe<FkEmailCustomerCustomerIdInverseInput>;
  enquiriesUsingId?: InputMaybe<FkEnquiryCustomerCustomerIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  tripsUsingId?: InputMaybe<FkTripCustomerCustomerIdInverseInput>;
};

/** The `customerTraveller` to be created by this mutation. */
export type FkCustomerTravellerCustomerCustomerIdCustomerTravellerCreateInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerToCustomerId?: InputMaybe<FkCustomerTravellerCustomerCustomerIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  travellerId?: InputMaybe<Scalars['UUID']['input']>;
  travellerToTravellerId?: InputMaybe<FkCustomerTravellerTravellerTravellerIdInput>;
};

/** Input for the nested mutation of `customer` in the `CustomerTravellerInput` mutation. */
export type FkCustomerTravellerCustomerCustomerIdInput = {
  /** The primary key(s) for `customer` for the far side of the relationship. */
  connectById?: InputMaybe<CustomerPkCustomerConnect>;
  /** A `CustomerInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkCustomerTravellerCustomerCustomerIdCustomerCreateInput>;
  /** The primary key(s) for `customer` for the far side of the relationship. */
  deleteById?: InputMaybe<CustomerPkCustomerDelete>;
  /** The primary key(s) and patch data for `customer` for the far side of the relationship. */
  updateById?: InputMaybe<CustomerOnCustomerTravellerForFkCustomerTravellerCustomerCustomerIdUsingPkCustomerUpdate>;
};

/** Input for the nested mutation of `customerTraveller` in the `CustomerInput` mutation. */
export type FkCustomerTravellerCustomerCustomerIdInverseInput = {
  /** The primary key(s) for `customerTraveller` for the far side of the relationship. */
  connectById?: InputMaybe<Array<CustomerTravellerPkCustomerTravellerConnect>>;
  /** A `CustomerTravellerInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkCustomerTravellerCustomerCustomerIdCustomerTravellerCreateInput>>;
  /** The primary key(s) for `customerTraveller` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<CustomerTravellerPkCustomerTravellerDelete>>;
  /** Flag indicating whether all other `customerTraveller` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `customerTraveller` for the far side of the relationship. */
  updateById?: InputMaybe<Array<CustomerTravellerOnCustomerTravellerForFkCustomerTravellerCustomerCustomerIdUsingPkCustomerTravellerUpdate>>;
};

/** The `customerTraveller` to be created by this mutation. */
export type FkCustomerTravellerTravellerTravellerIdCustomerTravellerCreateInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerId?: InputMaybe<Scalars['UUID']['input']>;
  customerToCustomerId?: InputMaybe<FkCustomerTravellerCustomerCustomerIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  travellerToTravellerId?: InputMaybe<FkCustomerTravellerTravellerTravellerIdInput>;
};

/** Input for the nested mutation of `traveller` in the `CustomerTravellerInput` mutation. */
export type FkCustomerTravellerTravellerTravellerIdInput = {
  /** The primary key(s) for `traveller` for the far side of the relationship. */
  connectById?: InputMaybe<TravellerPkTravellerConnect>;
  /** A `TravellerInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkCustomerTravellerTravellerTravellerIdTravellerCreateInput>;
  /** The primary key(s) for `traveller` for the far side of the relationship. */
  deleteById?: InputMaybe<TravellerPkTravellerDelete>;
  /** The primary key(s) and patch data for `traveller` for the far side of the relationship. */
  updateById?: InputMaybe<TravellerOnCustomerTravellerForFkCustomerTravellerTravellerTravellerIdUsingPkTravellerUpdate>;
};

/** Input for the nested mutation of `customerTraveller` in the `TravellerInput` mutation. */
export type FkCustomerTravellerTravellerTravellerIdInverseInput = {
  /** The primary key(s) for `customerTraveller` for the far side of the relationship. */
  connectById?: InputMaybe<Array<CustomerTravellerPkCustomerTravellerConnect>>;
  /** A `CustomerTravellerInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkCustomerTravellerTravellerTravellerIdCustomerTravellerCreateInput>>;
  /** The primary key(s) for `customerTraveller` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<CustomerTravellerPkCustomerTravellerDelete>>;
  /** Flag indicating whether all other `customerTraveller` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `customerTraveller` for the far side of the relationship. */
  updateById?: InputMaybe<Array<CustomerTravellerOnCustomerTravellerForFkCustomerTravellerTravellerTravellerIdUsingPkCustomerTravellerUpdate>>;
};

/** The `traveller` to be created by this mutation. */
export type FkCustomerTravellerTravellerTravellerIdTravellerCreateInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerTravellersUsingId?: InputMaybe<FkCustomerTravellerTravellerTravellerIdInverseInput>;
  dateOfBirth?: InputMaybe<Scalars['Datetime']['input']>;
  dietaryRequirements?: InputMaybe<Scalars['String']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  emergencyContact?: InputMaybe<Scalars['String']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  height?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  insuranceDetails?: InputMaybe<Scalars['String']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  medicalConditions?: InputMaybe<Scalars['String']['input']>;
  middleName?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  nationality?: InputMaybe<Scalars['String']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  passportsUsingId?: InputMaybe<FkPassportTravellerTravellerIdInverseInput>;
  phone?: InputMaybe<Scalars['String']['input']>;
  tripTravellersUsingId?: InputMaybe<FkTripTravellerTravellerTravellerIdInverseInput>;
  weight?: InputMaybe<Scalars['Int']['input']>;
};

/** The `country` to be created by this mutation. */
export type FkDestinationCountryCountryIdCountryCreateInput = {
  airportsUsingId?: InputMaybe<FkAirportCountryCountryIdInverseInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationsUsingId?: InputMaybe<FkDestinationCountryCountryIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  iso2?: InputMaybe<Scalars['String']['input']>;
  iso3?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  passportsUsingId?: InputMaybe<PassportCountry2IdFkeyInverseInput>;
  propertiesUsingId?: InputMaybe<FkPropertyCountryCountryIdInverseInput>;
};

/** The `destination` to be created by this mutation. */
export type FkDestinationCountryCountryIdDestinationCreateInput = {
  alias: Scalars['String']['input'];
  body?: InputMaybe<Scalars['String']['input']>;
  countryToCountryId?: InputMaybe<FkDestinationCountryCountryIdInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationFeaturesUsingId?: InputMaybe<FkDestinationFeatureDestinationDestinationIdInverseInput>;
  destinationGuidesUsingId?: InputMaybe<FkDestinationGuideDestinationDestinationIdInverseInput>;
  destinationToParentId?: InputMaybe<FkDestinationDestinationParentIdInput>;
  galleryId?: InputMaybe<Scalars['UUID']['input']>;
  heroMediaId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  latitude?: InputMaybe<Scalars['Float']['input']>;
  longitude?: InputMaybe<Scalars['Float']['input']>;
  mediaGalleryToGalleryId?: InputMaybe<FkDestinationMediaGalleryGalleryIdInput>;
  mediaItemToHeroMediaId?: InputMaybe<DestinationHeroMediaIdFkeyInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  parentId?: InputMaybe<Scalars['UUID']['input']>;
  propertiesUsingId?: InputMaybe<FkPropertyDestinationInverseInput>;
  quoteDayDestinationsUsingId?: InputMaybe<FkQuoteDayDestinationDestinationDestinationIdInverseInput>;
};

/** Input for the nested mutation of `country` in the `DestinationInput` mutation. */
export type FkDestinationCountryCountryIdInput = {
  /** The primary key(s) for `country` for the far side of the relationship. */
  connectById?: InputMaybe<CountryPkCountryConnect>;
  /** A `CountryInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkDestinationCountryCountryIdCountryCreateInput>;
  /** The primary key(s) for `country` for the far side of the relationship. */
  deleteById?: InputMaybe<CountryPkCountryDelete>;
  /** The primary key(s) and patch data for `country` for the far side of the relationship. */
  updateById?: InputMaybe<CountryOnDestinationForFkDestinationCountryCountryIdUsingPkCountryUpdate>;
};

/** Input for the nested mutation of `destination` in the `CountryInput` mutation. */
export type FkDestinationCountryCountryIdInverseInput = {
  /** The primary key(s) for `destination` for the far side of the relationship. */
  connectByCountryIdAndAlias?: InputMaybe<Array<DestinationUqDestinationAliasConnect>>;
  /** The primary key(s) for `destination` for the far side of the relationship. */
  connectById?: InputMaybe<Array<DestinationPkDestinationConnect>>;
  /** A `DestinationInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkDestinationCountryCountryIdDestinationCreateInput>>;
  /** The primary key(s) for `destination` for the far side of the relationship. */
  deleteByCountryIdAndAlias?: InputMaybe<Array<DestinationUqDestinationAliasDelete>>;
  /** The primary key(s) for `destination` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<DestinationPkDestinationDelete>>;
  /** Flag indicating whether all other `destination` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `destination` for the far side of the relationship. */
  updateByCountryIdAndAlias?: InputMaybe<Array<DestinationOnDestinationForFkDestinationCountryCountryIdUsingUqDestinationAliasUpdate>>;
  /** The primary key(s) and patch data for `destination` for the far side of the relationship. */
  updateById?: InputMaybe<Array<DestinationOnDestinationForFkDestinationCountryCountryIdUsingPkDestinationUpdate>>;
};

/** The `destination` to be created by this mutation. */
export type FkDestinationDestinationParentIdDestinationCreateInput = {
  alias: Scalars['String']['input'];
  body?: InputMaybe<Scalars['String']['input']>;
  countryId?: InputMaybe<Scalars['UUID']['input']>;
  countryToCountryId?: InputMaybe<FkDestinationCountryCountryIdInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationFeaturesUsingId?: InputMaybe<FkDestinationFeatureDestinationDestinationIdInverseInput>;
  destinationGuidesUsingId?: InputMaybe<FkDestinationGuideDestinationDestinationIdInverseInput>;
  destinationToParentId?: InputMaybe<FkDestinationDestinationParentIdInput>;
  galleryId?: InputMaybe<Scalars['UUID']['input']>;
  heroMediaId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  latitude?: InputMaybe<Scalars['Float']['input']>;
  longitude?: InputMaybe<Scalars['Float']['input']>;
  mediaGalleryToGalleryId?: InputMaybe<FkDestinationMediaGalleryGalleryIdInput>;
  mediaItemToHeroMediaId?: InputMaybe<DestinationHeroMediaIdFkeyInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  propertiesUsingId?: InputMaybe<FkPropertyDestinationInverseInput>;
  quoteDayDestinationsUsingId?: InputMaybe<FkQuoteDayDestinationDestinationDestinationIdInverseInput>;
};

/** Input for the nested mutation of `destination` in the `DestinationInput` mutation. */
export type FkDestinationDestinationParentIdInput = {
  /** The primary key(s) for `destination` for the far side of the relationship. */
  connectByCountryIdAndAlias?: InputMaybe<DestinationUqDestinationAliasConnect>;
  /** The primary key(s) for `destination` for the far side of the relationship. */
  connectById?: InputMaybe<DestinationPkDestinationConnect>;
  /** A `DestinationInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkDestinationDestinationParentIdDestinationCreateInput>;
  /** The primary key(s) for `destination` for the far side of the relationship. */
  deleteByCountryIdAndAlias?: InputMaybe<DestinationUqDestinationAliasDelete>;
  /** The primary key(s) for `destination` for the far side of the relationship. */
  deleteById?: InputMaybe<DestinationPkDestinationDelete>;
  /** The primary key(s) and patch data for `destination` for the far side of the relationship. */
  updateByCountryIdAndAlias?: InputMaybe<DestinationOnDestinationForFkDestinationDestinationParentIdUsingUqDestinationAliasUpdate>;
  /** The primary key(s) and patch data for `destination` for the far side of the relationship. */
  updateById?: InputMaybe<DestinationOnDestinationForFkDestinationDestinationParentIdUsingPkDestinationUpdate>;
};

/** The `destination` to be created by this mutation. */
export type FkDestinationFeatureDestinationDestinationIdDestinationCreateInput = {
  alias: Scalars['String']['input'];
  body?: InputMaybe<Scalars['String']['input']>;
  countryId?: InputMaybe<Scalars['UUID']['input']>;
  countryToCountryId?: InputMaybe<FkDestinationCountryCountryIdInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationFeaturesUsingId?: InputMaybe<FkDestinationFeatureDestinationDestinationIdInverseInput>;
  destinationGuidesUsingId?: InputMaybe<FkDestinationGuideDestinationDestinationIdInverseInput>;
  destinationToParentId?: InputMaybe<FkDestinationDestinationParentIdInput>;
  galleryId?: InputMaybe<Scalars['UUID']['input']>;
  heroMediaId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  latitude?: InputMaybe<Scalars['Float']['input']>;
  longitude?: InputMaybe<Scalars['Float']['input']>;
  mediaGalleryToGalleryId?: InputMaybe<FkDestinationMediaGalleryGalleryIdInput>;
  mediaItemToHeroMediaId?: InputMaybe<DestinationHeroMediaIdFkeyInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  parentId?: InputMaybe<Scalars['UUID']['input']>;
  propertiesUsingId?: InputMaybe<FkPropertyDestinationInverseInput>;
  quoteDayDestinationsUsingId?: InputMaybe<FkQuoteDayDestinationDestinationDestinationIdInverseInput>;
};

/** The `destinationFeature` to be created by this mutation. */
export type FkDestinationFeatureDestinationDestinationIdDestinationFeatureCreateInput = {
  body?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationToDestinationId?: InputMaybe<FkDestinationFeatureDestinationDestinationIdInput>;
  galleryId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryToGalleryId?: InputMaybe<FkDestinationFeatureMediaGalleryGalleryIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** Input for the nested mutation of `destination` in the `DestinationFeatureInput` mutation. */
export type FkDestinationFeatureDestinationDestinationIdInput = {
  /** The primary key(s) for `destination` for the far side of the relationship. */
  connectByCountryIdAndAlias?: InputMaybe<DestinationUqDestinationAliasConnect>;
  /** The primary key(s) for `destination` for the far side of the relationship. */
  connectById?: InputMaybe<DestinationPkDestinationConnect>;
  /** A `DestinationInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkDestinationFeatureDestinationDestinationIdDestinationCreateInput>;
  /** The primary key(s) for `destination` for the far side of the relationship. */
  deleteByCountryIdAndAlias?: InputMaybe<DestinationUqDestinationAliasDelete>;
  /** The primary key(s) for `destination` for the far side of the relationship. */
  deleteById?: InputMaybe<DestinationPkDestinationDelete>;
  /** The primary key(s) and patch data for `destination` for the far side of the relationship. */
  updateByCountryIdAndAlias?: InputMaybe<DestinationOnDestinationFeatureForFkDestinationFeatureDestinationDestinationIdUsingUqDestinationAliasUpdate>;
  /** The primary key(s) and patch data for `destination` for the far side of the relationship. */
  updateById?: InputMaybe<DestinationOnDestinationFeatureForFkDestinationFeatureDestinationDestinationIdUsingPkDestinationUpdate>;
};

/** Input for the nested mutation of `destinationFeature` in the `DestinationInput` mutation. */
export type FkDestinationFeatureDestinationDestinationIdInverseInput = {
  /** The primary key(s) for `destinationFeature` for the far side of the relationship. */
  connectById?: InputMaybe<Array<DestinationFeaturePkDestinationFeatureConnect>>;
  /** A `DestinationFeatureInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkDestinationFeatureDestinationDestinationIdDestinationFeatureCreateInput>>;
  /** The primary key(s) for `destinationFeature` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<DestinationFeaturePkDestinationFeatureDelete>>;
  /** Flag indicating whether all other `destinationFeature` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `destinationFeature` for the far side of the relationship. */
  updateById?: InputMaybe<Array<DestinationFeatureOnDestinationFeatureForFkDestinationFeatureDestinationDestinationIdUsingPkDestinationFeatureUpdate>>;
};

/** The `destinationFeature` to be created by this mutation. */
export type FkDestinationFeatureMediaGalleryGalleryIdDestinationFeatureCreateInput = {
  body?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationId?: InputMaybe<Scalars['UUID']['input']>;
  destinationToDestinationId?: InputMaybe<FkDestinationFeatureDestinationDestinationIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryToGalleryId?: InputMaybe<FkDestinationFeatureMediaGalleryGalleryIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** Input for the nested mutation of `mediaGallery` in the `DestinationFeatureInput` mutation. */
export type FkDestinationFeatureMediaGalleryGalleryIdInput = {
  /** The primary key(s) for `mediaGallery` for the far side of the relationship. */
  connectById?: InputMaybe<MediaGalleryPkMediaGalleryConnect>;
  /** A `MediaGalleryInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkDestinationFeatureMediaGalleryGalleryIdMediaGalleryCreateInput>;
  /** The primary key(s) for `mediaGallery` for the far side of the relationship. */
  deleteById?: InputMaybe<MediaGalleryPkMediaGalleryDelete>;
  /** The primary key(s) and patch data for `mediaGallery` for the far side of the relationship. */
  updateById?: InputMaybe<MediaGalleryOnDestinationFeatureForFkDestinationFeatureMediaGalleryGalleryIdUsingPkMediaGalleryUpdate>;
};

/** Input for the nested mutation of `destinationFeature` in the `MediaGalleryInput` mutation. */
export type FkDestinationFeatureMediaGalleryGalleryIdInverseInput = {
  /** The primary key(s) for `destinationFeature` for the far side of the relationship. */
  connectById?: InputMaybe<Array<DestinationFeaturePkDestinationFeatureConnect>>;
  /** A `DestinationFeatureInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkDestinationFeatureMediaGalleryGalleryIdDestinationFeatureCreateInput>>;
  /** The primary key(s) for `destinationFeature` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<DestinationFeaturePkDestinationFeatureDelete>>;
  /** Flag indicating whether all other `destinationFeature` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `destinationFeature` for the far side of the relationship. */
  updateById?: InputMaybe<Array<DestinationFeatureOnDestinationFeatureForFkDestinationFeatureMediaGalleryGalleryIdUsingPkDestinationFeatureUpdate>>;
};

/** The `mediaGallery` to be created by this mutation. */
export type FkDestinationFeatureMediaGalleryGalleryIdMediaGalleryCreateInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationFeaturesUsingId?: InputMaybe<FkDestinationFeatureMediaGalleryGalleryIdInverseInput>;
  destinationsUsingId?: InputMaybe<FkDestinationMediaGalleryGalleryIdInverseInput>;
  featuresUsingId?: InputMaybe<FkFeatureMediaGalleryGalleryIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  isProtected?: InputMaybe<Scalars['Boolean']['input']>;
  mediaGalleryItemsUsingId?: InputMaybe<FkMediaGalleryItemMediaGalleryMediaGalleryIdInverseInput>;
  mediaGalleryToParentId?: InputMaybe<FkMediaGalleryMediaGalleryParentIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  parentId?: InputMaybe<Scalars['UUID']['input']>;
  propertiesUsingId?: InputMaybe<FkPropertyMediaGalleryGalleryIdInverseInput>;
  suppliersUsingId?: InputMaybe<FkSupplierMediaGalleryGalleryIdInverseInput>;
  tripsUsingId?: InputMaybe<FkTripMediaGalleryMediaGalleryIdInverseInput>;
};

/** The `destination` to be created by this mutation. */
export type FkDestinationGuideDestinationDestinationIdDestinationCreateInput = {
  alias: Scalars['String']['input'];
  body?: InputMaybe<Scalars['String']['input']>;
  countryId?: InputMaybe<Scalars['UUID']['input']>;
  countryToCountryId?: InputMaybe<FkDestinationCountryCountryIdInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationFeaturesUsingId?: InputMaybe<FkDestinationFeatureDestinationDestinationIdInverseInput>;
  destinationGuidesUsingId?: InputMaybe<FkDestinationGuideDestinationDestinationIdInverseInput>;
  destinationToParentId?: InputMaybe<FkDestinationDestinationParentIdInput>;
  galleryId?: InputMaybe<Scalars['UUID']['input']>;
  heroMediaId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  latitude?: InputMaybe<Scalars['Float']['input']>;
  longitude?: InputMaybe<Scalars['Float']['input']>;
  mediaGalleryToGalleryId?: InputMaybe<FkDestinationMediaGalleryGalleryIdInput>;
  mediaItemToHeroMediaId?: InputMaybe<DestinationHeroMediaIdFkeyInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  parentId?: InputMaybe<Scalars['UUID']['input']>;
  propertiesUsingId?: InputMaybe<FkPropertyDestinationInverseInput>;
  quoteDayDestinationsUsingId?: InputMaybe<FkQuoteDayDestinationDestinationDestinationIdInverseInput>;
};

/** The `destinationGuide` to be created by this mutation. */
export type FkDestinationGuideDestinationDestinationIdDestinationGuideCreateInput = {
  body?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationToDestinationId?: InputMaybe<FkDestinationGuideDestinationDestinationIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** Input for the nested mutation of `destination` in the `DestinationGuideInput` mutation. */
export type FkDestinationGuideDestinationDestinationIdInput = {
  /** The primary key(s) for `destination` for the far side of the relationship. */
  connectByCountryIdAndAlias?: InputMaybe<DestinationUqDestinationAliasConnect>;
  /** The primary key(s) for `destination` for the far side of the relationship. */
  connectById?: InputMaybe<DestinationPkDestinationConnect>;
  /** A `DestinationInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkDestinationGuideDestinationDestinationIdDestinationCreateInput>;
  /** The primary key(s) for `destination` for the far side of the relationship. */
  deleteByCountryIdAndAlias?: InputMaybe<DestinationUqDestinationAliasDelete>;
  /** The primary key(s) for `destination` for the far side of the relationship. */
  deleteById?: InputMaybe<DestinationPkDestinationDelete>;
  /** The primary key(s) and patch data for `destination` for the far side of the relationship. */
  updateByCountryIdAndAlias?: InputMaybe<DestinationOnDestinationGuideForFkDestinationGuideDestinationDestinationIdUsingUqDestinationAliasUpdate>;
  /** The primary key(s) and patch data for `destination` for the far side of the relationship. */
  updateById?: InputMaybe<DestinationOnDestinationGuideForFkDestinationGuideDestinationDestinationIdUsingPkDestinationUpdate>;
};

/** Input for the nested mutation of `destinationGuide` in the `DestinationInput` mutation. */
export type FkDestinationGuideDestinationDestinationIdInverseInput = {
  /** The primary key(s) for `destinationGuide` for the far side of the relationship. */
  connectById?: InputMaybe<Array<DestinationGuidePkDestinationGuideConnect>>;
  /** A `DestinationGuideInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkDestinationGuideDestinationDestinationIdDestinationGuideCreateInput>>;
  /** The primary key(s) for `destinationGuide` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<DestinationGuidePkDestinationGuideDelete>>;
  /** Flag indicating whether all other `destinationGuide` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `destinationGuide` for the far side of the relationship. */
  updateById?: InputMaybe<Array<DestinationGuideOnDestinationGuideForFkDestinationGuideDestinationDestinationIdUsingPkDestinationGuideUpdate>>;
};

/** The `destination` to be created by this mutation. */
export type FkDestinationMediaGalleryGalleryIdDestinationCreateInput = {
  alias: Scalars['String']['input'];
  body?: InputMaybe<Scalars['String']['input']>;
  countryId?: InputMaybe<Scalars['UUID']['input']>;
  countryToCountryId?: InputMaybe<FkDestinationCountryCountryIdInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationFeaturesUsingId?: InputMaybe<FkDestinationFeatureDestinationDestinationIdInverseInput>;
  destinationGuidesUsingId?: InputMaybe<FkDestinationGuideDestinationDestinationIdInverseInput>;
  destinationToParentId?: InputMaybe<FkDestinationDestinationParentIdInput>;
  heroMediaId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  latitude?: InputMaybe<Scalars['Float']['input']>;
  longitude?: InputMaybe<Scalars['Float']['input']>;
  mediaGalleryToGalleryId?: InputMaybe<FkDestinationMediaGalleryGalleryIdInput>;
  mediaItemToHeroMediaId?: InputMaybe<DestinationHeroMediaIdFkeyInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  parentId?: InputMaybe<Scalars['UUID']['input']>;
  propertiesUsingId?: InputMaybe<FkPropertyDestinationInverseInput>;
  quoteDayDestinationsUsingId?: InputMaybe<FkQuoteDayDestinationDestinationDestinationIdInverseInput>;
};

/** Input for the nested mutation of `mediaGallery` in the `DestinationInput` mutation. */
export type FkDestinationMediaGalleryGalleryIdInput = {
  /** The primary key(s) for `mediaGallery` for the far side of the relationship. */
  connectById?: InputMaybe<MediaGalleryPkMediaGalleryConnect>;
  /** A `MediaGalleryInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkDestinationMediaGalleryGalleryIdMediaGalleryCreateInput>;
  /** The primary key(s) for `mediaGallery` for the far side of the relationship. */
  deleteById?: InputMaybe<MediaGalleryPkMediaGalleryDelete>;
  /** The primary key(s) and patch data for `mediaGallery` for the far side of the relationship. */
  updateById?: InputMaybe<MediaGalleryOnDestinationForFkDestinationMediaGalleryGalleryIdUsingPkMediaGalleryUpdate>;
};

/** Input for the nested mutation of `destination` in the `MediaGalleryInput` mutation. */
export type FkDestinationMediaGalleryGalleryIdInverseInput = {
  /** The primary key(s) for `destination` for the far side of the relationship. */
  connectByCountryIdAndAlias?: InputMaybe<Array<DestinationUqDestinationAliasConnect>>;
  /** The primary key(s) for `destination` for the far side of the relationship. */
  connectById?: InputMaybe<Array<DestinationPkDestinationConnect>>;
  /** A `DestinationInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkDestinationMediaGalleryGalleryIdDestinationCreateInput>>;
  /** The primary key(s) for `destination` for the far side of the relationship. */
  deleteByCountryIdAndAlias?: InputMaybe<Array<DestinationUqDestinationAliasDelete>>;
  /** The primary key(s) for `destination` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<DestinationPkDestinationDelete>>;
  /** Flag indicating whether all other `destination` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `destination` for the far side of the relationship. */
  updateByCountryIdAndAlias?: InputMaybe<Array<DestinationOnDestinationForFkDestinationMediaGalleryGalleryIdUsingUqDestinationAliasUpdate>>;
  /** The primary key(s) and patch data for `destination` for the far side of the relationship. */
  updateById?: InputMaybe<Array<DestinationOnDestinationForFkDestinationMediaGalleryGalleryIdUsingPkDestinationUpdate>>;
};

/** The `mediaGallery` to be created by this mutation. */
export type FkDestinationMediaGalleryGalleryIdMediaGalleryCreateInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationFeaturesUsingId?: InputMaybe<FkDestinationFeatureMediaGalleryGalleryIdInverseInput>;
  destinationsUsingId?: InputMaybe<FkDestinationMediaGalleryGalleryIdInverseInput>;
  featuresUsingId?: InputMaybe<FkFeatureMediaGalleryGalleryIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  isProtected?: InputMaybe<Scalars['Boolean']['input']>;
  mediaGalleryItemsUsingId?: InputMaybe<FkMediaGalleryItemMediaGalleryMediaGalleryIdInverseInput>;
  mediaGalleryToParentId?: InputMaybe<FkMediaGalleryMediaGalleryParentIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  parentId?: InputMaybe<Scalars['UUID']['input']>;
  propertiesUsingId?: InputMaybe<FkPropertyMediaGalleryGalleryIdInverseInput>;
  suppliersUsingId?: InputMaybe<FkSupplierMediaGalleryGalleryIdInverseInput>;
  tripsUsingId?: InputMaybe<FkTripMediaGalleryMediaGalleryIdInverseInput>;
};

/** The `customer` to be created by this mutation. */
export type FkEmailCustomerCustomerIdCustomerCreateInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerTravellersUsingId?: InputMaybe<FkCustomerTravellerCustomerCustomerIdInverseInput>;
  email?: InputMaybe<Scalars['String']['input']>;
  emailsUsingId?: InputMaybe<FkEmailCustomerCustomerIdInverseInput>;
  enquiriesUsingId?: InputMaybe<FkEnquiryCustomerCustomerIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  tripsUsingId?: InputMaybe<FkTripCustomerCustomerIdInverseInput>;
};

/** The `email` to be created by this mutation. */
export type FkEmailCustomerCustomerIdEmailCreateInput = {
  body?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerToCustomerId?: InputMaybe<FkEmailCustomerCustomerIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  quoteId?: InputMaybe<Scalars['UUID']['input']>;
  quoteToQuoteId?: InputMaybe<FkEmailQuoteQuoteIdInput>;
  recipients?: InputMaybe<Scalars['String']['input']>;
  subject?: InputMaybe<Scalars['String']['input']>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkEmailTripTripIdInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkEmailUserUserIdInput>;
};

/** Input for the nested mutation of `customer` in the `EmailInput` mutation. */
export type FkEmailCustomerCustomerIdInput = {
  /** The primary key(s) for `customer` for the far side of the relationship. */
  connectById?: InputMaybe<CustomerPkCustomerConnect>;
  /** A `CustomerInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkEmailCustomerCustomerIdCustomerCreateInput>;
  /** The primary key(s) for `customer` for the far side of the relationship. */
  deleteById?: InputMaybe<CustomerPkCustomerDelete>;
  /** The primary key(s) and patch data for `customer` for the far side of the relationship. */
  updateById?: InputMaybe<CustomerOnEmailForFkEmailCustomerCustomerIdUsingPkCustomerUpdate>;
};

/** Input for the nested mutation of `email` in the `CustomerInput` mutation. */
export type FkEmailCustomerCustomerIdInverseInput = {
  /** The primary key(s) for `email` for the far side of the relationship. */
  connectById?: InputMaybe<Array<EmailPkEmailConnect>>;
  /** A `EmailInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkEmailCustomerCustomerIdEmailCreateInput>>;
  /** The primary key(s) for `email` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<EmailPkEmailDelete>>;
  /** Flag indicating whether all other `email` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `email` for the far side of the relationship. */
  updateById?: InputMaybe<Array<EmailOnEmailForFkEmailCustomerCustomerIdUsingPkEmailUpdate>>;
};

/** The `email` to be created by this mutation. */
export type FkEmailQuoteQuoteIdEmailCreateInput = {
  body?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerId?: InputMaybe<Scalars['UUID']['input']>;
  customerToCustomerId?: InputMaybe<FkEmailCustomerCustomerIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  quoteToQuoteId?: InputMaybe<FkEmailQuoteQuoteIdInput>;
  recipients?: InputMaybe<Scalars['String']['input']>;
  subject?: InputMaybe<Scalars['String']['input']>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkEmailTripTripIdInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkEmailUserUserIdInput>;
};

/** Input for the nested mutation of `quote` in the `EmailInput` mutation. */
export type FkEmailQuoteQuoteIdInput = {
  /** The primary key(s) for `quote` for the far side of the relationship. */
  connectById?: InputMaybe<QuotePkQuoteConnect>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  connectByKey?: InputMaybe<QuoteUqQuoteKeyConnect>;
  /** A `QuoteInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkEmailQuoteQuoteIdQuoteCreateInput>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  deleteById?: InputMaybe<QuotePkQuoteDelete>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  deleteByKey?: InputMaybe<QuoteUqQuoteKeyDelete>;
  /** The primary key(s) and patch data for `quote` for the far side of the relationship. */
  updateById?: InputMaybe<QuoteOnEmailForFkEmailQuoteQuoteIdUsingPkQuoteUpdate>;
  /** The primary key(s) and patch data for `quote` for the far side of the relationship. */
  updateByKey?: InputMaybe<QuoteOnEmailForFkEmailQuoteQuoteIdUsingUqQuoteKeyUpdate>;
};

/** Input for the nested mutation of `email` in the `QuoteInput` mutation. */
export type FkEmailQuoteQuoteIdInverseInput = {
  /** The primary key(s) for `email` for the far side of the relationship. */
  connectById?: InputMaybe<Array<EmailPkEmailConnect>>;
  /** A `EmailInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkEmailQuoteQuoteIdEmailCreateInput>>;
  /** The primary key(s) for `email` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<EmailPkEmailDelete>>;
  /** Flag indicating whether all other `email` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `email` for the far side of the relationship. */
  updateById?: InputMaybe<Array<EmailOnEmailForFkEmailQuoteQuoteIdUsingPkEmailUpdate>>;
};

/** The `quote` to be created by this mutation. */
export type FkEmailQuoteQuoteIdQuoteCreateInput = {
  adjustment?: InputMaybe<Scalars['BigFloat']['input']>;
  agentMargin?: InputMaybe<Scalars['BigFloat']['input']>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  deposit?: InputMaybe<Scalars['BigFloat']['input']>;
  duration: Scalars['Int']['input'];
  emailsUsingId?: InputMaybe<FkEmailQuoteQuoteIdInverseInput>;
  exclusions?: InputMaybe<Scalars['String']['input']>;
  expires?: InputMaybe<Scalars['Datetime']['input']>;
  heroId?: InputMaybe<Scalars['UUID']['input']>;
  heroImageId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  inclusions?: InputMaybe<Scalars['String']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceQuoteQuoteIdInverseInput>;
  key?: InputMaybe<Scalars['String']['input']>;
  locked?: InputMaybe<Scalars['Datetime']['input']>;
  margin?: InputMaybe<Scalars['BigFloat']['input']>;
  mediaItemToHeroImageId?: InputMaybe<FkQuoteMediaItemHeroImageIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  quoteAcceptancesUsingId?: InputMaybe<FkQuoteAcceptanceQuoteInverseInput>;
  quoteAccommodationDetailsUsingId?: InputMaybe<FkQuoteAccommodationDetailQuoteQuoteIdInverseInput>;
  quoteCurrenciesUsingId?: InputMaybe<FkQuoteCurrencyQuoteQuoteIdInverseInput>;
  quoteDaysUsingId?: InputMaybe<FkQuoteDayQuoteQuoteIdInverseInput>;
  quoteFinanceLineItemsUsingId?: InputMaybe<FkQuoteFinanceLineItemQuoteQuoteIdInverseInput>;
  quoteHeroToHeroId?: InputMaybe<FkQuoteQuoteHeroHeroIdInput>;
  quoteLegalDocumentsUsingId?: InputMaybe<FkQuoteLegalDocumentQuoteInverseInput>;
  quoteStatusToStatus?: InputMaybe<FkQuoteStatusInput>;
  quoteViewsUsingId?: InputMaybe<FkQuoteViewQuoteQuoteIdInverseInput>;
  shortDescription?: InputMaybe<Scalars['String']['input']>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  travellerCount?: InputMaybe<Scalars['Int']['input']>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkQuoteTripTripIdInput>;
  tripsUsingId?: InputMaybe<FkTripQuoteActiveQuoteIdInverseInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkQuoteUserUserIdInput>;
};

/** The `email` to be created by this mutation. */
export type FkEmailTripTripIdEmailCreateInput = {
  body?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerId?: InputMaybe<Scalars['UUID']['input']>;
  customerToCustomerId?: InputMaybe<FkEmailCustomerCustomerIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  quoteId?: InputMaybe<Scalars['UUID']['input']>;
  quoteToQuoteId?: InputMaybe<FkEmailQuoteQuoteIdInput>;
  recipients?: InputMaybe<Scalars['String']['input']>;
  subject?: InputMaybe<Scalars['String']['input']>;
  tripToTripId?: InputMaybe<FkEmailTripTripIdInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkEmailUserUserIdInput>;
};

/** Input for the nested mutation of `trip` in the `EmailInput` mutation. */
export type FkEmailTripTripIdInput = {
  /** The primary key(s) for `trip` for the far side of the relationship. */
  connectById?: InputMaybe<TripPkTripConnect>;
  /** A `TripInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkEmailTripTripIdTripCreateInput>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  deleteById?: InputMaybe<TripPkTripDelete>;
  /** The primary key(s) and patch data for `trip` for the far side of the relationship. */
  updateById?: InputMaybe<TripOnEmailForFkEmailTripTripIdUsingPkTripUpdate>;
};

/** Input for the nested mutation of `email` in the `TripInput` mutation. */
export type FkEmailTripTripIdInverseInput = {
  /** The primary key(s) for `email` for the far side of the relationship. */
  connectById?: InputMaybe<Array<EmailPkEmailConnect>>;
  /** A `EmailInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkEmailTripTripIdEmailCreateInput>>;
  /** The primary key(s) for `email` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<EmailPkEmailDelete>>;
  /** Flag indicating whether all other `email` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `email` for the far side of the relationship. */
  updateById?: InputMaybe<Array<EmailOnEmailForFkEmailTripTripIdUsingPkEmailUpdate>>;
};

/** The `trip` to be created by this mutation. */
export type FkEmailTripTripIdTripCreateInput = {
  activeQuoteId?: InputMaybe<Scalars['UUID']['input']>;
  agencyId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberToAgencyMemberId?: InputMaybe<FkTripAgencyMemberAgencyMemberIdInput>;
  agencyToAgencyId?: InputMaybe<FkTripAgencyAgencyIdInput>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerId?: InputMaybe<Scalars['UUID']['input']>;
  customerToCustomerId?: InputMaybe<FkTripCustomerCustomerIdInput>;
  dates?: InputMaybe<Scalars['String']['input']>;
  destination?: InputMaybe<Scalars['String']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  emailsUsingId?: InputMaybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: InputMaybe<FkEnquiryTripTripIdInverseInput>;
  expensesUsingId?: InputMaybe<FkExpenseTripTripIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceTripTripIdInverseInput>;
  mediaGalleryId?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryToMediaGalleryId?: InputMaybe<FkTripMediaGalleryMediaGalleryIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notesUsingId?: InputMaybe<FkNoteTripTripIdInverseInput>;
  paymentsUsingId?: InputMaybe<FkPaymentTripTripIdInverseInput>;
  quotePublicsUsingId?: InputMaybe<FakePublicQuotePublicForeignKey0InverseInput>;
  quoteToActiveQuoteId?: InputMaybe<FkTripQuoteActiveQuoteIdInput>;
  quotesUsingId?: InputMaybe<FkQuoteTripTripIdInverseInput>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceTripTripIdInverseInput>;
  testimonialsUsingId?: InputMaybe<FkTestimonialTripTripIdInverseInput>;
  tripFlightsUsingId?: InputMaybe<FkTripFlightTripTripIdInverseInput>;
  tripTravellersUsingId?: InputMaybe<FkTripTravellerTripTripIdInverseInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkTripUserUserIdInput>;
};

/** The `email` to be created by this mutation. */
export type FkEmailUserUserIdEmailCreateInput = {
  body?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerId?: InputMaybe<Scalars['UUID']['input']>;
  customerToCustomerId?: InputMaybe<FkEmailCustomerCustomerIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  quoteId?: InputMaybe<Scalars['UUID']['input']>;
  quoteToQuoteId?: InputMaybe<FkEmailQuoteQuoteIdInput>;
  recipients?: InputMaybe<Scalars['String']['input']>;
  subject?: InputMaybe<Scalars['String']['input']>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkEmailTripTripIdInput>;
  userToUserId?: InputMaybe<FkEmailUserUserIdInput>;
};

/** Input for the nested mutation of `user` in the `EmailInput` mutation. */
export type FkEmailUserUserIdInput = {
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectById?: InputMaybe<UserPkUserConnect>;
  /** A `UserInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkEmailUserUserIdUserCreateInput>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteById?: InputMaybe<UserPkUserDelete>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateById?: InputMaybe<UserOnEmailForFkEmailUserUserIdUsingPkUserUpdate>;
};

/** Input for the nested mutation of `email` in the `UserInput` mutation. */
export type FkEmailUserUserIdInverseInput = {
  /** The primary key(s) for `email` for the far side of the relationship. */
  connectById?: InputMaybe<Array<EmailPkEmailConnect>>;
  /** A `EmailInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkEmailUserUserIdEmailCreateInput>>;
  /** The primary key(s) for `email` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<EmailPkEmailDelete>>;
  /** Flag indicating whether all other `email` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `email` for the far side of the relationship. */
  updateById?: InputMaybe<Array<EmailOnEmailForFkEmailUserUserIdUsingPkEmailUpdate>>;
};

/** The `user` to be created by this mutation. */
export type FkEmailUserUserIdUserCreateInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  emailsUsingId?: InputMaybe<FkEmailUserUserIdInverseInput>;
  externalId?: InputMaybe<Scalars['String']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  genderPreposition?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name: Scalars['String']['input'];
  notesUsingId?: InputMaybe<FkNoteUserUserIdInverseInput>;
  password?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  quotePublicsUsingId?: InputMaybe<FakePublicQuotePublicForeignKey2InverseInput>;
  quotesUsingId?: InputMaybe<FkQuoteUserUserIdInverseInput>;
  remindersUsingId?: InputMaybe<FkReminderUserUserIdInverseInput>;
  skype?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  transactionNotesUsingId?: InputMaybe<FkTransactionNoteUserUserIdInverseInput>;
  tripsUsingId?: InputMaybe<FkTripUserUserIdInverseInput>;
};

/** The `customer` to be created by this mutation. */
export type FkEnquiryCustomerCustomerIdCustomerCreateInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerTravellersUsingId?: InputMaybe<FkCustomerTravellerCustomerCustomerIdInverseInput>;
  email?: InputMaybe<Scalars['String']['input']>;
  emailsUsingId?: InputMaybe<FkEmailCustomerCustomerIdInverseInput>;
  enquiriesUsingId?: InputMaybe<FkEnquiryCustomerCustomerIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  tripsUsingId?: InputMaybe<FkTripCustomerCustomerIdInverseInput>;
};

/** The `enquiry` to be created by this mutation. */
export type FkEnquiryCustomerCustomerIdEnquiryCreateInput = {
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  comments?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerToCustomerId?: InputMaybe<FkEnquiryCustomerCustomerIdInput>;
  dates?: InputMaybe<Scalars['String']['input']>;
  destination?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  source?: InputMaybe<Scalars['String']['input']>;
  status: Scalars['Int']['input'];
  travellers?: InputMaybe<Scalars['String']['input']>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkEnquiryTripTripIdInput>;
};

/** Input for the nested mutation of `customer` in the `EnquiryInput` mutation. */
export type FkEnquiryCustomerCustomerIdInput = {
  /** The primary key(s) for `customer` for the far side of the relationship. */
  connectById?: InputMaybe<CustomerPkCustomerConnect>;
  /** A `CustomerInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkEnquiryCustomerCustomerIdCustomerCreateInput>;
  /** The primary key(s) for `customer` for the far side of the relationship. */
  deleteById?: InputMaybe<CustomerPkCustomerDelete>;
  /** The primary key(s) and patch data for `customer` for the far side of the relationship. */
  updateById?: InputMaybe<CustomerOnEnquiryForFkEnquiryCustomerCustomerIdUsingPkCustomerUpdate>;
};

/** Input for the nested mutation of `enquiry` in the `CustomerInput` mutation. */
export type FkEnquiryCustomerCustomerIdInverseInput = {
  /** The primary key(s) for `enquiry` for the far side of the relationship. */
  connectById?: InputMaybe<Array<EnquiryPkEnquiryConnect>>;
  /** A `EnquiryInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkEnquiryCustomerCustomerIdEnquiryCreateInput>>;
  /** The primary key(s) for `enquiry` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<EnquiryPkEnquiryDelete>>;
  /** Flag indicating whether all other `enquiry` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `enquiry` for the far side of the relationship. */
  updateById?: InputMaybe<Array<EnquiryOnEnquiryForFkEnquiryCustomerCustomerIdUsingPkEnquiryUpdate>>;
};

/** The `enquiry` to be created by this mutation. */
export type FkEnquiryTripTripIdEnquiryCreateInput = {
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  comments?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerId?: InputMaybe<Scalars['UUID']['input']>;
  customerToCustomerId?: InputMaybe<FkEnquiryCustomerCustomerIdInput>;
  dates?: InputMaybe<Scalars['String']['input']>;
  destination?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  source?: InputMaybe<Scalars['String']['input']>;
  status: Scalars['Int']['input'];
  travellers?: InputMaybe<Scalars['String']['input']>;
  tripToTripId?: InputMaybe<FkEnquiryTripTripIdInput>;
};

/** Input for the nested mutation of `trip` in the `EnquiryInput` mutation. */
export type FkEnquiryTripTripIdInput = {
  /** The primary key(s) for `trip` for the far side of the relationship. */
  connectById?: InputMaybe<TripPkTripConnect>;
  /** A `TripInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkEnquiryTripTripIdTripCreateInput>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  deleteById?: InputMaybe<TripPkTripDelete>;
  /** The primary key(s) and patch data for `trip` for the far side of the relationship. */
  updateById?: InputMaybe<TripOnEnquiryForFkEnquiryTripTripIdUsingPkTripUpdate>;
};

/** Input for the nested mutation of `enquiry` in the `TripInput` mutation. */
export type FkEnquiryTripTripIdInverseInput = {
  /** The primary key(s) for `enquiry` for the far side of the relationship. */
  connectById?: InputMaybe<Array<EnquiryPkEnquiryConnect>>;
  /** A `EnquiryInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkEnquiryTripTripIdEnquiryCreateInput>>;
  /** The primary key(s) for `enquiry` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<EnquiryPkEnquiryDelete>>;
  /** Flag indicating whether all other `enquiry` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `enquiry` for the far side of the relationship. */
  updateById?: InputMaybe<Array<EnquiryOnEnquiryForFkEnquiryTripTripIdUsingPkEnquiryUpdate>>;
};

/** The `trip` to be created by this mutation. */
export type FkEnquiryTripTripIdTripCreateInput = {
  activeQuoteId?: InputMaybe<Scalars['UUID']['input']>;
  agencyId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberToAgencyMemberId?: InputMaybe<FkTripAgencyMemberAgencyMemberIdInput>;
  agencyToAgencyId?: InputMaybe<FkTripAgencyAgencyIdInput>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerId?: InputMaybe<Scalars['UUID']['input']>;
  customerToCustomerId?: InputMaybe<FkTripCustomerCustomerIdInput>;
  dates?: InputMaybe<Scalars['String']['input']>;
  destination?: InputMaybe<Scalars['String']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  emailsUsingId?: InputMaybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: InputMaybe<FkEnquiryTripTripIdInverseInput>;
  expensesUsingId?: InputMaybe<FkExpenseTripTripIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceTripTripIdInverseInput>;
  mediaGalleryId?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryToMediaGalleryId?: InputMaybe<FkTripMediaGalleryMediaGalleryIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notesUsingId?: InputMaybe<FkNoteTripTripIdInverseInput>;
  paymentsUsingId?: InputMaybe<FkPaymentTripTripIdInverseInput>;
  quotePublicsUsingId?: InputMaybe<FakePublicQuotePublicForeignKey0InverseInput>;
  quoteToActiveQuoteId?: InputMaybe<FkTripQuoteActiveQuoteIdInput>;
  quotesUsingId?: InputMaybe<FkQuoteTripTripIdInverseInput>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceTripTripIdInverseInput>;
  testimonialsUsingId?: InputMaybe<FkTestimonialTripTripIdInverseInput>;
  tripFlightsUsingId?: InputMaybe<FkTripFlightTripTripIdInverseInput>;
  tripTravellersUsingId?: InputMaybe<FkTripTravellerTripTripIdInverseInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkTripUserUserIdInput>;
};

/** The `expense` to be created by this mutation. */
export type FkExpenseFinanceCategoryCategoryIdExpenseCreateInput = {
  amount: Scalars['BigFloat']['input'];
  amountActual: Scalars['BigFloat']['input'];
  created?: InputMaybe<Scalars['Datetime']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  financeCategoryToCategoryId?: InputMaybe<FkExpenseFinanceCategoryCategoryIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoiceId?: InputMaybe<Scalars['UUID']['input']>;
  invoiceToInvoiceId?: InputMaybe<FkExpenseInvoiceInvoiceIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  paid: Scalars['Datetime']['input'];
  reference?: InputMaybe<Scalars['String']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierId?: InputMaybe<Scalars['UUID']['input']>;
  supplierInvoiceId?: InputMaybe<Scalars['UUID']['input']>;
  supplierInvoiceToSupplierInvoiceId?: InputMaybe<FkExpenseSupplierInvoiceSupplierInvoiceIdInput>;
  supplierToSupplierId?: InputMaybe<FkExpenseSupplierSupplierIdInput>;
  transactionLinksUsingId?: InputMaybe<FkTransactionLinkExpenseExpenseIdInverseInput>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkExpenseTripTripIdInput>;
};

/** The `financeCategory` to be created by this mutation. */
export type FkExpenseFinanceCategoryCategoryIdFinanceCategoryCreateInput = {
  code?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  expensesUsingId?: InputMaybe<FkExpenseFinanceCategoryCategoryIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceFinanceCategoryCategoryIdInverseInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  paymentsUsingId?: InputMaybe<FkPaymentFinanceCategoryCategoryIdInverseInput>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceFinanceCategoryCategoryIdInverseInput>;
  transactionsUsingId?: InputMaybe<FkTransactionFinanceCategoryCategoryIdInverseInput>;
  type?: InputMaybe<Scalars['Int']['input']>;
};

/** Input for the nested mutation of `financeCategory` in the `ExpenseInput` mutation. */
export type FkExpenseFinanceCategoryCategoryIdInput = {
  /** The primary key(s) for `financeCategory` for the far side of the relationship. */
  connectById?: InputMaybe<FinanceCategoryPkFinanceCategoryConnect>;
  /** A `FinanceCategoryInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkExpenseFinanceCategoryCategoryIdFinanceCategoryCreateInput>;
  /** The primary key(s) for `financeCategory` for the far side of the relationship. */
  deleteById?: InputMaybe<FinanceCategoryPkFinanceCategoryDelete>;
  /** The primary key(s) and patch data for `financeCategory` for the far side of the relationship. */
  updateById?: InputMaybe<FinanceCategoryOnExpenseForFkExpenseFinanceCategoryCategoryIdUsingPkFinanceCategoryUpdate>;
};

/** Input for the nested mutation of `expense` in the `FinanceCategoryInput` mutation. */
export type FkExpenseFinanceCategoryCategoryIdInverseInput = {
  /** The primary key(s) for `expense` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ExpensePkExpenseConnect>>;
  /** A `ExpenseInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkExpenseFinanceCategoryCategoryIdExpenseCreateInput>>;
  /** The primary key(s) for `expense` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ExpensePkExpenseDelete>>;
  /** Flag indicating whether all other `expense` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `expense` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ExpenseOnExpenseForFkExpenseFinanceCategoryCategoryIdUsingPkExpenseUpdate>>;
};

/** The `expense` to be created by this mutation. */
export type FkExpenseInvoiceInvoiceIdExpenseCreateInput = {
  amount: Scalars['BigFloat']['input'];
  amountActual: Scalars['BigFloat']['input'];
  categoryId?: InputMaybe<Scalars['UUID']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  financeCategoryToCategoryId?: InputMaybe<FkExpenseFinanceCategoryCategoryIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoiceToInvoiceId?: InputMaybe<FkExpenseInvoiceInvoiceIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  paid: Scalars['Datetime']['input'];
  reference?: InputMaybe<Scalars['String']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierId?: InputMaybe<Scalars['UUID']['input']>;
  supplierInvoiceId?: InputMaybe<Scalars['UUID']['input']>;
  supplierInvoiceToSupplierInvoiceId?: InputMaybe<FkExpenseSupplierInvoiceSupplierInvoiceIdInput>;
  supplierToSupplierId?: InputMaybe<FkExpenseSupplierSupplierIdInput>;
  transactionLinksUsingId?: InputMaybe<FkTransactionLinkExpenseExpenseIdInverseInput>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkExpenseTripTripIdInput>;
};

/** Input for the nested mutation of `invoice` in the `ExpenseInput` mutation. */
export type FkExpenseInvoiceInvoiceIdInput = {
  /** The primary key(s) for `invoice` for the far side of the relationship. */
  connectById?: InputMaybe<InvoicePkInvoiceConnect>;
  /** A `InvoiceInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkExpenseInvoiceInvoiceIdInvoiceCreateInput>;
  /** The primary key(s) for `invoice` for the far side of the relationship. */
  deleteById?: InputMaybe<InvoicePkInvoiceDelete>;
  /** The primary key(s) and patch data for `invoice` for the far side of the relationship. */
  updateById?: InputMaybe<InvoiceOnExpenseForFkExpenseInvoiceInvoiceIdUsingPkInvoiceUpdate>;
};

/** Input for the nested mutation of `expense` in the `InvoiceInput` mutation. */
export type FkExpenseInvoiceInvoiceIdInverseInput = {
  /** The primary key(s) for `expense` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ExpensePkExpenseConnect>>;
  /** A `ExpenseInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkExpenseInvoiceInvoiceIdExpenseCreateInput>>;
  /** The primary key(s) for `expense` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ExpensePkExpenseDelete>>;
  /** Flag indicating whether all other `expense` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `expense` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ExpenseOnExpenseForFkExpenseInvoiceInvoiceIdUsingPkExpenseUpdate>>;
};

/** The `invoice` to be created by this mutation. */
export type FkExpenseInvoiceInvoiceIdInvoiceCreateInput = {
  amount: Scalars['BigFloat']['input'];
  categoryId?: InputMaybe<Scalars['UUID']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  due: Scalars['Datetime']['input'];
  expensesUsingId?: InputMaybe<FkExpenseInvoiceInvoiceIdInverseInput>;
  financeCategoryToCategoryId?: InputMaybe<FkInvoiceFinanceCategoryCategoryIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoiced?: InputMaybe<Scalars['Datetime']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  locked?: InputMaybe<Scalars['Datetime']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  note?: InputMaybe<Scalars['String']['input']>;
  number?: InputMaybe<Scalars['Int']['input']>;
  paid?: InputMaybe<Scalars['Datetime']['input']>;
  paymentsUsingId?: InputMaybe<FkPaymentInvoiceInvoiceIdInverseInput>;
  quoteId?: InputMaybe<Scalars['UUID']['input']>;
  quoteToQuoteId?: InputMaybe<FkInvoiceQuoteQuoteIdInput>;
  summary?: InputMaybe<Scalars['String']['input']>;
  transactionLinksUsingId?: InputMaybe<FkTransactionLinkInvoiceInvoiceIdInverseInput>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkInvoiceTripTripIdInput>;
  type?: InputMaybe<Scalars['String']['input']>;
  voided?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The `expense` to be created by this mutation. */
export type FkExpenseSupplierInvoiceSupplierInvoiceIdExpenseCreateInput = {
  amount: Scalars['BigFloat']['input'];
  amountActual: Scalars['BigFloat']['input'];
  categoryId?: InputMaybe<Scalars['UUID']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  financeCategoryToCategoryId?: InputMaybe<FkExpenseFinanceCategoryCategoryIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoiceId?: InputMaybe<Scalars['UUID']['input']>;
  invoiceToInvoiceId?: InputMaybe<FkExpenseInvoiceInvoiceIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  paid: Scalars['Datetime']['input'];
  reference?: InputMaybe<Scalars['String']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierId?: InputMaybe<Scalars['UUID']['input']>;
  supplierInvoiceToSupplierInvoiceId?: InputMaybe<FkExpenseSupplierInvoiceSupplierInvoiceIdInput>;
  supplierToSupplierId?: InputMaybe<FkExpenseSupplierSupplierIdInput>;
  transactionLinksUsingId?: InputMaybe<FkTransactionLinkExpenseExpenseIdInverseInput>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkExpenseTripTripIdInput>;
};

/** Input for the nested mutation of `supplierInvoice` in the `ExpenseInput` mutation. */
export type FkExpenseSupplierInvoiceSupplierInvoiceIdInput = {
  /** The primary key(s) for `supplierInvoice` for the far side of the relationship. */
  connectById?: InputMaybe<SupplierInvoicePkSupplierInvoiceConnect>;
  /** A `SupplierInvoiceInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkExpenseSupplierInvoiceSupplierInvoiceIdSupplierInvoiceCreateInput>;
  /** The primary key(s) for `supplierInvoice` for the far side of the relationship. */
  deleteById?: InputMaybe<SupplierInvoicePkSupplierInvoiceDelete>;
  /** The primary key(s) and patch data for `supplierInvoice` for the far side of the relationship. */
  updateById?: InputMaybe<SupplierInvoiceOnExpenseForFkExpenseSupplierInvoiceSupplierInvoiceIdUsingPkSupplierInvoiceUpdate>;
};

/** Input for the nested mutation of `expense` in the `SupplierInvoiceInput` mutation. */
export type FkExpenseSupplierInvoiceSupplierInvoiceIdInverseInput = {
  /** The primary key(s) for `expense` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ExpensePkExpenseConnect>>;
  /** A `ExpenseInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkExpenseSupplierInvoiceSupplierInvoiceIdExpenseCreateInput>>;
  /** The primary key(s) for `expense` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ExpensePkExpenseDelete>>;
  /** Flag indicating whether all other `expense` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `expense` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ExpenseOnExpenseForFkExpenseSupplierInvoiceSupplierInvoiceIdUsingPkExpenseUpdate>>;
};

/** The `supplierInvoice` to be created by this mutation. */
export type FkExpenseSupplierInvoiceSupplierInvoiceIdSupplierInvoiceCreateInput = {
  amount: Scalars['BigFloat']['input'];
  amountActual?: InputMaybe<Scalars['BigFloat']['input']>;
  categoryId?: InputMaybe<Scalars['UUID']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  due: Scalars['Datetime']['input'];
  expensesUsingId?: InputMaybe<FkExpenseSupplierInvoiceSupplierInvoiceIdInverseInput>;
  financeCategoryToCategoryId?: InputMaybe<FkSupplierInvoiceFinanceCategoryCategoryIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  mediaItemId?: InputMaybe<Scalars['UUID']['input']>;
  mediaItemToMediaItemId?: InputMaybe<FkSupplierInvoiceMediaItemMediaItemIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  number?: InputMaybe<Scalars['Int']['input']>;
  paid?: InputMaybe<Scalars['Datetime']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierId?: InputMaybe<Scalars['UUID']['input']>;
  supplierToSupplierId?: InputMaybe<FkSupplierInvoiceSupplierSupplierIdInput>;
  transactionLinksUsingId?: InputMaybe<FkTransactionLinkSupplierInvoiceSupplierInvoiceIdInverseInput>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkSupplierInvoiceTripTripIdInput>;
  type?: InputMaybe<Scalars['String']['input']>;
  voided?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The `expense` to be created by this mutation. */
export type FkExpenseSupplierSupplierIdExpenseCreateInput = {
  amount: Scalars['BigFloat']['input'];
  amountActual: Scalars['BigFloat']['input'];
  categoryId?: InputMaybe<Scalars['UUID']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  financeCategoryToCategoryId?: InputMaybe<FkExpenseFinanceCategoryCategoryIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoiceId?: InputMaybe<Scalars['UUID']['input']>;
  invoiceToInvoiceId?: InputMaybe<FkExpenseInvoiceInvoiceIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  paid: Scalars['Datetime']['input'];
  reference?: InputMaybe<Scalars['String']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierInvoiceId?: InputMaybe<Scalars['UUID']['input']>;
  supplierInvoiceToSupplierInvoiceId?: InputMaybe<FkExpenseSupplierInvoiceSupplierInvoiceIdInput>;
  supplierToSupplierId?: InputMaybe<FkExpenseSupplierSupplierIdInput>;
  transactionLinksUsingId?: InputMaybe<FkTransactionLinkExpenseExpenseIdInverseInput>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkExpenseTripTripIdInput>;
};

/** Input for the nested mutation of `supplier` in the `ExpenseInput` mutation. */
export type FkExpenseSupplierSupplierIdInput = {
  /** The primary key(s) for `supplier` for the far side of the relationship. */
  connectById?: InputMaybe<SupplierPkSupplierConnect>;
  /** A `SupplierInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkExpenseSupplierSupplierIdSupplierCreateInput>;
  /** The primary key(s) for `supplier` for the far side of the relationship. */
  deleteById?: InputMaybe<SupplierPkSupplierDelete>;
  /** The primary key(s) and patch data for `supplier` for the far side of the relationship. */
  updateById?: InputMaybe<SupplierOnExpenseForFkExpenseSupplierSupplierIdUsingPkSupplierUpdate>;
};

/** Input for the nested mutation of `expense` in the `SupplierInput` mutation. */
export type FkExpenseSupplierSupplierIdInverseInput = {
  /** The primary key(s) for `expense` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ExpensePkExpenseConnect>>;
  /** A `ExpenseInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkExpenseSupplierSupplierIdExpenseCreateInput>>;
  /** The primary key(s) for `expense` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ExpensePkExpenseDelete>>;
  /** Flag indicating whether all other `expense` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `expense` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ExpenseOnExpenseForFkExpenseSupplierSupplierIdUsingPkExpenseUpdate>>;
};

/** The `supplier` to be created by this mutation. */
export type FkExpenseSupplierSupplierIdSupplierCreateInput = {
  agenciesUsingId?: InputMaybe<FkAgencySupplierInverseInput>;
  bankDetails?: InputMaybe<Scalars['String']['input']>;
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  contactNumber?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  expensesUsingId?: InputMaybe<FkExpenseSupplierSupplierIdInverseInput>;
  galleryId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryToGalleryId?: InputMaybe<FkSupplierMediaGalleryGalleryIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  quoteFinanceLineItemsUsingId?: InputMaybe<FkQuoteFinanceLineItemSupplierSupplierIdInverseInput>;
  region?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceSupplierSupplierIdInverseInput>;
  url?: InputMaybe<Scalars['String']['input']>;
};

/** The `expense` to be created by this mutation. */
export type FkExpenseTripTripIdExpenseCreateInput = {
  amount: Scalars['BigFloat']['input'];
  amountActual: Scalars['BigFloat']['input'];
  categoryId?: InputMaybe<Scalars['UUID']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  financeCategoryToCategoryId?: InputMaybe<FkExpenseFinanceCategoryCategoryIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoiceId?: InputMaybe<Scalars['UUID']['input']>;
  invoiceToInvoiceId?: InputMaybe<FkExpenseInvoiceInvoiceIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  paid: Scalars['Datetime']['input'];
  reference?: InputMaybe<Scalars['String']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierId?: InputMaybe<Scalars['UUID']['input']>;
  supplierInvoiceId?: InputMaybe<Scalars['UUID']['input']>;
  supplierInvoiceToSupplierInvoiceId?: InputMaybe<FkExpenseSupplierInvoiceSupplierInvoiceIdInput>;
  supplierToSupplierId?: InputMaybe<FkExpenseSupplierSupplierIdInput>;
  transactionLinksUsingId?: InputMaybe<FkTransactionLinkExpenseExpenseIdInverseInput>;
  tripToTripId?: InputMaybe<FkExpenseTripTripIdInput>;
};

/** Input for the nested mutation of `trip` in the `ExpenseInput` mutation. */
export type FkExpenseTripTripIdInput = {
  /** The primary key(s) for `trip` for the far side of the relationship. */
  connectById?: InputMaybe<TripPkTripConnect>;
  /** A `TripInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkExpenseTripTripIdTripCreateInput>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  deleteById?: InputMaybe<TripPkTripDelete>;
  /** The primary key(s) and patch data for `trip` for the far side of the relationship. */
  updateById?: InputMaybe<TripOnExpenseForFkExpenseTripTripIdUsingPkTripUpdate>;
};

/** Input for the nested mutation of `expense` in the `TripInput` mutation. */
export type FkExpenseTripTripIdInverseInput = {
  /** The primary key(s) for `expense` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ExpensePkExpenseConnect>>;
  /** A `ExpenseInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkExpenseTripTripIdExpenseCreateInput>>;
  /** The primary key(s) for `expense` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ExpensePkExpenseDelete>>;
  /** Flag indicating whether all other `expense` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `expense` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ExpenseOnExpenseForFkExpenseTripTripIdUsingPkExpenseUpdate>>;
};

/** The `trip` to be created by this mutation. */
export type FkExpenseTripTripIdTripCreateInput = {
  activeQuoteId?: InputMaybe<Scalars['UUID']['input']>;
  agencyId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberToAgencyMemberId?: InputMaybe<FkTripAgencyMemberAgencyMemberIdInput>;
  agencyToAgencyId?: InputMaybe<FkTripAgencyAgencyIdInput>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerId?: InputMaybe<Scalars['UUID']['input']>;
  customerToCustomerId?: InputMaybe<FkTripCustomerCustomerIdInput>;
  dates?: InputMaybe<Scalars['String']['input']>;
  destination?: InputMaybe<Scalars['String']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  emailsUsingId?: InputMaybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: InputMaybe<FkEnquiryTripTripIdInverseInput>;
  expensesUsingId?: InputMaybe<FkExpenseTripTripIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceTripTripIdInverseInput>;
  mediaGalleryId?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryToMediaGalleryId?: InputMaybe<FkTripMediaGalleryMediaGalleryIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notesUsingId?: InputMaybe<FkNoteTripTripIdInverseInput>;
  paymentsUsingId?: InputMaybe<FkPaymentTripTripIdInverseInput>;
  quotePublicsUsingId?: InputMaybe<FakePublicQuotePublicForeignKey0InverseInput>;
  quoteToActiveQuoteId?: InputMaybe<FkTripQuoteActiveQuoteIdInput>;
  quotesUsingId?: InputMaybe<FkQuoteTripTripIdInverseInput>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceTripTripIdInverseInput>;
  testimonialsUsingId?: InputMaybe<FkTestimonialTripTripIdInverseInput>;
  tripFlightsUsingId?: InputMaybe<FkTripFlightTripTripIdInverseInput>;
  tripTravellersUsingId?: InputMaybe<FkTripTravellerTripTripIdInverseInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkTripUserUserIdInput>;
};

/** The `feature` to be created by this mutation. */
export type FkFeatureMediaGalleryGalleryIdFeatureCreateInput = {
  body?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryToGalleryId?: InputMaybe<FkFeatureMediaGalleryGalleryIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** Input for the nested mutation of `mediaGallery` in the `FeatureInput` mutation. */
export type FkFeatureMediaGalleryGalleryIdInput = {
  /** The primary key(s) for `mediaGallery` for the far side of the relationship. */
  connectById?: InputMaybe<MediaGalleryPkMediaGalleryConnect>;
  /** A `MediaGalleryInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkFeatureMediaGalleryGalleryIdMediaGalleryCreateInput>;
  /** The primary key(s) for `mediaGallery` for the far side of the relationship. */
  deleteById?: InputMaybe<MediaGalleryPkMediaGalleryDelete>;
  /** The primary key(s) and patch data for `mediaGallery` for the far side of the relationship. */
  updateById?: InputMaybe<MediaGalleryOnFeatureForFkFeatureMediaGalleryGalleryIdUsingPkMediaGalleryUpdate>;
};

/** Input for the nested mutation of `feature` in the `MediaGalleryInput` mutation. */
export type FkFeatureMediaGalleryGalleryIdInverseInput = {
  /** The primary key(s) for `feature` for the far side of the relationship. */
  connectById?: InputMaybe<Array<FeaturePkFeatureConnect>>;
  /** A `FeatureInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkFeatureMediaGalleryGalleryIdFeatureCreateInput>>;
  /** The primary key(s) for `feature` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<FeaturePkFeatureDelete>>;
  /** Flag indicating whether all other `feature` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `feature` for the far side of the relationship. */
  updateById?: InputMaybe<Array<FeatureOnFeatureForFkFeatureMediaGalleryGalleryIdUsingPkFeatureUpdate>>;
};

/** The `mediaGallery` to be created by this mutation. */
export type FkFeatureMediaGalleryGalleryIdMediaGalleryCreateInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationFeaturesUsingId?: InputMaybe<FkDestinationFeatureMediaGalleryGalleryIdInverseInput>;
  destinationsUsingId?: InputMaybe<FkDestinationMediaGalleryGalleryIdInverseInput>;
  featuresUsingId?: InputMaybe<FkFeatureMediaGalleryGalleryIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  isProtected?: InputMaybe<Scalars['Boolean']['input']>;
  mediaGalleryItemsUsingId?: InputMaybe<FkMediaGalleryItemMediaGalleryMediaGalleryIdInverseInput>;
  mediaGalleryToParentId?: InputMaybe<FkMediaGalleryMediaGalleryParentIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  parentId?: InputMaybe<Scalars['UUID']['input']>;
  propertiesUsingId?: InputMaybe<FkPropertyMediaGalleryGalleryIdInverseInput>;
  suppliersUsingId?: InputMaybe<FkSupplierMediaGalleryGalleryIdInverseInput>;
  tripsUsingId?: InputMaybe<FkTripMediaGalleryMediaGalleryIdInverseInput>;
};

/** The `financeCategory` to be created by this mutation. */
export type FkInvoiceFinanceCategoryCategoryIdFinanceCategoryCreateInput = {
  code?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  expensesUsingId?: InputMaybe<FkExpenseFinanceCategoryCategoryIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceFinanceCategoryCategoryIdInverseInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  paymentsUsingId?: InputMaybe<FkPaymentFinanceCategoryCategoryIdInverseInput>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceFinanceCategoryCategoryIdInverseInput>;
  transactionsUsingId?: InputMaybe<FkTransactionFinanceCategoryCategoryIdInverseInput>;
  type?: InputMaybe<Scalars['Int']['input']>;
};

/** Input for the nested mutation of `financeCategory` in the `InvoiceInput` mutation. */
export type FkInvoiceFinanceCategoryCategoryIdInput = {
  /** The primary key(s) for `financeCategory` for the far side of the relationship. */
  connectById?: InputMaybe<FinanceCategoryPkFinanceCategoryConnect>;
  /** A `FinanceCategoryInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkInvoiceFinanceCategoryCategoryIdFinanceCategoryCreateInput>;
  /** The primary key(s) for `financeCategory` for the far side of the relationship. */
  deleteById?: InputMaybe<FinanceCategoryPkFinanceCategoryDelete>;
  /** The primary key(s) and patch data for `financeCategory` for the far side of the relationship. */
  updateById?: InputMaybe<FinanceCategoryOnInvoiceForFkInvoiceFinanceCategoryCategoryIdUsingPkFinanceCategoryUpdate>;
};

/** Input for the nested mutation of `invoice` in the `FinanceCategoryInput` mutation. */
export type FkInvoiceFinanceCategoryCategoryIdInverseInput = {
  /** The primary key(s) for `invoice` for the far side of the relationship. */
  connectById?: InputMaybe<Array<InvoicePkInvoiceConnect>>;
  /** A `InvoiceInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkInvoiceFinanceCategoryCategoryIdInvoiceCreateInput>>;
  /** The primary key(s) for `invoice` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<InvoicePkInvoiceDelete>>;
  /** Flag indicating whether all other `invoice` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `invoice` for the far side of the relationship. */
  updateById?: InputMaybe<Array<InvoiceOnInvoiceForFkInvoiceFinanceCategoryCategoryIdUsingPkInvoiceUpdate>>;
};

/** The `invoice` to be created by this mutation. */
export type FkInvoiceFinanceCategoryCategoryIdInvoiceCreateInput = {
  amount: Scalars['BigFloat']['input'];
  created?: InputMaybe<Scalars['Datetime']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  due: Scalars['Datetime']['input'];
  expensesUsingId?: InputMaybe<FkExpenseInvoiceInvoiceIdInverseInput>;
  financeCategoryToCategoryId?: InputMaybe<FkInvoiceFinanceCategoryCategoryIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoiced?: InputMaybe<Scalars['Datetime']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  locked?: InputMaybe<Scalars['Datetime']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  note?: InputMaybe<Scalars['String']['input']>;
  number?: InputMaybe<Scalars['Int']['input']>;
  paid?: InputMaybe<Scalars['Datetime']['input']>;
  paymentsUsingId?: InputMaybe<FkPaymentInvoiceInvoiceIdInverseInput>;
  quoteId?: InputMaybe<Scalars['UUID']['input']>;
  quoteToQuoteId?: InputMaybe<FkInvoiceQuoteQuoteIdInput>;
  summary?: InputMaybe<Scalars['String']['input']>;
  transactionLinksUsingId?: InputMaybe<FkTransactionLinkInvoiceInvoiceIdInverseInput>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkInvoiceTripTripIdInput>;
  type?: InputMaybe<Scalars['String']['input']>;
  voided?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Input for the nested mutation of `quote` in the `InvoiceInput` mutation. */
export type FkInvoiceQuoteQuoteIdInput = {
  /** The primary key(s) for `quote` for the far side of the relationship. */
  connectById?: InputMaybe<QuotePkQuoteConnect>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  connectByKey?: InputMaybe<QuoteUqQuoteKeyConnect>;
  /** A `QuoteInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkInvoiceQuoteQuoteIdQuoteCreateInput>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  deleteById?: InputMaybe<QuotePkQuoteDelete>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  deleteByKey?: InputMaybe<QuoteUqQuoteKeyDelete>;
  /** The primary key(s) and patch data for `quote` for the far side of the relationship. */
  updateById?: InputMaybe<QuoteOnInvoiceForFkInvoiceQuoteQuoteIdUsingPkQuoteUpdate>;
  /** The primary key(s) and patch data for `quote` for the far side of the relationship. */
  updateByKey?: InputMaybe<QuoteOnInvoiceForFkInvoiceQuoteQuoteIdUsingUqQuoteKeyUpdate>;
};

/** Input for the nested mutation of `invoice` in the `QuoteInput` mutation. */
export type FkInvoiceQuoteQuoteIdInverseInput = {
  /** The primary key(s) for `invoice` for the far side of the relationship. */
  connectById?: InputMaybe<Array<InvoicePkInvoiceConnect>>;
  /** A `InvoiceInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkInvoiceQuoteQuoteIdInvoiceCreateInput>>;
  /** The primary key(s) for `invoice` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<InvoicePkInvoiceDelete>>;
  /** Flag indicating whether all other `invoice` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `invoice` for the far side of the relationship. */
  updateById?: InputMaybe<Array<InvoiceOnInvoiceForFkInvoiceQuoteQuoteIdUsingPkInvoiceUpdate>>;
};

/** The `invoice` to be created by this mutation. */
export type FkInvoiceQuoteQuoteIdInvoiceCreateInput = {
  amount: Scalars['BigFloat']['input'];
  categoryId?: InputMaybe<Scalars['UUID']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  due: Scalars['Datetime']['input'];
  expensesUsingId?: InputMaybe<FkExpenseInvoiceInvoiceIdInverseInput>;
  financeCategoryToCategoryId?: InputMaybe<FkInvoiceFinanceCategoryCategoryIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoiced?: InputMaybe<Scalars['Datetime']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  locked?: InputMaybe<Scalars['Datetime']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  note?: InputMaybe<Scalars['String']['input']>;
  number?: InputMaybe<Scalars['Int']['input']>;
  paid?: InputMaybe<Scalars['Datetime']['input']>;
  paymentsUsingId?: InputMaybe<FkPaymentInvoiceInvoiceIdInverseInput>;
  quoteToQuoteId?: InputMaybe<FkInvoiceQuoteQuoteIdInput>;
  summary?: InputMaybe<Scalars['String']['input']>;
  transactionLinksUsingId?: InputMaybe<FkTransactionLinkInvoiceInvoiceIdInverseInput>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkInvoiceTripTripIdInput>;
  type?: InputMaybe<Scalars['String']['input']>;
  voided?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The `quote` to be created by this mutation. */
export type FkInvoiceQuoteQuoteIdQuoteCreateInput = {
  adjustment?: InputMaybe<Scalars['BigFloat']['input']>;
  agentMargin?: InputMaybe<Scalars['BigFloat']['input']>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  deposit?: InputMaybe<Scalars['BigFloat']['input']>;
  duration: Scalars['Int']['input'];
  emailsUsingId?: InputMaybe<FkEmailQuoteQuoteIdInverseInput>;
  exclusions?: InputMaybe<Scalars['String']['input']>;
  expires?: InputMaybe<Scalars['Datetime']['input']>;
  heroId?: InputMaybe<Scalars['UUID']['input']>;
  heroImageId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  inclusions?: InputMaybe<Scalars['String']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceQuoteQuoteIdInverseInput>;
  key?: InputMaybe<Scalars['String']['input']>;
  locked?: InputMaybe<Scalars['Datetime']['input']>;
  margin?: InputMaybe<Scalars['BigFloat']['input']>;
  mediaItemToHeroImageId?: InputMaybe<FkQuoteMediaItemHeroImageIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  quoteAcceptancesUsingId?: InputMaybe<FkQuoteAcceptanceQuoteInverseInput>;
  quoteAccommodationDetailsUsingId?: InputMaybe<FkQuoteAccommodationDetailQuoteQuoteIdInverseInput>;
  quoteCurrenciesUsingId?: InputMaybe<FkQuoteCurrencyQuoteQuoteIdInverseInput>;
  quoteDaysUsingId?: InputMaybe<FkQuoteDayQuoteQuoteIdInverseInput>;
  quoteFinanceLineItemsUsingId?: InputMaybe<FkQuoteFinanceLineItemQuoteQuoteIdInverseInput>;
  quoteHeroToHeroId?: InputMaybe<FkQuoteQuoteHeroHeroIdInput>;
  quoteLegalDocumentsUsingId?: InputMaybe<FkQuoteLegalDocumentQuoteInverseInput>;
  quoteStatusToStatus?: InputMaybe<FkQuoteStatusInput>;
  quoteViewsUsingId?: InputMaybe<FkQuoteViewQuoteQuoteIdInverseInput>;
  shortDescription?: InputMaybe<Scalars['String']['input']>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  travellerCount?: InputMaybe<Scalars['Int']['input']>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkQuoteTripTripIdInput>;
  tripsUsingId?: InputMaybe<FkTripQuoteActiveQuoteIdInverseInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkQuoteUserUserIdInput>;
};

/** Input for the nested mutation of `trip` in the `InvoiceInput` mutation. */
export type FkInvoiceTripTripIdInput = {
  /** The primary key(s) for `trip` for the far side of the relationship. */
  connectById?: InputMaybe<TripPkTripConnect>;
  /** A `TripInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkInvoiceTripTripIdTripCreateInput>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  deleteById?: InputMaybe<TripPkTripDelete>;
  /** The primary key(s) and patch data for `trip` for the far side of the relationship. */
  updateById?: InputMaybe<TripOnInvoiceForFkInvoiceTripTripIdUsingPkTripUpdate>;
};

/** Input for the nested mutation of `invoice` in the `TripInput` mutation. */
export type FkInvoiceTripTripIdInverseInput = {
  /** The primary key(s) for `invoice` for the far side of the relationship. */
  connectById?: InputMaybe<Array<InvoicePkInvoiceConnect>>;
  /** A `InvoiceInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkInvoiceTripTripIdInvoiceCreateInput>>;
  /** The primary key(s) for `invoice` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<InvoicePkInvoiceDelete>>;
  /** Flag indicating whether all other `invoice` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `invoice` for the far side of the relationship. */
  updateById?: InputMaybe<Array<InvoiceOnInvoiceForFkInvoiceTripTripIdUsingPkInvoiceUpdate>>;
};

/** The `invoice` to be created by this mutation. */
export type FkInvoiceTripTripIdInvoiceCreateInput = {
  amount: Scalars['BigFloat']['input'];
  categoryId?: InputMaybe<Scalars['UUID']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  due: Scalars['Datetime']['input'];
  expensesUsingId?: InputMaybe<FkExpenseInvoiceInvoiceIdInverseInput>;
  financeCategoryToCategoryId?: InputMaybe<FkInvoiceFinanceCategoryCategoryIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoiced?: InputMaybe<Scalars['Datetime']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  locked?: InputMaybe<Scalars['Datetime']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  note?: InputMaybe<Scalars['String']['input']>;
  number?: InputMaybe<Scalars['Int']['input']>;
  paid?: InputMaybe<Scalars['Datetime']['input']>;
  paymentsUsingId?: InputMaybe<FkPaymentInvoiceInvoiceIdInverseInput>;
  quoteId?: InputMaybe<Scalars['UUID']['input']>;
  quoteToQuoteId?: InputMaybe<FkInvoiceQuoteQuoteIdInput>;
  summary?: InputMaybe<Scalars['String']['input']>;
  transactionLinksUsingId?: InputMaybe<FkTransactionLinkInvoiceInvoiceIdInverseInput>;
  tripToTripId?: InputMaybe<FkInvoiceTripTripIdInput>;
  type?: InputMaybe<Scalars['String']['input']>;
  voided?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The `trip` to be created by this mutation. */
export type FkInvoiceTripTripIdTripCreateInput = {
  activeQuoteId?: InputMaybe<Scalars['UUID']['input']>;
  agencyId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberToAgencyMemberId?: InputMaybe<FkTripAgencyMemberAgencyMemberIdInput>;
  agencyToAgencyId?: InputMaybe<FkTripAgencyAgencyIdInput>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerId?: InputMaybe<Scalars['UUID']['input']>;
  customerToCustomerId?: InputMaybe<FkTripCustomerCustomerIdInput>;
  dates?: InputMaybe<Scalars['String']['input']>;
  destination?: InputMaybe<Scalars['String']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  emailsUsingId?: InputMaybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: InputMaybe<FkEnquiryTripTripIdInverseInput>;
  expensesUsingId?: InputMaybe<FkExpenseTripTripIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceTripTripIdInverseInput>;
  mediaGalleryId?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryToMediaGalleryId?: InputMaybe<FkTripMediaGalleryMediaGalleryIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notesUsingId?: InputMaybe<FkNoteTripTripIdInverseInput>;
  paymentsUsingId?: InputMaybe<FkPaymentTripTripIdInverseInput>;
  quotePublicsUsingId?: InputMaybe<FakePublicQuotePublicForeignKey0InverseInput>;
  quoteToActiveQuoteId?: InputMaybe<FkTripQuoteActiveQuoteIdInput>;
  quotesUsingId?: InputMaybe<FkQuoteTripTripIdInverseInput>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceTripTripIdInverseInput>;
  testimonialsUsingId?: InputMaybe<FkTestimonialTripTripIdInverseInput>;
  tripFlightsUsingId?: InputMaybe<FkTripFlightTripTripIdInverseInput>;
  tripTravellersUsingId?: InputMaybe<FkTripTravellerTripTripIdInverseInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkTripUserUserIdInput>;
};

/** Input for the nested mutation of `legalFolder` in the `LegalDocumentInput` mutation. */
export type FkLegalDocumentFolderInput = {
  /** The primary key(s) for `legalFolder` for the far side of the relationship. */
  connectById?: InputMaybe<LegalFolderPkLegalFolderConnect>;
  /** A `LegalFolderInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkLegalDocumentFolderLegalFolderCreateInput>;
  /** The primary key(s) for `legalFolder` for the far side of the relationship. */
  deleteById?: InputMaybe<LegalFolderPkLegalFolderDelete>;
  /** The primary key(s) and patch data for `legalFolder` for the far side of the relationship. */
  updateById?: InputMaybe<LegalFolderOnLegalDocumentForFkLegalDocumentFolderUsingPkLegalFolderUpdate>;
};

/** Input for the nested mutation of `legalDocument` in the `LegalFolderInput` mutation. */
export type FkLegalDocumentFolderInverseInput = {
  /** The primary key(s) for `legalDocument` for the far side of the relationship. */
  connectById?: InputMaybe<Array<LegalDocumentPkLegalDocumentConnect>>;
  /** A `LegalDocumentInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkLegalDocumentFolderLegalDocumentCreateInput>>;
  /** The primary key(s) for `legalDocument` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<LegalDocumentPkLegalDocumentDelete>>;
  /** Flag indicating whether all other `legalDocument` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `legalDocument` for the far side of the relationship. */
  updateById?: InputMaybe<Array<LegalDocumentOnLegalDocumentForFkLegalDocumentFolderUsingPkLegalDocumentUpdate>>;
};

/** The `legalDocument` to be created by this mutation. */
export type FkLegalDocumentFolderLegalDocumentCreateInput = {
  body: Scalars['String']['input'];
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  legalFolderToFolderId?: InputMaybe<FkLegalDocumentFolderInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name: Scalars['String']['input'];
  quoteLegalDocumentsUsingId?: InputMaybe<FkQuoteLegalDocumentLegalDocumentInverseInput>;
  validFrom?: InputMaybe<Scalars['Datetime']['input']>;
  validTo?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The `legalFolder` to be created by this mutation. */
export type FkLegalDocumentFolderLegalFolderCreateInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  legalDocumentsUsingId?: InputMaybe<FkLegalDocumentFolderInverseInput>;
  legalFolderToParentId?: InputMaybe<FkLegalFolderParentInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name: Scalars['String']['input'];
  parentId?: InputMaybe<Scalars['UUID']['input']>;
};

/** Input for the nested mutation of `legalFolder` in the `LegalFolderInput` mutation. */
export type FkLegalFolderParentInput = {
  /** The primary key(s) for `legalFolder` for the far side of the relationship. */
  connectById?: InputMaybe<LegalFolderPkLegalFolderConnect>;
  /** A `LegalFolderInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkLegalFolderParentLegalFolderCreateInput>;
  /** The primary key(s) for `legalFolder` for the far side of the relationship. */
  deleteById?: InputMaybe<LegalFolderPkLegalFolderDelete>;
  /** The primary key(s) and patch data for `legalFolder` for the far side of the relationship. */
  updateById?: InputMaybe<LegalFolderOnLegalFolderForFkLegalFolderParentUsingPkLegalFolderUpdate>;
};

/** The `legalFolder` to be created by this mutation. */
export type FkLegalFolderParentLegalFolderCreateInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  legalDocumentsUsingId?: InputMaybe<FkLegalDocumentFolderInverseInput>;
  legalFolderToParentId?: InputMaybe<FkLegalFolderParentInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name: Scalars['String']['input'];
};

/** Input for the nested mutation of `mediaGallery` in the `MediaGalleryItemInput` mutation. */
export type FkMediaGalleryItemMediaGalleryMediaGalleryIdInput = {
  /** The primary key(s) for `mediaGallery` for the far side of the relationship. */
  connectById?: InputMaybe<MediaGalleryPkMediaGalleryConnect>;
  /** A `MediaGalleryInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkMediaGalleryItemMediaGalleryMediaGalleryIdMediaGalleryCreateInput>;
  /** The primary key(s) for `mediaGallery` for the far side of the relationship. */
  deleteById?: InputMaybe<MediaGalleryPkMediaGalleryDelete>;
  /** The primary key(s) and patch data for `mediaGallery` for the far side of the relationship. */
  updateById?: InputMaybe<MediaGalleryOnMediaGalleryItemForFkMediaGalleryItemMediaGalleryMediaGalleryIdUsingPkMediaGalleryUpdate>;
};

/** Input for the nested mutation of `mediaGalleryItem` in the `MediaGalleryInput` mutation. */
export type FkMediaGalleryItemMediaGalleryMediaGalleryIdInverseInput = {
  /** The primary key(s) for `mediaGalleryItem` for the far side of the relationship. */
  connectById?: InputMaybe<Array<MediaGalleryItemPkMediaGalleryItemConnect>>;
  /** A `MediaGalleryItemInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkMediaGalleryItemMediaGalleryMediaGalleryIdMediaGalleryItemCreateInput>>;
  /** The primary key(s) for `mediaGalleryItem` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<MediaGalleryItemPkMediaGalleryItemDelete>>;
  /** Flag indicating whether all other `mediaGalleryItem` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `mediaGalleryItem` for the far side of the relationship. */
  updateById?: InputMaybe<Array<MediaGalleryItemOnMediaGalleryItemForFkMediaGalleryItemMediaGalleryMediaGalleryIdUsingPkMediaGalleryItemUpdate>>;
};

/** The `mediaGallery` to be created by this mutation. */
export type FkMediaGalleryItemMediaGalleryMediaGalleryIdMediaGalleryCreateInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationFeaturesUsingId?: InputMaybe<FkDestinationFeatureMediaGalleryGalleryIdInverseInput>;
  destinationsUsingId?: InputMaybe<FkDestinationMediaGalleryGalleryIdInverseInput>;
  featuresUsingId?: InputMaybe<FkFeatureMediaGalleryGalleryIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  isProtected?: InputMaybe<Scalars['Boolean']['input']>;
  mediaGalleryItemsUsingId?: InputMaybe<FkMediaGalleryItemMediaGalleryMediaGalleryIdInverseInput>;
  mediaGalleryToParentId?: InputMaybe<FkMediaGalleryMediaGalleryParentIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  parentId?: InputMaybe<Scalars['UUID']['input']>;
  propertiesUsingId?: InputMaybe<FkPropertyMediaGalleryGalleryIdInverseInput>;
  suppliersUsingId?: InputMaybe<FkSupplierMediaGalleryGalleryIdInverseInput>;
  tripsUsingId?: InputMaybe<FkTripMediaGalleryMediaGalleryIdInverseInput>;
};

/** The `mediaGalleryItem` to be created by this mutation. */
export type FkMediaGalleryItemMediaGalleryMediaGalleryIdMediaGalleryItemCreateInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  isHero?: InputMaybe<Scalars['Boolean']['input']>;
  mediaGalleryToMediaGalleryId?: InputMaybe<FkMediaGalleryItemMediaGalleryMediaGalleryIdInput>;
  mediaItemId?: InputMaybe<Scalars['UUID']['input']>;
  mediaItemToMediaItemId?: InputMaybe<FkMediaGalleryItemMediaItemMediaItemIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Input for the nested mutation of `mediaItem` in the `MediaGalleryItemInput` mutation. */
export type FkMediaGalleryItemMediaItemMediaItemIdInput = {
  /** The primary key(s) for `mediaItem` for the far side of the relationship. */
  connectById?: InputMaybe<MediaItemPkMediaItemConnect>;
  /** A `MediaItemInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkMediaGalleryItemMediaItemMediaItemIdMediaItemCreateInput>;
  /** The primary key(s) for `mediaItem` for the far side of the relationship. */
  deleteById?: InputMaybe<MediaItemPkMediaItemDelete>;
  /** The primary key(s) and patch data for `mediaItem` for the far side of the relationship. */
  updateById?: InputMaybe<MediaItemOnMediaGalleryItemForFkMediaGalleryItemMediaItemMediaItemIdUsingPkMediaItemUpdate>;
};

/** Input for the nested mutation of `mediaGalleryItem` in the `MediaItemInput` mutation. */
export type FkMediaGalleryItemMediaItemMediaItemIdInverseInput = {
  /** The primary key(s) for `mediaGalleryItem` for the far side of the relationship. */
  connectById?: InputMaybe<Array<MediaGalleryItemPkMediaGalleryItemConnect>>;
  /** A `MediaGalleryItemInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkMediaGalleryItemMediaItemMediaItemIdMediaGalleryItemCreateInput>>;
  /** The primary key(s) for `mediaGalleryItem` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<MediaGalleryItemPkMediaGalleryItemDelete>>;
  /** Flag indicating whether all other `mediaGalleryItem` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `mediaGalleryItem` for the far side of the relationship. */
  updateById?: InputMaybe<Array<MediaGalleryItemOnMediaGalleryItemForFkMediaGalleryItemMediaItemMediaItemIdUsingPkMediaGalleryItemUpdate>>;
};

/** The `mediaGalleryItem` to be created by this mutation. */
export type FkMediaGalleryItemMediaItemMediaItemIdMediaGalleryItemCreateInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  isHero?: InputMaybe<Scalars['Boolean']['input']>;
  mediaGalleryId?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryToMediaGalleryId?: InputMaybe<FkMediaGalleryItemMediaGalleryMediaGalleryIdInput>;
  mediaItemToMediaItemId?: InputMaybe<FkMediaGalleryItemMediaItemMediaItemIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The `mediaItem` to be created by this mutation. */
export type FkMediaGalleryItemMediaItemMediaItemIdMediaItemCreateInput = {
  agenciesUsingId?: InputMaybe<FkAgencyMediaItemLogoIdInverseInput>;
  contentType?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationsUsingId?: InputMaybe<DestinationHeroMediaIdFkeyInverseInput>;
  fileName?: InputMaybe<Scalars['String']['input']>;
  hash?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryItemsUsingId?: InputMaybe<FkMediaGalleryItemMediaItemMediaItemIdInverseInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  propertiesUsingId?: InputMaybe<FkPropertyMediaItemHeroMediaIdInverseInput>;
  quoteHeroesUsingId?: InputMaybe<FkQuoteHeroMediaItemImageIdInverseInput>;
  quotesUsingId?: InputMaybe<FkQuoteMediaItemHeroImageIdInverseInput>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceMediaItemMediaItemIdInverseInput>;
};

/** Input for the nested mutation of `mediaGallery` in the `MediaGalleryInput` mutation. */
export type FkMediaGalleryMediaGalleryParentIdInput = {
  /** The primary key(s) for `mediaGallery` for the far side of the relationship. */
  connectById?: InputMaybe<MediaGalleryPkMediaGalleryConnect>;
  /** A `MediaGalleryInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkMediaGalleryMediaGalleryParentIdMediaGalleryCreateInput>;
  /** The primary key(s) for `mediaGallery` for the far side of the relationship. */
  deleteById?: InputMaybe<MediaGalleryPkMediaGalleryDelete>;
  /** The primary key(s) and patch data for `mediaGallery` for the far side of the relationship. */
  updateById?: InputMaybe<MediaGalleryOnMediaGalleryForFkMediaGalleryMediaGalleryParentIdUsingPkMediaGalleryUpdate>;
};

/** The `mediaGallery` to be created by this mutation. */
export type FkMediaGalleryMediaGalleryParentIdMediaGalleryCreateInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationFeaturesUsingId?: InputMaybe<FkDestinationFeatureMediaGalleryGalleryIdInverseInput>;
  destinationsUsingId?: InputMaybe<FkDestinationMediaGalleryGalleryIdInverseInput>;
  featuresUsingId?: InputMaybe<FkFeatureMediaGalleryGalleryIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  isProtected?: InputMaybe<Scalars['Boolean']['input']>;
  mediaGalleryItemsUsingId?: InputMaybe<FkMediaGalleryItemMediaGalleryMediaGalleryIdInverseInput>;
  mediaGalleryToParentId?: InputMaybe<FkMediaGalleryMediaGalleryParentIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  propertiesUsingId?: InputMaybe<FkPropertyMediaGalleryGalleryIdInverseInput>;
  suppliersUsingId?: InputMaybe<FkSupplierMediaGalleryGalleryIdInverseInput>;
  tripsUsingId?: InputMaybe<FkTripMediaGalleryMediaGalleryIdInverseInput>;
};

/** Input for the nested mutation of `trip` in the `NoteInput` mutation. */
export type FkNoteTripTripIdInput = {
  /** The primary key(s) for `trip` for the far side of the relationship. */
  connectById?: InputMaybe<TripPkTripConnect>;
  /** A `TripInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkNoteTripTripIdTripCreateInput>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  deleteById?: InputMaybe<TripPkTripDelete>;
  /** The primary key(s) and patch data for `trip` for the far side of the relationship. */
  updateById?: InputMaybe<TripOnNoteForFkNoteTripTripIdUsingPkTripUpdate>;
};

/** Input for the nested mutation of `note` in the `TripInput` mutation. */
export type FkNoteTripTripIdInverseInput = {
  /** The primary key(s) for `note` for the far side of the relationship. */
  connectById?: InputMaybe<Array<NotePkNoteConnect>>;
  /** A `NoteInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkNoteTripTripIdNoteCreateInput>>;
  /** The primary key(s) for `note` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<NotePkNoteDelete>>;
  /** Flag indicating whether all other `note` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `note` for the far side of the relationship. */
  updateById?: InputMaybe<Array<NoteOnNoteForFkNoteTripTripIdUsingPkNoteUpdate>>;
};

/** The `note` to be created by this mutation. */
export type FkNoteTripTripIdNoteCreateInput = {
  body?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  tripToTripId?: InputMaybe<FkNoteTripTripIdInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkNoteUserUserIdInput>;
};

/** The `trip` to be created by this mutation. */
export type FkNoteTripTripIdTripCreateInput = {
  activeQuoteId?: InputMaybe<Scalars['UUID']['input']>;
  agencyId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberToAgencyMemberId?: InputMaybe<FkTripAgencyMemberAgencyMemberIdInput>;
  agencyToAgencyId?: InputMaybe<FkTripAgencyAgencyIdInput>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerId?: InputMaybe<Scalars['UUID']['input']>;
  customerToCustomerId?: InputMaybe<FkTripCustomerCustomerIdInput>;
  dates?: InputMaybe<Scalars['String']['input']>;
  destination?: InputMaybe<Scalars['String']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  emailsUsingId?: InputMaybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: InputMaybe<FkEnquiryTripTripIdInverseInput>;
  expensesUsingId?: InputMaybe<FkExpenseTripTripIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceTripTripIdInverseInput>;
  mediaGalleryId?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryToMediaGalleryId?: InputMaybe<FkTripMediaGalleryMediaGalleryIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notesUsingId?: InputMaybe<FkNoteTripTripIdInverseInput>;
  paymentsUsingId?: InputMaybe<FkPaymentTripTripIdInverseInput>;
  quotePublicsUsingId?: InputMaybe<FakePublicQuotePublicForeignKey0InverseInput>;
  quoteToActiveQuoteId?: InputMaybe<FkTripQuoteActiveQuoteIdInput>;
  quotesUsingId?: InputMaybe<FkQuoteTripTripIdInverseInput>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceTripTripIdInverseInput>;
  testimonialsUsingId?: InputMaybe<FkTestimonialTripTripIdInverseInput>;
  tripFlightsUsingId?: InputMaybe<FkTripFlightTripTripIdInverseInput>;
  tripTravellersUsingId?: InputMaybe<FkTripTravellerTripTripIdInverseInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkTripUserUserIdInput>;
};

/** Input for the nested mutation of `user` in the `NoteInput` mutation. */
export type FkNoteUserUserIdInput = {
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectById?: InputMaybe<UserPkUserConnect>;
  /** A `UserInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkNoteUserUserIdUserCreateInput>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteById?: InputMaybe<UserPkUserDelete>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateById?: InputMaybe<UserOnNoteForFkNoteUserUserIdUsingPkUserUpdate>;
};

/** Input for the nested mutation of `note` in the `UserInput` mutation. */
export type FkNoteUserUserIdInverseInput = {
  /** The primary key(s) for `note` for the far side of the relationship. */
  connectById?: InputMaybe<Array<NotePkNoteConnect>>;
  /** A `NoteInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkNoteUserUserIdNoteCreateInput>>;
  /** The primary key(s) for `note` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<NotePkNoteDelete>>;
  /** Flag indicating whether all other `note` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `note` for the far side of the relationship. */
  updateById?: InputMaybe<Array<NoteOnNoteForFkNoteUserUserIdUsingPkNoteUpdate>>;
};

/** The `note` to be created by this mutation. */
export type FkNoteUserUserIdNoteCreateInput = {
  body?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkNoteTripTripIdInput>;
  userToUserId?: InputMaybe<FkNoteUserUserIdInput>;
};

/** The `user` to be created by this mutation. */
export type FkNoteUserUserIdUserCreateInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  emailsUsingId?: InputMaybe<FkEmailUserUserIdInverseInput>;
  externalId?: InputMaybe<Scalars['String']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  genderPreposition?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name: Scalars['String']['input'];
  notesUsingId?: InputMaybe<FkNoteUserUserIdInverseInput>;
  password?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  quotePublicsUsingId?: InputMaybe<FakePublicQuotePublicForeignKey2InverseInput>;
  quotesUsingId?: InputMaybe<FkQuoteUserUserIdInverseInput>;
  remindersUsingId?: InputMaybe<FkReminderUserUserIdInverseInput>;
  skype?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  transactionNotesUsingId?: InputMaybe<FkTransactionNoteUserUserIdInverseInput>;
  tripsUsingId?: InputMaybe<FkTripUserUserIdInverseInput>;
};

/** Input for the nested mutation of `traveller` in the `PassportInput` mutation. */
export type FkPassportTravellerTravellerIdInput = {
  /** The primary key(s) for `traveller` for the far side of the relationship. */
  connectById?: InputMaybe<TravellerPkTravellerConnect>;
  /** A `TravellerInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkPassportTravellerTravellerIdTravellerCreateInput>;
  /** The primary key(s) for `traveller` for the far side of the relationship. */
  deleteById?: InputMaybe<TravellerPkTravellerDelete>;
  /** The primary key(s) and patch data for `traveller` for the far side of the relationship. */
  updateById?: InputMaybe<TravellerOnPassportForFkPassportTravellerTravellerIdUsingPkTravellerUpdate>;
};

/** Input for the nested mutation of `passport` in the `TravellerInput` mutation. */
export type FkPassportTravellerTravellerIdInverseInput = {
  /** The primary key(s) for `passport` for the far side of the relationship. */
  connectById?: InputMaybe<Array<PassportPkPassportConnect>>;
  /** A `PassportInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkPassportTravellerTravellerIdPassportCreateInput>>;
  /** The primary key(s) for `passport` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<PassportPkPassportDelete>>;
  /** Flag indicating whether all other `passport` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `passport` for the far side of the relationship. */
  updateById?: InputMaybe<Array<PassportOnPassportForFkPassportTravellerTravellerIdUsingPkPassportUpdate>>;
};

/** The `passport` to be created by this mutation. */
export type FkPassportTravellerTravellerIdPassportCreateInput = {
  countryId?: InputMaybe<Scalars['UUID']['input']>;
  countryOfIssue?: InputMaybe<Scalars['String']['input']>;
  countryToCountryId?: InputMaybe<PassportCountry2IdFkeyInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  expiry: Scalars['Datetime']['input'];
  id?: InputMaybe<Scalars['UUID']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  number?: InputMaybe<Scalars['String']['input']>;
  travellerToTravellerId?: InputMaybe<FkPassportTravellerTravellerIdInput>;
};

/** The `traveller` to be created by this mutation. */
export type FkPassportTravellerTravellerIdTravellerCreateInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerTravellersUsingId?: InputMaybe<FkCustomerTravellerTravellerTravellerIdInverseInput>;
  dateOfBirth?: InputMaybe<Scalars['Datetime']['input']>;
  dietaryRequirements?: InputMaybe<Scalars['String']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  emergencyContact?: InputMaybe<Scalars['String']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  height?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  insuranceDetails?: InputMaybe<Scalars['String']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  medicalConditions?: InputMaybe<Scalars['String']['input']>;
  middleName?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  nationality?: InputMaybe<Scalars['String']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  passportsUsingId?: InputMaybe<FkPassportTravellerTravellerIdInverseInput>;
  phone?: InputMaybe<Scalars['String']['input']>;
  tripTravellersUsingId?: InputMaybe<FkTripTravellerTravellerTravellerIdInverseInput>;
  weight?: InputMaybe<Scalars['Int']['input']>;
};

/** The `financeCategory` to be created by this mutation. */
export type FkPaymentFinanceCategoryCategoryIdFinanceCategoryCreateInput = {
  code?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  expensesUsingId?: InputMaybe<FkExpenseFinanceCategoryCategoryIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceFinanceCategoryCategoryIdInverseInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  paymentsUsingId?: InputMaybe<FkPaymentFinanceCategoryCategoryIdInverseInput>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceFinanceCategoryCategoryIdInverseInput>;
  transactionsUsingId?: InputMaybe<FkTransactionFinanceCategoryCategoryIdInverseInput>;
  type?: InputMaybe<Scalars['Int']['input']>;
};

/** Input for the nested mutation of `financeCategory` in the `PaymentInput` mutation. */
export type FkPaymentFinanceCategoryCategoryIdInput = {
  /** The primary key(s) for `financeCategory` for the far side of the relationship. */
  connectById?: InputMaybe<FinanceCategoryPkFinanceCategoryConnect>;
  /** A `FinanceCategoryInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkPaymentFinanceCategoryCategoryIdFinanceCategoryCreateInput>;
  /** The primary key(s) for `financeCategory` for the far side of the relationship. */
  deleteById?: InputMaybe<FinanceCategoryPkFinanceCategoryDelete>;
  /** The primary key(s) and patch data for `financeCategory` for the far side of the relationship. */
  updateById?: InputMaybe<FinanceCategoryOnPaymentForFkPaymentFinanceCategoryCategoryIdUsingPkFinanceCategoryUpdate>;
};

/** Input for the nested mutation of `payment` in the `FinanceCategoryInput` mutation. */
export type FkPaymentFinanceCategoryCategoryIdInverseInput = {
  /** The primary key(s) for `payment` for the far side of the relationship. */
  connectById?: InputMaybe<Array<PaymentPkPaymentConnect>>;
  /** A `PaymentInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkPaymentFinanceCategoryCategoryIdPaymentCreateInput>>;
  /** The primary key(s) for `payment` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<PaymentPkPaymentDelete>>;
  /** Flag indicating whether all other `payment` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `payment` for the far side of the relationship. */
  updateById?: InputMaybe<Array<PaymentOnPaymentForFkPaymentFinanceCategoryCategoryIdUsingPkPaymentUpdate>>;
};

/** The `payment` to be created by this mutation. */
export type FkPaymentFinanceCategoryCategoryIdPaymentCreateInput = {
  amount: Scalars['BigFloat']['input'];
  amountActual: Scalars['BigFloat']['input'];
  created?: InputMaybe<Scalars['Datetime']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  financeCategoryToCategoryId?: InputMaybe<FkPaymentFinanceCategoryCategoryIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoiceId?: InputMaybe<Scalars['UUID']['input']>;
  invoiceToInvoiceId?: InputMaybe<FkPaymentInvoiceInvoiceIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  paid: Scalars['Datetime']['input'];
  reference?: InputMaybe<Scalars['String']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  transactionLinksUsingId?: InputMaybe<FkTransactionLinkPaymentPaymentIdInverseInput>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkPaymentTripTripIdInput>;
  type?: InputMaybe<Scalars['Int']['input']>;
};

/** Input for the nested mutation of `invoice` in the `PaymentInput` mutation. */
export type FkPaymentInvoiceInvoiceIdInput = {
  /** The primary key(s) for `invoice` for the far side of the relationship. */
  connectById?: InputMaybe<InvoicePkInvoiceConnect>;
  /** A `InvoiceInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkPaymentInvoiceInvoiceIdInvoiceCreateInput>;
  /** The primary key(s) for `invoice` for the far side of the relationship. */
  deleteById?: InputMaybe<InvoicePkInvoiceDelete>;
  /** The primary key(s) and patch data for `invoice` for the far side of the relationship. */
  updateById?: InputMaybe<InvoiceOnPaymentForFkPaymentInvoiceInvoiceIdUsingPkInvoiceUpdate>;
};

/** Input for the nested mutation of `payment` in the `InvoiceInput` mutation. */
export type FkPaymentInvoiceInvoiceIdInverseInput = {
  /** The primary key(s) for `payment` for the far side of the relationship. */
  connectById?: InputMaybe<Array<PaymentPkPaymentConnect>>;
  /** A `PaymentInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkPaymentInvoiceInvoiceIdPaymentCreateInput>>;
  /** The primary key(s) for `payment` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<PaymentPkPaymentDelete>>;
  /** Flag indicating whether all other `payment` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `payment` for the far side of the relationship. */
  updateById?: InputMaybe<Array<PaymentOnPaymentForFkPaymentInvoiceInvoiceIdUsingPkPaymentUpdate>>;
};

/** The `invoice` to be created by this mutation. */
export type FkPaymentInvoiceInvoiceIdInvoiceCreateInput = {
  amount: Scalars['BigFloat']['input'];
  categoryId?: InputMaybe<Scalars['UUID']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  due: Scalars['Datetime']['input'];
  expensesUsingId?: InputMaybe<FkExpenseInvoiceInvoiceIdInverseInput>;
  financeCategoryToCategoryId?: InputMaybe<FkInvoiceFinanceCategoryCategoryIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoiced?: InputMaybe<Scalars['Datetime']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  locked?: InputMaybe<Scalars['Datetime']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  note?: InputMaybe<Scalars['String']['input']>;
  number?: InputMaybe<Scalars['Int']['input']>;
  paid?: InputMaybe<Scalars['Datetime']['input']>;
  paymentsUsingId?: InputMaybe<FkPaymentInvoiceInvoiceIdInverseInput>;
  quoteId?: InputMaybe<Scalars['UUID']['input']>;
  quoteToQuoteId?: InputMaybe<FkInvoiceQuoteQuoteIdInput>;
  summary?: InputMaybe<Scalars['String']['input']>;
  transactionLinksUsingId?: InputMaybe<FkTransactionLinkInvoiceInvoiceIdInverseInput>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkInvoiceTripTripIdInput>;
  type?: InputMaybe<Scalars['String']['input']>;
  voided?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The `payment` to be created by this mutation. */
export type FkPaymentInvoiceInvoiceIdPaymentCreateInput = {
  amount: Scalars['BigFloat']['input'];
  amountActual: Scalars['BigFloat']['input'];
  categoryId?: InputMaybe<Scalars['UUID']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  financeCategoryToCategoryId?: InputMaybe<FkPaymentFinanceCategoryCategoryIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoiceToInvoiceId?: InputMaybe<FkPaymentInvoiceInvoiceIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  paid: Scalars['Datetime']['input'];
  reference?: InputMaybe<Scalars['String']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  transactionLinksUsingId?: InputMaybe<FkTransactionLinkPaymentPaymentIdInverseInput>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkPaymentTripTripIdInput>;
  type?: InputMaybe<Scalars['Int']['input']>;
};

/** Input for the nested mutation of `trip` in the `PaymentInput` mutation. */
export type FkPaymentTripTripIdInput = {
  /** The primary key(s) for `trip` for the far side of the relationship. */
  connectById?: InputMaybe<TripPkTripConnect>;
  /** A `TripInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkPaymentTripTripIdTripCreateInput>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  deleteById?: InputMaybe<TripPkTripDelete>;
  /** The primary key(s) and patch data for `trip` for the far side of the relationship. */
  updateById?: InputMaybe<TripOnPaymentForFkPaymentTripTripIdUsingPkTripUpdate>;
};

/** Input for the nested mutation of `payment` in the `TripInput` mutation. */
export type FkPaymentTripTripIdInverseInput = {
  /** The primary key(s) for `payment` for the far side of the relationship. */
  connectById?: InputMaybe<Array<PaymentPkPaymentConnect>>;
  /** A `PaymentInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkPaymentTripTripIdPaymentCreateInput>>;
  /** The primary key(s) for `payment` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<PaymentPkPaymentDelete>>;
  /** Flag indicating whether all other `payment` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `payment` for the far side of the relationship. */
  updateById?: InputMaybe<Array<PaymentOnPaymentForFkPaymentTripTripIdUsingPkPaymentUpdate>>;
};

/** The `payment` to be created by this mutation. */
export type FkPaymentTripTripIdPaymentCreateInput = {
  amount: Scalars['BigFloat']['input'];
  amountActual: Scalars['BigFloat']['input'];
  categoryId?: InputMaybe<Scalars['UUID']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  financeCategoryToCategoryId?: InputMaybe<FkPaymentFinanceCategoryCategoryIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoiceId?: InputMaybe<Scalars['UUID']['input']>;
  invoiceToInvoiceId?: InputMaybe<FkPaymentInvoiceInvoiceIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  paid: Scalars['Datetime']['input'];
  reference?: InputMaybe<Scalars['String']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  transactionLinksUsingId?: InputMaybe<FkTransactionLinkPaymentPaymentIdInverseInput>;
  tripToTripId?: InputMaybe<FkPaymentTripTripIdInput>;
  type?: InputMaybe<Scalars['Int']['input']>;
};

/** The `trip` to be created by this mutation. */
export type FkPaymentTripTripIdTripCreateInput = {
  activeQuoteId?: InputMaybe<Scalars['UUID']['input']>;
  agencyId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberToAgencyMemberId?: InputMaybe<FkTripAgencyMemberAgencyMemberIdInput>;
  agencyToAgencyId?: InputMaybe<FkTripAgencyAgencyIdInput>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerId?: InputMaybe<Scalars['UUID']['input']>;
  customerToCustomerId?: InputMaybe<FkTripCustomerCustomerIdInput>;
  dates?: InputMaybe<Scalars['String']['input']>;
  destination?: InputMaybe<Scalars['String']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  emailsUsingId?: InputMaybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: InputMaybe<FkEnquiryTripTripIdInverseInput>;
  expensesUsingId?: InputMaybe<FkExpenseTripTripIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceTripTripIdInverseInput>;
  mediaGalleryId?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryToMediaGalleryId?: InputMaybe<FkTripMediaGalleryMediaGalleryIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notesUsingId?: InputMaybe<FkNoteTripTripIdInverseInput>;
  paymentsUsingId?: InputMaybe<FkPaymentTripTripIdInverseInput>;
  quotePublicsUsingId?: InputMaybe<FakePublicQuotePublicForeignKey0InverseInput>;
  quoteToActiveQuoteId?: InputMaybe<FkTripQuoteActiveQuoteIdInput>;
  quotesUsingId?: InputMaybe<FkQuoteTripTripIdInverseInput>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceTripTripIdInverseInput>;
  testimonialsUsingId?: InputMaybe<FkTestimonialTripTripIdInverseInput>;
  tripFlightsUsingId?: InputMaybe<FkTripFlightTripTripIdInverseInput>;
  tripTravellersUsingId?: InputMaybe<FkTripTravellerTripTripIdInverseInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkTripUserUserIdInput>;
};

/** The `country` to be created by this mutation. */
export type FkPropertyCountryCountryIdCountryCreateInput = {
  airportsUsingId?: InputMaybe<FkAirportCountryCountryIdInverseInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationsUsingId?: InputMaybe<FkDestinationCountryCountryIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  iso2?: InputMaybe<Scalars['String']['input']>;
  iso3?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  passportsUsingId?: InputMaybe<PassportCountry2IdFkeyInverseInput>;
  propertiesUsingId?: InputMaybe<FkPropertyCountryCountryIdInverseInput>;
};

/** Input for the nested mutation of `country` in the `PropertyInput` mutation. */
export type FkPropertyCountryCountryIdInput = {
  /** The primary key(s) for `country` for the far side of the relationship. */
  connectById?: InputMaybe<CountryPkCountryConnect>;
  /** A `CountryInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkPropertyCountryCountryIdCountryCreateInput>;
  /** The primary key(s) for `country` for the far side of the relationship. */
  deleteById?: InputMaybe<CountryPkCountryDelete>;
  /** The primary key(s) and patch data for `country` for the far side of the relationship. */
  updateById?: InputMaybe<CountryOnPropertyForFkPropertyCountryCountryIdUsingPkCountryUpdate>;
};

/** Input for the nested mutation of `property` in the `CountryInput` mutation. */
export type FkPropertyCountryCountryIdInverseInput = {
  /** The primary key(s) for `property` for the far side of the relationship. */
  connectById?: InputMaybe<Array<PropertyPkPropertyConnect>>;
  /** A `PropertyInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkPropertyCountryCountryIdPropertyCreateInput>>;
  /** The primary key(s) for `property` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<PropertyPkPropertyDelete>>;
  /** Flag indicating whether all other `property` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `property` for the far side of the relationship. */
  updateById?: InputMaybe<Array<PropertyOnPropertyForFkPropertyCountryCountryIdUsingPkPropertyUpdate>>;
};

/** The `property` to be created by this mutation. */
export type FkPropertyCountryCountryIdPropertyCreateInput = {
  alias?: InputMaybe<Scalars['String']['input']>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  contactNumber?: InputMaybe<Scalars['String']['input']>;
  countryToCountryId?: InputMaybe<FkPropertyCountryCountryIdInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationId?: InputMaybe<Scalars['UUID']['input']>;
  destinationToDestinationId?: InputMaybe<FkPropertyDestinationInput>;
  externalReference?: InputMaybe<Scalars['String']['input']>;
  featureCopy?: InputMaybe<Scalars['String']['input']>;
  featured?: InputMaybe<Scalars['Datetime']['input']>;
  galleryId?: InputMaybe<Scalars['UUID']['input']>;
  heroMediaId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  latitude?: InputMaybe<Scalars['Float']['input']>;
  longitude?: InputMaybe<Scalars['Float']['input']>;
  mapPointId?: InputMaybe<Scalars['UUID']['input']>;
  mapPointToMapPointId?: InputMaybe<FkPropertyMapPointMapPointIdInput>;
  mediaGalleryToGalleryId?: InputMaybe<FkPropertyMediaGalleryGalleryIdInput>;
  mediaItemToHeroMediaId?: InputMaybe<FkPropertyMediaItemHeroMediaIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  nearestAirport?: InputMaybe<Scalars['String']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  plusCode?: InputMaybe<Scalars['String']['input']>;
  quoteAccommodationDetailsUsingId?: InputMaybe<FkQuoteAccommodationDetailPropertyPropertyIdInverseInput>;
  quoteDaysUsingId?: InputMaybe<QuoteDayPropertyIdFkeyInverseInput>;
  region?: InputMaybe<Scalars['String']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  timezone?: InputMaybe<Scalars['String']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
};

/** The `destination` to be created by this mutation. */
export type FkPropertyDestinationDestinationCreateInput = {
  alias: Scalars['String']['input'];
  body?: InputMaybe<Scalars['String']['input']>;
  countryId?: InputMaybe<Scalars['UUID']['input']>;
  countryToCountryId?: InputMaybe<FkDestinationCountryCountryIdInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationFeaturesUsingId?: InputMaybe<FkDestinationFeatureDestinationDestinationIdInverseInput>;
  destinationGuidesUsingId?: InputMaybe<FkDestinationGuideDestinationDestinationIdInverseInput>;
  destinationToParentId?: InputMaybe<FkDestinationDestinationParentIdInput>;
  galleryId?: InputMaybe<Scalars['UUID']['input']>;
  heroMediaId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  latitude?: InputMaybe<Scalars['Float']['input']>;
  longitude?: InputMaybe<Scalars['Float']['input']>;
  mediaGalleryToGalleryId?: InputMaybe<FkDestinationMediaGalleryGalleryIdInput>;
  mediaItemToHeroMediaId?: InputMaybe<DestinationHeroMediaIdFkeyInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  parentId?: InputMaybe<Scalars['UUID']['input']>;
  propertiesUsingId?: InputMaybe<FkPropertyDestinationInverseInput>;
  quoteDayDestinationsUsingId?: InputMaybe<FkQuoteDayDestinationDestinationDestinationIdInverseInput>;
};

/** Input for the nested mutation of `destination` in the `PropertyInput` mutation. */
export type FkPropertyDestinationInput = {
  /** The primary key(s) for `destination` for the far side of the relationship. */
  connectByCountryIdAndAlias?: InputMaybe<DestinationUqDestinationAliasConnect>;
  /** The primary key(s) for `destination` for the far side of the relationship. */
  connectById?: InputMaybe<DestinationPkDestinationConnect>;
  /** A `DestinationInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkPropertyDestinationDestinationCreateInput>;
  /** The primary key(s) for `destination` for the far side of the relationship. */
  deleteByCountryIdAndAlias?: InputMaybe<DestinationUqDestinationAliasDelete>;
  /** The primary key(s) for `destination` for the far side of the relationship. */
  deleteById?: InputMaybe<DestinationPkDestinationDelete>;
  /** The primary key(s) and patch data for `destination` for the far side of the relationship. */
  updateByCountryIdAndAlias?: InputMaybe<DestinationOnPropertyForFkPropertyDestinationUsingUqDestinationAliasUpdate>;
  /** The primary key(s) and patch data for `destination` for the far side of the relationship. */
  updateById?: InputMaybe<DestinationOnPropertyForFkPropertyDestinationUsingPkDestinationUpdate>;
};

/** Input for the nested mutation of `property` in the `DestinationInput` mutation. */
export type FkPropertyDestinationInverseInput = {
  /** The primary key(s) for `property` for the far side of the relationship. */
  connectById?: InputMaybe<Array<PropertyPkPropertyConnect>>;
  /** A `PropertyInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkPropertyDestinationPropertyCreateInput>>;
  /** The primary key(s) for `property` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<PropertyPkPropertyDelete>>;
  /** Flag indicating whether all other `property` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `property` for the far side of the relationship. */
  updateById?: InputMaybe<Array<PropertyOnPropertyForFkPropertyDestinationUsingPkPropertyUpdate>>;
};

/** The `property` to be created by this mutation. */
export type FkPropertyDestinationPropertyCreateInput = {
  alias?: InputMaybe<Scalars['String']['input']>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  contactNumber?: InputMaybe<Scalars['String']['input']>;
  countryId?: InputMaybe<Scalars['UUID']['input']>;
  countryToCountryId?: InputMaybe<FkPropertyCountryCountryIdInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationToDestinationId?: InputMaybe<FkPropertyDestinationInput>;
  externalReference?: InputMaybe<Scalars['String']['input']>;
  featureCopy?: InputMaybe<Scalars['String']['input']>;
  featured?: InputMaybe<Scalars['Datetime']['input']>;
  galleryId?: InputMaybe<Scalars['UUID']['input']>;
  heroMediaId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  latitude?: InputMaybe<Scalars['Float']['input']>;
  longitude?: InputMaybe<Scalars['Float']['input']>;
  mapPointId?: InputMaybe<Scalars['UUID']['input']>;
  mapPointToMapPointId?: InputMaybe<FkPropertyMapPointMapPointIdInput>;
  mediaGalleryToGalleryId?: InputMaybe<FkPropertyMediaGalleryGalleryIdInput>;
  mediaItemToHeroMediaId?: InputMaybe<FkPropertyMediaItemHeroMediaIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  nearestAirport?: InputMaybe<Scalars['String']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  plusCode?: InputMaybe<Scalars['String']['input']>;
  quoteAccommodationDetailsUsingId?: InputMaybe<FkQuoteAccommodationDetailPropertyPropertyIdInverseInput>;
  quoteDaysUsingId?: InputMaybe<QuoteDayPropertyIdFkeyInverseInput>;
  region?: InputMaybe<Scalars['String']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  timezone?: InputMaybe<Scalars['String']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
};

/** Input for the nested mutation of `mapPoint` in the `PropertyInput` mutation. */
export type FkPropertyMapPointMapPointIdInput = {
  /** The primary key(s) for `mapPoint` for the far side of the relationship. */
  connectById?: InputMaybe<MapPointPkMapPointConnect>;
  /** A `MapPointInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkPropertyMapPointMapPointIdMapPointCreateInput>;
  /** The primary key(s) for `mapPoint` for the far side of the relationship. */
  deleteById?: InputMaybe<MapPointPkMapPointDelete>;
  /** The primary key(s) and patch data for `mapPoint` for the far side of the relationship. */
  updateById?: InputMaybe<MapPointOnPropertyForFkPropertyMapPointMapPointIdUsingPkMapPointUpdate>;
};

/** Input for the nested mutation of `property` in the `MapPointInput` mutation. */
export type FkPropertyMapPointMapPointIdInverseInput = {
  /** The primary key(s) for `property` for the far side of the relationship. */
  connectById?: InputMaybe<Array<PropertyPkPropertyConnect>>;
  /** A `PropertyInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkPropertyMapPointMapPointIdPropertyCreateInput>>;
  /** The primary key(s) for `property` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<PropertyPkPropertyDelete>>;
  /** Flag indicating whether all other `property` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `property` for the far side of the relationship. */
  updateById?: InputMaybe<Array<PropertyOnPropertyForFkPropertyMapPointMapPointIdUsingPkPropertyUpdate>>;
};

/** The `mapPoint` to be created by this mutation. */
export type FkPropertyMapPointMapPointIdMapPointCreateInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  latitude: Scalars['Float']['input'];
  longitude: Scalars['Float']['input'];
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  propertiesUsingId?: InputMaybe<FkPropertyMapPointMapPointIdInverseInput>;
};

/** The `property` to be created by this mutation. */
export type FkPropertyMapPointMapPointIdPropertyCreateInput = {
  alias?: InputMaybe<Scalars['String']['input']>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  contactNumber?: InputMaybe<Scalars['String']['input']>;
  countryId?: InputMaybe<Scalars['UUID']['input']>;
  countryToCountryId?: InputMaybe<FkPropertyCountryCountryIdInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationId?: InputMaybe<Scalars['UUID']['input']>;
  destinationToDestinationId?: InputMaybe<FkPropertyDestinationInput>;
  externalReference?: InputMaybe<Scalars['String']['input']>;
  featureCopy?: InputMaybe<Scalars['String']['input']>;
  featured?: InputMaybe<Scalars['Datetime']['input']>;
  galleryId?: InputMaybe<Scalars['UUID']['input']>;
  heroMediaId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  latitude?: InputMaybe<Scalars['Float']['input']>;
  longitude?: InputMaybe<Scalars['Float']['input']>;
  mapPointToMapPointId?: InputMaybe<FkPropertyMapPointMapPointIdInput>;
  mediaGalleryToGalleryId?: InputMaybe<FkPropertyMediaGalleryGalleryIdInput>;
  mediaItemToHeroMediaId?: InputMaybe<FkPropertyMediaItemHeroMediaIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  nearestAirport?: InputMaybe<Scalars['String']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  plusCode?: InputMaybe<Scalars['String']['input']>;
  quoteAccommodationDetailsUsingId?: InputMaybe<FkQuoteAccommodationDetailPropertyPropertyIdInverseInput>;
  quoteDaysUsingId?: InputMaybe<QuoteDayPropertyIdFkeyInverseInput>;
  region?: InputMaybe<Scalars['String']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  timezone?: InputMaybe<Scalars['String']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
};

/** Input for the nested mutation of `mediaGallery` in the `PropertyInput` mutation. */
export type FkPropertyMediaGalleryGalleryIdInput = {
  /** The primary key(s) for `mediaGallery` for the far side of the relationship. */
  connectById?: InputMaybe<MediaGalleryPkMediaGalleryConnect>;
  /** A `MediaGalleryInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkPropertyMediaGalleryGalleryIdMediaGalleryCreateInput>;
  /** The primary key(s) for `mediaGallery` for the far side of the relationship. */
  deleteById?: InputMaybe<MediaGalleryPkMediaGalleryDelete>;
  /** The primary key(s) and patch data for `mediaGallery` for the far side of the relationship. */
  updateById?: InputMaybe<MediaGalleryOnPropertyForFkPropertyMediaGalleryGalleryIdUsingPkMediaGalleryUpdate>;
};

/** Input for the nested mutation of `property` in the `MediaGalleryInput` mutation. */
export type FkPropertyMediaGalleryGalleryIdInverseInput = {
  /** The primary key(s) for `property` for the far side of the relationship. */
  connectById?: InputMaybe<Array<PropertyPkPropertyConnect>>;
  /** A `PropertyInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkPropertyMediaGalleryGalleryIdPropertyCreateInput>>;
  /** The primary key(s) for `property` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<PropertyPkPropertyDelete>>;
  /** Flag indicating whether all other `property` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `property` for the far side of the relationship. */
  updateById?: InputMaybe<Array<PropertyOnPropertyForFkPropertyMediaGalleryGalleryIdUsingPkPropertyUpdate>>;
};

/** The `mediaGallery` to be created by this mutation. */
export type FkPropertyMediaGalleryGalleryIdMediaGalleryCreateInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationFeaturesUsingId?: InputMaybe<FkDestinationFeatureMediaGalleryGalleryIdInverseInput>;
  destinationsUsingId?: InputMaybe<FkDestinationMediaGalleryGalleryIdInverseInput>;
  featuresUsingId?: InputMaybe<FkFeatureMediaGalleryGalleryIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  isProtected?: InputMaybe<Scalars['Boolean']['input']>;
  mediaGalleryItemsUsingId?: InputMaybe<FkMediaGalleryItemMediaGalleryMediaGalleryIdInverseInput>;
  mediaGalleryToParentId?: InputMaybe<FkMediaGalleryMediaGalleryParentIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  parentId?: InputMaybe<Scalars['UUID']['input']>;
  propertiesUsingId?: InputMaybe<FkPropertyMediaGalleryGalleryIdInverseInput>;
  suppliersUsingId?: InputMaybe<FkSupplierMediaGalleryGalleryIdInverseInput>;
  tripsUsingId?: InputMaybe<FkTripMediaGalleryMediaGalleryIdInverseInput>;
};

/** The `property` to be created by this mutation. */
export type FkPropertyMediaGalleryGalleryIdPropertyCreateInput = {
  alias?: InputMaybe<Scalars['String']['input']>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  contactNumber?: InputMaybe<Scalars['String']['input']>;
  countryId?: InputMaybe<Scalars['UUID']['input']>;
  countryToCountryId?: InputMaybe<FkPropertyCountryCountryIdInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationId?: InputMaybe<Scalars['UUID']['input']>;
  destinationToDestinationId?: InputMaybe<FkPropertyDestinationInput>;
  externalReference?: InputMaybe<Scalars['String']['input']>;
  featureCopy?: InputMaybe<Scalars['String']['input']>;
  featured?: InputMaybe<Scalars['Datetime']['input']>;
  heroMediaId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  latitude?: InputMaybe<Scalars['Float']['input']>;
  longitude?: InputMaybe<Scalars['Float']['input']>;
  mapPointId?: InputMaybe<Scalars['UUID']['input']>;
  mapPointToMapPointId?: InputMaybe<FkPropertyMapPointMapPointIdInput>;
  mediaGalleryToGalleryId?: InputMaybe<FkPropertyMediaGalleryGalleryIdInput>;
  mediaItemToHeroMediaId?: InputMaybe<FkPropertyMediaItemHeroMediaIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  nearestAirport?: InputMaybe<Scalars['String']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  plusCode?: InputMaybe<Scalars['String']['input']>;
  quoteAccommodationDetailsUsingId?: InputMaybe<FkQuoteAccommodationDetailPropertyPropertyIdInverseInput>;
  quoteDaysUsingId?: InputMaybe<QuoteDayPropertyIdFkeyInverseInput>;
  region?: InputMaybe<Scalars['String']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  timezone?: InputMaybe<Scalars['String']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
};

/** Input for the nested mutation of `mediaItem` in the `PropertyInput` mutation. */
export type FkPropertyMediaItemHeroMediaIdInput = {
  /** The primary key(s) for `mediaItem` for the far side of the relationship. */
  connectById?: InputMaybe<MediaItemPkMediaItemConnect>;
  /** A `MediaItemInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkPropertyMediaItemHeroMediaIdMediaItemCreateInput>;
  /** The primary key(s) for `mediaItem` for the far side of the relationship. */
  deleteById?: InputMaybe<MediaItemPkMediaItemDelete>;
  /** The primary key(s) and patch data for `mediaItem` for the far side of the relationship. */
  updateById?: InputMaybe<MediaItemOnPropertyForFkPropertyMediaItemHeroMediaIdUsingPkMediaItemUpdate>;
};

/** Input for the nested mutation of `property` in the `MediaItemInput` mutation. */
export type FkPropertyMediaItemHeroMediaIdInverseInput = {
  /** The primary key(s) for `property` for the far side of the relationship. */
  connectById?: InputMaybe<Array<PropertyPkPropertyConnect>>;
  /** A `PropertyInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkPropertyMediaItemHeroMediaIdPropertyCreateInput>>;
  /** The primary key(s) for `property` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<PropertyPkPropertyDelete>>;
  /** Flag indicating whether all other `property` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `property` for the far side of the relationship. */
  updateById?: InputMaybe<Array<PropertyOnPropertyForFkPropertyMediaItemHeroMediaIdUsingPkPropertyUpdate>>;
};

/** The `mediaItem` to be created by this mutation. */
export type FkPropertyMediaItemHeroMediaIdMediaItemCreateInput = {
  agenciesUsingId?: InputMaybe<FkAgencyMediaItemLogoIdInverseInput>;
  contentType?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationsUsingId?: InputMaybe<DestinationHeroMediaIdFkeyInverseInput>;
  fileName?: InputMaybe<Scalars['String']['input']>;
  hash?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryItemsUsingId?: InputMaybe<FkMediaGalleryItemMediaItemMediaItemIdInverseInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  propertiesUsingId?: InputMaybe<FkPropertyMediaItemHeroMediaIdInverseInput>;
  quoteHeroesUsingId?: InputMaybe<FkQuoteHeroMediaItemImageIdInverseInput>;
  quotesUsingId?: InputMaybe<FkQuoteMediaItemHeroImageIdInverseInput>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceMediaItemMediaItemIdInverseInput>;
};

/** The `property` to be created by this mutation. */
export type FkPropertyMediaItemHeroMediaIdPropertyCreateInput = {
  alias?: InputMaybe<Scalars['String']['input']>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  contactNumber?: InputMaybe<Scalars['String']['input']>;
  countryId?: InputMaybe<Scalars['UUID']['input']>;
  countryToCountryId?: InputMaybe<FkPropertyCountryCountryIdInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationId?: InputMaybe<Scalars['UUID']['input']>;
  destinationToDestinationId?: InputMaybe<FkPropertyDestinationInput>;
  externalReference?: InputMaybe<Scalars['String']['input']>;
  featureCopy?: InputMaybe<Scalars['String']['input']>;
  featured?: InputMaybe<Scalars['Datetime']['input']>;
  galleryId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  latitude?: InputMaybe<Scalars['Float']['input']>;
  longitude?: InputMaybe<Scalars['Float']['input']>;
  mapPointId?: InputMaybe<Scalars['UUID']['input']>;
  mapPointToMapPointId?: InputMaybe<FkPropertyMapPointMapPointIdInput>;
  mediaGalleryToGalleryId?: InputMaybe<FkPropertyMediaGalleryGalleryIdInput>;
  mediaItemToHeroMediaId?: InputMaybe<FkPropertyMediaItemHeroMediaIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  nearestAirport?: InputMaybe<Scalars['String']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  plusCode?: InputMaybe<Scalars['String']['input']>;
  quoteAccommodationDetailsUsingId?: InputMaybe<FkQuoteAccommodationDetailPropertyPropertyIdInverseInput>;
  quoteDaysUsingId?: InputMaybe<QuoteDayPropertyIdFkeyInverseInput>;
  region?: InputMaybe<Scalars['String']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  timezone?: InputMaybe<Scalars['String']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
};

/** Input for the nested mutation of `quote` in the `QuoteAcceptanceInput` mutation. */
export type FkQuoteAcceptanceQuoteInput = {
  /** The primary key(s) for `quote` for the far side of the relationship. */
  connectById?: InputMaybe<QuotePkQuoteConnect>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  connectByKey?: InputMaybe<QuoteUqQuoteKeyConnect>;
  /** A `QuoteInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkQuoteAcceptanceQuoteQuoteCreateInput>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  deleteById?: InputMaybe<QuotePkQuoteDelete>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  deleteByKey?: InputMaybe<QuoteUqQuoteKeyDelete>;
  /** The primary key(s) and patch data for `quote` for the far side of the relationship. */
  updateById?: InputMaybe<QuoteOnQuoteAcceptanceForFkQuoteAcceptanceQuoteUsingPkQuoteUpdate>;
  /** The primary key(s) and patch data for `quote` for the far side of the relationship. */
  updateByKey?: InputMaybe<QuoteOnQuoteAcceptanceForFkQuoteAcceptanceQuoteUsingUqQuoteKeyUpdate>;
};

/** Input for the nested mutation of `quoteAcceptance` in the `QuoteInput` mutation. */
export type FkQuoteAcceptanceQuoteInverseInput = {
  /** The primary key(s) for `quoteAcceptance` for the far side of the relationship. */
  connectById?: InputMaybe<Array<QuoteAcceptancePkQuoteAcceptanceConnect>>;
  /** A `QuoteAcceptanceInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkQuoteAcceptanceQuoteQuoteAcceptanceCreateInput>>;
  /** The primary key(s) for `quoteAcceptance` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<QuoteAcceptancePkQuoteAcceptanceDelete>>;
  /** Flag indicating whether all other `quoteAcceptance` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `quoteAcceptance` for the far side of the relationship. */
  updateById?: InputMaybe<Array<QuoteAcceptanceOnQuoteAcceptanceForFkQuoteAcceptanceQuoteUsingPkQuoteAcceptanceUpdate>>;
};

/** The `quoteAcceptance` to be created by this mutation. */
export type FkQuoteAcceptanceQuoteQuoteAcceptanceCreateInput = {
  accepted: Scalars['Datetime']['input'];
  created?: InputMaybe<Scalars['Datetime']['input']>;
  email: Scalars['String']['input'];
  id?: InputMaybe<Scalars['UUID']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name: Scalars['String']['input'];
  quoteToQuoteId?: InputMaybe<FkQuoteAcceptanceQuoteInput>;
  voided?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The `quote` to be created by this mutation. */
export type FkQuoteAcceptanceQuoteQuoteCreateInput = {
  adjustment?: InputMaybe<Scalars['BigFloat']['input']>;
  agentMargin?: InputMaybe<Scalars['BigFloat']['input']>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  deposit?: InputMaybe<Scalars['BigFloat']['input']>;
  duration: Scalars['Int']['input'];
  emailsUsingId?: InputMaybe<FkEmailQuoteQuoteIdInverseInput>;
  exclusions?: InputMaybe<Scalars['String']['input']>;
  expires?: InputMaybe<Scalars['Datetime']['input']>;
  heroId?: InputMaybe<Scalars['UUID']['input']>;
  heroImageId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  inclusions?: InputMaybe<Scalars['String']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceQuoteQuoteIdInverseInput>;
  key?: InputMaybe<Scalars['String']['input']>;
  locked?: InputMaybe<Scalars['Datetime']['input']>;
  margin?: InputMaybe<Scalars['BigFloat']['input']>;
  mediaItemToHeroImageId?: InputMaybe<FkQuoteMediaItemHeroImageIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  quoteAcceptancesUsingId?: InputMaybe<FkQuoteAcceptanceQuoteInverseInput>;
  quoteAccommodationDetailsUsingId?: InputMaybe<FkQuoteAccommodationDetailQuoteQuoteIdInverseInput>;
  quoteCurrenciesUsingId?: InputMaybe<FkQuoteCurrencyQuoteQuoteIdInverseInput>;
  quoteDaysUsingId?: InputMaybe<FkQuoteDayQuoteQuoteIdInverseInput>;
  quoteFinanceLineItemsUsingId?: InputMaybe<FkQuoteFinanceLineItemQuoteQuoteIdInverseInput>;
  quoteHeroToHeroId?: InputMaybe<FkQuoteQuoteHeroHeroIdInput>;
  quoteLegalDocumentsUsingId?: InputMaybe<FkQuoteLegalDocumentQuoteInverseInput>;
  quoteStatusToStatus?: InputMaybe<FkQuoteStatusInput>;
  quoteViewsUsingId?: InputMaybe<FkQuoteViewQuoteQuoteIdInverseInput>;
  shortDescription?: InputMaybe<Scalars['String']['input']>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  travellerCount?: InputMaybe<Scalars['Int']['input']>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkQuoteTripTripIdInput>;
  tripsUsingId?: InputMaybe<FkTripQuoteActiveQuoteIdInverseInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkQuoteUserUserIdInput>;
};

/** Input for the nested mutation of `property` in the `QuoteAccommodationDetailInput` mutation. */
export type FkQuoteAccommodationDetailPropertyPropertyIdInput = {
  /** The primary key(s) for `property` for the far side of the relationship. */
  connectById?: InputMaybe<PropertyPkPropertyConnect>;
  /** A `PropertyInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkQuoteAccommodationDetailPropertyPropertyIdPropertyCreateInput>;
  /** The primary key(s) for `property` for the far side of the relationship. */
  deleteById?: InputMaybe<PropertyPkPropertyDelete>;
  /** The primary key(s) and patch data for `property` for the far side of the relationship. */
  updateById?: InputMaybe<PropertyOnQuoteAccommodationDetailForFkQuoteAccommodationDetailPropertyPropertyIdUsingPkPropertyUpdate>;
};

/** Input for the nested mutation of `quoteAccommodationDetail` in the `PropertyInput` mutation. */
export type FkQuoteAccommodationDetailPropertyPropertyIdInverseInput = {
  /** The primary key(s) for `quoteAccommodationDetail` for the far side of the relationship. */
  connectById?: InputMaybe<Array<QuoteAccommodationDetailPkQuoteAccommodationDetailConnect>>;
  /** A `QuoteAccommodationDetailInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkQuoteAccommodationDetailPropertyPropertyIdQuoteAccommodationDetailCreateInput>>;
  /** The primary key(s) for `quoteAccommodationDetail` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<QuoteAccommodationDetailPkQuoteAccommodationDetailDelete>>;
  /** Flag indicating whether all other `quoteAccommodationDetail` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `quoteAccommodationDetail` for the far side of the relationship. */
  updateById?: InputMaybe<Array<QuoteAccommodationDetailOnQuoteAccommodationDetailForFkQuoteAccommodationDetailPropertyPropertyIdUsingPkQuoteAccommodationDetailUpdate>>;
};

/** The `property` to be created by this mutation. */
export type FkQuoteAccommodationDetailPropertyPropertyIdPropertyCreateInput = {
  alias?: InputMaybe<Scalars['String']['input']>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  contactNumber?: InputMaybe<Scalars['String']['input']>;
  countryId?: InputMaybe<Scalars['UUID']['input']>;
  countryToCountryId?: InputMaybe<FkPropertyCountryCountryIdInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationId?: InputMaybe<Scalars['UUID']['input']>;
  destinationToDestinationId?: InputMaybe<FkPropertyDestinationInput>;
  externalReference?: InputMaybe<Scalars['String']['input']>;
  featureCopy?: InputMaybe<Scalars['String']['input']>;
  featured?: InputMaybe<Scalars['Datetime']['input']>;
  galleryId?: InputMaybe<Scalars['UUID']['input']>;
  heroMediaId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  latitude?: InputMaybe<Scalars['Float']['input']>;
  longitude?: InputMaybe<Scalars['Float']['input']>;
  mapPointId?: InputMaybe<Scalars['UUID']['input']>;
  mapPointToMapPointId?: InputMaybe<FkPropertyMapPointMapPointIdInput>;
  mediaGalleryToGalleryId?: InputMaybe<FkPropertyMediaGalleryGalleryIdInput>;
  mediaItemToHeroMediaId?: InputMaybe<FkPropertyMediaItemHeroMediaIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  nearestAirport?: InputMaybe<Scalars['String']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  plusCode?: InputMaybe<Scalars['String']['input']>;
  quoteAccommodationDetailsUsingId?: InputMaybe<FkQuoteAccommodationDetailPropertyPropertyIdInverseInput>;
  quoteDaysUsingId?: InputMaybe<QuoteDayPropertyIdFkeyInverseInput>;
  region?: InputMaybe<Scalars['String']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  timezone?: InputMaybe<Scalars['String']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
};

/** The `quoteAccommodationDetail` to be created by this mutation. */
export type FkQuoteAccommodationDetailPropertyPropertyIdQuoteAccommodationDetailCreateInput = {
  basis?: InputMaybe<Scalars['String']['input']>;
  beverageInclusions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  confirmation?: InputMaybe<Scalars['String']['input']>;
  foodInclusions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  nights: Scalars['Int']['input'];
  notes?: InputMaybe<Scalars['String']['input']>;
  propertyToPropertyId?: InputMaybe<FkQuoteAccommodationDetailPropertyPropertyIdInput>;
  quoteDaysUsingId?: InputMaybe<FkQuoteDayQuoteAccommodationDetailAccommodationIdInverseInput>;
  quoteId?: InputMaybe<Scalars['UUID']['input']>;
  quotePublic?: InputMaybe<FakePublicQuoteAccommodationDetailForeignKey0Input>;
  quoteToQuoteId?: InputMaybe<FkQuoteAccommodationDetailQuoteQuoteIdInput>;
  roomType?: InputMaybe<Scalars['String']['input']>;
  sortOrder: Scalars['Int']['input'];
  summary?: InputMaybe<Scalars['String']['input']>;
};

/** Input for the nested mutation of `quote` in the `QuoteAccommodationDetailInput` mutation. */
export type FkQuoteAccommodationDetailQuoteQuoteIdInput = {
  /** The primary key(s) for `quote` for the far side of the relationship. */
  connectById?: InputMaybe<QuotePkQuoteConnect>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  connectByKey?: InputMaybe<QuoteUqQuoteKeyConnect>;
  /** A `QuoteInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkQuoteAccommodationDetailQuoteQuoteIdQuoteCreateInput>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  deleteById?: InputMaybe<QuotePkQuoteDelete>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  deleteByKey?: InputMaybe<QuoteUqQuoteKeyDelete>;
  /** The primary key(s) and patch data for `quote` for the far side of the relationship. */
  updateById?: InputMaybe<QuoteOnQuoteAccommodationDetailForFkQuoteAccommodationDetailQuoteQuoteIdUsingPkQuoteUpdate>;
  /** The primary key(s) and patch data for `quote` for the far side of the relationship. */
  updateByKey?: InputMaybe<QuoteOnQuoteAccommodationDetailForFkQuoteAccommodationDetailQuoteQuoteIdUsingUqQuoteKeyUpdate>;
};

/** Input for the nested mutation of `quoteAccommodationDetail` in the `QuoteInput` mutation. */
export type FkQuoteAccommodationDetailQuoteQuoteIdInverseInput = {
  /** The primary key(s) for `quoteAccommodationDetail` for the far side of the relationship. */
  connectById?: InputMaybe<Array<QuoteAccommodationDetailPkQuoteAccommodationDetailConnect>>;
  /** A `QuoteAccommodationDetailInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkQuoteAccommodationDetailQuoteQuoteIdQuoteAccommodationDetailCreateInput>>;
  /** The primary key(s) for `quoteAccommodationDetail` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<QuoteAccommodationDetailPkQuoteAccommodationDetailDelete>>;
  /** Flag indicating whether all other `quoteAccommodationDetail` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `quoteAccommodationDetail` for the far side of the relationship. */
  updateById?: InputMaybe<Array<QuoteAccommodationDetailOnQuoteAccommodationDetailForFkQuoteAccommodationDetailQuoteQuoteIdUsingPkQuoteAccommodationDetailUpdate>>;
};

/** The `quoteAccommodationDetail` to be created by this mutation. */
export type FkQuoteAccommodationDetailQuoteQuoteIdQuoteAccommodationDetailCreateInput = {
  basis?: InputMaybe<Scalars['String']['input']>;
  beverageInclusions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  confirmation?: InputMaybe<Scalars['String']['input']>;
  foodInclusions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  nights: Scalars['Int']['input'];
  notes?: InputMaybe<Scalars['String']['input']>;
  propertyId?: InputMaybe<Scalars['UUID']['input']>;
  propertyToPropertyId?: InputMaybe<FkQuoteAccommodationDetailPropertyPropertyIdInput>;
  quoteDaysUsingId?: InputMaybe<FkQuoteDayQuoteAccommodationDetailAccommodationIdInverseInput>;
  quotePublic?: InputMaybe<FakePublicQuoteAccommodationDetailForeignKey0Input>;
  quoteToQuoteId?: InputMaybe<FkQuoteAccommodationDetailQuoteQuoteIdInput>;
  roomType?: InputMaybe<Scalars['String']['input']>;
  sortOrder: Scalars['Int']['input'];
  summary?: InputMaybe<Scalars['String']['input']>;
};

/** The `quote` to be created by this mutation. */
export type FkQuoteAccommodationDetailQuoteQuoteIdQuoteCreateInput = {
  adjustment?: InputMaybe<Scalars['BigFloat']['input']>;
  agentMargin?: InputMaybe<Scalars['BigFloat']['input']>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  deposit?: InputMaybe<Scalars['BigFloat']['input']>;
  duration: Scalars['Int']['input'];
  emailsUsingId?: InputMaybe<FkEmailQuoteQuoteIdInverseInput>;
  exclusions?: InputMaybe<Scalars['String']['input']>;
  expires?: InputMaybe<Scalars['Datetime']['input']>;
  heroId?: InputMaybe<Scalars['UUID']['input']>;
  heroImageId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  inclusions?: InputMaybe<Scalars['String']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceQuoteQuoteIdInverseInput>;
  key?: InputMaybe<Scalars['String']['input']>;
  locked?: InputMaybe<Scalars['Datetime']['input']>;
  margin?: InputMaybe<Scalars['BigFloat']['input']>;
  mediaItemToHeroImageId?: InputMaybe<FkQuoteMediaItemHeroImageIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  quoteAcceptancesUsingId?: InputMaybe<FkQuoteAcceptanceQuoteInverseInput>;
  quoteAccommodationDetailsUsingId?: InputMaybe<FkQuoteAccommodationDetailQuoteQuoteIdInverseInput>;
  quoteCurrenciesUsingId?: InputMaybe<FkQuoteCurrencyQuoteQuoteIdInverseInput>;
  quoteDaysUsingId?: InputMaybe<FkQuoteDayQuoteQuoteIdInverseInput>;
  quoteFinanceLineItemsUsingId?: InputMaybe<FkQuoteFinanceLineItemQuoteQuoteIdInverseInput>;
  quoteHeroToHeroId?: InputMaybe<FkQuoteQuoteHeroHeroIdInput>;
  quoteLegalDocumentsUsingId?: InputMaybe<FkQuoteLegalDocumentQuoteInverseInput>;
  quoteStatusToStatus?: InputMaybe<FkQuoteStatusInput>;
  quoteViewsUsingId?: InputMaybe<FkQuoteViewQuoteQuoteIdInverseInput>;
  shortDescription?: InputMaybe<Scalars['String']['input']>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  travellerCount?: InputMaybe<Scalars['Int']['input']>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkQuoteTripTripIdInput>;
  tripsUsingId?: InputMaybe<FkTripQuoteActiveQuoteIdInverseInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkQuoteUserUserIdInput>;
};

/** Input for the nested mutation of `quote` in the `QuoteCurrencyInput` mutation. */
export type FkQuoteCurrencyQuoteQuoteIdInput = {
  /** The primary key(s) for `quote` for the far side of the relationship. */
  connectById?: InputMaybe<QuotePkQuoteConnect>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  connectByKey?: InputMaybe<QuoteUqQuoteKeyConnect>;
  /** A `QuoteInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkQuoteCurrencyQuoteQuoteIdQuoteCreateInput>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  deleteById?: InputMaybe<QuotePkQuoteDelete>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  deleteByKey?: InputMaybe<QuoteUqQuoteKeyDelete>;
  /** The primary key(s) and patch data for `quote` for the far side of the relationship. */
  updateById?: InputMaybe<QuoteOnQuoteCurrencyForFkQuoteCurrencyQuoteQuoteIdUsingPkQuoteUpdate>;
  /** The primary key(s) and patch data for `quote` for the far side of the relationship. */
  updateByKey?: InputMaybe<QuoteOnQuoteCurrencyForFkQuoteCurrencyQuoteQuoteIdUsingUqQuoteKeyUpdate>;
};

/** Input for the nested mutation of `quoteCurrency` in the `QuoteInput` mutation. */
export type FkQuoteCurrencyQuoteQuoteIdInverseInput = {
  /** The primary key(s) for `quoteCurrency` for the far side of the relationship. */
  connectById?: InputMaybe<Array<QuoteCurrencyPkQuoteCurrencyConnect>>;
  /** A `QuoteCurrencyInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkQuoteCurrencyQuoteQuoteIdQuoteCurrencyCreateInput>>;
  /** The primary key(s) for `quoteCurrency` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<QuoteCurrencyPkQuoteCurrencyDelete>>;
  /** Flag indicating whether all other `quoteCurrency` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `quoteCurrency` for the far side of the relationship. */
  updateById?: InputMaybe<Array<QuoteCurrencyOnQuoteCurrencyForFkQuoteCurrencyQuoteQuoteIdUsingPkQuoteCurrencyUpdate>>;
};

/** The `quote` to be created by this mutation. */
export type FkQuoteCurrencyQuoteQuoteIdQuoteCreateInput = {
  adjustment?: InputMaybe<Scalars['BigFloat']['input']>;
  agentMargin?: InputMaybe<Scalars['BigFloat']['input']>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  deposit?: InputMaybe<Scalars['BigFloat']['input']>;
  duration: Scalars['Int']['input'];
  emailsUsingId?: InputMaybe<FkEmailQuoteQuoteIdInverseInput>;
  exclusions?: InputMaybe<Scalars['String']['input']>;
  expires?: InputMaybe<Scalars['Datetime']['input']>;
  heroId?: InputMaybe<Scalars['UUID']['input']>;
  heroImageId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  inclusions?: InputMaybe<Scalars['String']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceQuoteQuoteIdInverseInput>;
  key?: InputMaybe<Scalars['String']['input']>;
  locked?: InputMaybe<Scalars['Datetime']['input']>;
  margin?: InputMaybe<Scalars['BigFloat']['input']>;
  mediaItemToHeroImageId?: InputMaybe<FkQuoteMediaItemHeroImageIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  quoteAcceptancesUsingId?: InputMaybe<FkQuoteAcceptanceQuoteInverseInput>;
  quoteAccommodationDetailsUsingId?: InputMaybe<FkQuoteAccommodationDetailQuoteQuoteIdInverseInput>;
  quoteCurrenciesUsingId?: InputMaybe<FkQuoteCurrencyQuoteQuoteIdInverseInput>;
  quoteDaysUsingId?: InputMaybe<FkQuoteDayQuoteQuoteIdInverseInput>;
  quoteFinanceLineItemsUsingId?: InputMaybe<FkQuoteFinanceLineItemQuoteQuoteIdInverseInput>;
  quoteHeroToHeroId?: InputMaybe<FkQuoteQuoteHeroHeroIdInput>;
  quoteLegalDocumentsUsingId?: InputMaybe<FkQuoteLegalDocumentQuoteInverseInput>;
  quoteStatusToStatus?: InputMaybe<FkQuoteStatusInput>;
  quoteViewsUsingId?: InputMaybe<FkQuoteViewQuoteQuoteIdInverseInput>;
  shortDescription?: InputMaybe<Scalars['String']['input']>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  travellerCount?: InputMaybe<Scalars['Int']['input']>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkQuoteTripTripIdInput>;
  tripsUsingId?: InputMaybe<FkTripQuoteActiveQuoteIdInverseInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkQuoteUserUserIdInput>;
};

/** The `quoteCurrency` to be created by this mutation. */
export type FkQuoteCurrencyQuoteQuoteIdQuoteCurrencyCreateInput = {
  code?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  quoteToQuoteId?: InputMaybe<FkQuoteCurrencyQuoteQuoteIdInput>;
  rate: Scalars['BigFloat']['input'];
};

/** The `destination` to be created by this mutation. */
export type FkQuoteDayDestinationDestinationDestinationIdDestinationCreateInput = {
  alias: Scalars['String']['input'];
  body?: InputMaybe<Scalars['String']['input']>;
  countryId?: InputMaybe<Scalars['UUID']['input']>;
  countryToCountryId?: InputMaybe<FkDestinationCountryCountryIdInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationFeaturesUsingId?: InputMaybe<FkDestinationFeatureDestinationDestinationIdInverseInput>;
  destinationGuidesUsingId?: InputMaybe<FkDestinationGuideDestinationDestinationIdInverseInput>;
  destinationToParentId?: InputMaybe<FkDestinationDestinationParentIdInput>;
  galleryId?: InputMaybe<Scalars['UUID']['input']>;
  heroMediaId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  latitude?: InputMaybe<Scalars['Float']['input']>;
  longitude?: InputMaybe<Scalars['Float']['input']>;
  mediaGalleryToGalleryId?: InputMaybe<FkDestinationMediaGalleryGalleryIdInput>;
  mediaItemToHeroMediaId?: InputMaybe<DestinationHeroMediaIdFkeyInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  parentId?: InputMaybe<Scalars['UUID']['input']>;
  propertiesUsingId?: InputMaybe<FkPropertyDestinationInverseInput>;
  quoteDayDestinationsUsingId?: InputMaybe<FkQuoteDayDestinationDestinationDestinationIdInverseInput>;
};

/** Input for the nested mutation of `destination` in the `QuoteDayDestinationInput` mutation. */
export type FkQuoteDayDestinationDestinationDestinationIdInput = {
  /** The primary key(s) for `destination` for the far side of the relationship. */
  connectByCountryIdAndAlias?: InputMaybe<DestinationUqDestinationAliasConnect>;
  /** The primary key(s) for `destination` for the far side of the relationship. */
  connectById?: InputMaybe<DestinationPkDestinationConnect>;
  /** A `DestinationInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkQuoteDayDestinationDestinationDestinationIdDestinationCreateInput>;
  /** The primary key(s) for `destination` for the far side of the relationship. */
  deleteByCountryIdAndAlias?: InputMaybe<DestinationUqDestinationAliasDelete>;
  /** The primary key(s) for `destination` for the far side of the relationship. */
  deleteById?: InputMaybe<DestinationPkDestinationDelete>;
  /** The primary key(s) and patch data for `destination` for the far side of the relationship. */
  updateByCountryIdAndAlias?: InputMaybe<DestinationOnQuoteDayDestinationForFkQuoteDayDestinationDestinationDestinationIdUsingUqDestinationAliasUpdate>;
  /** The primary key(s) and patch data for `destination` for the far side of the relationship. */
  updateById?: InputMaybe<DestinationOnQuoteDayDestinationForFkQuoteDayDestinationDestinationDestinationIdUsingPkDestinationUpdate>;
};

/** Input for the nested mutation of `quoteDayDestination` in the `DestinationInput` mutation. */
export type FkQuoteDayDestinationDestinationDestinationIdInverseInput = {
  /** The primary key(s) for `quoteDayDestination` for the far side of the relationship. */
  connectById?: InputMaybe<Array<QuoteDayDestinationPkQuoteDayDestinationConnect>>;
  /** A `QuoteDayDestinationInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkQuoteDayDestinationDestinationDestinationIdQuoteDayDestinationCreateInput>>;
  /** The primary key(s) for `quoteDayDestination` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<QuoteDayDestinationPkQuoteDayDestinationDelete>>;
  /** Flag indicating whether all other `quoteDayDestination` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `quoteDayDestination` for the far side of the relationship. */
  updateById?: InputMaybe<Array<QuoteDayDestinationOnQuoteDayDestinationForFkQuoteDayDestinationDestinationDestinationIdUsingPkQuoteDayDestinationUpdate>>;
};

/** The `quoteDayDestination` to be created by this mutation. */
export type FkQuoteDayDestinationDestinationDestinationIdQuoteDayDestinationCreateInput = {
  dayId?: InputMaybe<Scalars['UUID']['input']>;
  destinationToDestinationId?: InputMaybe<FkQuoteDayDestinationDestinationDestinationIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  quoteDayToDayId?: InputMaybe<FkQuoteDayDestinationQuoteDayDayIdInput>;
  sortOrder: Scalars['Int']['input'];
};

/** Input for the nested mutation of `quoteDay` in the `QuoteDayDestinationInput` mutation. */
export type FkQuoteDayDestinationQuoteDayDayIdInput = {
  /** The primary key(s) for `quoteDay` for the far side of the relationship. */
  connectById?: InputMaybe<QuoteDayPkQuoteDayConnect>;
  /** A `QuoteDayInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkQuoteDayDestinationQuoteDayDayIdQuoteDayCreateInput>;
  /** The primary key(s) for `quoteDay` for the far side of the relationship. */
  deleteById?: InputMaybe<QuoteDayPkQuoteDayDelete>;
  /** The primary key(s) and patch data for `quoteDay` for the far side of the relationship. */
  updateById?: InputMaybe<QuoteDayOnQuoteDayDestinationForFkQuoteDayDestinationQuoteDayDayIdUsingPkQuoteDayUpdate>;
};

/** Input for the nested mutation of `quoteDayDestination` in the `QuoteDayInput` mutation. */
export type FkQuoteDayDestinationQuoteDayDayIdInverseInput = {
  /** The primary key(s) for `quoteDayDestination` for the far side of the relationship. */
  connectById?: InputMaybe<Array<QuoteDayDestinationPkQuoteDayDestinationConnect>>;
  /** A `QuoteDayDestinationInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkQuoteDayDestinationQuoteDayDayIdQuoteDayDestinationCreateInput>>;
  /** The primary key(s) for `quoteDayDestination` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<QuoteDayDestinationPkQuoteDayDestinationDelete>>;
  /** Flag indicating whether all other `quoteDayDestination` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `quoteDayDestination` for the far side of the relationship. */
  updateById?: InputMaybe<Array<QuoteDayDestinationOnQuoteDayDestinationForFkQuoteDayDestinationQuoteDayDayIdUsingPkQuoteDayDestinationUpdate>>;
};

/** The `quoteDay` to be created by this mutation. */
export type FkQuoteDayDestinationQuoteDayDayIdQuoteDayCreateInput = {
  accommodationId?: InputMaybe<Scalars['UUID']['input']>;
  activityDetail?: InputMaybe<Scalars['String']['input']>;
  activitySummary?: InputMaybe<Scalars['String']['input']>;
  date?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  propertyId?: InputMaybe<Scalars['UUID']['input']>;
  propertyToPropertyId?: InputMaybe<QuoteDayPropertyIdFkeyInput>;
  quoteAccommodationDetailToAccommodationId?: InputMaybe<FkQuoteDayQuoteAccommodationDetailAccommodationIdInput>;
  quoteDayDestinationsUsingId?: InputMaybe<FkQuoteDayDestinationQuoteDayDayIdInverseInput>;
  quoteId?: InputMaybe<Scalars['UUID']['input']>;
  quotePublic?: InputMaybe<FakePublicQuoteDayForeignKey0Input>;
  quoteToQuoteId?: InputMaybe<FkQuoteDayQuoteQuoteIdInput>;
  sortOrder: Scalars['Int']['input'];
};

/** The `quoteDayDestination` to be created by this mutation. */
export type FkQuoteDayDestinationQuoteDayDayIdQuoteDayDestinationCreateInput = {
  destinationId?: InputMaybe<Scalars['UUID']['input']>;
  destinationToDestinationId?: InputMaybe<FkQuoteDayDestinationDestinationDestinationIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  quoteDayToDayId?: InputMaybe<FkQuoteDayDestinationQuoteDayDayIdInput>;
  sortOrder: Scalars['Int']['input'];
};

/** Input for the nested mutation of `quoteAccommodationDetail` in the `QuoteDayInput` mutation. */
export type FkQuoteDayQuoteAccommodationDetailAccommodationIdInput = {
  /** The primary key(s) for `quoteAccommodationDetail` for the far side of the relationship. */
  connectById?: InputMaybe<QuoteAccommodationDetailPkQuoteAccommodationDetailConnect>;
  /** A `QuoteAccommodationDetailInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkQuoteDayQuoteAccommodationDetailAccommodationIdQuoteAccommodationDetailCreateInput>;
  /** The primary key(s) for `quoteAccommodationDetail` for the far side of the relationship. */
  deleteById?: InputMaybe<QuoteAccommodationDetailPkQuoteAccommodationDetailDelete>;
  /** The primary key(s) and patch data for `quoteAccommodationDetail` for the far side of the relationship. */
  updateById?: InputMaybe<QuoteAccommodationDetailOnQuoteDayForFkQuoteDayQuoteAccommodationDetailAccommodationIdUsingPkQuoteAccommodationDetailUpdate>;
};

/** Input for the nested mutation of `quoteDay` in the `QuoteAccommodationDetailInput` mutation. */
export type FkQuoteDayQuoteAccommodationDetailAccommodationIdInverseInput = {
  /** The primary key(s) for `quoteDay` for the far side of the relationship. */
  connectById?: InputMaybe<Array<QuoteDayPkQuoteDayConnect>>;
  /** A `QuoteDayInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkQuoteDayQuoteAccommodationDetailAccommodationIdQuoteDayCreateInput>>;
  /** The primary key(s) for `quoteDay` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<QuoteDayPkQuoteDayDelete>>;
  /** Flag indicating whether all other `quoteDay` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `quoteDay` for the far side of the relationship. */
  updateById?: InputMaybe<Array<QuoteDayOnQuoteDayForFkQuoteDayQuoteAccommodationDetailAccommodationIdUsingPkQuoteDayUpdate>>;
};

/** The `quoteAccommodationDetail` to be created by this mutation. */
export type FkQuoteDayQuoteAccommodationDetailAccommodationIdQuoteAccommodationDetailCreateInput = {
  basis?: InputMaybe<Scalars['String']['input']>;
  beverageInclusions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  confirmation?: InputMaybe<Scalars['String']['input']>;
  foodInclusions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  nights: Scalars['Int']['input'];
  notes?: InputMaybe<Scalars['String']['input']>;
  propertyId?: InputMaybe<Scalars['UUID']['input']>;
  propertyToPropertyId?: InputMaybe<FkQuoteAccommodationDetailPropertyPropertyIdInput>;
  quoteDaysUsingId?: InputMaybe<FkQuoteDayQuoteAccommodationDetailAccommodationIdInverseInput>;
  quoteId?: InputMaybe<Scalars['UUID']['input']>;
  quotePublic?: InputMaybe<FakePublicQuoteAccommodationDetailForeignKey0Input>;
  quoteToQuoteId?: InputMaybe<FkQuoteAccommodationDetailQuoteQuoteIdInput>;
  roomType?: InputMaybe<Scalars['String']['input']>;
  sortOrder: Scalars['Int']['input'];
  summary?: InputMaybe<Scalars['String']['input']>;
};

/** The `quoteDay` to be created by this mutation. */
export type FkQuoteDayQuoteAccommodationDetailAccommodationIdQuoteDayCreateInput = {
  activityDetail?: InputMaybe<Scalars['String']['input']>;
  activitySummary?: InputMaybe<Scalars['String']['input']>;
  date?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  propertyId?: InputMaybe<Scalars['UUID']['input']>;
  propertyToPropertyId?: InputMaybe<QuoteDayPropertyIdFkeyInput>;
  quoteAccommodationDetailToAccommodationId?: InputMaybe<FkQuoteDayQuoteAccommodationDetailAccommodationIdInput>;
  quoteDayDestinationsUsingId?: InputMaybe<FkQuoteDayDestinationQuoteDayDayIdInverseInput>;
  quoteId?: InputMaybe<Scalars['UUID']['input']>;
  quotePublic?: InputMaybe<FakePublicQuoteDayForeignKey0Input>;
  quoteToQuoteId?: InputMaybe<FkQuoteDayQuoteQuoteIdInput>;
  sortOrder: Scalars['Int']['input'];
};

/** Input for the nested mutation of `quote` in the `QuoteDayInput` mutation. */
export type FkQuoteDayQuoteQuoteIdInput = {
  /** The primary key(s) for `quote` for the far side of the relationship. */
  connectById?: InputMaybe<QuotePkQuoteConnect>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  connectByKey?: InputMaybe<QuoteUqQuoteKeyConnect>;
  /** A `QuoteInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkQuoteDayQuoteQuoteIdQuoteCreateInput>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  deleteById?: InputMaybe<QuotePkQuoteDelete>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  deleteByKey?: InputMaybe<QuoteUqQuoteKeyDelete>;
  /** The primary key(s) and patch data for `quote` for the far side of the relationship. */
  updateById?: InputMaybe<QuoteOnQuoteDayForFkQuoteDayQuoteQuoteIdUsingPkQuoteUpdate>;
  /** The primary key(s) and patch data for `quote` for the far side of the relationship. */
  updateByKey?: InputMaybe<QuoteOnQuoteDayForFkQuoteDayQuoteQuoteIdUsingUqQuoteKeyUpdate>;
};

/** Input for the nested mutation of `quoteDay` in the `QuoteInput` mutation. */
export type FkQuoteDayQuoteQuoteIdInverseInput = {
  /** The primary key(s) for `quoteDay` for the far side of the relationship. */
  connectById?: InputMaybe<Array<QuoteDayPkQuoteDayConnect>>;
  /** A `QuoteDayInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkQuoteDayQuoteQuoteIdQuoteDayCreateInput>>;
  /** The primary key(s) for `quoteDay` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<QuoteDayPkQuoteDayDelete>>;
  /** Flag indicating whether all other `quoteDay` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `quoteDay` for the far side of the relationship. */
  updateById?: InputMaybe<Array<QuoteDayOnQuoteDayForFkQuoteDayQuoteQuoteIdUsingPkQuoteDayUpdate>>;
};

/** The `quote` to be created by this mutation. */
export type FkQuoteDayQuoteQuoteIdQuoteCreateInput = {
  adjustment?: InputMaybe<Scalars['BigFloat']['input']>;
  agentMargin?: InputMaybe<Scalars['BigFloat']['input']>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  deposit?: InputMaybe<Scalars['BigFloat']['input']>;
  duration: Scalars['Int']['input'];
  emailsUsingId?: InputMaybe<FkEmailQuoteQuoteIdInverseInput>;
  exclusions?: InputMaybe<Scalars['String']['input']>;
  expires?: InputMaybe<Scalars['Datetime']['input']>;
  heroId?: InputMaybe<Scalars['UUID']['input']>;
  heroImageId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  inclusions?: InputMaybe<Scalars['String']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceQuoteQuoteIdInverseInput>;
  key?: InputMaybe<Scalars['String']['input']>;
  locked?: InputMaybe<Scalars['Datetime']['input']>;
  margin?: InputMaybe<Scalars['BigFloat']['input']>;
  mediaItemToHeroImageId?: InputMaybe<FkQuoteMediaItemHeroImageIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  quoteAcceptancesUsingId?: InputMaybe<FkQuoteAcceptanceQuoteInverseInput>;
  quoteAccommodationDetailsUsingId?: InputMaybe<FkQuoteAccommodationDetailQuoteQuoteIdInverseInput>;
  quoteCurrenciesUsingId?: InputMaybe<FkQuoteCurrencyQuoteQuoteIdInverseInput>;
  quoteDaysUsingId?: InputMaybe<FkQuoteDayQuoteQuoteIdInverseInput>;
  quoteFinanceLineItemsUsingId?: InputMaybe<FkQuoteFinanceLineItemQuoteQuoteIdInverseInput>;
  quoteHeroToHeroId?: InputMaybe<FkQuoteQuoteHeroHeroIdInput>;
  quoteLegalDocumentsUsingId?: InputMaybe<FkQuoteLegalDocumentQuoteInverseInput>;
  quoteStatusToStatus?: InputMaybe<FkQuoteStatusInput>;
  quoteViewsUsingId?: InputMaybe<FkQuoteViewQuoteQuoteIdInverseInput>;
  shortDescription?: InputMaybe<Scalars['String']['input']>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  travellerCount?: InputMaybe<Scalars['Int']['input']>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkQuoteTripTripIdInput>;
  tripsUsingId?: InputMaybe<FkTripQuoteActiveQuoteIdInverseInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkQuoteUserUserIdInput>;
};

/** The `quoteDay` to be created by this mutation. */
export type FkQuoteDayQuoteQuoteIdQuoteDayCreateInput = {
  accommodationId?: InputMaybe<Scalars['UUID']['input']>;
  activityDetail?: InputMaybe<Scalars['String']['input']>;
  activitySummary?: InputMaybe<Scalars['String']['input']>;
  date?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  propertyId?: InputMaybe<Scalars['UUID']['input']>;
  propertyToPropertyId?: InputMaybe<QuoteDayPropertyIdFkeyInput>;
  quoteAccommodationDetailToAccommodationId?: InputMaybe<FkQuoteDayQuoteAccommodationDetailAccommodationIdInput>;
  quoteDayDestinationsUsingId?: InputMaybe<FkQuoteDayDestinationQuoteDayDayIdInverseInput>;
  quotePublic?: InputMaybe<FakePublicQuoteDayForeignKey0Input>;
  quoteToQuoteId?: InputMaybe<FkQuoteDayQuoteQuoteIdInput>;
  sortOrder: Scalars['Int']['input'];
};

/** Input for the nested mutation of `quote` in the `QuoteFinanceLineItemInput` mutation. */
export type FkQuoteFinanceLineItemQuoteQuoteIdInput = {
  /** The primary key(s) for `quote` for the far side of the relationship. */
  connectById?: InputMaybe<QuotePkQuoteConnect>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  connectByKey?: InputMaybe<QuoteUqQuoteKeyConnect>;
  /** A `QuoteInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkQuoteFinanceLineItemQuoteQuoteIdQuoteCreateInput>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  deleteById?: InputMaybe<QuotePkQuoteDelete>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  deleteByKey?: InputMaybe<QuoteUqQuoteKeyDelete>;
  /** The primary key(s) and patch data for `quote` for the far side of the relationship. */
  updateById?: InputMaybe<QuoteOnQuoteFinanceLineItemForFkQuoteFinanceLineItemQuoteQuoteIdUsingPkQuoteUpdate>;
  /** The primary key(s) and patch data for `quote` for the far side of the relationship. */
  updateByKey?: InputMaybe<QuoteOnQuoteFinanceLineItemForFkQuoteFinanceLineItemQuoteQuoteIdUsingUqQuoteKeyUpdate>;
};

/** Input for the nested mutation of `quoteFinanceLineItem` in the `QuoteInput` mutation. */
export type FkQuoteFinanceLineItemQuoteQuoteIdInverseInput = {
  /** The primary key(s) for `quoteFinanceLineItem` for the far side of the relationship. */
  connectById?: InputMaybe<Array<QuoteFinanceLineItemPkQuoteFinanceLineItemConnect>>;
  /** A `QuoteFinanceLineItemInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkQuoteFinanceLineItemQuoteQuoteIdQuoteFinanceLineItemCreateInput>>;
  /** The primary key(s) for `quoteFinanceLineItem` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<QuoteFinanceLineItemPkQuoteFinanceLineItemDelete>>;
  /** Flag indicating whether all other `quoteFinanceLineItem` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `quoteFinanceLineItem` for the far side of the relationship. */
  updateById?: InputMaybe<Array<QuoteFinanceLineItemOnQuoteFinanceLineItemForFkQuoteFinanceLineItemQuoteQuoteIdUsingPkQuoteFinanceLineItemUpdate>>;
};

/** The `quote` to be created by this mutation. */
export type FkQuoteFinanceLineItemQuoteQuoteIdQuoteCreateInput = {
  adjustment?: InputMaybe<Scalars['BigFloat']['input']>;
  agentMargin?: InputMaybe<Scalars['BigFloat']['input']>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  deposit?: InputMaybe<Scalars['BigFloat']['input']>;
  duration: Scalars['Int']['input'];
  emailsUsingId?: InputMaybe<FkEmailQuoteQuoteIdInverseInput>;
  exclusions?: InputMaybe<Scalars['String']['input']>;
  expires?: InputMaybe<Scalars['Datetime']['input']>;
  heroId?: InputMaybe<Scalars['UUID']['input']>;
  heroImageId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  inclusions?: InputMaybe<Scalars['String']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceQuoteQuoteIdInverseInput>;
  key?: InputMaybe<Scalars['String']['input']>;
  locked?: InputMaybe<Scalars['Datetime']['input']>;
  margin?: InputMaybe<Scalars['BigFloat']['input']>;
  mediaItemToHeroImageId?: InputMaybe<FkQuoteMediaItemHeroImageIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  quoteAcceptancesUsingId?: InputMaybe<FkQuoteAcceptanceQuoteInverseInput>;
  quoteAccommodationDetailsUsingId?: InputMaybe<FkQuoteAccommodationDetailQuoteQuoteIdInverseInput>;
  quoteCurrenciesUsingId?: InputMaybe<FkQuoteCurrencyQuoteQuoteIdInverseInput>;
  quoteDaysUsingId?: InputMaybe<FkQuoteDayQuoteQuoteIdInverseInput>;
  quoteFinanceLineItemsUsingId?: InputMaybe<FkQuoteFinanceLineItemQuoteQuoteIdInverseInput>;
  quoteHeroToHeroId?: InputMaybe<FkQuoteQuoteHeroHeroIdInput>;
  quoteLegalDocumentsUsingId?: InputMaybe<FkQuoteLegalDocumentQuoteInverseInput>;
  quoteStatusToStatus?: InputMaybe<FkQuoteStatusInput>;
  quoteViewsUsingId?: InputMaybe<FkQuoteViewQuoteQuoteIdInverseInput>;
  shortDescription?: InputMaybe<Scalars['String']['input']>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  travellerCount?: InputMaybe<Scalars['Int']['input']>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkQuoteTripTripIdInput>;
  tripsUsingId?: InputMaybe<FkTripQuoteActiveQuoteIdInverseInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkQuoteUserUserIdInput>;
};

/** The `quoteFinanceLineItem` to be created by this mutation. */
export type FkQuoteFinanceLineItemQuoteQuoteIdQuoteFinanceLineItemCreateInput = {
  amount: Scalars['BigFloat']['input'];
  confirmation?: InputMaybe<Scalars['String']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  excludeMargin?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  marginOverride?: InputMaybe<Scalars['BigFloat']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  quantity: Scalars['Int']['input'];
  quoteToQuoteId?: InputMaybe<FkQuoteFinanceLineItemQuoteQuoteIdInput>;
  sortOrder: Scalars['Int']['input'];
  supplierId?: InputMaybe<Scalars['UUID']['input']>;
  supplierToSupplierId?: InputMaybe<FkQuoteFinanceLineItemSupplierSupplierIdInput>;
};

/** Input for the nested mutation of `supplier` in the `QuoteFinanceLineItemInput` mutation. */
export type FkQuoteFinanceLineItemSupplierSupplierIdInput = {
  /** The primary key(s) for `supplier` for the far side of the relationship. */
  connectById?: InputMaybe<SupplierPkSupplierConnect>;
  /** A `SupplierInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkQuoteFinanceLineItemSupplierSupplierIdSupplierCreateInput>;
  /** The primary key(s) for `supplier` for the far side of the relationship. */
  deleteById?: InputMaybe<SupplierPkSupplierDelete>;
  /** The primary key(s) and patch data for `supplier` for the far side of the relationship. */
  updateById?: InputMaybe<SupplierOnQuoteFinanceLineItemForFkQuoteFinanceLineItemSupplierSupplierIdUsingPkSupplierUpdate>;
};

/** Input for the nested mutation of `quoteFinanceLineItem` in the `SupplierInput` mutation. */
export type FkQuoteFinanceLineItemSupplierSupplierIdInverseInput = {
  /** The primary key(s) for `quoteFinanceLineItem` for the far side of the relationship. */
  connectById?: InputMaybe<Array<QuoteFinanceLineItemPkQuoteFinanceLineItemConnect>>;
  /** A `QuoteFinanceLineItemInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkQuoteFinanceLineItemSupplierSupplierIdQuoteFinanceLineItemCreateInput>>;
  /** The primary key(s) for `quoteFinanceLineItem` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<QuoteFinanceLineItemPkQuoteFinanceLineItemDelete>>;
  /** Flag indicating whether all other `quoteFinanceLineItem` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `quoteFinanceLineItem` for the far side of the relationship. */
  updateById?: InputMaybe<Array<QuoteFinanceLineItemOnQuoteFinanceLineItemForFkQuoteFinanceLineItemSupplierSupplierIdUsingPkQuoteFinanceLineItemUpdate>>;
};

/** The `quoteFinanceLineItem` to be created by this mutation. */
export type FkQuoteFinanceLineItemSupplierSupplierIdQuoteFinanceLineItemCreateInput = {
  amount: Scalars['BigFloat']['input'];
  confirmation?: InputMaybe<Scalars['String']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  excludeMargin?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  marginOverride?: InputMaybe<Scalars['BigFloat']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  quantity: Scalars['Int']['input'];
  quoteId?: InputMaybe<Scalars['UUID']['input']>;
  quoteToQuoteId?: InputMaybe<FkQuoteFinanceLineItemQuoteQuoteIdInput>;
  sortOrder: Scalars['Int']['input'];
  supplierToSupplierId?: InputMaybe<FkQuoteFinanceLineItemSupplierSupplierIdInput>;
};

/** The `supplier` to be created by this mutation. */
export type FkQuoteFinanceLineItemSupplierSupplierIdSupplierCreateInput = {
  agenciesUsingId?: InputMaybe<FkAgencySupplierInverseInput>;
  bankDetails?: InputMaybe<Scalars['String']['input']>;
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  contactNumber?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  expensesUsingId?: InputMaybe<FkExpenseSupplierSupplierIdInverseInput>;
  galleryId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryToGalleryId?: InputMaybe<FkSupplierMediaGalleryGalleryIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  quoteFinanceLineItemsUsingId?: InputMaybe<FkQuoteFinanceLineItemSupplierSupplierIdInverseInput>;
  region?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceSupplierSupplierIdInverseInput>;
  url?: InputMaybe<Scalars['String']['input']>;
};

/** Input for the nested mutation of `mediaItem` in the `QuoteHeroInput` mutation. */
export type FkQuoteHeroMediaItemImageIdInput = {
  /** The primary key(s) for `mediaItem` for the far side of the relationship. */
  connectById?: InputMaybe<MediaItemPkMediaItemConnect>;
  /** A `MediaItemInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkQuoteHeroMediaItemImageIdMediaItemCreateInput>;
  /** The primary key(s) for `mediaItem` for the far side of the relationship. */
  deleteById?: InputMaybe<MediaItemPkMediaItemDelete>;
  /** The primary key(s) and patch data for `mediaItem` for the far side of the relationship. */
  updateById?: InputMaybe<MediaItemOnQuoteHeroForFkQuoteHeroMediaItemImageIdUsingPkMediaItemUpdate>;
};

/** Input for the nested mutation of `quoteHero` in the `MediaItemInput` mutation. */
export type FkQuoteHeroMediaItemImageIdInverseInput = {
  /** The primary key(s) for `quoteHero` for the far side of the relationship. */
  connectById?: InputMaybe<Array<QuoteHeroPkQuoteHeroConnect>>;
  /** A `QuoteHeroInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkQuoteHeroMediaItemImageIdQuoteHeroCreateInput>>;
  /** The primary key(s) for `quoteHero` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<QuoteHeroPkQuoteHeroDelete>>;
  /** Flag indicating whether all other `quoteHero` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `quoteHero` for the far side of the relationship. */
  updateById?: InputMaybe<Array<QuoteHeroOnQuoteHeroForFkQuoteHeroMediaItemImageIdUsingPkQuoteHeroUpdate>>;
};

/** The `mediaItem` to be created by this mutation. */
export type FkQuoteHeroMediaItemImageIdMediaItemCreateInput = {
  agenciesUsingId?: InputMaybe<FkAgencyMediaItemLogoIdInverseInput>;
  contentType?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationsUsingId?: InputMaybe<DestinationHeroMediaIdFkeyInverseInput>;
  fileName?: InputMaybe<Scalars['String']['input']>;
  hash?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryItemsUsingId?: InputMaybe<FkMediaGalleryItemMediaItemMediaItemIdInverseInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  propertiesUsingId?: InputMaybe<FkPropertyMediaItemHeroMediaIdInverseInput>;
  quoteHeroesUsingId?: InputMaybe<FkQuoteHeroMediaItemImageIdInverseInput>;
  quotesUsingId?: InputMaybe<FkQuoteMediaItemHeroImageIdInverseInput>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceMediaItemMediaItemIdInverseInput>;
};

/** The `quoteHero` to be created by this mutation. */
export type FkQuoteHeroMediaItemImageIdQuoteHeroCreateInput = {
  id?: InputMaybe<Scalars['UUID']['input']>;
  mediaItemToImageId?: InputMaybe<FkQuoteHeroMediaItemImageIdInput>;
  quotePublicsUsingId?: InputMaybe<FakePublicQuotePublicForeignKey1InverseInput>;
  quotesUsingId?: InputMaybe<FkQuoteQuoteHeroHeroIdInverseInput>;
  style?: InputMaybe<Scalars['String']['input']>;
  subtitle?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** Input for the nested mutation of `legalDocument` in the `QuoteLegalDocumentInput` mutation. */
export type FkQuoteLegalDocumentLegalDocumentInput = {
  /** The primary key(s) for `legalDocument` for the far side of the relationship. */
  connectById?: InputMaybe<LegalDocumentPkLegalDocumentConnect>;
  /** A `LegalDocumentInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkQuoteLegalDocumentLegalDocumentLegalDocumentCreateInput>;
  /** The primary key(s) for `legalDocument` for the far side of the relationship. */
  deleteById?: InputMaybe<LegalDocumentPkLegalDocumentDelete>;
  /** The primary key(s) and patch data for `legalDocument` for the far side of the relationship. */
  updateById?: InputMaybe<LegalDocumentOnQuoteLegalDocumentForFkQuoteLegalDocumentLegalDocumentUsingPkLegalDocumentUpdate>;
};

/** Input for the nested mutation of `quoteLegalDocument` in the `LegalDocumentInput` mutation. */
export type FkQuoteLegalDocumentLegalDocumentInverseInput = {
  /** The primary key(s) for `quoteLegalDocument` for the far side of the relationship. */
  connectById?: InputMaybe<Array<QuoteLegalDocumentPkQuoteLegalDocumentConnect>>;
  /** A `QuoteLegalDocumentInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkQuoteLegalDocumentLegalDocumentQuoteLegalDocumentCreateInput>>;
  /** The primary key(s) for `quoteLegalDocument` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<QuoteLegalDocumentPkQuoteLegalDocumentDelete>>;
  /** Flag indicating whether all other `quoteLegalDocument` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `quoteLegalDocument` for the far side of the relationship. */
  updateById?: InputMaybe<Array<QuoteLegalDocumentOnQuoteLegalDocumentForFkQuoteLegalDocumentLegalDocumentUsingPkQuoteLegalDocumentUpdate>>;
};

/** The `legalDocument` to be created by this mutation. */
export type FkQuoteLegalDocumentLegalDocumentLegalDocumentCreateInput = {
  body: Scalars['String']['input'];
  created?: InputMaybe<Scalars['Datetime']['input']>;
  folderId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  legalFolderToFolderId?: InputMaybe<FkLegalDocumentFolderInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name: Scalars['String']['input'];
  quoteLegalDocumentsUsingId?: InputMaybe<FkQuoteLegalDocumentLegalDocumentInverseInput>;
  validFrom?: InputMaybe<Scalars['Datetime']['input']>;
  validTo?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The `quoteLegalDocument` to be created by this mutation. */
export type FkQuoteLegalDocumentLegalDocumentQuoteLegalDocumentCreateInput = {
  id?: InputMaybe<Scalars['UUID']['input']>;
  legalDocumentToLegalDocumentId?: InputMaybe<FkQuoteLegalDocumentLegalDocumentInput>;
  quoteId?: InputMaybe<Scalars['UUID']['input']>;
  quotePublic?: InputMaybe<FakePublicQuoteLegalDocumentForeignKey0Input>;
  quoteToQuoteId?: InputMaybe<FkQuoteLegalDocumentQuoteInput>;
  sortOrder?: InputMaybe<Scalars['Int']['input']>;
};

/** Input for the nested mutation of `quote` in the `QuoteLegalDocumentInput` mutation. */
export type FkQuoteLegalDocumentQuoteInput = {
  /** The primary key(s) for `quote` for the far side of the relationship. */
  connectById?: InputMaybe<QuotePkQuoteConnect>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  connectByKey?: InputMaybe<QuoteUqQuoteKeyConnect>;
  /** A `QuoteInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkQuoteLegalDocumentQuoteQuoteCreateInput>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  deleteById?: InputMaybe<QuotePkQuoteDelete>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  deleteByKey?: InputMaybe<QuoteUqQuoteKeyDelete>;
  /** The primary key(s) and patch data for `quote` for the far side of the relationship. */
  updateById?: InputMaybe<QuoteOnQuoteLegalDocumentForFkQuoteLegalDocumentQuoteUsingPkQuoteUpdate>;
  /** The primary key(s) and patch data for `quote` for the far side of the relationship. */
  updateByKey?: InputMaybe<QuoteOnQuoteLegalDocumentForFkQuoteLegalDocumentQuoteUsingUqQuoteKeyUpdate>;
};

/** Input for the nested mutation of `quoteLegalDocument` in the `QuoteInput` mutation. */
export type FkQuoteLegalDocumentQuoteInverseInput = {
  /** The primary key(s) for `quoteLegalDocument` for the far side of the relationship. */
  connectById?: InputMaybe<Array<QuoteLegalDocumentPkQuoteLegalDocumentConnect>>;
  /** A `QuoteLegalDocumentInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkQuoteLegalDocumentQuoteQuoteLegalDocumentCreateInput>>;
  /** The primary key(s) for `quoteLegalDocument` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<QuoteLegalDocumentPkQuoteLegalDocumentDelete>>;
  /** Flag indicating whether all other `quoteLegalDocument` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `quoteLegalDocument` for the far side of the relationship. */
  updateById?: InputMaybe<Array<QuoteLegalDocumentOnQuoteLegalDocumentForFkQuoteLegalDocumentQuoteUsingPkQuoteLegalDocumentUpdate>>;
};

/** The `quote` to be created by this mutation. */
export type FkQuoteLegalDocumentQuoteQuoteCreateInput = {
  adjustment?: InputMaybe<Scalars['BigFloat']['input']>;
  agentMargin?: InputMaybe<Scalars['BigFloat']['input']>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  deposit?: InputMaybe<Scalars['BigFloat']['input']>;
  duration: Scalars['Int']['input'];
  emailsUsingId?: InputMaybe<FkEmailQuoteQuoteIdInverseInput>;
  exclusions?: InputMaybe<Scalars['String']['input']>;
  expires?: InputMaybe<Scalars['Datetime']['input']>;
  heroId?: InputMaybe<Scalars['UUID']['input']>;
  heroImageId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  inclusions?: InputMaybe<Scalars['String']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceQuoteQuoteIdInverseInput>;
  key?: InputMaybe<Scalars['String']['input']>;
  locked?: InputMaybe<Scalars['Datetime']['input']>;
  margin?: InputMaybe<Scalars['BigFloat']['input']>;
  mediaItemToHeroImageId?: InputMaybe<FkQuoteMediaItemHeroImageIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  quoteAcceptancesUsingId?: InputMaybe<FkQuoteAcceptanceQuoteInverseInput>;
  quoteAccommodationDetailsUsingId?: InputMaybe<FkQuoteAccommodationDetailQuoteQuoteIdInverseInput>;
  quoteCurrenciesUsingId?: InputMaybe<FkQuoteCurrencyQuoteQuoteIdInverseInput>;
  quoteDaysUsingId?: InputMaybe<FkQuoteDayQuoteQuoteIdInverseInput>;
  quoteFinanceLineItemsUsingId?: InputMaybe<FkQuoteFinanceLineItemQuoteQuoteIdInverseInput>;
  quoteHeroToHeroId?: InputMaybe<FkQuoteQuoteHeroHeroIdInput>;
  quoteLegalDocumentsUsingId?: InputMaybe<FkQuoteLegalDocumentQuoteInverseInput>;
  quoteStatusToStatus?: InputMaybe<FkQuoteStatusInput>;
  quoteViewsUsingId?: InputMaybe<FkQuoteViewQuoteQuoteIdInverseInput>;
  shortDescription?: InputMaybe<Scalars['String']['input']>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  travellerCount?: InputMaybe<Scalars['Int']['input']>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkQuoteTripTripIdInput>;
  tripsUsingId?: InputMaybe<FkTripQuoteActiveQuoteIdInverseInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkQuoteUserUserIdInput>;
};

/** The `quoteLegalDocument` to be created by this mutation. */
export type FkQuoteLegalDocumentQuoteQuoteLegalDocumentCreateInput = {
  id?: InputMaybe<Scalars['UUID']['input']>;
  legalDocumentId?: InputMaybe<Scalars['UUID']['input']>;
  legalDocumentToLegalDocumentId?: InputMaybe<FkQuoteLegalDocumentLegalDocumentInput>;
  quotePublic?: InputMaybe<FakePublicQuoteLegalDocumentForeignKey0Input>;
  quoteToQuoteId?: InputMaybe<FkQuoteLegalDocumentQuoteInput>;
  sortOrder?: InputMaybe<Scalars['Int']['input']>;
};

/** Input for the nested mutation of `mediaItem` in the `QuoteInput` mutation. */
export type FkQuoteMediaItemHeroImageIdInput = {
  /** The primary key(s) for `mediaItem` for the far side of the relationship. */
  connectById?: InputMaybe<MediaItemPkMediaItemConnect>;
  /** A `MediaItemInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkQuoteMediaItemHeroImageIdMediaItemCreateInput>;
  /** The primary key(s) for `mediaItem` for the far side of the relationship. */
  deleteById?: InputMaybe<MediaItemPkMediaItemDelete>;
  /** The primary key(s) and patch data for `mediaItem` for the far side of the relationship. */
  updateById?: InputMaybe<MediaItemOnQuoteForFkQuoteMediaItemHeroImageIdUsingPkMediaItemUpdate>;
};

/** Input for the nested mutation of `quote` in the `MediaItemInput` mutation. */
export type FkQuoteMediaItemHeroImageIdInverseInput = {
  /** The primary key(s) for `quote` for the far side of the relationship. */
  connectById?: InputMaybe<Array<QuotePkQuoteConnect>>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  connectByKey?: InputMaybe<Array<QuoteUqQuoteKeyConnect>>;
  /** A `QuoteInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkQuoteMediaItemHeroImageIdQuoteCreateInput>>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<QuotePkQuoteDelete>>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  deleteByKey?: InputMaybe<Array<QuoteUqQuoteKeyDelete>>;
  /** Flag indicating whether all other `quote` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `quote` for the far side of the relationship. */
  updateById?: InputMaybe<Array<QuoteOnQuoteForFkQuoteMediaItemHeroImageIdUsingPkQuoteUpdate>>;
  /** The primary key(s) and patch data for `quote` for the far side of the relationship. */
  updateByKey?: InputMaybe<Array<QuoteOnQuoteForFkQuoteMediaItemHeroImageIdUsingUqQuoteKeyUpdate>>;
};

/** The `mediaItem` to be created by this mutation. */
export type FkQuoteMediaItemHeroImageIdMediaItemCreateInput = {
  agenciesUsingId?: InputMaybe<FkAgencyMediaItemLogoIdInverseInput>;
  contentType?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationsUsingId?: InputMaybe<DestinationHeroMediaIdFkeyInverseInput>;
  fileName?: InputMaybe<Scalars['String']['input']>;
  hash?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryItemsUsingId?: InputMaybe<FkMediaGalleryItemMediaItemMediaItemIdInverseInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  propertiesUsingId?: InputMaybe<FkPropertyMediaItemHeroMediaIdInverseInput>;
  quoteHeroesUsingId?: InputMaybe<FkQuoteHeroMediaItemImageIdInverseInput>;
  quotesUsingId?: InputMaybe<FkQuoteMediaItemHeroImageIdInverseInput>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceMediaItemMediaItemIdInverseInput>;
};

/** The `quote` to be created by this mutation. */
export type FkQuoteMediaItemHeroImageIdQuoteCreateInput = {
  adjustment?: InputMaybe<Scalars['BigFloat']['input']>;
  agentMargin?: InputMaybe<Scalars['BigFloat']['input']>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  deposit?: InputMaybe<Scalars['BigFloat']['input']>;
  duration: Scalars['Int']['input'];
  emailsUsingId?: InputMaybe<FkEmailQuoteQuoteIdInverseInput>;
  exclusions?: InputMaybe<Scalars['String']['input']>;
  expires?: InputMaybe<Scalars['Datetime']['input']>;
  heroId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  inclusions?: InputMaybe<Scalars['String']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceQuoteQuoteIdInverseInput>;
  key?: InputMaybe<Scalars['String']['input']>;
  locked?: InputMaybe<Scalars['Datetime']['input']>;
  margin?: InputMaybe<Scalars['BigFloat']['input']>;
  mediaItemToHeroImageId?: InputMaybe<FkQuoteMediaItemHeroImageIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  quoteAcceptancesUsingId?: InputMaybe<FkQuoteAcceptanceQuoteInverseInput>;
  quoteAccommodationDetailsUsingId?: InputMaybe<FkQuoteAccommodationDetailQuoteQuoteIdInverseInput>;
  quoteCurrenciesUsingId?: InputMaybe<FkQuoteCurrencyQuoteQuoteIdInverseInput>;
  quoteDaysUsingId?: InputMaybe<FkQuoteDayQuoteQuoteIdInverseInput>;
  quoteFinanceLineItemsUsingId?: InputMaybe<FkQuoteFinanceLineItemQuoteQuoteIdInverseInput>;
  quoteHeroToHeroId?: InputMaybe<FkQuoteQuoteHeroHeroIdInput>;
  quoteLegalDocumentsUsingId?: InputMaybe<FkQuoteLegalDocumentQuoteInverseInput>;
  quoteStatusToStatus?: InputMaybe<FkQuoteStatusInput>;
  quoteViewsUsingId?: InputMaybe<FkQuoteViewQuoteQuoteIdInverseInput>;
  shortDescription?: InputMaybe<Scalars['String']['input']>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  travellerCount?: InputMaybe<Scalars['Int']['input']>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkQuoteTripTripIdInput>;
  tripsUsingId?: InputMaybe<FkTripQuoteActiveQuoteIdInverseInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkQuoteUserUserIdInput>;
};

/** Input for the nested mutation of `quoteHero` in the `QuoteInput` mutation. */
export type FkQuoteQuoteHeroHeroIdInput = {
  /** The primary key(s) for `quoteHero` for the far side of the relationship. */
  connectById?: InputMaybe<QuoteHeroPkQuoteHeroConnect>;
  /** A `QuoteHeroInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkQuoteQuoteHeroHeroIdQuoteHeroCreateInput>;
  /** The primary key(s) for `quoteHero` for the far side of the relationship. */
  deleteById?: InputMaybe<QuoteHeroPkQuoteHeroDelete>;
  /** The primary key(s) and patch data for `quoteHero` for the far side of the relationship. */
  updateById?: InputMaybe<QuoteHeroOnQuoteForFkQuoteQuoteHeroHeroIdUsingPkQuoteHeroUpdate>;
};

/** Input for the nested mutation of `quote` in the `QuoteHeroInput` mutation. */
export type FkQuoteQuoteHeroHeroIdInverseInput = {
  /** The primary key(s) for `quote` for the far side of the relationship. */
  connectById?: InputMaybe<Array<QuotePkQuoteConnect>>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  connectByKey?: InputMaybe<Array<QuoteUqQuoteKeyConnect>>;
  /** A `QuoteInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkQuoteQuoteHeroHeroIdQuoteCreateInput>>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<QuotePkQuoteDelete>>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  deleteByKey?: InputMaybe<Array<QuoteUqQuoteKeyDelete>>;
  /** Flag indicating whether all other `quote` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `quote` for the far side of the relationship. */
  updateById?: InputMaybe<Array<QuoteOnQuoteForFkQuoteQuoteHeroHeroIdUsingPkQuoteUpdate>>;
  /** The primary key(s) and patch data for `quote` for the far side of the relationship. */
  updateByKey?: InputMaybe<Array<QuoteOnQuoteForFkQuoteQuoteHeroHeroIdUsingUqQuoteKeyUpdate>>;
};

/** The `quote` to be created by this mutation. */
export type FkQuoteQuoteHeroHeroIdQuoteCreateInput = {
  adjustment?: InputMaybe<Scalars['BigFloat']['input']>;
  agentMargin?: InputMaybe<Scalars['BigFloat']['input']>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  deposit?: InputMaybe<Scalars['BigFloat']['input']>;
  duration: Scalars['Int']['input'];
  emailsUsingId?: InputMaybe<FkEmailQuoteQuoteIdInverseInput>;
  exclusions?: InputMaybe<Scalars['String']['input']>;
  expires?: InputMaybe<Scalars['Datetime']['input']>;
  heroImageId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  inclusions?: InputMaybe<Scalars['String']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceQuoteQuoteIdInverseInput>;
  key?: InputMaybe<Scalars['String']['input']>;
  locked?: InputMaybe<Scalars['Datetime']['input']>;
  margin?: InputMaybe<Scalars['BigFloat']['input']>;
  mediaItemToHeroImageId?: InputMaybe<FkQuoteMediaItemHeroImageIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  quoteAcceptancesUsingId?: InputMaybe<FkQuoteAcceptanceQuoteInverseInput>;
  quoteAccommodationDetailsUsingId?: InputMaybe<FkQuoteAccommodationDetailQuoteQuoteIdInverseInput>;
  quoteCurrenciesUsingId?: InputMaybe<FkQuoteCurrencyQuoteQuoteIdInverseInput>;
  quoteDaysUsingId?: InputMaybe<FkQuoteDayQuoteQuoteIdInverseInput>;
  quoteFinanceLineItemsUsingId?: InputMaybe<FkQuoteFinanceLineItemQuoteQuoteIdInverseInput>;
  quoteHeroToHeroId?: InputMaybe<FkQuoteQuoteHeroHeroIdInput>;
  quoteLegalDocumentsUsingId?: InputMaybe<FkQuoteLegalDocumentQuoteInverseInput>;
  quoteStatusToStatus?: InputMaybe<FkQuoteStatusInput>;
  quoteViewsUsingId?: InputMaybe<FkQuoteViewQuoteQuoteIdInverseInput>;
  shortDescription?: InputMaybe<Scalars['String']['input']>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  travellerCount?: InputMaybe<Scalars['Int']['input']>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkQuoteTripTripIdInput>;
  tripsUsingId?: InputMaybe<FkTripQuoteActiveQuoteIdInverseInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkQuoteUserUserIdInput>;
};

/** The `quoteHero` to be created by this mutation. */
export type FkQuoteQuoteHeroHeroIdQuoteHeroCreateInput = {
  id?: InputMaybe<Scalars['UUID']['input']>;
  imageId?: InputMaybe<Scalars['UUID']['input']>;
  mediaItemToImageId?: InputMaybe<FkQuoteHeroMediaItemImageIdInput>;
  quotePublicsUsingId?: InputMaybe<FakePublicQuotePublicForeignKey1InverseInput>;
  quotesUsingId?: InputMaybe<FkQuoteQuoteHeroHeroIdInverseInput>;
  style?: InputMaybe<Scalars['String']['input']>;
  subtitle?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** Input for the nested mutation of `quoteStatus` in the `QuoteInput` mutation. */
export type FkQuoteStatusInput = {
  /** The primary key(s) for `quoteStatus` for the far side of the relationship. */
  connectById?: InputMaybe<QuoteStatusPkQuoteStatusConnect>;
  /** A `QuoteStatusInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkQuoteStatusQuoteStatusCreateInput>;
  /** The primary key(s) for `quoteStatus` for the far side of the relationship. */
  deleteById?: InputMaybe<QuoteStatusPkQuoteStatusDelete>;
  /** The primary key(s) and patch data for `quoteStatus` for the far side of the relationship. */
  updateById?: InputMaybe<QuoteStatusOnQuoteForFkQuoteStatusUsingPkQuoteStatusUpdate>;
};

/** Input for the nested mutation of `quote` in the `QuoteStatusInput` mutation. */
export type FkQuoteStatusInverseInput = {
  /** The primary key(s) for `quote` for the far side of the relationship. */
  connectById?: InputMaybe<Array<QuotePkQuoteConnect>>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  connectByKey?: InputMaybe<Array<QuoteUqQuoteKeyConnect>>;
  /** A `QuoteInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkQuoteStatusQuoteCreateInput>>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<QuotePkQuoteDelete>>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  deleteByKey?: InputMaybe<Array<QuoteUqQuoteKeyDelete>>;
  /** Flag indicating whether all other `quote` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `quote` for the far side of the relationship. */
  updateById?: InputMaybe<Array<QuoteOnQuoteForFkQuoteStatusUsingPkQuoteUpdate>>;
  /** The primary key(s) and patch data for `quote` for the far side of the relationship. */
  updateByKey?: InputMaybe<Array<QuoteOnQuoteForFkQuoteStatusUsingUqQuoteKeyUpdate>>;
};

/** The `quote` to be created by this mutation. */
export type FkQuoteStatusQuoteCreateInput = {
  adjustment?: InputMaybe<Scalars['BigFloat']['input']>;
  agentMargin?: InputMaybe<Scalars['BigFloat']['input']>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  deposit?: InputMaybe<Scalars['BigFloat']['input']>;
  duration: Scalars['Int']['input'];
  emailsUsingId?: InputMaybe<FkEmailQuoteQuoteIdInverseInput>;
  exclusions?: InputMaybe<Scalars['String']['input']>;
  expires?: InputMaybe<Scalars['Datetime']['input']>;
  heroId?: InputMaybe<Scalars['UUID']['input']>;
  heroImageId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  inclusions?: InputMaybe<Scalars['String']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceQuoteQuoteIdInverseInput>;
  key?: InputMaybe<Scalars['String']['input']>;
  locked?: InputMaybe<Scalars['Datetime']['input']>;
  margin?: InputMaybe<Scalars['BigFloat']['input']>;
  mediaItemToHeroImageId?: InputMaybe<FkQuoteMediaItemHeroImageIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  quoteAcceptancesUsingId?: InputMaybe<FkQuoteAcceptanceQuoteInverseInput>;
  quoteAccommodationDetailsUsingId?: InputMaybe<FkQuoteAccommodationDetailQuoteQuoteIdInverseInput>;
  quoteCurrenciesUsingId?: InputMaybe<FkQuoteCurrencyQuoteQuoteIdInverseInput>;
  quoteDaysUsingId?: InputMaybe<FkQuoteDayQuoteQuoteIdInverseInput>;
  quoteFinanceLineItemsUsingId?: InputMaybe<FkQuoteFinanceLineItemQuoteQuoteIdInverseInput>;
  quoteHeroToHeroId?: InputMaybe<FkQuoteQuoteHeroHeroIdInput>;
  quoteLegalDocumentsUsingId?: InputMaybe<FkQuoteLegalDocumentQuoteInverseInput>;
  quoteStatusToStatus?: InputMaybe<FkQuoteStatusInput>;
  quoteViewsUsingId?: InputMaybe<FkQuoteViewQuoteQuoteIdInverseInput>;
  shortDescription?: InputMaybe<Scalars['String']['input']>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  travellerCount?: InputMaybe<Scalars['Int']['input']>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkQuoteTripTripIdInput>;
  tripsUsingId?: InputMaybe<FkTripQuoteActiveQuoteIdInverseInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkQuoteUserUserIdInput>;
};

/** The `quoteStatus` to be created by this mutation. */
export type FkQuoteStatusQuoteStatusCreateInput = {
  id: Scalars['Int']['input'];
  name: Scalars['String']['input'];
  quotesUsingId?: InputMaybe<FkQuoteStatusInverseInput>;
};

/** Input for the nested mutation of `trip` in the `QuoteInput` mutation. */
export type FkQuoteTripTripIdInput = {
  /** The primary key(s) for `trip` for the far side of the relationship. */
  connectById?: InputMaybe<TripPkTripConnect>;
  /** A `TripInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkQuoteTripTripIdTripCreateInput>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  deleteById?: InputMaybe<TripPkTripDelete>;
  /** The primary key(s) and patch data for `trip` for the far side of the relationship. */
  updateById?: InputMaybe<TripOnQuoteForFkQuoteTripTripIdUsingPkTripUpdate>;
};

/** Input for the nested mutation of `quote` in the `TripInput` mutation. */
export type FkQuoteTripTripIdInverseInput = {
  /** The primary key(s) for `quote` for the far side of the relationship. */
  connectById?: InputMaybe<Array<QuotePkQuoteConnect>>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  connectByKey?: InputMaybe<Array<QuoteUqQuoteKeyConnect>>;
  /** A `QuoteInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkQuoteTripTripIdQuoteCreateInput>>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<QuotePkQuoteDelete>>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  deleteByKey?: InputMaybe<Array<QuoteUqQuoteKeyDelete>>;
  /** Flag indicating whether all other `quote` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `quote` for the far side of the relationship. */
  updateById?: InputMaybe<Array<QuoteOnQuoteForFkQuoteTripTripIdUsingPkQuoteUpdate>>;
  /** The primary key(s) and patch data for `quote` for the far side of the relationship. */
  updateByKey?: InputMaybe<Array<QuoteOnQuoteForFkQuoteTripTripIdUsingUqQuoteKeyUpdate>>;
};

/** The `quote` to be created by this mutation. */
export type FkQuoteTripTripIdQuoteCreateInput = {
  adjustment?: InputMaybe<Scalars['BigFloat']['input']>;
  agentMargin?: InputMaybe<Scalars['BigFloat']['input']>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  deposit?: InputMaybe<Scalars['BigFloat']['input']>;
  duration: Scalars['Int']['input'];
  emailsUsingId?: InputMaybe<FkEmailQuoteQuoteIdInverseInput>;
  exclusions?: InputMaybe<Scalars['String']['input']>;
  expires?: InputMaybe<Scalars['Datetime']['input']>;
  heroId?: InputMaybe<Scalars['UUID']['input']>;
  heroImageId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  inclusions?: InputMaybe<Scalars['String']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceQuoteQuoteIdInverseInput>;
  key?: InputMaybe<Scalars['String']['input']>;
  locked?: InputMaybe<Scalars['Datetime']['input']>;
  margin?: InputMaybe<Scalars['BigFloat']['input']>;
  mediaItemToHeroImageId?: InputMaybe<FkQuoteMediaItemHeroImageIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  quoteAcceptancesUsingId?: InputMaybe<FkQuoteAcceptanceQuoteInverseInput>;
  quoteAccommodationDetailsUsingId?: InputMaybe<FkQuoteAccommodationDetailQuoteQuoteIdInverseInput>;
  quoteCurrenciesUsingId?: InputMaybe<FkQuoteCurrencyQuoteQuoteIdInverseInput>;
  quoteDaysUsingId?: InputMaybe<FkQuoteDayQuoteQuoteIdInverseInput>;
  quoteFinanceLineItemsUsingId?: InputMaybe<FkQuoteFinanceLineItemQuoteQuoteIdInverseInput>;
  quoteHeroToHeroId?: InputMaybe<FkQuoteQuoteHeroHeroIdInput>;
  quoteLegalDocumentsUsingId?: InputMaybe<FkQuoteLegalDocumentQuoteInverseInput>;
  quoteStatusToStatus?: InputMaybe<FkQuoteStatusInput>;
  quoteViewsUsingId?: InputMaybe<FkQuoteViewQuoteQuoteIdInverseInput>;
  shortDescription?: InputMaybe<Scalars['String']['input']>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  travellerCount?: InputMaybe<Scalars['Int']['input']>;
  tripToTripId?: InputMaybe<FkQuoteTripTripIdInput>;
  tripsUsingId?: InputMaybe<FkTripQuoteActiveQuoteIdInverseInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkQuoteUserUserIdInput>;
};

/** The `trip` to be created by this mutation. */
export type FkQuoteTripTripIdTripCreateInput = {
  activeQuoteId?: InputMaybe<Scalars['UUID']['input']>;
  agencyId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberToAgencyMemberId?: InputMaybe<FkTripAgencyMemberAgencyMemberIdInput>;
  agencyToAgencyId?: InputMaybe<FkTripAgencyAgencyIdInput>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerId?: InputMaybe<Scalars['UUID']['input']>;
  customerToCustomerId?: InputMaybe<FkTripCustomerCustomerIdInput>;
  dates?: InputMaybe<Scalars['String']['input']>;
  destination?: InputMaybe<Scalars['String']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  emailsUsingId?: InputMaybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: InputMaybe<FkEnquiryTripTripIdInverseInput>;
  expensesUsingId?: InputMaybe<FkExpenseTripTripIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceTripTripIdInverseInput>;
  mediaGalleryId?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryToMediaGalleryId?: InputMaybe<FkTripMediaGalleryMediaGalleryIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notesUsingId?: InputMaybe<FkNoteTripTripIdInverseInput>;
  paymentsUsingId?: InputMaybe<FkPaymentTripTripIdInverseInput>;
  quotePublicsUsingId?: InputMaybe<FakePublicQuotePublicForeignKey0InverseInput>;
  quoteToActiveQuoteId?: InputMaybe<FkTripQuoteActiveQuoteIdInput>;
  quotesUsingId?: InputMaybe<FkQuoteTripTripIdInverseInput>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceTripTripIdInverseInput>;
  testimonialsUsingId?: InputMaybe<FkTestimonialTripTripIdInverseInput>;
  tripFlightsUsingId?: InputMaybe<FkTripFlightTripTripIdInverseInput>;
  tripTravellersUsingId?: InputMaybe<FkTripTravellerTripTripIdInverseInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkTripUserUserIdInput>;
};

/** Input for the nested mutation of `user` in the `QuoteInput` mutation. */
export type FkQuoteUserUserIdInput = {
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectById?: InputMaybe<UserPkUserConnect>;
  /** A `UserInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkQuoteUserUserIdUserCreateInput>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteById?: InputMaybe<UserPkUserDelete>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateById?: InputMaybe<UserOnQuoteForFkQuoteUserUserIdUsingPkUserUpdate>;
};

/** Input for the nested mutation of `quote` in the `UserInput` mutation. */
export type FkQuoteUserUserIdInverseInput = {
  /** The primary key(s) for `quote` for the far side of the relationship. */
  connectById?: InputMaybe<Array<QuotePkQuoteConnect>>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  connectByKey?: InputMaybe<Array<QuoteUqQuoteKeyConnect>>;
  /** A `QuoteInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkQuoteUserUserIdQuoteCreateInput>>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<QuotePkQuoteDelete>>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  deleteByKey?: InputMaybe<Array<QuoteUqQuoteKeyDelete>>;
  /** Flag indicating whether all other `quote` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `quote` for the far side of the relationship. */
  updateById?: InputMaybe<Array<QuoteOnQuoteForFkQuoteUserUserIdUsingPkQuoteUpdate>>;
  /** The primary key(s) and patch data for `quote` for the far side of the relationship. */
  updateByKey?: InputMaybe<Array<QuoteOnQuoteForFkQuoteUserUserIdUsingUqQuoteKeyUpdate>>;
};

/** The `quote` to be created by this mutation. */
export type FkQuoteUserUserIdQuoteCreateInput = {
  adjustment?: InputMaybe<Scalars['BigFloat']['input']>;
  agentMargin?: InputMaybe<Scalars['BigFloat']['input']>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  deposit?: InputMaybe<Scalars['BigFloat']['input']>;
  duration: Scalars['Int']['input'];
  emailsUsingId?: InputMaybe<FkEmailQuoteQuoteIdInverseInput>;
  exclusions?: InputMaybe<Scalars['String']['input']>;
  expires?: InputMaybe<Scalars['Datetime']['input']>;
  heroId?: InputMaybe<Scalars['UUID']['input']>;
  heroImageId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  inclusions?: InputMaybe<Scalars['String']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceQuoteQuoteIdInverseInput>;
  key?: InputMaybe<Scalars['String']['input']>;
  locked?: InputMaybe<Scalars['Datetime']['input']>;
  margin?: InputMaybe<Scalars['BigFloat']['input']>;
  mediaItemToHeroImageId?: InputMaybe<FkQuoteMediaItemHeroImageIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  quoteAcceptancesUsingId?: InputMaybe<FkQuoteAcceptanceQuoteInverseInput>;
  quoteAccommodationDetailsUsingId?: InputMaybe<FkQuoteAccommodationDetailQuoteQuoteIdInverseInput>;
  quoteCurrenciesUsingId?: InputMaybe<FkQuoteCurrencyQuoteQuoteIdInverseInput>;
  quoteDaysUsingId?: InputMaybe<FkQuoteDayQuoteQuoteIdInverseInput>;
  quoteFinanceLineItemsUsingId?: InputMaybe<FkQuoteFinanceLineItemQuoteQuoteIdInverseInput>;
  quoteHeroToHeroId?: InputMaybe<FkQuoteQuoteHeroHeroIdInput>;
  quoteLegalDocumentsUsingId?: InputMaybe<FkQuoteLegalDocumentQuoteInverseInput>;
  quoteStatusToStatus?: InputMaybe<FkQuoteStatusInput>;
  quoteViewsUsingId?: InputMaybe<FkQuoteViewQuoteQuoteIdInverseInput>;
  shortDescription?: InputMaybe<Scalars['String']['input']>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  travellerCount?: InputMaybe<Scalars['Int']['input']>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkQuoteTripTripIdInput>;
  tripsUsingId?: InputMaybe<FkTripQuoteActiveQuoteIdInverseInput>;
  userToUserId?: InputMaybe<FkQuoteUserUserIdInput>;
};

/** The `user` to be created by this mutation. */
export type FkQuoteUserUserIdUserCreateInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  emailsUsingId?: InputMaybe<FkEmailUserUserIdInverseInput>;
  externalId?: InputMaybe<Scalars['String']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  genderPreposition?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name: Scalars['String']['input'];
  notesUsingId?: InputMaybe<FkNoteUserUserIdInverseInput>;
  password?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  quotePublicsUsingId?: InputMaybe<FakePublicQuotePublicForeignKey2InverseInput>;
  quotesUsingId?: InputMaybe<FkQuoteUserUserIdInverseInput>;
  remindersUsingId?: InputMaybe<FkReminderUserUserIdInverseInput>;
  skype?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  transactionNotesUsingId?: InputMaybe<FkTransactionNoteUserUserIdInverseInput>;
  tripsUsingId?: InputMaybe<FkTripUserUserIdInverseInput>;
};

/** Input for the nested mutation of `quote` in the `QuoteViewInput` mutation. */
export type FkQuoteViewQuoteQuoteIdInput = {
  /** The primary key(s) for `quote` for the far side of the relationship. */
  connectById?: InputMaybe<QuotePkQuoteConnect>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  connectByKey?: InputMaybe<QuoteUqQuoteKeyConnect>;
  /** A `QuoteInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkQuoteViewQuoteQuoteIdQuoteCreateInput>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  deleteById?: InputMaybe<QuotePkQuoteDelete>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  deleteByKey?: InputMaybe<QuoteUqQuoteKeyDelete>;
  /** The primary key(s) and patch data for `quote` for the far side of the relationship. */
  updateById?: InputMaybe<QuoteOnQuoteViewForFkQuoteViewQuoteQuoteIdUsingPkQuoteUpdate>;
  /** The primary key(s) and patch data for `quote` for the far side of the relationship. */
  updateByKey?: InputMaybe<QuoteOnQuoteViewForFkQuoteViewQuoteQuoteIdUsingUqQuoteKeyUpdate>;
};

/** Input for the nested mutation of `quoteView` in the `QuoteInput` mutation. */
export type FkQuoteViewQuoteQuoteIdInverseInput = {
  /** The primary key(s) for `quoteView` for the far side of the relationship. */
  connectById?: InputMaybe<Array<QuoteViewPkQuoteViewConnect>>;
  /** A `QuoteViewInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkQuoteViewQuoteQuoteIdQuoteViewCreateInput>>;
  /** The primary key(s) for `quoteView` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<QuoteViewPkQuoteViewDelete>>;
  /** Flag indicating whether all other `quoteView` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `quoteView` for the far side of the relationship. */
  updateById?: InputMaybe<Array<QuoteViewOnQuoteViewForFkQuoteViewQuoteQuoteIdUsingPkQuoteViewUpdate>>;
};

/** The `quote` to be created by this mutation. */
export type FkQuoteViewQuoteQuoteIdQuoteCreateInput = {
  adjustment?: InputMaybe<Scalars['BigFloat']['input']>;
  agentMargin?: InputMaybe<Scalars['BigFloat']['input']>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  deposit?: InputMaybe<Scalars['BigFloat']['input']>;
  duration: Scalars['Int']['input'];
  emailsUsingId?: InputMaybe<FkEmailQuoteQuoteIdInverseInput>;
  exclusions?: InputMaybe<Scalars['String']['input']>;
  expires?: InputMaybe<Scalars['Datetime']['input']>;
  heroId?: InputMaybe<Scalars['UUID']['input']>;
  heroImageId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  inclusions?: InputMaybe<Scalars['String']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceQuoteQuoteIdInverseInput>;
  key?: InputMaybe<Scalars['String']['input']>;
  locked?: InputMaybe<Scalars['Datetime']['input']>;
  margin?: InputMaybe<Scalars['BigFloat']['input']>;
  mediaItemToHeroImageId?: InputMaybe<FkQuoteMediaItemHeroImageIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  quoteAcceptancesUsingId?: InputMaybe<FkQuoteAcceptanceQuoteInverseInput>;
  quoteAccommodationDetailsUsingId?: InputMaybe<FkQuoteAccommodationDetailQuoteQuoteIdInverseInput>;
  quoteCurrenciesUsingId?: InputMaybe<FkQuoteCurrencyQuoteQuoteIdInverseInput>;
  quoteDaysUsingId?: InputMaybe<FkQuoteDayQuoteQuoteIdInverseInput>;
  quoteFinanceLineItemsUsingId?: InputMaybe<FkQuoteFinanceLineItemQuoteQuoteIdInverseInput>;
  quoteHeroToHeroId?: InputMaybe<FkQuoteQuoteHeroHeroIdInput>;
  quoteLegalDocumentsUsingId?: InputMaybe<FkQuoteLegalDocumentQuoteInverseInput>;
  quoteStatusToStatus?: InputMaybe<FkQuoteStatusInput>;
  quoteViewsUsingId?: InputMaybe<FkQuoteViewQuoteQuoteIdInverseInput>;
  shortDescription?: InputMaybe<Scalars['String']['input']>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  travellerCount?: InputMaybe<Scalars['Int']['input']>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkQuoteTripTripIdInput>;
  tripsUsingId?: InputMaybe<FkTripQuoteActiveQuoteIdInverseInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkQuoteUserUserIdInput>;
};

/** The `quoteView` to be created by this mutation. */
export type FkQuoteViewQuoteQuoteIdQuoteViewCreateInput = {
  city?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  quoteToQuoteId?: InputMaybe<FkQuoteViewQuoteQuoteIdInput>;
  timezone?: InputMaybe<Scalars['String']['input']>;
  userIp?: InputMaybe<Scalars['String']['input']>;
  viewType?: InputMaybe<Scalars['String']['input']>;
};

/** Input for the nested mutation of `user` in the `ReminderInput` mutation. */
export type FkReminderUserUserIdInput = {
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectById?: InputMaybe<UserPkUserConnect>;
  /** A `UserInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkReminderUserUserIdUserCreateInput>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteById?: InputMaybe<UserPkUserDelete>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateById?: InputMaybe<UserOnReminderForFkReminderUserUserIdUsingPkUserUpdate>;
};

/** Input for the nested mutation of `reminder` in the `UserInput` mutation. */
export type FkReminderUserUserIdInverseInput = {
  /** The primary key(s) for `reminder` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ReminderPkReminderConnect>>;
  /** A `ReminderInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkReminderUserUserIdReminderCreateInput>>;
  /** The primary key(s) for `reminder` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ReminderPkReminderDelete>>;
  /** Flag indicating whether all other `reminder` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `reminder` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ReminderOnReminderForFkReminderUserUserIdUsingPkReminderUpdate>>;
};

/** The `reminder` to be created by this mutation. */
export type FkReminderUserUserIdReminderCreateInput = {
  body?: InputMaybe<Scalars['String']['input']>;
  date: Scalars['Datetime']['input'];
  id?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkReminderUserUserIdInput>;
};

/** The `user` to be created by this mutation. */
export type FkReminderUserUserIdUserCreateInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  emailsUsingId?: InputMaybe<FkEmailUserUserIdInverseInput>;
  externalId?: InputMaybe<Scalars['String']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  genderPreposition?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name: Scalars['String']['input'];
  notesUsingId?: InputMaybe<FkNoteUserUserIdInverseInput>;
  password?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  quotePublicsUsingId?: InputMaybe<FakePublicQuotePublicForeignKey2InverseInput>;
  quotesUsingId?: InputMaybe<FkQuoteUserUserIdInverseInput>;
  remindersUsingId?: InputMaybe<FkReminderUserUserIdInverseInput>;
  skype?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  transactionNotesUsingId?: InputMaybe<FkTransactionNoteUserUserIdInverseInput>;
  tripsUsingId?: InputMaybe<FkTripUserUserIdInverseInput>;
};

/** The `financeCategory` to be created by this mutation. */
export type FkSupplierInvoiceFinanceCategoryCategoryIdFinanceCategoryCreateInput = {
  code?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  expensesUsingId?: InputMaybe<FkExpenseFinanceCategoryCategoryIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceFinanceCategoryCategoryIdInverseInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  paymentsUsingId?: InputMaybe<FkPaymentFinanceCategoryCategoryIdInverseInput>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceFinanceCategoryCategoryIdInverseInput>;
  transactionsUsingId?: InputMaybe<FkTransactionFinanceCategoryCategoryIdInverseInput>;
  type?: InputMaybe<Scalars['Int']['input']>;
};

/** Input for the nested mutation of `financeCategory` in the `SupplierInvoiceInput` mutation. */
export type FkSupplierInvoiceFinanceCategoryCategoryIdInput = {
  /** The primary key(s) for `financeCategory` for the far side of the relationship. */
  connectById?: InputMaybe<FinanceCategoryPkFinanceCategoryConnect>;
  /** A `FinanceCategoryInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkSupplierInvoiceFinanceCategoryCategoryIdFinanceCategoryCreateInput>;
  /** The primary key(s) for `financeCategory` for the far side of the relationship. */
  deleteById?: InputMaybe<FinanceCategoryPkFinanceCategoryDelete>;
  /** The primary key(s) and patch data for `financeCategory` for the far side of the relationship. */
  updateById?: InputMaybe<FinanceCategoryOnSupplierInvoiceForFkSupplierInvoiceFinanceCategoryCategoryIdUsingPkFinanceCategoryUpdate>;
};

/** Input for the nested mutation of `supplierInvoice` in the `FinanceCategoryInput` mutation. */
export type FkSupplierInvoiceFinanceCategoryCategoryIdInverseInput = {
  /** The primary key(s) for `supplierInvoice` for the far side of the relationship. */
  connectById?: InputMaybe<Array<SupplierInvoicePkSupplierInvoiceConnect>>;
  /** A `SupplierInvoiceInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkSupplierInvoiceFinanceCategoryCategoryIdSupplierInvoiceCreateInput>>;
  /** The primary key(s) for `supplierInvoice` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<SupplierInvoicePkSupplierInvoiceDelete>>;
  /** Flag indicating whether all other `supplierInvoice` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `supplierInvoice` for the far side of the relationship. */
  updateById?: InputMaybe<Array<SupplierInvoiceOnSupplierInvoiceForFkSupplierInvoiceFinanceCategoryCategoryIdUsingPkSupplierInvoiceUpdate>>;
};

/** The `supplierInvoice` to be created by this mutation. */
export type FkSupplierInvoiceFinanceCategoryCategoryIdSupplierInvoiceCreateInput = {
  amount: Scalars['BigFloat']['input'];
  amountActual?: InputMaybe<Scalars['BigFloat']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  due: Scalars['Datetime']['input'];
  expensesUsingId?: InputMaybe<FkExpenseSupplierInvoiceSupplierInvoiceIdInverseInput>;
  financeCategoryToCategoryId?: InputMaybe<FkSupplierInvoiceFinanceCategoryCategoryIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  mediaItemId?: InputMaybe<Scalars['UUID']['input']>;
  mediaItemToMediaItemId?: InputMaybe<FkSupplierInvoiceMediaItemMediaItemIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  number?: InputMaybe<Scalars['Int']['input']>;
  paid?: InputMaybe<Scalars['Datetime']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierId?: InputMaybe<Scalars['UUID']['input']>;
  supplierToSupplierId?: InputMaybe<FkSupplierInvoiceSupplierSupplierIdInput>;
  transactionLinksUsingId?: InputMaybe<FkTransactionLinkSupplierInvoiceSupplierInvoiceIdInverseInput>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkSupplierInvoiceTripTripIdInput>;
  type?: InputMaybe<Scalars['String']['input']>;
  voided?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Input for the nested mutation of `mediaItem` in the `SupplierInvoiceInput` mutation. */
export type FkSupplierInvoiceMediaItemMediaItemIdInput = {
  /** The primary key(s) for `mediaItem` for the far side of the relationship. */
  connectById?: InputMaybe<MediaItemPkMediaItemConnect>;
  /** A `MediaItemInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkSupplierInvoiceMediaItemMediaItemIdMediaItemCreateInput>;
  /** The primary key(s) for `mediaItem` for the far side of the relationship. */
  deleteById?: InputMaybe<MediaItemPkMediaItemDelete>;
  /** The primary key(s) and patch data for `mediaItem` for the far side of the relationship. */
  updateById?: InputMaybe<MediaItemOnSupplierInvoiceForFkSupplierInvoiceMediaItemMediaItemIdUsingPkMediaItemUpdate>;
};

/** Input for the nested mutation of `supplierInvoice` in the `MediaItemInput` mutation. */
export type FkSupplierInvoiceMediaItemMediaItemIdInverseInput = {
  /** The primary key(s) for `supplierInvoice` for the far side of the relationship. */
  connectById?: InputMaybe<Array<SupplierInvoicePkSupplierInvoiceConnect>>;
  /** A `SupplierInvoiceInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkSupplierInvoiceMediaItemMediaItemIdSupplierInvoiceCreateInput>>;
  /** The primary key(s) for `supplierInvoice` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<SupplierInvoicePkSupplierInvoiceDelete>>;
  /** Flag indicating whether all other `supplierInvoice` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `supplierInvoice` for the far side of the relationship. */
  updateById?: InputMaybe<Array<SupplierInvoiceOnSupplierInvoiceForFkSupplierInvoiceMediaItemMediaItemIdUsingPkSupplierInvoiceUpdate>>;
};

/** The `mediaItem` to be created by this mutation. */
export type FkSupplierInvoiceMediaItemMediaItemIdMediaItemCreateInput = {
  agenciesUsingId?: InputMaybe<FkAgencyMediaItemLogoIdInverseInput>;
  contentType?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationsUsingId?: InputMaybe<DestinationHeroMediaIdFkeyInverseInput>;
  fileName?: InputMaybe<Scalars['String']['input']>;
  hash?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryItemsUsingId?: InputMaybe<FkMediaGalleryItemMediaItemMediaItemIdInverseInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  propertiesUsingId?: InputMaybe<FkPropertyMediaItemHeroMediaIdInverseInput>;
  quoteHeroesUsingId?: InputMaybe<FkQuoteHeroMediaItemImageIdInverseInput>;
  quotesUsingId?: InputMaybe<FkQuoteMediaItemHeroImageIdInverseInput>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceMediaItemMediaItemIdInverseInput>;
};

/** The `supplierInvoice` to be created by this mutation. */
export type FkSupplierInvoiceMediaItemMediaItemIdSupplierInvoiceCreateInput = {
  amount: Scalars['BigFloat']['input'];
  amountActual?: InputMaybe<Scalars['BigFloat']['input']>;
  categoryId?: InputMaybe<Scalars['UUID']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  due: Scalars['Datetime']['input'];
  expensesUsingId?: InputMaybe<FkExpenseSupplierInvoiceSupplierInvoiceIdInverseInput>;
  financeCategoryToCategoryId?: InputMaybe<FkSupplierInvoiceFinanceCategoryCategoryIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  mediaItemToMediaItemId?: InputMaybe<FkSupplierInvoiceMediaItemMediaItemIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  number?: InputMaybe<Scalars['Int']['input']>;
  paid?: InputMaybe<Scalars['Datetime']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierId?: InputMaybe<Scalars['UUID']['input']>;
  supplierToSupplierId?: InputMaybe<FkSupplierInvoiceSupplierSupplierIdInput>;
  transactionLinksUsingId?: InputMaybe<FkTransactionLinkSupplierInvoiceSupplierInvoiceIdInverseInput>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkSupplierInvoiceTripTripIdInput>;
  type?: InputMaybe<Scalars['String']['input']>;
  voided?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Input for the nested mutation of `supplier` in the `SupplierInvoiceInput` mutation. */
export type FkSupplierInvoiceSupplierSupplierIdInput = {
  /** The primary key(s) for `supplier` for the far side of the relationship. */
  connectById?: InputMaybe<SupplierPkSupplierConnect>;
  /** A `SupplierInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkSupplierInvoiceSupplierSupplierIdSupplierCreateInput>;
  /** The primary key(s) for `supplier` for the far side of the relationship. */
  deleteById?: InputMaybe<SupplierPkSupplierDelete>;
  /** The primary key(s) and patch data for `supplier` for the far side of the relationship. */
  updateById?: InputMaybe<SupplierOnSupplierInvoiceForFkSupplierInvoiceSupplierSupplierIdUsingPkSupplierUpdate>;
};

/** Input for the nested mutation of `supplierInvoice` in the `SupplierInput` mutation. */
export type FkSupplierInvoiceSupplierSupplierIdInverseInput = {
  /** The primary key(s) for `supplierInvoice` for the far side of the relationship. */
  connectById?: InputMaybe<Array<SupplierInvoicePkSupplierInvoiceConnect>>;
  /** A `SupplierInvoiceInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkSupplierInvoiceSupplierSupplierIdSupplierInvoiceCreateInput>>;
  /** The primary key(s) for `supplierInvoice` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<SupplierInvoicePkSupplierInvoiceDelete>>;
  /** Flag indicating whether all other `supplierInvoice` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `supplierInvoice` for the far side of the relationship. */
  updateById?: InputMaybe<Array<SupplierInvoiceOnSupplierInvoiceForFkSupplierInvoiceSupplierSupplierIdUsingPkSupplierInvoiceUpdate>>;
};

/** The `supplier` to be created by this mutation. */
export type FkSupplierInvoiceSupplierSupplierIdSupplierCreateInput = {
  agenciesUsingId?: InputMaybe<FkAgencySupplierInverseInput>;
  bankDetails?: InputMaybe<Scalars['String']['input']>;
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  contactNumber?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  expensesUsingId?: InputMaybe<FkExpenseSupplierSupplierIdInverseInput>;
  galleryId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryToGalleryId?: InputMaybe<FkSupplierMediaGalleryGalleryIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  quoteFinanceLineItemsUsingId?: InputMaybe<FkQuoteFinanceLineItemSupplierSupplierIdInverseInput>;
  region?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceSupplierSupplierIdInverseInput>;
  url?: InputMaybe<Scalars['String']['input']>;
};

/** The `supplierInvoice` to be created by this mutation. */
export type FkSupplierInvoiceSupplierSupplierIdSupplierInvoiceCreateInput = {
  amount: Scalars['BigFloat']['input'];
  amountActual?: InputMaybe<Scalars['BigFloat']['input']>;
  categoryId?: InputMaybe<Scalars['UUID']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  due: Scalars['Datetime']['input'];
  expensesUsingId?: InputMaybe<FkExpenseSupplierInvoiceSupplierInvoiceIdInverseInput>;
  financeCategoryToCategoryId?: InputMaybe<FkSupplierInvoiceFinanceCategoryCategoryIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  mediaItemId?: InputMaybe<Scalars['UUID']['input']>;
  mediaItemToMediaItemId?: InputMaybe<FkSupplierInvoiceMediaItemMediaItemIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  number?: InputMaybe<Scalars['Int']['input']>;
  paid?: InputMaybe<Scalars['Datetime']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierToSupplierId?: InputMaybe<FkSupplierInvoiceSupplierSupplierIdInput>;
  transactionLinksUsingId?: InputMaybe<FkTransactionLinkSupplierInvoiceSupplierInvoiceIdInverseInput>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkSupplierInvoiceTripTripIdInput>;
  type?: InputMaybe<Scalars['String']['input']>;
  voided?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Input for the nested mutation of `trip` in the `SupplierInvoiceInput` mutation. */
export type FkSupplierInvoiceTripTripIdInput = {
  /** The primary key(s) for `trip` for the far side of the relationship. */
  connectById?: InputMaybe<TripPkTripConnect>;
  /** A `TripInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkSupplierInvoiceTripTripIdTripCreateInput>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  deleteById?: InputMaybe<TripPkTripDelete>;
  /** The primary key(s) and patch data for `trip` for the far side of the relationship. */
  updateById?: InputMaybe<TripOnSupplierInvoiceForFkSupplierInvoiceTripTripIdUsingPkTripUpdate>;
};

/** Input for the nested mutation of `supplierInvoice` in the `TripInput` mutation. */
export type FkSupplierInvoiceTripTripIdInverseInput = {
  /** The primary key(s) for `supplierInvoice` for the far side of the relationship. */
  connectById?: InputMaybe<Array<SupplierInvoicePkSupplierInvoiceConnect>>;
  /** A `SupplierInvoiceInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkSupplierInvoiceTripTripIdSupplierInvoiceCreateInput>>;
  /** The primary key(s) for `supplierInvoice` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<SupplierInvoicePkSupplierInvoiceDelete>>;
  /** Flag indicating whether all other `supplierInvoice` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `supplierInvoice` for the far side of the relationship. */
  updateById?: InputMaybe<Array<SupplierInvoiceOnSupplierInvoiceForFkSupplierInvoiceTripTripIdUsingPkSupplierInvoiceUpdate>>;
};

/** The `supplierInvoice` to be created by this mutation. */
export type FkSupplierInvoiceTripTripIdSupplierInvoiceCreateInput = {
  amount: Scalars['BigFloat']['input'];
  amountActual?: InputMaybe<Scalars['BigFloat']['input']>;
  categoryId?: InputMaybe<Scalars['UUID']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  due: Scalars['Datetime']['input'];
  expensesUsingId?: InputMaybe<FkExpenseSupplierInvoiceSupplierInvoiceIdInverseInput>;
  financeCategoryToCategoryId?: InputMaybe<FkSupplierInvoiceFinanceCategoryCategoryIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  mediaItemId?: InputMaybe<Scalars['UUID']['input']>;
  mediaItemToMediaItemId?: InputMaybe<FkSupplierInvoiceMediaItemMediaItemIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  number?: InputMaybe<Scalars['Int']['input']>;
  paid?: InputMaybe<Scalars['Datetime']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierId?: InputMaybe<Scalars['UUID']['input']>;
  supplierToSupplierId?: InputMaybe<FkSupplierInvoiceSupplierSupplierIdInput>;
  transactionLinksUsingId?: InputMaybe<FkTransactionLinkSupplierInvoiceSupplierInvoiceIdInverseInput>;
  tripToTripId?: InputMaybe<FkSupplierInvoiceTripTripIdInput>;
  type?: InputMaybe<Scalars['String']['input']>;
  voided?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The `trip` to be created by this mutation. */
export type FkSupplierInvoiceTripTripIdTripCreateInput = {
  activeQuoteId?: InputMaybe<Scalars['UUID']['input']>;
  agencyId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberToAgencyMemberId?: InputMaybe<FkTripAgencyMemberAgencyMemberIdInput>;
  agencyToAgencyId?: InputMaybe<FkTripAgencyAgencyIdInput>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerId?: InputMaybe<Scalars['UUID']['input']>;
  customerToCustomerId?: InputMaybe<FkTripCustomerCustomerIdInput>;
  dates?: InputMaybe<Scalars['String']['input']>;
  destination?: InputMaybe<Scalars['String']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  emailsUsingId?: InputMaybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: InputMaybe<FkEnquiryTripTripIdInverseInput>;
  expensesUsingId?: InputMaybe<FkExpenseTripTripIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceTripTripIdInverseInput>;
  mediaGalleryId?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryToMediaGalleryId?: InputMaybe<FkTripMediaGalleryMediaGalleryIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notesUsingId?: InputMaybe<FkNoteTripTripIdInverseInput>;
  paymentsUsingId?: InputMaybe<FkPaymentTripTripIdInverseInput>;
  quotePublicsUsingId?: InputMaybe<FakePublicQuotePublicForeignKey0InverseInput>;
  quoteToActiveQuoteId?: InputMaybe<FkTripQuoteActiveQuoteIdInput>;
  quotesUsingId?: InputMaybe<FkQuoteTripTripIdInverseInput>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceTripTripIdInverseInput>;
  testimonialsUsingId?: InputMaybe<FkTestimonialTripTripIdInverseInput>;
  tripFlightsUsingId?: InputMaybe<FkTripFlightTripTripIdInverseInput>;
  tripTravellersUsingId?: InputMaybe<FkTripTravellerTripTripIdInverseInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkTripUserUserIdInput>;
};

/** Input for the nested mutation of `mediaGallery` in the `SupplierInput` mutation. */
export type FkSupplierMediaGalleryGalleryIdInput = {
  /** The primary key(s) for `mediaGallery` for the far side of the relationship. */
  connectById?: InputMaybe<MediaGalleryPkMediaGalleryConnect>;
  /** A `MediaGalleryInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkSupplierMediaGalleryGalleryIdMediaGalleryCreateInput>;
  /** The primary key(s) for `mediaGallery` for the far side of the relationship. */
  deleteById?: InputMaybe<MediaGalleryPkMediaGalleryDelete>;
  /** The primary key(s) and patch data for `mediaGallery` for the far side of the relationship. */
  updateById?: InputMaybe<MediaGalleryOnSupplierForFkSupplierMediaGalleryGalleryIdUsingPkMediaGalleryUpdate>;
};

/** Input for the nested mutation of `supplier` in the `MediaGalleryInput` mutation. */
export type FkSupplierMediaGalleryGalleryIdInverseInput = {
  /** The primary key(s) for `supplier` for the far side of the relationship. */
  connectById?: InputMaybe<Array<SupplierPkSupplierConnect>>;
  /** A `SupplierInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkSupplierMediaGalleryGalleryIdSupplierCreateInput>>;
  /** The primary key(s) for `supplier` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<SupplierPkSupplierDelete>>;
  /** Flag indicating whether all other `supplier` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `supplier` for the far side of the relationship. */
  updateById?: InputMaybe<Array<SupplierOnSupplierForFkSupplierMediaGalleryGalleryIdUsingPkSupplierUpdate>>;
};

/** The `mediaGallery` to be created by this mutation. */
export type FkSupplierMediaGalleryGalleryIdMediaGalleryCreateInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationFeaturesUsingId?: InputMaybe<FkDestinationFeatureMediaGalleryGalleryIdInverseInput>;
  destinationsUsingId?: InputMaybe<FkDestinationMediaGalleryGalleryIdInverseInput>;
  featuresUsingId?: InputMaybe<FkFeatureMediaGalleryGalleryIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  isProtected?: InputMaybe<Scalars['Boolean']['input']>;
  mediaGalleryItemsUsingId?: InputMaybe<FkMediaGalleryItemMediaGalleryMediaGalleryIdInverseInput>;
  mediaGalleryToParentId?: InputMaybe<FkMediaGalleryMediaGalleryParentIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  parentId?: InputMaybe<Scalars['UUID']['input']>;
  propertiesUsingId?: InputMaybe<FkPropertyMediaGalleryGalleryIdInverseInput>;
  suppliersUsingId?: InputMaybe<FkSupplierMediaGalleryGalleryIdInverseInput>;
  tripsUsingId?: InputMaybe<FkTripMediaGalleryMediaGalleryIdInverseInput>;
};

/** The `supplier` to be created by this mutation. */
export type FkSupplierMediaGalleryGalleryIdSupplierCreateInput = {
  agenciesUsingId?: InputMaybe<FkAgencySupplierInverseInput>;
  bankDetails?: InputMaybe<Scalars['String']['input']>;
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  contactNumber?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  expensesUsingId?: InputMaybe<FkExpenseSupplierSupplierIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryToGalleryId?: InputMaybe<FkSupplierMediaGalleryGalleryIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  quoteFinanceLineItemsUsingId?: InputMaybe<FkQuoteFinanceLineItemSupplierSupplierIdInverseInput>;
  region?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceSupplierSupplierIdInverseInput>;
  url?: InputMaybe<Scalars['String']['input']>;
};

/** Input for the nested mutation of `trip` in the `TestimonialInput` mutation. */
export type FkTestimonialTripTripIdInput = {
  /** The primary key(s) for `trip` for the far side of the relationship. */
  connectById?: InputMaybe<TripPkTripConnect>;
  /** A `TripInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkTestimonialTripTripIdTripCreateInput>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  deleteById?: InputMaybe<TripPkTripDelete>;
  /** The primary key(s) and patch data for `trip` for the far side of the relationship. */
  updateById?: InputMaybe<TripOnTestimonialForFkTestimonialTripTripIdUsingPkTripUpdate>;
};

/** Input for the nested mutation of `testimonial` in the `TripInput` mutation. */
export type FkTestimonialTripTripIdInverseInput = {
  /** The primary key(s) for `testimonial` for the far side of the relationship. */
  connectById?: InputMaybe<Array<TestimonialPkTestimonialConnect>>;
  /** A `TestimonialInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkTestimonialTripTripIdTestimonialCreateInput>>;
  /** The primary key(s) for `testimonial` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<TestimonialPkTestimonialDelete>>;
  /** Flag indicating whether all other `testimonial` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `testimonial` for the far side of the relationship. */
  updateById?: InputMaybe<Array<TestimonialOnTestimonialForFkTestimonialTripTripIdUsingPkTestimonialUpdate>>;
};

/** The `testimonial` to be created by this mutation. */
export type FkTestimonialTripTripIdTestimonialCreateInput = {
  body?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  guestName?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  tripToTripId?: InputMaybe<FkTestimonialTripTripIdInput>;
};

/** The `trip` to be created by this mutation. */
export type FkTestimonialTripTripIdTripCreateInput = {
  activeQuoteId?: InputMaybe<Scalars['UUID']['input']>;
  agencyId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberToAgencyMemberId?: InputMaybe<FkTripAgencyMemberAgencyMemberIdInput>;
  agencyToAgencyId?: InputMaybe<FkTripAgencyAgencyIdInput>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerId?: InputMaybe<Scalars['UUID']['input']>;
  customerToCustomerId?: InputMaybe<FkTripCustomerCustomerIdInput>;
  dates?: InputMaybe<Scalars['String']['input']>;
  destination?: InputMaybe<Scalars['String']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  emailsUsingId?: InputMaybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: InputMaybe<FkEnquiryTripTripIdInverseInput>;
  expensesUsingId?: InputMaybe<FkExpenseTripTripIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceTripTripIdInverseInput>;
  mediaGalleryId?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryToMediaGalleryId?: InputMaybe<FkTripMediaGalleryMediaGalleryIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notesUsingId?: InputMaybe<FkNoteTripTripIdInverseInput>;
  paymentsUsingId?: InputMaybe<FkPaymentTripTripIdInverseInput>;
  quotePublicsUsingId?: InputMaybe<FakePublicQuotePublicForeignKey0InverseInput>;
  quoteToActiveQuoteId?: InputMaybe<FkTripQuoteActiveQuoteIdInput>;
  quotesUsingId?: InputMaybe<FkQuoteTripTripIdInverseInput>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceTripTripIdInverseInput>;
  testimonialsUsingId?: InputMaybe<FkTestimonialTripTripIdInverseInput>;
  tripFlightsUsingId?: InputMaybe<FkTripFlightTripTripIdInverseInput>;
  tripTravellersUsingId?: InputMaybe<FkTripTravellerTripTripIdInverseInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkTripUserUserIdInput>;
};

/** The `account` to be created by this mutation. */
export type FkTransactionAccountAccountIdAccountCreateInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  details?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  institution?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  transactionImportBatchesUsingId?: InputMaybe<FkTransactionImportBatchAccountAccountIdInverseInput>;
  transactionsUsingId?: InputMaybe<FkTransactionAccountAccountIdInverseInput>;
};

/** Input for the nested mutation of `account` in the `TransactionInput` mutation. */
export type FkTransactionAccountAccountIdInput = {
  /** The primary key(s) for `account` for the far side of the relationship. */
  connectById?: InputMaybe<AccountPkAccountConnect>;
  /** A `AccountInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkTransactionAccountAccountIdAccountCreateInput>;
  /** The primary key(s) for `account` for the far side of the relationship. */
  deleteById?: InputMaybe<AccountPkAccountDelete>;
  /** The primary key(s) and patch data for `account` for the far side of the relationship. */
  updateById?: InputMaybe<AccountOnTransactionForFkTransactionAccountAccountIdUsingPkAccountUpdate>;
};

/** Input for the nested mutation of `transaction` in the `AccountInput` mutation. */
export type FkTransactionAccountAccountIdInverseInput = {
  /** The primary key(s) for `transaction` for the far side of the relationship. */
  connectById?: InputMaybe<Array<TransactionPkTransactionConnect>>;
  /** A `TransactionInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkTransactionAccountAccountIdTransactionCreateInput>>;
  /** The primary key(s) for `transaction` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<TransactionPkTransactionDelete>>;
  /** Flag indicating whether all other `transaction` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `transaction` for the far side of the relationship. */
  updateById?: InputMaybe<Array<TransactionOnTransactionForFkTransactionAccountAccountIdUsingPkTransactionUpdate>>;
};

/** The `transaction` to be created by this mutation. */
export type FkTransactionAccountAccountIdTransactionCreateInput = {
  accountToAccountId?: InputMaybe<FkTransactionAccountAccountIdInput>;
  amount: Scalars['BigFloat']['input'];
  balance?: InputMaybe<Scalars['BigFloat']['input']>;
  categoryId?: InputMaybe<Scalars['UUID']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  date: Scalars['Datetime']['input'];
  description?: InputMaybe<Scalars['String']['input']>;
  externalId?: InputMaybe<Scalars['String']['input']>;
  financeCategoryToCategoryId?: InputMaybe<FkTransactionFinanceCategoryCategoryIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  reverseTransactionId?: InputMaybe<Scalars['UUID']['input']>;
  source?: InputMaybe<Scalars['String']['input']>;
  status: Scalars['Int']['input'];
  transactionImportBatchId?: InputMaybe<Scalars['UUID']['input']>;
  transactionImportBatchToTransactionImportBatchId?: InputMaybe<FkTransactionTransactionImportBatchTransactionImportBatchIdInput>;
  transactionLinksUsingId?: InputMaybe<FkTransactionLinkTransactionTransactionIdInverseInput>;
  transactionNotesUsingId?: InputMaybe<FkTransactionNoteTransactionTransactionIdInverseInput>;
  transactionToReverseTransactionId?: InputMaybe<FkTransactionTransactionReverseTransactionIdInput>;
};

/** The `financeCategory` to be created by this mutation. */
export type FkTransactionFinanceCategoryCategoryIdFinanceCategoryCreateInput = {
  code?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  expensesUsingId?: InputMaybe<FkExpenseFinanceCategoryCategoryIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceFinanceCategoryCategoryIdInverseInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  paymentsUsingId?: InputMaybe<FkPaymentFinanceCategoryCategoryIdInverseInput>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceFinanceCategoryCategoryIdInverseInput>;
  transactionsUsingId?: InputMaybe<FkTransactionFinanceCategoryCategoryIdInverseInput>;
  type?: InputMaybe<Scalars['Int']['input']>;
};

/** Input for the nested mutation of `financeCategory` in the `TransactionInput` mutation. */
export type FkTransactionFinanceCategoryCategoryIdInput = {
  /** The primary key(s) for `financeCategory` for the far side of the relationship. */
  connectById?: InputMaybe<FinanceCategoryPkFinanceCategoryConnect>;
  /** A `FinanceCategoryInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkTransactionFinanceCategoryCategoryIdFinanceCategoryCreateInput>;
  /** The primary key(s) for `financeCategory` for the far side of the relationship. */
  deleteById?: InputMaybe<FinanceCategoryPkFinanceCategoryDelete>;
  /** The primary key(s) and patch data for `financeCategory` for the far side of the relationship. */
  updateById?: InputMaybe<FinanceCategoryOnTransactionForFkTransactionFinanceCategoryCategoryIdUsingPkFinanceCategoryUpdate>;
};

/** Input for the nested mutation of `transaction` in the `FinanceCategoryInput` mutation. */
export type FkTransactionFinanceCategoryCategoryIdInverseInput = {
  /** The primary key(s) for `transaction` for the far side of the relationship. */
  connectById?: InputMaybe<Array<TransactionPkTransactionConnect>>;
  /** A `TransactionInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkTransactionFinanceCategoryCategoryIdTransactionCreateInput>>;
  /** The primary key(s) for `transaction` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<TransactionPkTransactionDelete>>;
  /** Flag indicating whether all other `transaction` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `transaction` for the far side of the relationship. */
  updateById?: InputMaybe<Array<TransactionOnTransactionForFkTransactionFinanceCategoryCategoryIdUsingPkTransactionUpdate>>;
};

/** The `transaction` to be created by this mutation. */
export type FkTransactionFinanceCategoryCategoryIdTransactionCreateInput = {
  accountId?: InputMaybe<Scalars['UUID']['input']>;
  accountToAccountId?: InputMaybe<FkTransactionAccountAccountIdInput>;
  amount: Scalars['BigFloat']['input'];
  balance?: InputMaybe<Scalars['BigFloat']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  date: Scalars['Datetime']['input'];
  description?: InputMaybe<Scalars['String']['input']>;
  externalId?: InputMaybe<Scalars['String']['input']>;
  financeCategoryToCategoryId?: InputMaybe<FkTransactionFinanceCategoryCategoryIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  reverseTransactionId?: InputMaybe<Scalars['UUID']['input']>;
  source?: InputMaybe<Scalars['String']['input']>;
  status: Scalars['Int']['input'];
  transactionImportBatchId?: InputMaybe<Scalars['UUID']['input']>;
  transactionImportBatchToTransactionImportBatchId?: InputMaybe<FkTransactionTransactionImportBatchTransactionImportBatchIdInput>;
  transactionLinksUsingId?: InputMaybe<FkTransactionLinkTransactionTransactionIdInverseInput>;
  transactionNotesUsingId?: InputMaybe<FkTransactionNoteTransactionTransactionIdInverseInput>;
  transactionToReverseTransactionId?: InputMaybe<FkTransactionTransactionReverseTransactionIdInput>;
};

/** The `account` to be created by this mutation. */
export type FkTransactionImportBatchAccountAccountIdAccountCreateInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  details?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  institution?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  transactionImportBatchesUsingId?: InputMaybe<FkTransactionImportBatchAccountAccountIdInverseInput>;
  transactionsUsingId?: InputMaybe<FkTransactionAccountAccountIdInverseInput>;
};

/** Input for the nested mutation of `account` in the `TransactionImportBatchInput` mutation. */
export type FkTransactionImportBatchAccountAccountIdInput = {
  /** The primary key(s) for `account` for the far side of the relationship. */
  connectById?: InputMaybe<AccountPkAccountConnect>;
  /** A `AccountInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkTransactionImportBatchAccountAccountIdAccountCreateInput>;
  /** The primary key(s) for `account` for the far side of the relationship. */
  deleteById?: InputMaybe<AccountPkAccountDelete>;
  /** The primary key(s) and patch data for `account` for the far side of the relationship. */
  updateById?: InputMaybe<AccountOnTransactionImportBatchForFkTransactionImportBatchAccountAccountIdUsingPkAccountUpdate>;
};

/** Input for the nested mutation of `transactionImportBatch` in the `AccountInput` mutation. */
export type FkTransactionImportBatchAccountAccountIdInverseInput = {
  /** The primary key(s) for `transactionImportBatch` for the far side of the relationship. */
  connectById?: InputMaybe<Array<TransactionImportBatchPkTransactionImportBatchConnect>>;
  /** A `TransactionImportBatchInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkTransactionImportBatchAccountAccountIdTransactionImportBatchCreateInput>>;
  /** The primary key(s) for `transactionImportBatch` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<TransactionImportBatchPkTransactionImportBatchDelete>>;
  /** Flag indicating whether all other `transactionImportBatch` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `transactionImportBatch` for the far side of the relationship. */
  updateById?: InputMaybe<Array<TransactionImportBatchOnTransactionImportBatchForFkTransactionImportBatchAccountAccountIdUsingPkTransactionImportBatchUpdate>>;
};

/** The `transactionImportBatch` to be created by this mutation. */
export type FkTransactionImportBatchAccountAccountIdTransactionImportBatchCreateInput = {
  accountToAccountId?: InputMaybe<FkTransactionImportBatchAccountAccountIdInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  dateRangeMax: Scalars['Datetime']['input'];
  dateRangeMin: Scalars['Datetime']['input'];
  id?: InputMaybe<Scalars['UUID']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  transactionsUsingId?: InputMaybe<FkTransactionTransactionImportBatchTransactionImportBatchIdInverseInput>;
};

/** The `expense` to be created by this mutation. */
export type FkTransactionLinkExpenseExpenseIdExpenseCreateInput = {
  amount: Scalars['BigFloat']['input'];
  amountActual: Scalars['BigFloat']['input'];
  categoryId?: InputMaybe<Scalars['UUID']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  financeCategoryToCategoryId?: InputMaybe<FkExpenseFinanceCategoryCategoryIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoiceId?: InputMaybe<Scalars['UUID']['input']>;
  invoiceToInvoiceId?: InputMaybe<FkExpenseInvoiceInvoiceIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  paid: Scalars['Datetime']['input'];
  reference?: InputMaybe<Scalars['String']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierId?: InputMaybe<Scalars['UUID']['input']>;
  supplierInvoiceId?: InputMaybe<Scalars['UUID']['input']>;
  supplierInvoiceToSupplierInvoiceId?: InputMaybe<FkExpenseSupplierInvoiceSupplierInvoiceIdInput>;
  supplierToSupplierId?: InputMaybe<FkExpenseSupplierSupplierIdInput>;
  transactionLinksUsingId?: InputMaybe<FkTransactionLinkExpenseExpenseIdInverseInput>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkExpenseTripTripIdInput>;
};

/** Input for the nested mutation of `expense` in the `TransactionLinkInput` mutation. */
export type FkTransactionLinkExpenseExpenseIdInput = {
  /** The primary key(s) for `expense` for the far side of the relationship. */
  connectById?: InputMaybe<ExpensePkExpenseConnect>;
  /** A `ExpenseInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkTransactionLinkExpenseExpenseIdExpenseCreateInput>;
  /** The primary key(s) for `expense` for the far side of the relationship. */
  deleteById?: InputMaybe<ExpensePkExpenseDelete>;
  /** The primary key(s) and patch data for `expense` for the far side of the relationship. */
  updateById?: InputMaybe<ExpenseOnTransactionLinkForFkTransactionLinkExpenseExpenseIdUsingPkExpenseUpdate>;
};

/** Input for the nested mutation of `transactionLink` in the `ExpenseInput` mutation. */
export type FkTransactionLinkExpenseExpenseIdInverseInput = {
  /** The primary key(s) for `transactionLink` for the far side of the relationship. */
  connectById?: InputMaybe<Array<TransactionLinkPkTransactionLinkConnect>>;
  /** A `TransactionLinkInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkTransactionLinkExpenseExpenseIdTransactionLinkCreateInput>>;
  /** The primary key(s) for `transactionLink` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<TransactionLinkPkTransactionLinkDelete>>;
  /** Flag indicating whether all other `transactionLink` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `transactionLink` for the far side of the relationship. */
  updateById?: InputMaybe<Array<TransactionLinkOnTransactionLinkForFkTransactionLinkExpenseExpenseIdUsingPkTransactionLinkUpdate>>;
};

/** The `transactionLink` to be created by this mutation. */
export type FkTransactionLinkExpenseExpenseIdTransactionLinkCreateInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  expenseToExpenseId?: InputMaybe<FkTransactionLinkExpenseExpenseIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoiceId?: InputMaybe<Scalars['UUID']['input']>;
  invoiceToInvoiceId?: InputMaybe<FkTransactionLinkInvoiceInvoiceIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  paymentId?: InputMaybe<Scalars['UUID']['input']>;
  paymentToPaymentId?: InputMaybe<FkTransactionLinkPaymentPaymentIdInput>;
  status?: InputMaybe<Scalars['Int']['input']>;
  supplierInvoiceId?: InputMaybe<Scalars['UUID']['input']>;
  supplierInvoiceToSupplierInvoiceId?: InputMaybe<FkTransactionLinkSupplierInvoiceSupplierInvoiceIdInput>;
  transactionId?: InputMaybe<Scalars['UUID']['input']>;
  transactionToTransactionId?: InputMaybe<FkTransactionLinkTransactionTransactionIdInput>;
};

/** Input for the nested mutation of `invoice` in the `TransactionLinkInput` mutation. */
export type FkTransactionLinkInvoiceInvoiceIdInput = {
  /** The primary key(s) for `invoice` for the far side of the relationship. */
  connectById?: InputMaybe<InvoicePkInvoiceConnect>;
  /** A `InvoiceInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkTransactionLinkInvoiceInvoiceIdInvoiceCreateInput>;
  /** The primary key(s) for `invoice` for the far side of the relationship. */
  deleteById?: InputMaybe<InvoicePkInvoiceDelete>;
  /** The primary key(s) and patch data for `invoice` for the far side of the relationship. */
  updateById?: InputMaybe<InvoiceOnTransactionLinkForFkTransactionLinkInvoiceInvoiceIdUsingPkInvoiceUpdate>;
};

/** Input for the nested mutation of `transactionLink` in the `InvoiceInput` mutation. */
export type FkTransactionLinkInvoiceInvoiceIdInverseInput = {
  /** The primary key(s) for `transactionLink` for the far side of the relationship. */
  connectById?: InputMaybe<Array<TransactionLinkPkTransactionLinkConnect>>;
  /** A `TransactionLinkInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkTransactionLinkInvoiceInvoiceIdTransactionLinkCreateInput>>;
  /** The primary key(s) for `transactionLink` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<TransactionLinkPkTransactionLinkDelete>>;
  /** Flag indicating whether all other `transactionLink` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `transactionLink` for the far side of the relationship. */
  updateById?: InputMaybe<Array<TransactionLinkOnTransactionLinkForFkTransactionLinkInvoiceInvoiceIdUsingPkTransactionLinkUpdate>>;
};

/** The `invoice` to be created by this mutation. */
export type FkTransactionLinkInvoiceInvoiceIdInvoiceCreateInput = {
  amount: Scalars['BigFloat']['input'];
  categoryId?: InputMaybe<Scalars['UUID']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  due: Scalars['Datetime']['input'];
  expensesUsingId?: InputMaybe<FkExpenseInvoiceInvoiceIdInverseInput>;
  financeCategoryToCategoryId?: InputMaybe<FkInvoiceFinanceCategoryCategoryIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoiced?: InputMaybe<Scalars['Datetime']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  locked?: InputMaybe<Scalars['Datetime']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  note?: InputMaybe<Scalars['String']['input']>;
  number?: InputMaybe<Scalars['Int']['input']>;
  paid?: InputMaybe<Scalars['Datetime']['input']>;
  paymentsUsingId?: InputMaybe<FkPaymentInvoiceInvoiceIdInverseInput>;
  quoteId?: InputMaybe<Scalars['UUID']['input']>;
  quoteToQuoteId?: InputMaybe<FkInvoiceQuoteQuoteIdInput>;
  summary?: InputMaybe<Scalars['String']['input']>;
  transactionLinksUsingId?: InputMaybe<FkTransactionLinkInvoiceInvoiceIdInverseInput>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkInvoiceTripTripIdInput>;
  type?: InputMaybe<Scalars['String']['input']>;
  voided?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The `transactionLink` to be created by this mutation. */
export type FkTransactionLinkInvoiceInvoiceIdTransactionLinkCreateInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  expenseId?: InputMaybe<Scalars['UUID']['input']>;
  expenseToExpenseId?: InputMaybe<FkTransactionLinkExpenseExpenseIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoiceToInvoiceId?: InputMaybe<FkTransactionLinkInvoiceInvoiceIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  paymentId?: InputMaybe<Scalars['UUID']['input']>;
  paymentToPaymentId?: InputMaybe<FkTransactionLinkPaymentPaymentIdInput>;
  status?: InputMaybe<Scalars['Int']['input']>;
  supplierInvoiceId?: InputMaybe<Scalars['UUID']['input']>;
  supplierInvoiceToSupplierInvoiceId?: InputMaybe<FkTransactionLinkSupplierInvoiceSupplierInvoiceIdInput>;
  transactionId?: InputMaybe<Scalars['UUID']['input']>;
  transactionToTransactionId?: InputMaybe<FkTransactionLinkTransactionTransactionIdInput>;
};

/** Input for the nested mutation of `payment` in the `TransactionLinkInput` mutation. */
export type FkTransactionLinkPaymentPaymentIdInput = {
  /** The primary key(s) for `payment` for the far side of the relationship. */
  connectById?: InputMaybe<PaymentPkPaymentConnect>;
  /** A `PaymentInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkTransactionLinkPaymentPaymentIdPaymentCreateInput>;
  /** The primary key(s) for `payment` for the far side of the relationship. */
  deleteById?: InputMaybe<PaymentPkPaymentDelete>;
  /** The primary key(s) and patch data for `payment` for the far side of the relationship. */
  updateById?: InputMaybe<PaymentOnTransactionLinkForFkTransactionLinkPaymentPaymentIdUsingPkPaymentUpdate>;
};

/** Input for the nested mutation of `transactionLink` in the `PaymentInput` mutation. */
export type FkTransactionLinkPaymentPaymentIdInverseInput = {
  /** The primary key(s) for `transactionLink` for the far side of the relationship. */
  connectById?: InputMaybe<Array<TransactionLinkPkTransactionLinkConnect>>;
  /** A `TransactionLinkInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkTransactionLinkPaymentPaymentIdTransactionLinkCreateInput>>;
  /** The primary key(s) for `transactionLink` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<TransactionLinkPkTransactionLinkDelete>>;
  /** Flag indicating whether all other `transactionLink` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `transactionLink` for the far side of the relationship. */
  updateById?: InputMaybe<Array<TransactionLinkOnTransactionLinkForFkTransactionLinkPaymentPaymentIdUsingPkTransactionLinkUpdate>>;
};

/** The `payment` to be created by this mutation. */
export type FkTransactionLinkPaymentPaymentIdPaymentCreateInput = {
  amount: Scalars['BigFloat']['input'];
  amountActual: Scalars['BigFloat']['input'];
  categoryId?: InputMaybe<Scalars['UUID']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  financeCategoryToCategoryId?: InputMaybe<FkPaymentFinanceCategoryCategoryIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoiceId?: InputMaybe<Scalars['UUID']['input']>;
  invoiceToInvoiceId?: InputMaybe<FkPaymentInvoiceInvoiceIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  paid: Scalars['Datetime']['input'];
  reference?: InputMaybe<Scalars['String']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  transactionLinksUsingId?: InputMaybe<FkTransactionLinkPaymentPaymentIdInverseInput>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkPaymentTripTripIdInput>;
  type?: InputMaybe<Scalars['Int']['input']>;
};

/** The `transactionLink` to be created by this mutation. */
export type FkTransactionLinkPaymentPaymentIdTransactionLinkCreateInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  expenseId?: InputMaybe<Scalars['UUID']['input']>;
  expenseToExpenseId?: InputMaybe<FkTransactionLinkExpenseExpenseIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoiceId?: InputMaybe<Scalars['UUID']['input']>;
  invoiceToInvoiceId?: InputMaybe<FkTransactionLinkInvoiceInvoiceIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  paymentToPaymentId?: InputMaybe<FkTransactionLinkPaymentPaymentIdInput>;
  status?: InputMaybe<Scalars['Int']['input']>;
  supplierInvoiceId?: InputMaybe<Scalars['UUID']['input']>;
  supplierInvoiceToSupplierInvoiceId?: InputMaybe<FkTransactionLinkSupplierInvoiceSupplierInvoiceIdInput>;
  transactionId?: InputMaybe<Scalars['UUID']['input']>;
  transactionToTransactionId?: InputMaybe<FkTransactionLinkTransactionTransactionIdInput>;
};

/** Input for the nested mutation of `supplierInvoice` in the `TransactionLinkInput` mutation. */
export type FkTransactionLinkSupplierInvoiceSupplierInvoiceIdInput = {
  /** The primary key(s) for `supplierInvoice` for the far side of the relationship. */
  connectById?: InputMaybe<SupplierInvoicePkSupplierInvoiceConnect>;
  /** A `SupplierInvoiceInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkTransactionLinkSupplierInvoiceSupplierInvoiceIdSupplierInvoiceCreateInput>;
  /** The primary key(s) for `supplierInvoice` for the far side of the relationship. */
  deleteById?: InputMaybe<SupplierInvoicePkSupplierInvoiceDelete>;
  /** The primary key(s) and patch data for `supplierInvoice` for the far side of the relationship. */
  updateById?: InputMaybe<SupplierInvoiceOnTransactionLinkForFkTransactionLinkSupplierInvoiceSupplierInvoiceIdUsingPkSupplierInvoiceUpdate>;
};

/** Input for the nested mutation of `transactionLink` in the `SupplierInvoiceInput` mutation. */
export type FkTransactionLinkSupplierInvoiceSupplierInvoiceIdInverseInput = {
  /** The primary key(s) for `transactionLink` for the far side of the relationship. */
  connectById?: InputMaybe<Array<TransactionLinkPkTransactionLinkConnect>>;
  /** A `TransactionLinkInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkTransactionLinkSupplierInvoiceSupplierInvoiceIdTransactionLinkCreateInput>>;
  /** The primary key(s) for `transactionLink` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<TransactionLinkPkTransactionLinkDelete>>;
  /** Flag indicating whether all other `transactionLink` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `transactionLink` for the far side of the relationship. */
  updateById?: InputMaybe<Array<TransactionLinkOnTransactionLinkForFkTransactionLinkSupplierInvoiceSupplierInvoiceIdUsingPkTransactionLinkUpdate>>;
};

/** The `supplierInvoice` to be created by this mutation. */
export type FkTransactionLinkSupplierInvoiceSupplierInvoiceIdSupplierInvoiceCreateInput = {
  amount: Scalars['BigFloat']['input'];
  amountActual?: InputMaybe<Scalars['BigFloat']['input']>;
  categoryId?: InputMaybe<Scalars['UUID']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  due: Scalars['Datetime']['input'];
  expensesUsingId?: InputMaybe<FkExpenseSupplierInvoiceSupplierInvoiceIdInverseInput>;
  financeCategoryToCategoryId?: InputMaybe<FkSupplierInvoiceFinanceCategoryCategoryIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  mediaItemId?: InputMaybe<Scalars['UUID']['input']>;
  mediaItemToMediaItemId?: InputMaybe<FkSupplierInvoiceMediaItemMediaItemIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  number?: InputMaybe<Scalars['Int']['input']>;
  paid?: InputMaybe<Scalars['Datetime']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierId?: InputMaybe<Scalars['UUID']['input']>;
  supplierToSupplierId?: InputMaybe<FkSupplierInvoiceSupplierSupplierIdInput>;
  transactionLinksUsingId?: InputMaybe<FkTransactionLinkSupplierInvoiceSupplierInvoiceIdInverseInput>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkSupplierInvoiceTripTripIdInput>;
  type?: InputMaybe<Scalars['String']['input']>;
  voided?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The `transactionLink` to be created by this mutation. */
export type FkTransactionLinkSupplierInvoiceSupplierInvoiceIdTransactionLinkCreateInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  expenseId?: InputMaybe<Scalars['UUID']['input']>;
  expenseToExpenseId?: InputMaybe<FkTransactionLinkExpenseExpenseIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoiceId?: InputMaybe<Scalars['UUID']['input']>;
  invoiceToInvoiceId?: InputMaybe<FkTransactionLinkInvoiceInvoiceIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  paymentId?: InputMaybe<Scalars['UUID']['input']>;
  paymentToPaymentId?: InputMaybe<FkTransactionLinkPaymentPaymentIdInput>;
  status?: InputMaybe<Scalars['Int']['input']>;
  supplierInvoiceToSupplierInvoiceId?: InputMaybe<FkTransactionLinkSupplierInvoiceSupplierInvoiceIdInput>;
  transactionId?: InputMaybe<Scalars['UUID']['input']>;
  transactionToTransactionId?: InputMaybe<FkTransactionLinkTransactionTransactionIdInput>;
};

/** Input for the nested mutation of `transaction` in the `TransactionLinkInput` mutation. */
export type FkTransactionLinkTransactionTransactionIdInput = {
  /** The primary key(s) for `transaction` for the far side of the relationship. */
  connectById?: InputMaybe<TransactionPkTransactionConnect>;
  /** A `TransactionInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkTransactionLinkTransactionTransactionIdTransactionCreateInput>;
  /** The primary key(s) for `transaction` for the far side of the relationship. */
  deleteById?: InputMaybe<TransactionPkTransactionDelete>;
  /** The primary key(s) and patch data for `transaction` for the far side of the relationship. */
  updateById?: InputMaybe<TransactionOnTransactionLinkForFkTransactionLinkTransactionTransactionIdUsingPkTransactionUpdate>;
};

/** Input for the nested mutation of `transactionLink` in the `TransactionInput` mutation. */
export type FkTransactionLinkTransactionTransactionIdInverseInput = {
  /** The primary key(s) for `transactionLink` for the far side of the relationship. */
  connectById?: InputMaybe<Array<TransactionLinkPkTransactionLinkConnect>>;
  /** A `TransactionLinkInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkTransactionLinkTransactionTransactionIdTransactionLinkCreateInput>>;
  /** The primary key(s) for `transactionLink` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<TransactionLinkPkTransactionLinkDelete>>;
  /** Flag indicating whether all other `transactionLink` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `transactionLink` for the far side of the relationship. */
  updateById?: InputMaybe<Array<TransactionLinkOnTransactionLinkForFkTransactionLinkTransactionTransactionIdUsingPkTransactionLinkUpdate>>;
};

/** The `transaction` to be created by this mutation. */
export type FkTransactionLinkTransactionTransactionIdTransactionCreateInput = {
  accountId?: InputMaybe<Scalars['UUID']['input']>;
  accountToAccountId?: InputMaybe<FkTransactionAccountAccountIdInput>;
  amount: Scalars['BigFloat']['input'];
  balance?: InputMaybe<Scalars['BigFloat']['input']>;
  categoryId?: InputMaybe<Scalars['UUID']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  date: Scalars['Datetime']['input'];
  description?: InputMaybe<Scalars['String']['input']>;
  externalId?: InputMaybe<Scalars['String']['input']>;
  financeCategoryToCategoryId?: InputMaybe<FkTransactionFinanceCategoryCategoryIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  reverseTransactionId?: InputMaybe<Scalars['UUID']['input']>;
  source?: InputMaybe<Scalars['String']['input']>;
  status: Scalars['Int']['input'];
  transactionImportBatchId?: InputMaybe<Scalars['UUID']['input']>;
  transactionImportBatchToTransactionImportBatchId?: InputMaybe<FkTransactionTransactionImportBatchTransactionImportBatchIdInput>;
  transactionLinksUsingId?: InputMaybe<FkTransactionLinkTransactionTransactionIdInverseInput>;
  transactionNotesUsingId?: InputMaybe<FkTransactionNoteTransactionTransactionIdInverseInput>;
  transactionToReverseTransactionId?: InputMaybe<FkTransactionTransactionReverseTransactionIdInput>;
};

/** The `transactionLink` to be created by this mutation. */
export type FkTransactionLinkTransactionTransactionIdTransactionLinkCreateInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  expenseId?: InputMaybe<Scalars['UUID']['input']>;
  expenseToExpenseId?: InputMaybe<FkTransactionLinkExpenseExpenseIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoiceId?: InputMaybe<Scalars['UUID']['input']>;
  invoiceToInvoiceId?: InputMaybe<FkTransactionLinkInvoiceInvoiceIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  paymentId?: InputMaybe<Scalars['UUID']['input']>;
  paymentToPaymentId?: InputMaybe<FkTransactionLinkPaymentPaymentIdInput>;
  status?: InputMaybe<Scalars['Int']['input']>;
  supplierInvoiceId?: InputMaybe<Scalars['UUID']['input']>;
  supplierInvoiceToSupplierInvoiceId?: InputMaybe<FkTransactionLinkSupplierInvoiceSupplierInvoiceIdInput>;
  transactionToTransactionId?: InputMaybe<FkTransactionLinkTransactionTransactionIdInput>;
};

/** Input for the nested mutation of `transaction` in the `TransactionNoteInput` mutation. */
export type FkTransactionNoteTransactionTransactionIdInput = {
  /** The primary key(s) for `transaction` for the far side of the relationship. */
  connectById?: InputMaybe<TransactionPkTransactionConnect>;
  /** A `TransactionInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkTransactionNoteTransactionTransactionIdTransactionCreateInput>;
  /** The primary key(s) for `transaction` for the far side of the relationship. */
  deleteById?: InputMaybe<TransactionPkTransactionDelete>;
  /** The primary key(s) and patch data for `transaction` for the far side of the relationship. */
  updateById?: InputMaybe<TransactionOnTransactionNoteForFkTransactionNoteTransactionTransactionIdUsingPkTransactionUpdate>;
};

/** Input for the nested mutation of `transactionNote` in the `TransactionInput` mutation. */
export type FkTransactionNoteTransactionTransactionIdInverseInput = {
  /** The primary key(s) for `transactionNote` for the far side of the relationship. */
  connectById?: InputMaybe<Array<TransactionNotePkTransactionNoteConnect>>;
  /** A `TransactionNoteInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkTransactionNoteTransactionTransactionIdTransactionNoteCreateInput>>;
  /** The primary key(s) for `transactionNote` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<TransactionNotePkTransactionNoteDelete>>;
  /** Flag indicating whether all other `transactionNote` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `transactionNote` for the far side of the relationship. */
  updateById?: InputMaybe<Array<TransactionNoteOnTransactionNoteForFkTransactionNoteTransactionTransactionIdUsingPkTransactionNoteUpdate>>;
};

/** The `transaction` to be created by this mutation. */
export type FkTransactionNoteTransactionTransactionIdTransactionCreateInput = {
  accountId?: InputMaybe<Scalars['UUID']['input']>;
  accountToAccountId?: InputMaybe<FkTransactionAccountAccountIdInput>;
  amount: Scalars['BigFloat']['input'];
  balance?: InputMaybe<Scalars['BigFloat']['input']>;
  categoryId?: InputMaybe<Scalars['UUID']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  date: Scalars['Datetime']['input'];
  description?: InputMaybe<Scalars['String']['input']>;
  externalId?: InputMaybe<Scalars['String']['input']>;
  financeCategoryToCategoryId?: InputMaybe<FkTransactionFinanceCategoryCategoryIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  reverseTransactionId?: InputMaybe<Scalars['UUID']['input']>;
  source?: InputMaybe<Scalars['String']['input']>;
  status: Scalars['Int']['input'];
  transactionImportBatchId?: InputMaybe<Scalars['UUID']['input']>;
  transactionImportBatchToTransactionImportBatchId?: InputMaybe<FkTransactionTransactionImportBatchTransactionImportBatchIdInput>;
  transactionLinksUsingId?: InputMaybe<FkTransactionLinkTransactionTransactionIdInverseInput>;
  transactionNotesUsingId?: InputMaybe<FkTransactionNoteTransactionTransactionIdInverseInput>;
  transactionToReverseTransactionId?: InputMaybe<FkTransactionTransactionReverseTransactionIdInput>;
};

/** The `transactionNote` to be created by this mutation. */
export type FkTransactionNoteTransactionTransactionIdTransactionNoteCreateInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  message?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  transactionToTransactionId?: InputMaybe<FkTransactionNoteTransactionTransactionIdInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkTransactionNoteUserUserIdInput>;
};

/** Input for the nested mutation of `user` in the `TransactionNoteInput` mutation. */
export type FkTransactionNoteUserUserIdInput = {
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectById?: InputMaybe<UserPkUserConnect>;
  /** A `UserInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkTransactionNoteUserUserIdUserCreateInput>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteById?: InputMaybe<UserPkUserDelete>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateById?: InputMaybe<UserOnTransactionNoteForFkTransactionNoteUserUserIdUsingPkUserUpdate>;
};

/** Input for the nested mutation of `transactionNote` in the `UserInput` mutation. */
export type FkTransactionNoteUserUserIdInverseInput = {
  /** The primary key(s) for `transactionNote` for the far side of the relationship. */
  connectById?: InputMaybe<Array<TransactionNotePkTransactionNoteConnect>>;
  /** A `TransactionNoteInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkTransactionNoteUserUserIdTransactionNoteCreateInput>>;
  /** The primary key(s) for `transactionNote` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<TransactionNotePkTransactionNoteDelete>>;
  /** Flag indicating whether all other `transactionNote` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `transactionNote` for the far side of the relationship. */
  updateById?: InputMaybe<Array<TransactionNoteOnTransactionNoteForFkTransactionNoteUserUserIdUsingPkTransactionNoteUpdate>>;
};

/** The `transactionNote` to be created by this mutation. */
export type FkTransactionNoteUserUserIdTransactionNoteCreateInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  message?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  transactionId?: InputMaybe<Scalars['UUID']['input']>;
  transactionToTransactionId?: InputMaybe<FkTransactionNoteTransactionTransactionIdInput>;
  userToUserId?: InputMaybe<FkTransactionNoteUserUserIdInput>;
};

/** The `user` to be created by this mutation. */
export type FkTransactionNoteUserUserIdUserCreateInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  emailsUsingId?: InputMaybe<FkEmailUserUserIdInverseInput>;
  externalId?: InputMaybe<Scalars['String']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  genderPreposition?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name: Scalars['String']['input'];
  notesUsingId?: InputMaybe<FkNoteUserUserIdInverseInput>;
  password?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  quotePublicsUsingId?: InputMaybe<FakePublicQuotePublicForeignKey2InverseInput>;
  quotesUsingId?: InputMaybe<FkQuoteUserUserIdInverseInput>;
  remindersUsingId?: InputMaybe<FkReminderUserUserIdInverseInput>;
  skype?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  transactionNotesUsingId?: InputMaybe<FkTransactionNoteUserUserIdInverseInput>;
  tripsUsingId?: InputMaybe<FkTripUserUserIdInverseInput>;
};

/** Input for the nested mutation of `transactionImportBatch` in the `TransactionInput` mutation. */
export type FkTransactionTransactionImportBatchTransactionImportBatchIdInput = {
  /** The primary key(s) for `transactionImportBatch` for the far side of the relationship. */
  connectById?: InputMaybe<TransactionImportBatchPkTransactionImportBatchConnect>;
  /** A `TransactionImportBatchInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkTransactionTransactionImportBatchTransactionImportBatchIdTransactionImportBatchCreateInput>;
  /** The primary key(s) for `transactionImportBatch` for the far side of the relationship. */
  deleteById?: InputMaybe<TransactionImportBatchPkTransactionImportBatchDelete>;
  /** The primary key(s) and patch data for `transactionImportBatch` for the far side of the relationship. */
  updateById?: InputMaybe<TransactionImportBatchOnTransactionForFkTransactionTransactionImportBatchTransactionImportBatchIdUsingPkTransactionImportBatchUpdate>;
};

/** Input for the nested mutation of `transaction` in the `TransactionImportBatchInput` mutation. */
export type FkTransactionTransactionImportBatchTransactionImportBatchIdInverseInput = {
  /** The primary key(s) for `transaction` for the far side of the relationship. */
  connectById?: InputMaybe<Array<TransactionPkTransactionConnect>>;
  /** A `TransactionInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkTransactionTransactionImportBatchTransactionImportBatchIdTransactionCreateInput>>;
  /** The primary key(s) for `transaction` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<TransactionPkTransactionDelete>>;
  /** Flag indicating whether all other `transaction` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `transaction` for the far side of the relationship. */
  updateById?: InputMaybe<Array<TransactionOnTransactionForFkTransactionTransactionImportBatchTransactionImportBatchIdUsingPkTransactionUpdate>>;
};

/** The `transaction` to be created by this mutation. */
export type FkTransactionTransactionImportBatchTransactionImportBatchIdTransactionCreateInput = {
  accountId?: InputMaybe<Scalars['UUID']['input']>;
  accountToAccountId?: InputMaybe<FkTransactionAccountAccountIdInput>;
  amount: Scalars['BigFloat']['input'];
  balance?: InputMaybe<Scalars['BigFloat']['input']>;
  categoryId?: InputMaybe<Scalars['UUID']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  date: Scalars['Datetime']['input'];
  description?: InputMaybe<Scalars['String']['input']>;
  externalId?: InputMaybe<Scalars['String']['input']>;
  financeCategoryToCategoryId?: InputMaybe<FkTransactionFinanceCategoryCategoryIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  reverseTransactionId?: InputMaybe<Scalars['UUID']['input']>;
  source?: InputMaybe<Scalars['String']['input']>;
  status: Scalars['Int']['input'];
  transactionImportBatchToTransactionImportBatchId?: InputMaybe<FkTransactionTransactionImportBatchTransactionImportBatchIdInput>;
  transactionLinksUsingId?: InputMaybe<FkTransactionLinkTransactionTransactionIdInverseInput>;
  transactionNotesUsingId?: InputMaybe<FkTransactionNoteTransactionTransactionIdInverseInput>;
  transactionToReverseTransactionId?: InputMaybe<FkTransactionTransactionReverseTransactionIdInput>;
};

/** The `transactionImportBatch` to be created by this mutation. */
export type FkTransactionTransactionImportBatchTransactionImportBatchIdTransactionImportBatchCreateInput = {
  accountId?: InputMaybe<Scalars['UUID']['input']>;
  accountToAccountId?: InputMaybe<FkTransactionImportBatchAccountAccountIdInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  dateRangeMax: Scalars['Datetime']['input'];
  dateRangeMin: Scalars['Datetime']['input'];
  id?: InputMaybe<Scalars['UUID']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  transactionsUsingId?: InputMaybe<FkTransactionTransactionImportBatchTransactionImportBatchIdInverseInput>;
};

/** Input for the nested mutation of `transaction` in the `TransactionInput` mutation. */
export type FkTransactionTransactionReverseTransactionIdInput = {
  /** The primary key(s) for `transaction` for the far side of the relationship. */
  connectById?: InputMaybe<TransactionPkTransactionConnect>;
  /** A `TransactionInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkTransactionTransactionReverseTransactionIdTransactionCreateInput>;
  /** The primary key(s) for `transaction` for the far side of the relationship. */
  deleteById?: InputMaybe<TransactionPkTransactionDelete>;
  /** The primary key(s) and patch data for `transaction` for the far side of the relationship. */
  updateById?: InputMaybe<TransactionOnTransactionForFkTransactionTransactionReverseTransactionIdUsingPkTransactionUpdate>;
};

/** The `transaction` to be created by this mutation. */
export type FkTransactionTransactionReverseTransactionIdTransactionCreateInput = {
  accountId?: InputMaybe<Scalars['UUID']['input']>;
  accountToAccountId?: InputMaybe<FkTransactionAccountAccountIdInput>;
  amount: Scalars['BigFloat']['input'];
  balance?: InputMaybe<Scalars['BigFloat']['input']>;
  categoryId?: InputMaybe<Scalars['UUID']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  date: Scalars['Datetime']['input'];
  description?: InputMaybe<Scalars['String']['input']>;
  externalId?: InputMaybe<Scalars['String']['input']>;
  financeCategoryToCategoryId?: InputMaybe<FkTransactionFinanceCategoryCategoryIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  source?: InputMaybe<Scalars['String']['input']>;
  status: Scalars['Int']['input'];
  transactionImportBatchId?: InputMaybe<Scalars['UUID']['input']>;
  transactionImportBatchToTransactionImportBatchId?: InputMaybe<FkTransactionTransactionImportBatchTransactionImportBatchIdInput>;
  transactionLinksUsingId?: InputMaybe<FkTransactionLinkTransactionTransactionIdInverseInput>;
  transactionNotesUsingId?: InputMaybe<FkTransactionNoteTransactionTransactionIdInverseInput>;
  transactionToReverseTransactionId?: InputMaybe<FkTransactionTransactionReverseTransactionIdInput>;
};

/** The `agency` to be created by this mutation. */
export type FkTripAgencyAgencyIdAgencyCreateInput = {
  agencyMembersUsingId?: InputMaybe<FkAgencyMemberAgencyAgencyIdInverseInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  logoId?: InputMaybe<Scalars['UUID']['input']>;
  mediaItemToLogoId?: InputMaybe<FkAgencyMediaItemLogoIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  supplierId?: InputMaybe<Scalars['UUID']['input']>;
  supplierToSupplierId?: InputMaybe<FkAgencySupplierInput>;
  tripsUsingId?: InputMaybe<FkTripAgencyAgencyIdInverseInput>;
};

/** Input for the nested mutation of `agency` in the `TripInput` mutation. */
export type FkTripAgencyAgencyIdInput = {
  /** The primary key(s) for `agency` for the far side of the relationship. */
  connectById?: InputMaybe<AgencyPkAgencyConnect>;
  /** A `AgencyInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkTripAgencyAgencyIdAgencyCreateInput>;
  /** The primary key(s) for `agency` for the far side of the relationship. */
  deleteById?: InputMaybe<AgencyPkAgencyDelete>;
  /** The primary key(s) and patch data for `agency` for the far side of the relationship. */
  updateById?: InputMaybe<AgencyOnTripForFkTripAgencyAgencyIdUsingPkAgencyUpdate>;
};

/** Input for the nested mutation of `trip` in the `AgencyInput` mutation. */
export type FkTripAgencyAgencyIdInverseInput = {
  /** The primary key(s) for `trip` for the far side of the relationship. */
  connectById?: InputMaybe<Array<TripPkTripConnect>>;
  /** A `TripInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkTripAgencyAgencyIdTripCreateInput>>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<TripPkTripDelete>>;
  /** Flag indicating whether all other `trip` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `trip` for the far side of the relationship. */
  updateById?: InputMaybe<Array<TripOnTripForFkTripAgencyAgencyIdUsingPkTripUpdate>>;
};

/** The `trip` to be created by this mutation. */
export type FkTripAgencyAgencyIdTripCreateInput = {
  activeQuoteId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberToAgencyMemberId?: InputMaybe<FkTripAgencyMemberAgencyMemberIdInput>;
  agencyToAgencyId?: InputMaybe<FkTripAgencyAgencyIdInput>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerId?: InputMaybe<Scalars['UUID']['input']>;
  customerToCustomerId?: InputMaybe<FkTripCustomerCustomerIdInput>;
  dates?: InputMaybe<Scalars['String']['input']>;
  destination?: InputMaybe<Scalars['String']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  emailsUsingId?: InputMaybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: InputMaybe<FkEnquiryTripTripIdInverseInput>;
  expensesUsingId?: InputMaybe<FkExpenseTripTripIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceTripTripIdInverseInput>;
  mediaGalleryId?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryToMediaGalleryId?: InputMaybe<FkTripMediaGalleryMediaGalleryIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notesUsingId?: InputMaybe<FkNoteTripTripIdInverseInput>;
  paymentsUsingId?: InputMaybe<FkPaymentTripTripIdInverseInput>;
  quotePublicsUsingId?: InputMaybe<FakePublicQuotePublicForeignKey0InverseInput>;
  quoteToActiveQuoteId?: InputMaybe<FkTripQuoteActiveQuoteIdInput>;
  quotesUsingId?: InputMaybe<FkQuoteTripTripIdInverseInput>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceTripTripIdInverseInput>;
  testimonialsUsingId?: InputMaybe<FkTestimonialTripTripIdInverseInput>;
  tripFlightsUsingId?: InputMaybe<FkTripFlightTripTripIdInverseInput>;
  tripTravellersUsingId?: InputMaybe<FkTripTravellerTripTripIdInverseInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkTripUserUserIdInput>;
};

/** The `agencyMember` to be created by this mutation. */
export type FkTripAgencyMemberAgencyMemberIdAgencyMemberCreateInput = {
  agencyId?: InputMaybe<Scalars['UUID']['input']>;
  agencyToAgencyId?: InputMaybe<FkAgencyMemberAgencyAgencyIdInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  genderPreposition?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  skype?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  tripsUsingId?: InputMaybe<FkTripAgencyMemberAgencyMemberIdInverseInput>;
};

/** Input for the nested mutation of `agencyMember` in the `TripInput` mutation. */
export type FkTripAgencyMemberAgencyMemberIdInput = {
  /** The primary key(s) for `agencyMember` for the far side of the relationship. */
  connectById?: InputMaybe<AgencyMemberPkAgencyMemberConnect>;
  /** A `AgencyMemberInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkTripAgencyMemberAgencyMemberIdAgencyMemberCreateInput>;
  /** The primary key(s) for `agencyMember` for the far side of the relationship. */
  deleteById?: InputMaybe<AgencyMemberPkAgencyMemberDelete>;
  /** The primary key(s) and patch data for `agencyMember` for the far side of the relationship. */
  updateById?: InputMaybe<AgencyMemberOnTripForFkTripAgencyMemberAgencyMemberIdUsingPkAgencyMemberUpdate>;
};

/** Input for the nested mutation of `trip` in the `AgencyMemberInput` mutation. */
export type FkTripAgencyMemberAgencyMemberIdInverseInput = {
  /** The primary key(s) for `trip` for the far side of the relationship. */
  connectById?: InputMaybe<Array<TripPkTripConnect>>;
  /** A `TripInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkTripAgencyMemberAgencyMemberIdTripCreateInput>>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<TripPkTripDelete>>;
  /** Flag indicating whether all other `trip` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `trip` for the far side of the relationship. */
  updateById?: InputMaybe<Array<TripOnTripForFkTripAgencyMemberAgencyMemberIdUsingPkTripUpdate>>;
};

/** The `trip` to be created by this mutation. */
export type FkTripAgencyMemberAgencyMemberIdTripCreateInput = {
  activeQuoteId?: InputMaybe<Scalars['UUID']['input']>;
  agencyId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberToAgencyMemberId?: InputMaybe<FkTripAgencyMemberAgencyMemberIdInput>;
  agencyToAgencyId?: InputMaybe<FkTripAgencyAgencyIdInput>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerId?: InputMaybe<Scalars['UUID']['input']>;
  customerToCustomerId?: InputMaybe<FkTripCustomerCustomerIdInput>;
  dates?: InputMaybe<Scalars['String']['input']>;
  destination?: InputMaybe<Scalars['String']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  emailsUsingId?: InputMaybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: InputMaybe<FkEnquiryTripTripIdInverseInput>;
  expensesUsingId?: InputMaybe<FkExpenseTripTripIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceTripTripIdInverseInput>;
  mediaGalleryId?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryToMediaGalleryId?: InputMaybe<FkTripMediaGalleryMediaGalleryIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notesUsingId?: InputMaybe<FkNoteTripTripIdInverseInput>;
  paymentsUsingId?: InputMaybe<FkPaymentTripTripIdInverseInput>;
  quotePublicsUsingId?: InputMaybe<FakePublicQuotePublicForeignKey0InverseInput>;
  quoteToActiveQuoteId?: InputMaybe<FkTripQuoteActiveQuoteIdInput>;
  quotesUsingId?: InputMaybe<FkQuoteTripTripIdInverseInput>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceTripTripIdInverseInput>;
  testimonialsUsingId?: InputMaybe<FkTestimonialTripTripIdInverseInput>;
  tripFlightsUsingId?: InputMaybe<FkTripFlightTripTripIdInverseInput>;
  tripTravellersUsingId?: InputMaybe<FkTripTravellerTripTripIdInverseInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkTripUserUserIdInput>;
};

/** The `customer` to be created by this mutation. */
export type FkTripCustomerCustomerIdCustomerCreateInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerTravellersUsingId?: InputMaybe<FkCustomerTravellerCustomerCustomerIdInverseInput>;
  email?: InputMaybe<Scalars['String']['input']>;
  emailsUsingId?: InputMaybe<FkEmailCustomerCustomerIdInverseInput>;
  enquiriesUsingId?: InputMaybe<FkEnquiryCustomerCustomerIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  tripsUsingId?: InputMaybe<FkTripCustomerCustomerIdInverseInput>;
};

/** Input for the nested mutation of `customer` in the `TripInput` mutation. */
export type FkTripCustomerCustomerIdInput = {
  /** The primary key(s) for `customer` for the far side of the relationship. */
  connectById?: InputMaybe<CustomerPkCustomerConnect>;
  /** A `CustomerInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkTripCustomerCustomerIdCustomerCreateInput>;
  /** The primary key(s) for `customer` for the far side of the relationship. */
  deleteById?: InputMaybe<CustomerPkCustomerDelete>;
  /** The primary key(s) and patch data for `customer` for the far side of the relationship. */
  updateById?: InputMaybe<CustomerOnTripForFkTripCustomerCustomerIdUsingPkCustomerUpdate>;
};

/** Input for the nested mutation of `trip` in the `CustomerInput` mutation. */
export type FkTripCustomerCustomerIdInverseInput = {
  /** The primary key(s) for `trip` for the far side of the relationship. */
  connectById?: InputMaybe<Array<TripPkTripConnect>>;
  /** A `TripInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkTripCustomerCustomerIdTripCreateInput>>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<TripPkTripDelete>>;
  /** Flag indicating whether all other `trip` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `trip` for the far side of the relationship. */
  updateById?: InputMaybe<Array<TripOnTripForFkTripCustomerCustomerIdUsingPkTripUpdate>>;
};

/** The `trip` to be created by this mutation. */
export type FkTripCustomerCustomerIdTripCreateInput = {
  activeQuoteId?: InputMaybe<Scalars['UUID']['input']>;
  agencyId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberToAgencyMemberId?: InputMaybe<FkTripAgencyMemberAgencyMemberIdInput>;
  agencyToAgencyId?: InputMaybe<FkTripAgencyAgencyIdInput>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerToCustomerId?: InputMaybe<FkTripCustomerCustomerIdInput>;
  dates?: InputMaybe<Scalars['String']['input']>;
  destination?: InputMaybe<Scalars['String']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  emailsUsingId?: InputMaybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: InputMaybe<FkEnquiryTripTripIdInverseInput>;
  expensesUsingId?: InputMaybe<FkExpenseTripTripIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceTripTripIdInverseInput>;
  mediaGalleryId?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryToMediaGalleryId?: InputMaybe<FkTripMediaGalleryMediaGalleryIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notesUsingId?: InputMaybe<FkNoteTripTripIdInverseInput>;
  paymentsUsingId?: InputMaybe<FkPaymentTripTripIdInverseInput>;
  quotePublicsUsingId?: InputMaybe<FakePublicQuotePublicForeignKey0InverseInput>;
  quoteToActiveQuoteId?: InputMaybe<FkTripQuoteActiveQuoteIdInput>;
  quotesUsingId?: InputMaybe<FkQuoteTripTripIdInverseInput>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceTripTripIdInverseInput>;
  testimonialsUsingId?: InputMaybe<FkTestimonialTripTripIdInverseInput>;
  tripFlightsUsingId?: InputMaybe<FkTripFlightTripTripIdInverseInput>;
  tripTravellersUsingId?: InputMaybe<FkTripTravellerTripTripIdInverseInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkTripUserUserIdInput>;
};

/** Input for the nested mutation of `trip` in the `TripFlightInput` mutation. */
export type FkTripFlightTripTripIdInput = {
  /** The primary key(s) for `trip` for the far side of the relationship. */
  connectById?: InputMaybe<TripPkTripConnect>;
  /** A `TripInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkTripFlightTripTripIdTripCreateInput>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  deleteById?: InputMaybe<TripPkTripDelete>;
  /** The primary key(s) and patch data for `trip` for the far side of the relationship. */
  updateById?: InputMaybe<TripOnTripFlightForFkTripFlightTripTripIdUsingPkTripUpdate>;
};

/** Input for the nested mutation of `tripFlight` in the `TripInput` mutation. */
export type FkTripFlightTripTripIdInverseInput = {
  /** The primary key(s) for `tripFlight` for the far side of the relationship. */
  connectById?: InputMaybe<Array<TripFlightPkTripFlightConnect>>;
  /** A `TripFlightInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkTripFlightTripTripIdTripFlightCreateInput>>;
  /** The primary key(s) for `tripFlight` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<TripFlightPkTripFlightDelete>>;
  /** Flag indicating whether all other `tripFlight` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `tripFlight` for the far side of the relationship. */
  updateById?: InputMaybe<Array<TripFlightOnTripFlightForFkTripFlightTripTripIdUsingPkTripFlightUpdate>>;
};

/** The `trip` to be created by this mutation. */
export type FkTripFlightTripTripIdTripCreateInput = {
  activeQuoteId?: InputMaybe<Scalars['UUID']['input']>;
  agencyId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberToAgencyMemberId?: InputMaybe<FkTripAgencyMemberAgencyMemberIdInput>;
  agencyToAgencyId?: InputMaybe<FkTripAgencyAgencyIdInput>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerId?: InputMaybe<Scalars['UUID']['input']>;
  customerToCustomerId?: InputMaybe<FkTripCustomerCustomerIdInput>;
  dates?: InputMaybe<Scalars['String']['input']>;
  destination?: InputMaybe<Scalars['String']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  emailsUsingId?: InputMaybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: InputMaybe<FkEnquiryTripTripIdInverseInput>;
  expensesUsingId?: InputMaybe<FkExpenseTripTripIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceTripTripIdInverseInput>;
  mediaGalleryId?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryToMediaGalleryId?: InputMaybe<FkTripMediaGalleryMediaGalleryIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notesUsingId?: InputMaybe<FkNoteTripTripIdInverseInput>;
  paymentsUsingId?: InputMaybe<FkPaymentTripTripIdInverseInput>;
  quotePublicsUsingId?: InputMaybe<FakePublicQuotePublicForeignKey0InverseInput>;
  quoteToActiveQuoteId?: InputMaybe<FkTripQuoteActiveQuoteIdInput>;
  quotesUsingId?: InputMaybe<FkQuoteTripTripIdInverseInput>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceTripTripIdInverseInput>;
  testimonialsUsingId?: InputMaybe<FkTestimonialTripTripIdInverseInput>;
  tripFlightsUsingId?: InputMaybe<FkTripFlightTripTripIdInverseInput>;
  tripTravellersUsingId?: InputMaybe<FkTripTravellerTripTripIdInverseInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkTripUserUserIdInput>;
};

/** The `tripFlight` to be created by this mutation. */
export type FkTripFlightTripTripIdTripFlightCreateInput = {
  airportToArrivalAirportId?: InputMaybe<TripFlightArrivalAirport2IdFkeyInput>;
  airportToDepartureAirportId?: InputMaybe<TripFlightDepartureAirport2IdFkeyInput>;
  arrival: Scalars['Datetime']['input'];
  arrivalAirportId?: InputMaybe<Scalars['UUID']['input']>;
  carrier?: InputMaybe<Scalars['String']['input']>;
  departure: Scalars['Datetime']['input'];
  departureAirportId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  number?: InputMaybe<Scalars['String']['input']>;
  tripToTripId?: InputMaybe<FkTripFlightTripTripIdInput>;
};

/** Input for the nested mutation of `mediaGallery` in the `TripInput` mutation. */
export type FkTripMediaGalleryMediaGalleryIdInput = {
  /** The primary key(s) for `mediaGallery` for the far side of the relationship. */
  connectById?: InputMaybe<MediaGalleryPkMediaGalleryConnect>;
  /** A `MediaGalleryInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkTripMediaGalleryMediaGalleryIdMediaGalleryCreateInput>;
  /** The primary key(s) for `mediaGallery` for the far side of the relationship. */
  deleteById?: InputMaybe<MediaGalleryPkMediaGalleryDelete>;
  /** The primary key(s) and patch data for `mediaGallery` for the far side of the relationship. */
  updateById?: InputMaybe<MediaGalleryOnTripForFkTripMediaGalleryMediaGalleryIdUsingPkMediaGalleryUpdate>;
};

/** Input for the nested mutation of `trip` in the `MediaGalleryInput` mutation. */
export type FkTripMediaGalleryMediaGalleryIdInverseInput = {
  /** The primary key(s) for `trip` for the far side of the relationship. */
  connectById?: InputMaybe<Array<TripPkTripConnect>>;
  /** A `TripInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkTripMediaGalleryMediaGalleryIdTripCreateInput>>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<TripPkTripDelete>>;
  /** Flag indicating whether all other `trip` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `trip` for the far side of the relationship. */
  updateById?: InputMaybe<Array<TripOnTripForFkTripMediaGalleryMediaGalleryIdUsingPkTripUpdate>>;
};

/** The `mediaGallery` to be created by this mutation. */
export type FkTripMediaGalleryMediaGalleryIdMediaGalleryCreateInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationFeaturesUsingId?: InputMaybe<FkDestinationFeatureMediaGalleryGalleryIdInverseInput>;
  destinationsUsingId?: InputMaybe<FkDestinationMediaGalleryGalleryIdInverseInput>;
  featuresUsingId?: InputMaybe<FkFeatureMediaGalleryGalleryIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  isProtected?: InputMaybe<Scalars['Boolean']['input']>;
  mediaGalleryItemsUsingId?: InputMaybe<FkMediaGalleryItemMediaGalleryMediaGalleryIdInverseInput>;
  mediaGalleryToParentId?: InputMaybe<FkMediaGalleryMediaGalleryParentIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  parentId?: InputMaybe<Scalars['UUID']['input']>;
  propertiesUsingId?: InputMaybe<FkPropertyMediaGalleryGalleryIdInverseInput>;
  suppliersUsingId?: InputMaybe<FkSupplierMediaGalleryGalleryIdInverseInput>;
  tripsUsingId?: InputMaybe<FkTripMediaGalleryMediaGalleryIdInverseInput>;
};

/** The `trip` to be created by this mutation. */
export type FkTripMediaGalleryMediaGalleryIdTripCreateInput = {
  activeQuoteId?: InputMaybe<Scalars['UUID']['input']>;
  agencyId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberToAgencyMemberId?: InputMaybe<FkTripAgencyMemberAgencyMemberIdInput>;
  agencyToAgencyId?: InputMaybe<FkTripAgencyAgencyIdInput>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerId?: InputMaybe<Scalars['UUID']['input']>;
  customerToCustomerId?: InputMaybe<FkTripCustomerCustomerIdInput>;
  dates?: InputMaybe<Scalars['String']['input']>;
  destination?: InputMaybe<Scalars['String']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  emailsUsingId?: InputMaybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: InputMaybe<FkEnquiryTripTripIdInverseInput>;
  expensesUsingId?: InputMaybe<FkExpenseTripTripIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceTripTripIdInverseInput>;
  mediaGalleryToMediaGalleryId?: InputMaybe<FkTripMediaGalleryMediaGalleryIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notesUsingId?: InputMaybe<FkNoteTripTripIdInverseInput>;
  paymentsUsingId?: InputMaybe<FkPaymentTripTripIdInverseInput>;
  quotePublicsUsingId?: InputMaybe<FakePublicQuotePublicForeignKey0InverseInput>;
  quoteToActiveQuoteId?: InputMaybe<FkTripQuoteActiveQuoteIdInput>;
  quotesUsingId?: InputMaybe<FkQuoteTripTripIdInverseInput>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceTripTripIdInverseInput>;
  testimonialsUsingId?: InputMaybe<FkTestimonialTripTripIdInverseInput>;
  tripFlightsUsingId?: InputMaybe<FkTripFlightTripTripIdInverseInput>;
  tripTravellersUsingId?: InputMaybe<FkTripTravellerTripTripIdInverseInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkTripUserUserIdInput>;
};

/** Input for the nested mutation of `quote` in the `TripInput` mutation. */
export type FkTripQuoteActiveQuoteIdInput = {
  /** The primary key(s) for `quote` for the far side of the relationship. */
  connectById?: InputMaybe<QuotePkQuoteConnect>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  connectByKey?: InputMaybe<QuoteUqQuoteKeyConnect>;
  /** A `QuoteInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkTripQuoteActiveQuoteIdQuoteCreateInput>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  deleteById?: InputMaybe<QuotePkQuoteDelete>;
  /** The primary key(s) for `quote` for the far side of the relationship. */
  deleteByKey?: InputMaybe<QuoteUqQuoteKeyDelete>;
  /** The primary key(s) and patch data for `quote` for the far side of the relationship. */
  updateById?: InputMaybe<QuoteOnTripForFkTripQuoteActiveQuoteIdUsingPkQuoteUpdate>;
  /** The primary key(s) and patch data for `quote` for the far side of the relationship. */
  updateByKey?: InputMaybe<QuoteOnTripForFkTripQuoteActiveQuoteIdUsingUqQuoteKeyUpdate>;
};

/** Input for the nested mutation of `trip` in the `QuoteInput` mutation. */
export type FkTripQuoteActiveQuoteIdInverseInput = {
  /** The primary key(s) for `trip` for the far side of the relationship. */
  connectById?: InputMaybe<Array<TripPkTripConnect>>;
  /** A `TripInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkTripQuoteActiveQuoteIdTripCreateInput>>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<TripPkTripDelete>>;
  /** Flag indicating whether all other `trip` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `trip` for the far side of the relationship. */
  updateById?: InputMaybe<Array<TripOnTripForFkTripQuoteActiveQuoteIdUsingPkTripUpdate>>;
};

/** The `quote` to be created by this mutation. */
export type FkTripQuoteActiveQuoteIdQuoteCreateInput = {
  adjustment?: InputMaybe<Scalars['BigFloat']['input']>;
  agentMargin?: InputMaybe<Scalars['BigFloat']['input']>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  deposit?: InputMaybe<Scalars['BigFloat']['input']>;
  duration: Scalars['Int']['input'];
  emailsUsingId?: InputMaybe<FkEmailQuoteQuoteIdInverseInput>;
  exclusions?: InputMaybe<Scalars['String']['input']>;
  expires?: InputMaybe<Scalars['Datetime']['input']>;
  heroId?: InputMaybe<Scalars['UUID']['input']>;
  heroImageId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  inclusions?: InputMaybe<Scalars['String']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceQuoteQuoteIdInverseInput>;
  key?: InputMaybe<Scalars['String']['input']>;
  locked?: InputMaybe<Scalars['Datetime']['input']>;
  margin?: InputMaybe<Scalars['BigFloat']['input']>;
  mediaItemToHeroImageId?: InputMaybe<FkQuoteMediaItemHeroImageIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  quoteAcceptancesUsingId?: InputMaybe<FkQuoteAcceptanceQuoteInverseInput>;
  quoteAccommodationDetailsUsingId?: InputMaybe<FkQuoteAccommodationDetailQuoteQuoteIdInverseInput>;
  quoteCurrenciesUsingId?: InputMaybe<FkQuoteCurrencyQuoteQuoteIdInverseInput>;
  quoteDaysUsingId?: InputMaybe<FkQuoteDayQuoteQuoteIdInverseInput>;
  quoteFinanceLineItemsUsingId?: InputMaybe<FkQuoteFinanceLineItemQuoteQuoteIdInverseInput>;
  quoteHeroToHeroId?: InputMaybe<FkQuoteQuoteHeroHeroIdInput>;
  quoteLegalDocumentsUsingId?: InputMaybe<FkQuoteLegalDocumentQuoteInverseInput>;
  quoteStatusToStatus?: InputMaybe<FkQuoteStatusInput>;
  quoteViewsUsingId?: InputMaybe<FkQuoteViewQuoteQuoteIdInverseInput>;
  shortDescription?: InputMaybe<Scalars['String']['input']>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  travellerCount?: InputMaybe<Scalars['Int']['input']>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkQuoteTripTripIdInput>;
  tripsUsingId?: InputMaybe<FkTripQuoteActiveQuoteIdInverseInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkQuoteUserUserIdInput>;
};

/** The `trip` to be created by this mutation. */
export type FkTripQuoteActiveQuoteIdTripCreateInput = {
  agencyId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberToAgencyMemberId?: InputMaybe<FkTripAgencyMemberAgencyMemberIdInput>;
  agencyToAgencyId?: InputMaybe<FkTripAgencyAgencyIdInput>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerId?: InputMaybe<Scalars['UUID']['input']>;
  customerToCustomerId?: InputMaybe<FkTripCustomerCustomerIdInput>;
  dates?: InputMaybe<Scalars['String']['input']>;
  destination?: InputMaybe<Scalars['String']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  emailsUsingId?: InputMaybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: InputMaybe<FkEnquiryTripTripIdInverseInput>;
  expensesUsingId?: InputMaybe<FkExpenseTripTripIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceTripTripIdInverseInput>;
  mediaGalleryId?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryToMediaGalleryId?: InputMaybe<FkTripMediaGalleryMediaGalleryIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notesUsingId?: InputMaybe<FkNoteTripTripIdInverseInput>;
  paymentsUsingId?: InputMaybe<FkPaymentTripTripIdInverseInput>;
  quotePublicsUsingId?: InputMaybe<FakePublicQuotePublicForeignKey0InverseInput>;
  quoteToActiveQuoteId?: InputMaybe<FkTripQuoteActiveQuoteIdInput>;
  quotesUsingId?: InputMaybe<FkQuoteTripTripIdInverseInput>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceTripTripIdInverseInput>;
  testimonialsUsingId?: InputMaybe<FkTestimonialTripTripIdInverseInput>;
  tripFlightsUsingId?: InputMaybe<FkTripFlightTripTripIdInverseInput>;
  tripTravellersUsingId?: InputMaybe<FkTripTravellerTripTripIdInverseInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkTripUserUserIdInput>;
};

/** Input for the nested mutation of `traveller` in the `TripTravellerInput` mutation. */
export type FkTripTravellerTravellerTravellerIdInput = {
  /** The primary key(s) for `traveller` for the far side of the relationship. */
  connectById?: InputMaybe<TravellerPkTravellerConnect>;
  /** A `TravellerInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkTripTravellerTravellerTravellerIdTravellerCreateInput>;
  /** The primary key(s) for `traveller` for the far side of the relationship. */
  deleteById?: InputMaybe<TravellerPkTravellerDelete>;
  /** The primary key(s) and patch data for `traveller` for the far side of the relationship. */
  updateById?: InputMaybe<TravellerOnTripTravellerForFkTripTravellerTravellerTravellerIdUsingPkTravellerUpdate>;
};

/** Input for the nested mutation of `tripTraveller` in the `TravellerInput` mutation. */
export type FkTripTravellerTravellerTravellerIdInverseInput = {
  /** The primary key(s) for `tripTraveller` for the far side of the relationship. */
  connectById?: InputMaybe<Array<TripTravellerPkTripTravellerConnect>>;
  /** A `TripTravellerInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkTripTravellerTravellerTravellerIdTripTravellerCreateInput>>;
  /** The primary key(s) for `tripTraveller` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<TripTravellerPkTripTravellerDelete>>;
  /** Flag indicating whether all other `tripTraveller` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `tripTraveller` for the far side of the relationship. */
  updateById?: InputMaybe<Array<TripTravellerOnTripTravellerForFkTripTravellerTravellerTravellerIdUsingPkTripTravellerUpdate>>;
};

/** The `traveller` to be created by this mutation. */
export type FkTripTravellerTravellerTravellerIdTravellerCreateInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerTravellersUsingId?: InputMaybe<FkCustomerTravellerTravellerTravellerIdInverseInput>;
  dateOfBirth?: InputMaybe<Scalars['Datetime']['input']>;
  dietaryRequirements?: InputMaybe<Scalars['String']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  emergencyContact?: InputMaybe<Scalars['String']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  height?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  insuranceDetails?: InputMaybe<Scalars['String']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  medicalConditions?: InputMaybe<Scalars['String']['input']>;
  middleName?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  nationality?: InputMaybe<Scalars['String']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  passportsUsingId?: InputMaybe<FkPassportTravellerTravellerIdInverseInput>;
  phone?: InputMaybe<Scalars['String']['input']>;
  tripTravellersUsingId?: InputMaybe<FkTripTravellerTravellerTravellerIdInverseInput>;
  weight?: InputMaybe<Scalars['Int']['input']>;
};

/** The `tripTraveller` to be created by this mutation. */
export type FkTripTravellerTravellerTravellerIdTripTravellerCreateInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  travellerToTravellerId?: InputMaybe<FkTripTravellerTravellerTravellerIdInput>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkTripTravellerTripTripIdInput>;
};

/** Input for the nested mutation of `trip` in the `TripTravellerInput` mutation. */
export type FkTripTravellerTripTripIdInput = {
  /** The primary key(s) for `trip` for the far side of the relationship. */
  connectById?: InputMaybe<TripPkTripConnect>;
  /** A `TripInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkTripTravellerTripTripIdTripCreateInput>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  deleteById?: InputMaybe<TripPkTripDelete>;
  /** The primary key(s) and patch data for `trip` for the far side of the relationship. */
  updateById?: InputMaybe<TripOnTripTravellerForFkTripTravellerTripTripIdUsingPkTripUpdate>;
};

/** Input for the nested mutation of `tripTraveller` in the `TripInput` mutation. */
export type FkTripTravellerTripTripIdInverseInput = {
  /** The primary key(s) for `tripTraveller` for the far side of the relationship. */
  connectById?: InputMaybe<Array<TripTravellerPkTripTravellerConnect>>;
  /** A `TripTravellerInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkTripTravellerTripTripIdTripTravellerCreateInput>>;
  /** The primary key(s) for `tripTraveller` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<TripTravellerPkTripTravellerDelete>>;
  /** Flag indicating whether all other `tripTraveller` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `tripTraveller` for the far side of the relationship. */
  updateById?: InputMaybe<Array<TripTravellerOnTripTravellerForFkTripTravellerTripTripIdUsingPkTripTravellerUpdate>>;
};

/** The `trip` to be created by this mutation. */
export type FkTripTravellerTripTripIdTripCreateInput = {
  activeQuoteId?: InputMaybe<Scalars['UUID']['input']>;
  agencyId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberToAgencyMemberId?: InputMaybe<FkTripAgencyMemberAgencyMemberIdInput>;
  agencyToAgencyId?: InputMaybe<FkTripAgencyAgencyIdInput>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerId?: InputMaybe<Scalars['UUID']['input']>;
  customerToCustomerId?: InputMaybe<FkTripCustomerCustomerIdInput>;
  dates?: InputMaybe<Scalars['String']['input']>;
  destination?: InputMaybe<Scalars['String']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  emailsUsingId?: InputMaybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: InputMaybe<FkEnquiryTripTripIdInverseInput>;
  expensesUsingId?: InputMaybe<FkExpenseTripTripIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceTripTripIdInverseInput>;
  mediaGalleryId?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryToMediaGalleryId?: InputMaybe<FkTripMediaGalleryMediaGalleryIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notesUsingId?: InputMaybe<FkNoteTripTripIdInverseInput>;
  paymentsUsingId?: InputMaybe<FkPaymentTripTripIdInverseInput>;
  quotePublicsUsingId?: InputMaybe<FakePublicQuotePublicForeignKey0InverseInput>;
  quoteToActiveQuoteId?: InputMaybe<FkTripQuoteActiveQuoteIdInput>;
  quotesUsingId?: InputMaybe<FkQuoteTripTripIdInverseInput>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceTripTripIdInverseInput>;
  testimonialsUsingId?: InputMaybe<FkTestimonialTripTripIdInverseInput>;
  tripFlightsUsingId?: InputMaybe<FkTripFlightTripTripIdInverseInput>;
  tripTravellersUsingId?: InputMaybe<FkTripTravellerTripTripIdInverseInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkTripUserUserIdInput>;
};

/** The `tripTraveller` to be created by this mutation. */
export type FkTripTravellerTripTripIdTripTravellerCreateInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  travellerId?: InputMaybe<Scalars['UUID']['input']>;
  travellerToTravellerId?: InputMaybe<FkTripTravellerTravellerTravellerIdInput>;
  tripToTripId?: InputMaybe<FkTripTravellerTripTripIdInput>;
};

/** Input for the nested mutation of `user` in the `TripInput` mutation. */
export type FkTripUserUserIdInput = {
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectById?: InputMaybe<UserPkUserConnect>;
  /** A `UserInput` object that will be created and connected to this object. */
  create?: InputMaybe<FkTripUserUserIdUserCreateInput>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteById?: InputMaybe<UserPkUserDelete>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateById?: InputMaybe<UserOnTripForFkTripUserUserIdUsingPkUserUpdate>;
};

/** Input for the nested mutation of `trip` in the `UserInput` mutation. */
export type FkTripUserUserIdInverseInput = {
  /** The primary key(s) for `trip` for the far side of the relationship. */
  connectById?: InputMaybe<Array<TripPkTripConnect>>;
  /** A `TripInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FkTripUserUserIdTripCreateInput>>;
  /** The primary key(s) for `trip` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<TripPkTripDelete>>;
  /** Flag indicating whether all other `trip` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `trip` for the far side of the relationship. */
  updateById?: InputMaybe<Array<TripOnTripForFkTripUserUserIdUsingPkTripUpdate>>;
};

/** The `trip` to be created by this mutation. */
export type FkTripUserUserIdTripCreateInput = {
  activeQuoteId?: InputMaybe<Scalars['UUID']['input']>;
  agencyId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberToAgencyMemberId?: InputMaybe<FkTripAgencyMemberAgencyMemberIdInput>;
  agencyToAgencyId?: InputMaybe<FkTripAgencyAgencyIdInput>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerId?: InputMaybe<Scalars['UUID']['input']>;
  customerToCustomerId?: InputMaybe<FkTripCustomerCustomerIdInput>;
  dates?: InputMaybe<Scalars['String']['input']>;
  destination?: InputMaybe<Scalars['String']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  emailsUsingId?: InputMaybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: InputMaybe<FkEnquiryTripTripIdInverseInput>;
  expensesUsingId?: InputMaybe<FkExpenseTripTripIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceTripTripIdInverseInput>;
  mediaGalleryId?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryToMediaGalleryId?: InputMaybe<FkTripMediaGalleryMediaGalleryIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notesUsingId?: InputMaybe<FkNoteTripTripIdInverseInput>;
  paymentsUsingId?: InputMaybe<FkPaymentTripTripIdInverseInput>;
  quotePublicsUsingId?: InputMaybe<FakePublicQuotePublicForeignKey0InverseInput>;
  quoteToActiveQuoteId?: InputMaybe<FkTripQuoteActiveQuoteIdInput>;
  quotesUsingId?: InputMaybe<FkQuoteTripTripIdInverseInput>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceTripTripIdInverseInput>;
  testimonialsUsingId?: InputMaybe<FkTestimonialTripTripIdInverseInput>;
  tripFlightsUsingId?: InputMaybe<FkTripFlightTripTripIdInverseInput>;
  tripTravellersUsingId?: InputMaybe<FkTripTravellerTripTripIdInverseInput>;
  userToUserId?: InputMaybe<FkTripUserUserIdInput>;
};

/** The `user` to be created by this mutation. */
export type FkTripUserUserIdUserCreateInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  emailsUsingId?: InputMaybe<FkEmailUserUserIdInverseInput>;
  externalId?: InputMaybe<Scalars['String']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  genderPreposition?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name: Scalars['String']['input'];
  notesUsingId?: InputMaybe<FkNoteUserUserIdInverseInput>;
  password?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  quotePublicsUsingId?: InputMaybe<FakePublicQuotePublicForeignKey2InverseInput>;
  quotesUsingId?: InputMaybe<FkQuoteUserUserIdInverseInput>;
  remindersUsingId?: InputMaybe<FkReminderUserUserIdInverseInput>;
  skype?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  transactionNotesUsingId?: InputMaybe<FkTransactionNoteUserUserIdInverseInput>;
  tripsUsingId?: InputMaybe<FkTripUserUserIdInverseInput>;
};

/** A filter to be used against Float fields. All fields are combined with a logical ‘and.’ */
export type FloatFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['Float']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['Float']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['Float']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['Float']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['Float']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['Float']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['Float']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['Float']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['Float']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['Float']['input']>>;
};

export type GenerateUploadUrlInput = {
  contentType: Scalars['String']['input'];
  hash: Scalars['String']['input'];
  protected: Scalars['Boolean']['input'];
};

export type GenericResponse = {
  __typename?: 'GenericResponse';
  message?: Maybe<Scalars['String']['output']>;
  success: Scalars['Boolean']['output'];
};

export type GptItineraryImport = {
  input: Scalars['String']['input'];
};

export type GptItineraryImportOutput = {
  __typename?: 'GptItineraryImportOutput';
  accommodation: Array<GptItineraryImportOutputAccommodation>;
  duration: Scalars['Int']['output'];
  finance: Array<GptItineraryImportOutputFinanceItem>;
  itinerary: Array<GptItineraryImportOutputItineraryDay>;
  startDate: Scalars['String']['output'];
  summary: Scalars['String']['output'];
  title: Scalars['String']['output'];
};

export type GptItineraryImportOutputAccommodation = {
  __typename?: 'GptItineraryImportOutputAccommodation';
  date: Scalars['String']['output'];
  destination: Scalars['String']['output'];
  inclusions: GptItineraryImportOutputAccommodationInclusions;
  index: Scalars['Int']['output'];
  latitude: Scalars['Float']['output'];
  longitude: Scalars['Float']['output'];
  name: Scalars['String']['output'];
  nearestAirport: Scalars['String']['output'];
  nights: Scalars['Int']['output'];
  summary: Scalars['String']['output'];
};

export type GptItineraryImportOutputAccommodationInclusions = {
  __typename?: 'GptItineraryImportOutputAccommodationInclusions';
  beverages: GptItineraryImportOutputAccommodationInclusionsBeverages;
  food: GptItineraryImportOutputAccommodationInclusionsFood;
};

export type GptItineraryImportOutputAccommodationInclusionsBeverages = {
  __typename?: 'GptItineraryImportOutputAccommodationInclusionsBeverages';
  all: Scalars['Boolean']['output'];
  local: Scalars['Boolean']['output'];
};

export type GptItineraryImportOutputAccommodationInclusionsFood = {
  __typename?: 'GptItineraryImportOutputAccommodationInclusionsFood';
  breakfast: Scalars['Boolean']['output'];
  dinner: Scalars['Boolean']['output'];
  lunch: Scalars['Boolean']['output'];
};

export type GptItineraryImportOutputFinanceItem = {
  __typename?: 'GptItineraryImportOutputFinanceItem';
  amount: Scalars['Float']['output'];
  currency: Scalars['String']['output'];
};

export type GptItineraryImportOutputItineraryDay = {
  __typename?: 'GptItineraryImportOutputItineraryDay';
  accommodationIndex?: Maybe<Scalars['Int']['output']>;
  date: Scalars['String']['output'];
  detail: Scalars['String']['output'];
  summary: Array<Scalars['String']['output']>;
};

export type GptItineraryInput = {
  days: Array<GptItineraryInputDay>;
};

export type GptItineraryInputDay = {
  date: Scalars['String']['input'];
  day: Scalars['Int']['input'];
  detail?: InputMaybe<Scalars['String']['input']>;
  property: Scalars['String']['input'];
};

export type GptItineraryOutput = {
  __typename?: 'GptItineraryOutput';
  days: Array<GptItineraryOutputDay>;
};

export type GptItineraryOutputDay = {
  __typename?: 'GptItineraryOutputDay';
  day: Scalars['Int']['output'];
  detail?: Maybe<Scalars['String']['output']>;
  summary?: Maybe<Scalars['String']['output']>;
};

export type ImportWetuInput = {
  id: Scalars['String']['input'];
  quote: Scalars['String']['input'];
};

/** A filter to be used against Int fields. All fields are combined with a logical ‘and.’ */
export type IntFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['Int']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['Int']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['Int']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['Int']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['Int']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['Int']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['Int']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['Int']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['Int']['input']>>;
};

export type Invoice = {
  __typename?: 'Invoice';
  amount: Scalars['BigFloat']['output'];
  /** Reads a single `FinanceCategory` that is related to this `Invoice`. */
  category?: Maybe<FinanceCategory>;
  categoryId?: Maybe<Scalars['UUID']['output']>;
  created: Scalars['Datetime']['output'];
  currency?: Maybe<Scalars['String']['output']>;
  due: Scalars['Datetime']['output'];
  /** Reads and enables pagination through a set of `Expense`. */
  expenses: ExpensesConnection;
  id: Scalars['UUID']['output'];
  invoiced: Scalars['Datetime']['output'];
  key?: Maybe<Scalars['String']['output']>;
  locked?: Maybe<Scalars['Datetime']['output']>;
  modified: Scalars['Datetime']['output'];
  note?: Maybe<Scalars['String']['output']>;
  number: Scalars['Int']['output'];
  paid?: Maybe<Scalars['Datetime']['output']>;
  /** Reads and enables pagination through a set of `Payment`. */
  payments: PaymentsConnection;
  /** Reads a single `Quote` that is related to this `Invoice`. */
  quote?: Maybe<Quote>;
  quoteId?: Maybe<Scalars['UUID']['output']>;
  summary?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `TransactionLink`. */
  transactionLinks: TransactionLinksConnection;
  /** Reads a single `Trip` that is related to this `Invoice`. */
  trip?: Maybe<Trip>;
  tripId?: Maybe<Scalars['UUID']['output']>;
  type?: Maybe<Scalars['String']['output']>;
  voided?: Maybe<Scalars['Datetime']['output']>;
};


export type InvoiceExpensesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ExpenseCondition>;
  filter?: InputMaybe<ExpenseFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ExpensesOrderBy>>;
};


export type InvoicePaymentsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PaymentCondition>;
  filter?: InputMaybe<PaymentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PaymentsOrderBy>>;
};


export type InvoiceTransactionLinksArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TransactionLinkCondition>;
  filter?: InputMaybe<TransactionLinkFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TransactionLinksOrderBy>>;
};

/** A condition to be used against `Invoice` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type InvoiceCondition = {
  /** Checks for equality with the object’s `amount` field. */
  amount?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `categoryId` field. */
  categoryId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `currency` field. */
  currency?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `due` field. */
  due?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `invoiced` field. */
  invoiced?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `key` field. */
  key?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `locked` field. */
  locked?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `note` field. */
  note?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `number` field. */
  number?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `paid` field. */
  paid?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `quoteId` field. */
  quoteId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `summary` field. */
  summary?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `tripId` field. */
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `type` field. */
  type?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `voided` field. */
  voided?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A filter to be used against `Invoice` object types. All fields are combined with a logical ‘and.’ */
export type InvoiceFilter = {
  /** Filter by the object’s `amount` field. */
  amount?: InputMaybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<InvoiceFilter>>;
  /** Filter by the object’s `category` relation. */
  category?: InputMaybe<FinanceCategoryFilter>;
  /** A related `category` exists. */
  categoryExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `categoryId` field. */
  categoryId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `currency` field. */
  currency?: InputMaybe<StringFilter>;
  /** Filter by the object’s `due` field. */
  due?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `expenses` relation. */
  expenses?: InputMaybe<InvoiceToManyExpenseFilter>;
  /** Some related `expenses` exist. */
  expensesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `invoiced` field. */
  invoiced?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `key` field. */
  key?: InputMaybe<StringFilter>;
  /** Filter by the object’s `locked` field. */
  locked?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<InvoiceFilter>;
  /** Filter by the object’s `note` field. */
  note?: InputMaybe<StringFilter>;
  /** Filter by the object’s `number` field. */
  number?: InputMaybe<IntFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<InvoiceFilter>>;
  /** Filter by the object’s `paid` field. */
  paid?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `payments` relation. */
  payments?: InputMaybe<InvoiceToManyPaymentFilter>;
  /** Some related `payments` exist. */
  paymentsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `quote` relation. */
  quote?: InputMaybe<QuoteFilter>;
  /** A related `quote` exists. */
  quoteExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `quoteId` field. */
  quoteId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `summary` field. */
  summary?: InputMaybe<StringFilter>;
  /** Filter by the object’s `transactionLinks` relation. */
  transactionLinks?: InputMaybe<InvoiceToManyTransactionLinkFilter>;
  /** Some related `transactionLinks` exist. */
  transactionLinksExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `trip` relation. */
  trip?: InputMaybe<TripFilter>;
  /** A related `trip` exists. */
  tripExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `tripId` field. */
  tripId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `type` field. */
  type?: InputMaybe<StringFilter>;
  /** Filter by the object’s `voided` field. */
  voided?: InputMaybe<DatetimeFilter>;
};

/** An input for mutations affecting `Invoice` */
export type InvoiceInput = {
  amount: Scalars['BigFloat']['input'];
  categoryId?: InputMaybe<Scalars['UUID']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  due: Scalars['Datetime']['input'];
  expensesUsingId?: InputMaybe<FkExpenseInvoiceInvoiceIdInverseInput>;
  financeCategoryToCategoryId?: InputMaybe<FkInvoiceFinanceCategoryCategoryIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoiced?: InputMaybe<Scalars['Datetime']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  locked?: InputMaybe<Scalars['Datetime']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  note?: InputMaybe<Scalars['String']['input']>;
  number?: InputMaybe<Scalars['Int']['input']>;
  paid?: InputMaybe<Scalars['Datetime']['input']>;
  paymentsUsingId?: InputMaybe<FkPaymentInvoiceInvoiceIdInverseInput>;
  quoteId?: InputMaybe<Scalars['UUID']['input']>;
  quoteToQuoteId?: InputMaybe<FkInvoiceQuoteQuoteIdInput>;
  summary?: InputMaybe<Scalars['String']['input']>;
  transactionLinksUsingId?: InputMaybe<FkTransactionLinkInvoiceInvoiceIdInverseInput>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkInvoiceTripTripIdInput>;
  type?: InputMaybe<Scalars['String']['input']>;
  voided?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The fields on `invoice` to look up the row to update. */
export type InvoiceOnExpenseForFkExpenseInvoiceInvoiceIdUsingPkInvoiceUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `invoice` being updated. */
  patch: UpdateInvoiceOnExpenseForFkExpenseInvoiceInvoiceIdPatch;
};

/** The fields on `invoice` to look up the row to update. */
export type InvoiceOnInvoiceForFkInvoiceFinanceCategoryCategoryIdUsingPkInvoiceUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `invoice` being updated. */
  patch: UpdateInvoiceOnInvoiceForFkInvoiceFinanceCategoryCategoryIdPatch;
};

/** The fields on `invoice` to look up the row to update. */
export type InvoiceOnInvoiceForFkInvoiceQuoteQuoteIdUsingPkInvoiceUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `invoice` being updated. */
  patch: UpdateInvoiceOnInvoiceForFkInvoiceQuoteQuoteIdPatch;
};

/** The fields on `invoice` to look up the row to update. */
export type InvoiceOnInvoiceForFkInvoiceTripTripIdUsingPkInvoiceUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `invoice` being updated. */
  patch: UpdateInvoiceOnInvoiceForFkInvoiceTripTripIdPatch;
};

/** The fields on `invoice` to look up the row to update. */
export type InvoiceOnPaymentForFkPaymentInvoiceInvoiceIdUsingPkInvoiceUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `invoice` being updated. */
  patch: UpdateInvoiceOnPaymentForFkPaymentInvoiceInvoiceIdPatch;
};

/** The fields on `invoice` to look up the row to update. */
export type InvoiceOnTransactionLinkForFkTransactionLinkInvoiceInvoiceIdUsingPkInvoiceUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `invoice` being updated. */
  patch: UpdateInvoiceOnTransactionLinkForFkTransactionLinkInvoiceInvoiceIdPatch;
};

/** Represents an update to a `Invoice`. Fields that are set will be updated. */
export type InvoicePatch = {
  amount?: InputMaybe<Scalars['BigFloat']['input']>;
  categoryId?: InputMaybe<Scalars['UUID']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  due?: InputMaybe<Scalars['Datetime']['input']>;
  expensesUsingId?: InputMaybe<FkExpenseInvoiceInvoiceIdInverseInput>;
  financeCategoryToCategoryId?: InputMaybe<FkInvoiceFinanceCategoryCategoryIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoiced?: InputMaybe<Scalars['Datetime']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  locked?: InputMaybe<Scalars['Datetime']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  note?: InputMaybe<Scalars['String']['input']>;
  number?: InputMaybe<Scalars['Int']['input']>;
  paid?: InputMaybe<Scalars['Datetime']['input']>;
  paymentsUsingId?: InputMaybe<FkPaymentInvoiceInvoiceIdInverseInput>;
  quoteId?: InputMaybe<Scalars['UUID']['input']>;
  quoteToQuoteId?: InputMaybe<FkInvoiceQuoteQuoteIdInput>;
  summary?: InputMaybe<Scalars['String']['input']>;
  transactionLinksUsingId?: InputMaybe<FkTransactionLinkInvoiceInvoiceIdInverseInput>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkInvoiceTripTripIdInput>;
  type?: InputMaybe<Scalars['String']['input']>;
  voided?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The fields on `invoice` to look up the row to connect. */
export type InvoicePkInvoiceConnect = {
  id: Scalars['UUID']['input'];
};

/** The fields on `invoice` to look up the row to delete. */
export type InvoicePkInvoiceDelete = {
  id: Scalars['UUID']['input'];
};

export type InvoicePublic = {
  __typename?: 'InvoicePublic';
  amount?: Maybe<Scalars['BigFloat']['output']>;
  amountDue?: Maybe<Scalars['BigFloat']['output']>;
  amountPaid?: Maybe<Scalars['BigFloat']['output']>;
  categoryId?: Maybe<Scalars['UUID']['output']>;
  currency?: Maybe<Scalars['String']['output']>;
  due?: Maybe<Scalars['Datetime']['output']>;
  id: Scalars['UUID']['output'];
  invoiced?: Maybe<Scalars['Datetime']['output']>;
  key?: Maybe<Scalars['String']['output']>;
  number?: Maybe<Scalars['Int']['output']>;
  paid?: Maybe<Scalars['Datetime']['output']>;
  summary?: Maybe<Scalars['String']['output']>;
  trip?: Maybe<Scalars['String']['output']>;
  tripId?: Maybe<Scalars['UUID']['output']>;
};

/**
 * A condition to be used against `InvoicePublic` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type InvoicePublicCondition = {
  /** Checks for equality with the object’s `amount` field. */
  amount?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `amountDue` field. */
  amountDue?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `amountPaid` field. */
  amountPaid?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `categoryId` field. */
  categoryId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `currency` field. */
  currency?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `due` field. */
  due?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `invoiced` field. */
  invoiced?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `key` field. */
  key?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `number` field. */
  number?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `paid` field. */
  paid?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `summary` field. */
  summary?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `trip` field. */
  trip?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `tripId` field. */
  tripId?: InputMaybe<Scalars['UUID']['input']>;
};

/** A filter to be used against `InvoicePublic` object types. All fields are combined with a logical ‘and.’ */
export type InvoicePublicFilter = {
  /** Filter by the object’s `amount` field. */
  amount?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `amountDue` field. */
  amountDue?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `amountPaid` field. */
  amountPaid?: InputMaybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<InvoicePublicFilter>>;
  /** Filter by the object’s `categoryId` field. */
  categoryId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `currency` field. */
  currency?: InputMaybe<StringFilter>;
  /** Filter by the object’s `due` field. */
  due?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `invoiced` field. */
  invoiced?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `key` field. */
  key?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<InvoicePublicFilter>;
  /** Filter by the object’s `number` field. */
  number?: InputMaybe<IntFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<InvoicePublicFilter>>;
  /** Filter by the object’s `paid` field. */
  paid?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `summary` field. */
  summary?: InputMaybe<StringFilter>;
  /** Filter by the object’s `trip` field. */
  trip?: InputMaybe<StringFilter>;
  /** Filter by the object’s `tripId` field. */
  tripId?: InputMaybe<UuidFilter>;
};

/** A connection to a list of `InvoicePublic` values. */
export type InvoicePublicsConnection = {
  __typename?: 'InvoicePublicsConnection';
  /** A list of edges which contains the `InvoicePublic` and cursor to aid in pagination. */
  edges: Array<InvoicePublicsEdge>;
  /** A list of `InvoicePublic` objects. */
  nodes: Array<Maybe<InvoicePublic>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `InvoicePublic` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `InvoicePublic` edge in the connection. */
export type InvoicePublicsEdge = {
  __typename?: 'InvoicePublicsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `InvoicePublic` at the end of the edge. */
  node?: Maybe<InvoicePublic>;
};

/** Methods to use when ordering `InvoicePublic`. */
export enum InvoicePublicsOrderBy {
  AmountAsc = 'AMOUNT_ASC',
  AmountDesc = 'AMOUNT_DESC',
  AmountDueAsc = 'AMOUNT_DUE_ASC',
  AmountDueDesc = 'AMOUNT_DUE_DESC',
  AmountPaidAsc = 'AMOUNT_PAID_ASC',
  AmountPaidDesc = 'AMOUNT_PAID_DESC',
  CategoryIdAsc = 'CATEGORY_ID_ASC',
  CategoryIdDesc = 'CATEGORY_ID_DESC',
  CurrencyAsc = 'CURRENCY_ASC',
  CurrencyDesc = 'CURRENCY_DESC',
  DueAsc = 'DUE_ASC',
  DueDesc = 'DUE_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  InvoicedAsc = 'INVOICED_ASC',
  InvoicedDesc = 'INVOICED_DESC',
  KeyAsc = 'KEY_ASC',
  KeyDesc = 'KEY_DESC',
  Natural = 'NATURAL',
  NumberAsc = 'NUMBER_ASC',
  NumberDesc = 'NUMBER_DESC',
  PaidAsc = 'PAID_ASC',
  PaidDesc = 'PAID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SummaryAsc = 'SUMMARY_ASC',
  SummaryDesc = 'SUMMARY_DESC',
  TripAsc = 'TRIP_ASC',
  TripDesc = 'TRIP_DESC',
  TripIdAsc = 'TRIP_ID_ASC',
  TripIdDesc = 'TRIP_ID_DESC'
}

/** A connection to a list of `InvoiceSummary` values. */
export type InvoiceSummariesConnection = {
  __typename?: 'InvoiceSummariesConnection';
  /** A list of edges which contains the `InvoiceSummary` and cursor to aid in pagination. */
  edges: Array<InvoiceSummariesEdge>;
  /** A list of `InvoiceSummary` objects. */
  nodes: Array<Maybe<InvoiceSummary>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `InvoiceSummary` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `InvoiceSummary` edge in the connection. */
export type InvoiceSummariesEdge = {
  __typename?: 'InvoiceSummariesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `InvoiceSummary` at the end of the edge. */
  node?: Maybe<InvoiceSummary>;
};

/** Methods to use when ordering `InvoiceSummary`. */
export enum InvoiceSummariesOrderBy {
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  OutstandingAsc = 'OUTSTANDING_ASC',
  OutstandingDesc = 'OUTSTANDING_DESC',
  PaidActualAsc = 'PAID_ACTUAL_ASC',
  PaidActualDesc = 'PAID_ACTUAL_DESC',
  PaidAsc = 'PAID_ASC',
  PaidDesc = 'PAID_DESC'
}

export type InvoiceSummary = {
  __typename?: 'InvoiceSummary';
  id?: Maybe<Scalars['UUID']['output']>;
  outstanding?: Maybe<Scalars['BigFloat']['output']>;
  paid?: Maybe<Scalars['BigFloat']['output']>;
  paidActual?: Maybe<Scalars['BigFloat']['output']>;
};

/**
 * A condition to be used against `InvoiceSummary` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type InvoiceSummaryCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `outstanding` field. */
  outstanding?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `paid` field. */
  paid?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `paidActual` field. */
  paidActual?: InputMaybe<Scalars['BigFloat']['input']>;
};

/** A filter to be used against `InvoiceSummary` object types. All fields are combined with a logical ‘and.’ */
export type InvoiceSummaryFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<InvoiceSummaryFilter>>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Negates the expression. */
  not?: InputMaybe<InvoiceSummaryFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<InvoiceSummaryFilter>>;
  /** Filter by the object’s `outstanding` field. */
  outstanding?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `paid` field. */
  paid?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `paidActual` field. */
  paidActual?: InputMaybe<BigFloatFilter>;
};

/** A filter to be used against many `Expense` object types. All fields are combined with a logical ‘and.’ */
export type InvoiceToManyExpenseFilter = {
  /** Every related `Expense` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ExpenseFilter>;
  /** No related `Expense` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ExpenseFilter>;
  /** Some related `Expense` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ExpenseFilter>;
};

/** A filter to be used against many `Payment` object types. All fields are combined with a logical ‘and.’ */
export type InvoiceToManyPaymentFilter = {
  /** Every related `Payment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<PaymentFilter>;
  /** No related `Payment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<PaymentFilter>;
  /** Some related `Payment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<PaymentFilter>;
};

/** A filter to be used against many `TransactionLink` object types. All fields are combined with a logical ‘and.’ */
export type InvoiceToManyTransactionLinkFilter = {
  /** Every related `TransactionLink` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<TransactionLinkFilter>;
  /** No related `TransactionLink` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<TransactionLinkFilter>;
  /** Some related `TransactionLink` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<TransactionLinkFilter>;
};

/** A connection to a list of `Invoice` values. */
export type InvoicesConnection = {
  __typename?: 'InvoicesConnection';
  /** A list of edges which contains the `Invoice` and cursor to aid in pagination. */
  edges: Array<InvoicesEdge>;
  /** A list of `Invoice` objects. */
  nodes: Array<Maybe<Invoice>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Invoice` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Invoice` edge in the connection. */
export type InvoicesEdge = {
  __typename?: 'InvoicesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Invoice` at the end of the edge. */
  node?: Maybe<Invoice>;
};

/** Methods to use when ordering `Invoice`. */
export enum InvoicesOrderBy {
  AmountAsc = 'AMOUNT_ASC',
  AmountDesc = 'AMOUNT_DESC',
  CategoryIdAsc = 'CATEGORY_ID_ASC',
  CategoryIdDesc = 'CATEGORY_ID_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  CurrencyAsc = 'CURRENCY_ASC',
  CurrencyDesc = 'CURRENCY_DESC',
  DueAsc = 'DUE_ASC',
  DueDesc = 'DUE_DESC',
  ExpensesByInvoiceIdCountAsc = 'EXPENSES_BY_INVOICE_ID__COUNT_ASC',
  ExpensesByInvoiceIdCountDesc = 'EXPENSES_BY_INVOICE_ID__COUNT_DESC',
  FinanceCategoryByCategoryIdCodeAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__CODE_ASC',
  FinanceCategoryByCategoryIdCodeDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__CODE_DESC',
  FinanceCategoryByCategoryIdCreatedAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__CREATED_ASC',
  FinanceCategoryByCategoryIdCreatedDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__CREATED_DESC',
  FinanceCategoryByCategoryIdIdAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__ID_ASC',
  FinanceCategoryByCategoryIdIdDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__ID_DESC',
  FinanceCategoryByCategoryIdModifiedAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__MODIFIED_ASC',
  FinanceCategoryByCategoryIdModifiedDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__MODIFIED_DESC',
  FinanceCategoryByCategoryIdNameAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__NAME_ASC',
  FinanceCategoryByCategoryIdNameDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__NAME_DESC',
  FinanceCategoryByCategoryIdSummaryAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__SUMMARY_ASC',
  FinanceCategoryByCategoryIdSummaryDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__SUMMARY_DESC',
  FinanceCategoryByCategoryIdTypeAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__TYPE_ASC',
  FinanceCategoryByCategoryIdTypeDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__TYPE_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  InvoicedAsc = 'INVOICED_ASC',
  InvoicedDesc = 'INVOICED_DESC',
  KeyAsc = 'KEY_ASC',
  KeyDesc = 'KEY_DESC',
  LockedAsc = 'LOCKED_ASC',
  LockedDesc = 'LOCKED_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  Natural = 'NATURAL',
  NoteAsc = 'NOTE_ASC',
  NoteDesc = 'NOTE_DESC',
  NumberAsc = 'NUMBER_ASC',
  NumberDesc = 'NUMBER_DESC',
  PaidAsc = 'PAID_ASC',
  PaidDesc = 'PAID_DESC',
  PaymentsByInvoiceIdCountAsc = 'PAYMENTS_BY_INVOICE_ID__COUNT_ASC',
  PaymentsByInvoiceIdCountDesc = 'PAYMENTS_BY_INVOICE_ID__COUNT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QuoteByQuoteIdAdjustmentAsc = 'QUOTE_BY_QUOTE_ID__ADJUSTMENT_ASC',
  QuoteByQuoteIdAdjustmentDesc = 'QUOTE_BY_QUOTE_ID__ADJUSTMENT_DESC',
  QuoteByQuoteIdAgentMarginAsc = 'QUOTE_BY_QUOTE_ID__AGENT_MARGIN_ASC',
  QuoteByQuoteIdAgentMarginDesc = 'QUOTE_BY_QUOTE_ID__AGENT_MARGIN_DESC',
  QuoteByQuoteIdArchivedAsc = 'QUOTE_BY_QUOTE_ID__ARCHIVED_ASC',
  QuoteByQuoteIdArchivedDesc = 'QUOTE_BY_QUOTE_ID__ARCHIVED_DESC',
  QuoteByQuoteIdBaseCurrencyAsc = 'QUOTE_BY_QUOTE_ID__BASE_CURRENCY_ASC',
  QuoteByQuoteIdBaseCurrencyDesc = 'QUOTE_BY_QUOTE_ID__BASE_CURRENCY_DESC',
  QuoteByQuoteIdCreatedAsc = 'QUOTE_BY_QUOTE_ID__CREATED_ASC',
  QuoteByQuoteIdCreatedDesc = 'QUOTE_BY_QUOTE_ID__CREATED_DESC',
  QuoteByQuoteIdDepositAsc = 'QUOTE_BY_QUOTE_ID__DEPOSIT_ASC',
  QuoteByQuoteIdDepositDesc = 'QUOTE_BY_QUOTE_ID__DEPOSIT_DESC',
  QuoteByQuoteIdDurationAsc = 'QUOTE_BY_QUOTE_ID__DURATION_ASC',
  QuoteByQuoteIdDurationDesc = 'QUOTE_BY_QUOTE_ID__DURATION_DESC',
  QuoteByQuoteIdExclusionsAsc = 'QUOTE_BY_QUOTE_ID__EXCLUSIONS_ASC',
  QuoteByQuoteIdExclusionsDesc = 'QUOTE_BY_QUOTE_ID__EXCLUSIONS_DESC',
  QuoteByQuoteIdExpiresAsc = 'QUOTE_BY_QUOTE_ID__EXPIRES_ASC',
  QuoteByQuoteIdExpiresDesc = 'QUOTE_BY_QUOTE_ID__EXPIRES_DESC',
  QuoteByQuoteIdHeroIdAsc = 'QUOTE_BY_QUOTE_ID__HERO_ID_ASC',
  QuoteByQuoteIdHeroIdDesc = 'QUOTE_BY_QUOTE_ID__HERO_ID_DESC',
  QuoteByQuoteIdHeroImageIdAsc = 'QUOTE_BY_QUOTE_ID__HERO_IMAGE_ID_ASC',
  QuoteByQuoteIdHeroImageIdDesc = 'QUOTE_BY_QUOTE_ID__HERO_IMAGE_ID_DESC',
  QuoteByQuoteIdIdAsc = 'QUOTE_BY_QUOTE_ID__ID_ASC',
  QuoteByQuoteIdIdDesc = 'QUOTE_BY_QUOTE_ID__ID_DESC',
  QuoteByQuoteIdInclusionsAsc = 'QUOTE_BY_QUOTE_ID__INCLUSIONS_ASC',
  QuoteByQuoteIdInclusionsDesc = 'QUOTE_BY_QUOTE_ID__INCLUSIONS_DESC',
  QuoteByQuoteIdKeyAsc = 'QUOTE_BY_QUOTE_ID__KEY_ASC',
  QuoteByQuoteIdKeyDesc = 'QUOTE_BY_QUOTE_ID__KEY_DESC',
  QuoteByQuoteIdLockedAsc = 'QUOTE_BY_QUOTE_ID__LOCKED_ASC',
  QuoteByQuoteIdLockedDesc = 'QUOTE_BY_QUOTE_ID__LOCKED_DESC',
  QuoteByQuoteIdMarginAsc = 'QUOTE_BY_QUOTE_ID__MARGIN_ASC',
  QuoteByQuoteIdMarginDesc = 'QUOTE_BY_QUOTE_ID__MARGIN_DESC',
  QuoteByQuoteIdModifiedAsc = 'QUOTE_BY_QUOTE_ID__MODIFIED_ASC',
  QuoteByQuoteIdModifiedDesc = 'QUOTE_BY_QUOTE_ID__MODIFIED_DESC',
  QuoteByQuoteIdShortDescriptionAsc = 'QUOTE_BY_QUOTE_ID__SHORT_DESCRIPTION_ASC',
  QuoteByQuoteIdShortDescriptionDesc = 'QUOTE_BY_QUOTE_ID__SHORT_DESCRIPTION_DESC',
  QuoteByQuoteIdStartAsc = 'QUOTE_BY_QUOTE_ID__START_ASC',
  QuoteByQuoteIdStartDesc = 'QUOTE_BY_QUOTE_ID__START_DESC',
  QuoteByQuoteIdStatusAsc = 'QUOTE_BY_QUOTE_ID__STATUS_ASC',
  QuoteByQuoteIdStatusDesc = 'QUOTE_BY_QUOTE_ID__STATUS_DESC',
  QuoteByQuoteIdSummaryAsc = 'QUOTE_BY_QUOTE_ID__SUMMARY_ASC',
  QuoteByQuoteIdSummaryDesc = 'QUOTE_BY_QUOTE_ID__SUMMARY_DESC',
  QuoteByQuoteIdTravellerCountAsc = 'QUOTE_BY_QUOTE_ID__TRAVELLER_COUNT_ASC',
  QuoteByQuoteIdTravellerCountDesc = 'QUOTE_BY_QUOTE_ID__TRAVELLER_COUNT_DESC',
  QuoteByQuoteIdTripIdAsc = 'QUOTE_BY_QUOTE_ID__TRIP_ID_ASC',
  QuoteByQuoteIdTripIdDesc = 'QUOTE_BY_QUOTE_ID__TRIP_ID_DESC',
  QuoteByQuoteIdUserIdAsc = 'QUOTE_BY_QUOTE_ID__USER_ID_ASC',
  QuoteByQuoteIdUserIdDesc = 'QUOTE_BY_QUOTE_ID__USER_ID_DESC',
  QuoteIdAsc = 'QUOTE_ID_ASC',
  QuoteIdDesc = 'QUOTE_ID_DESC',
  SummaryAsc = 'SUMMARY_ASC',
  SummaryDesc = 'SUMMARY_DESC',
  TransactionLinksByInvoiceIdCountAsc = 'TRANSACTION_LINKS_BY_INVOICE_ID__COUNT_ASC',
  TransactionLinksByInvoiceIdCountDesc = 'TRANSACTION_LINKS_BY_INVOICE_ID__COUNT_DESC',
  TripByTripIdActiveQuoteIdAsc = 'TRIP_BY_TRIP_ID__ACTIVE_QUOTE_ID_ASC',
  TripByTripIdActiveQuoteIdDesc = 'TRIP_BY_TRIP_ID__ACTIVE_QUOTE_ID_DESC',
  TripByTripIdAgencyIdAsc = 'TRIP_BY_TRIP_ID__AGENCY_ID_ASC',
  TripByTripIdAgencyIdDesc = 'TRIP_BY_TRIP_ID__AGENCY_ID_DESC',
  TripByTripIdAgencyMemberIdAsc = 'TRIP_BY_TRIP_ID__AGENCY_MEMBER_ID_ASC',
  TripByTripIdAgencyMemberIdDesc = 'TRIP_BY_TRIP_ID__AGENCY_MEMBER_ID_DESC',
  TripByTripIdArchivedAsc = 'TRIP_BY_TRIP_ID__ARCHIVED_ASC',
  TripByTripIdArchivedDesc = 'TRIP_BY_TRIP_ID__ARCHIVED_DESC',
  TripByTripIdBaseCurrencyAsc = 'TRIP_BY_TRIP_ID__BASE_CURRENCY_ASC',
  TripByTripIdBaseCurrencyDesc = 'TRIP_BY_TRIP_ID__BASE_CURRENCY_DESC',
  TripByTripIdCreatedAsc = 'TRIP_BY_TRIP_ID__CREATED_ASC',
  TripByTripIdCreatedDesc = 'TRIP_BY_TRIP_ID__CREATED_DESC',
  TripByTripIdCustomerIdAsc = 'TRIP_BY_TRIP_ID__CUSTOMER_ID_ASC',
  TripByTripIdCustomerIdDesc = 'TRIP_BY_TRIP_ID__CUSTOMER_ID_DESC',
  TripByTripIdDatesAsc = 'TRIP_BY_TRIP_ID__DATES_ASC',
  TripByTripIdDatesDesc = 'TRIP_BY_TRIP_ID__DATES_DESC',
  TripByTripIdDestinationAsc = 'TRIP_BY_TRIP_ID__DESTINATION_ASC',
  TripByTripIdDestinationDesc = 'TRIP_BY_TRIP_ID__DESTINATION_DESC',
  TripByTripIdDurationAsc = 'TRIP_BY_TRIP_ID__DURATION_ASC',
  TripByTripIdDurationDesc = 'TRIP_BY_TRIP_ID__DURATION_DESC',
  TripByTripIdIdAsc = 'TRIP_BY_TRIP_ID__ID_ASC',
  TripByTripIdIdDesc = 'TRIP_BY_TRIP_ID__ID_DESC',
  TripByTripIdMediaGalleryIdAsc = 'TRIP_BY_TRIP_ID__MEDIA_GALLERY_ID_ASC',
  TripByTripIdMediaGalleryIdDesc = 'TRIP_BY_TRIP_ID__MEDIA_GALLERY_ID_DESC',
  TripByTripIdModifiedAsc = 'TRIP_BY_TRIP_ID__MODIFIED_ASC',
  TripByTripIdModifiedDesc = 'TRIP_BY_TRIP_ID__MODIFIED_DESC',
  TripByTripIdNameAsc = 'TRIP_BY_TRIP_ID__NAME_ASC',
  TripByTripIdNameDesc = 'TRIP_BY_TRIP_ID__NAME_DESC',
  TripByTripIdStartAsc = 'TRIP_BY_TRIP_ID__START_ASC',
  TripByTripIdStartDesc = 'TRIP_BY_TRIP_ID__START_DESC',
  TripByTripIdStatusAsc = 'TRIP_BY_TRIP_ID__STATUS_ASC',
  TripByTripIdStatusDesc = 'TRIP_BY_TRIP_ID__STATUS_DESC',
  TripByTripIdSummaryAsc = 'TRIP_BY_TRIP_ID__SUMMARY_ASC',
  TripByTripIdSummaryDesc = 'TRIP_BY_TRIP_ID__SUMMARY_DESC',
  TripByTripIdUserIdAsc = 'TRIP_BY_TRIP_ID__USER_ID_ASC',
  TripByTripIdUserIdDesc = 'TRIP_BY_TRIP_ID__USER_ID_DESC',
  TripIdAsc = 'TRIP_ID_ASC',
  TripIdDesc = 'TRIP_ID_DESC',
  TypeAsc = 'TYPE_ASC',
  TypeDesc = 'TYPE_DESC',
  VoidedAsc = 'VOIDED_ASC',
  VoidedDesc = 'VOIDED_DESC'
}

export type LegalDocument = {
  __typename?: 'LegalDocument';
  body: Scalars['String']['output'];
  created?: Maybe<Scalars['Datetime']['output']>;
  /** Reads a single `LegalFolder` that is related to this `LegalDocument`. */
  folder?: Maybe<LegalFolder>;
  folderId: Scalars['UUID']['output'];
  id: Scalars['UUID']['output'];
  modified?: Maybe<Scalars['Datetime']['output']>;
  name: Scalars['String']['output'];
  /** Reads and enables pagination through a set of `QuoteLegalDocument`. */
  quoteLegalDocuments: QuoteLegalDocumentsConnection;
  validFrom?: Maybe<Scalars['Datetime']['output']>;
  validTo?: Maybe<Scalars['Datetime']['output']>;
};


export type LegalDocumentQuoteLegalDocumentsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<QuoteLegalDocumentCondition>;
  filter?: InputMaybe<QuoteLegalDocumentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuoteLegalDocumentsOrderBy>>;
};

/**
 * A condition to be used against `LegalDocument` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type LegalDocumentCondition = {
  /** Checks for equality with the object’s `body` field. */
  body?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `folderId` field. */
  folderId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `validFrom` field. */
  validFrom?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `validTo` field. */
  validTo?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A filter to be used against `LegalDocument` object types. All fields are combined with a logical ‘and.’ */
export type LegalDocumentFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<LegalDocumentFilter>>;
  /** Filter by the object’s `body` field. */
  body?: InputMaybe<StringFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `folder` relation. */
  folder?: InputMaybe<LegalFolderFilter>;
  /** Filter by the object’s `folderId` field. */
  folderId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<LegalDocumentFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<LegalDocumentFilter>>;
  /** Filter by the object’s `quoteLegalDocuments` relation. */
  quoteLegalDocuments?: InputMaybe<LegalDocumentToManyQuoteLegalDocumentFilter>;
  /** Some related `quoteLegalDocuments` exist. */
  quoteLegalDocumentsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `validFrom` field. */
  validFrom?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `validTo` field. */
  validTo?: InputMaybe<DatetimeFilter>;
};

/** An input for mutations affecting `LegalDocument` */
export type LegalDocumentInput = {
  body: Scalars['String']['input'];
  created?: InputMaybe<Scalars['Datetime']['input']>;
  folderId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  legalFolderToFolderId?: InputMaybe<FkLegalDocumentFolderInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name: Scalars['String']['input'];
  quoteLegalDocumentsUsingId?: InputMaybe<FkQuoteLegalDocumentLegalDocumentInverseInput>;
  validFrom?: InputMaybe<Scalars['Datetime']['input']>;
  validTo?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The fields on `legalDocument` to look up the row to update. */
export type LegalDocumentOnLegalDocumentForFkLegalDocumentFolderUsingPkLegalDocumentUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `legalDocument` being updated. */
  patch: UpdateLegalDocumentOnLegalDocumentForFkLegalDocumentFolderPatch;
};

/** The fields on `legalDocument` to look up the row to update. */
export type LegalDocumentOnQuoteLegalDocumentForFkQuoteLegalDocumentLegalDocumentUsingPkLegalDocumentUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `legalDocument` being updated. */
  patch: UpdateLegalDocumentOnQuoteLegalDocumentForFkQuoteLegalDocumentLegalDocumentPatch;
};

/** Represents an update to a `LegalDocument`. Fields that are set will be updated. */
export type LegalDocumentPatch = {
  body?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  folderId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  legalFolderToFolderId?: InputMaybe<FkLegalDocumentFolderInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  quoteLegalDocumentsUsingId?: InputMaybe<FkQuoteLegalDocumentLegalDocumentInverseInput>;
  validFrom?: InputMaybe<Scalars['Datetime']['input']>;
  validTo?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The fields on `legalDocument` to look up the row to connect. */
export type LegalDocumentPkLegalDocumentConnect = {
  id: Scalars['UUID']['input'];
};

/** The fields on `legalDocument` to look up the row to delete. */
export type LegalDocumentPkLegalDocumentDelete = {
  id: Scalars['UUID']['input'];
};

/** A filter to be used against many `QuoteLegalDocument` object types. All fields are combined with a logical ‘and.’ */
export type LegalDocumentToManyQuoteLegalDocumentFilter = {
  /** Every related `QuoteLegalDocument` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<QuoteLegalDocumentFilter>;
  /** No related `QuoteLegalDocument` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<QuoteLegalDocumentFilter>;
  /** Some related `QuoteLegalDocument` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<QuoteLegalDocumentFilter>;
};

/** A connection to a list of `LegalDocument` values. */
export type LegalDocumentsConnection = {
  __typename?: 'LegalDocumentsConnection';
  /** A list of edges which contains the `LegalDocument` and cursor to aid in pagination. */
  edges: Array<LegalDocumentsEdge>;
  /** A list of `LegalDocument` objects. */
  nodes: Array<Maybe<LegalDocument>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `LegalDocument` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `LegalDocument` edge in the connection. */
export type LegalDocumentsEdge = {
  __typename?: 'LegalDocumentsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `LegalDocument` at the end of the edge. */
  node?: Maybe<LegalDocument>;
};

/** Methods to use when ordering `LegalDocument`. */
export enum LegalDocumentsOrderBy {
  BodyAsc = 'BODY_ASC',
  BodyDesc = 'BODY_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  FolderIdAsc = 'FOLDER_ID_ASC',
  FolderIdDesc = 'FOLDER_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LegalFolderByFolderIdCreatedAsc = 'LEGAL_FOLDER_BY_FOLDER_ID__CREATED_ASC',
  LegalFolderByFolderIdCreatedDesc = 'LEGAL_FOLDER_BY_FOLDER_ID__CREATED_DESC',
  LegalFolderByFolderIdIdAsc = 'LEGAL_FOLDER_BY_FOLDER_ID__ID_ASC',
  LegalFolderByFolderIdIdDesc = 'LEGAL_FOLDER_BY_FOLDER_ID__ID_DESC',
  LegalFolderByFolderIdModifiedAsc = 'LEGAL_FOLDER_BY_FOLDER_ID__MODIFIED_ASC',
  LegalFolderByFolderIdModifiedDesc = 'LEGAL_FOLDER_BY_FOLDER_ID__MODIFIED_DESC',
  LegalFolderByFolderIdNameAsc = 'LEGAL_FOLDER_BY_FOLDER_ID__NAME_ASC',
  LegalFolderByFolderIdNameDesc = 'LEGAL_FOLDER_BY_FOLDER_ID__NAME_DESC',
  LegalFolderByFolderIdParentIdAsc = 'LEGAL_FOLDER_BY_FOLDER_ID__PARENT_ID_ASC',
  LegalFolderByFolderIdParentIdDesc = 'LEGAL_FOLDER_BY_FOLDER_ID__PARENT_ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QuoteLegalDocumentsByLegalDocumentIdCountAsc = 'QUOTE_LEGAL_DOCUMENTS_BY_LEGAL_DOCUMENT_ID__COUNT_ASC',
  QuoteLegalDocumentsByLegalDocumentIdCountDesc = 'QUOTE_LEGAL_DOCUMENTS_BY_LEGAL_DOCUMENT_ID__COUNT_DESC',
  ValidFromAsc = 'VALID_FROM_ASC',
  ValidFromDesc = 'VALID_FROM_DESC',
  ValidToAsc = 'VALID_TO_ASC',
  ValidToDesc = 'VALID_TO_DESC'
}

export type LegalFolder = {
  __typename?: 'LegalFolder';
  /** Reads and enables pagination through a set of `LegalFolder`. */
  childLegalFolders: LegalFoldersConnection;
  created?: Maybe<Scalars['Datetime']['output']>;
  id: Scalars['UUID']['output'];
  /** Reads and enables pagination through a set of `LegalDocument`. */
  legalDocumentsByFolderId: LegalDocumentsConnection;
  modified?: Maybe<Scalars['Datetime']['output']>;
  name: Scalars['String']['output'];
  /** Reads a single `LegalFolder` that is related to this `LegalFolder`. */
  parent?: Maybe<LegalFolder>;
  parentId?: Maybe<Scalars['UUID']['output']>;
};


export type LegalFolderChildLegalFoldersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<LegalFolderCondition>;
  filter?: InputMaybe<LegalFolderFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LegalFoldersOrderBy>>;
};


export type LegalFolderLegalDocumentsByFolderIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<LegalDocumentCondition>;
  filter?: InputMaybe<LegalDocumentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LegalDocumentsOrderBy>>;
};

/**
 * A condition to be used against `LegalFolder` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type LegalFolderCondition = {
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `parentId` field. */
  parentId?: InputMaybe<Scalars['UUID']['input']>;
};

/** A filter to be used against `LegalFolder` object types. All fields are combined with a logical ‘and.’ */
export type LegalFolderFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<LegalFolderFilter>>;
  /** Filter by the object’s `childLegalFolders` relation. */
  childLegalFolders?: InputMaybe<LegalFolderToManyLegalFolderFilter>;
  /** Some related `childLegalFolders` exist. */
  childLegalFoldersExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `legalDocumentsByFolderId` relation. */
  legalDocumentsByFolderId?: InputMaybe<LegalFolderToManyLegalDocumentFilter>;
  /** Some related `legalDocumentsByFolderId` exist. */
  legalDocumentsByFolderIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<LegalFolderFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<LegalFolderFilter>>;
  /** Filter by the object’s `parent` relation. */
  parent?: InputMaybe<LegalFolderFilter>;
  /** A related `parent` exists. */
  parentExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `parentId` field. */
  parentId?: InputMaybe<UuidFilter>;
};

/** An input for mutations affecting `LegalFolder` */
export type LegalFolderInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  legalDocumentsUsingId?: InputMaybe<FkLegalDocumentFolderInverseInput>;
  legalFolderToParentId?: InputMaybe<FkLegalFolderParentInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name: Scalars['String']['input'];
  parentId?: InputMaybe<Scalars['UUID']['input']>;
};

/** The fields on `legalFolder` to look up the row to update. */
export type LegalFolderOnLegalDocumentForFkLegalDocumentFolderUsingPkLegalFolderUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `legalFolder` being updated. */
  patch: UpdateLegalFolderOnLegalDocumentForFkLegalDocumentFolderPatch;
};

/** The fields on `legalFolder` to look up the row to update. */
export type LegalFolderOnLegalFolderForFkLegalFolderParentUsingPkLegalFolderUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `legalFolder` being updated. */
  patch: UpdateLegalFolderOnLegalFolderForFkLegalFolderParentPatch;
};

/** Represents an update to a `LegalFolder`. Fields that are set will be updated. */
export type LegalFolderPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  legalDocumentsUsingId?: InputMaybe<FkLegalDocumentFolderInverseInput>;
  legalFolderToParentId?: InputMaybe<FkLegalFolderParentInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  parentId?: InputMaybe<Scalars['UUID']['input']>;
};

/** The fields on `legalFolder` to look up the row to connect. */
export type LegalFolderPkLegalFolderConnect = {
  id: Scalars['UUID']['input'];
};

/** The fields on `legalFolder` to look up the row to delete. */
export type LegalFolderPkLegalFolderDelete = {
  id: Scalars['UUID']['input'];
};

/** A filter to be used against many `LegalDocument` object types. All fields are combined with a logical ‘and.’ */
export type LegalFolderToManyLegalDocumentFilter = {
  /** Every related `LegalDocument` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<LegalDocumentFilter>;
  /** No related `LegalDocument` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<LegalDocumentFilter>;
  /** Some related `LegalDocument` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<LegalDocumentFilter>;
};

/** A filter to be used against many `LegalFolder` object types. All fields are combined with a logical ‘and.’ */
export type LegalFolderToManyLegalFolderFilter = {
  /** Every related `LegalFolder` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<LegalFolderFilter>;
  /** No related `LegalFolder` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<LegalFolderFilter>;
  /** Some related `LegalFolder` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<LegalFolderFilter>;
};

/** A connection to a list of `LegalFolder` values. */
export type LegalFoldersConnection = {
  __typename?: 'LegalFoldersConnection';
  /** A list of edges which contains the `LegalFolder` and cursor to aid in pagination. */
  edges: Array<LegalFoldersEdge>;
  /** A list of `LegalFolder` objects. */
  nodes: Array<Maybe<LegalFolder>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `LegalFolder` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `LegalFolder` edge in the connection. */
export type LegalFoldersEdge = {
  __typename?: 'LegalFoldersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `LegalFolder` at the end of the edge. */
  node?: Maybe<LegalFolder>;
};

/** Methods to use when ordering `LegalFolder`. */
export enum LegalFoldersOrderBy {
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LegalDocumentsByFolderIdCountAsc = 'LEGAL_DOCUMENTS_BY_FOLDER_ID__COUNT_ASC',
  LegalDocumentsByFolderIdCountDesc = 'LEGAL_DOCUMENTS_BY_FOLDER_ID__COUNT_DESC',
  LegalFoldersByParentIdCountAsc = 'LEGAL_FOLDERS_BY_PARENT_ID__COUNT_ASC',
  LegalFoldersByParentIdCountDesc = 'LEGAL_FOLDERS_BY_PARENT_ID__COUNT_DESC',
  LegalFolderByParentIdCreatedAsc = 'LEGAL_FOLDER_BY_PARENT_ID__CREATED_ASC',
  LegalFolderByParentIdCreatedDesc = 'LEGAL_FOLDER_BY_PARENT_ID__CREATED_DESC',
  LegalFolderByParentIdIdAsc = 'LEGAL_FOLDER_BY_PARENT_ID__ID_ASC',
  LegalFolderByParentIdIdDesc = 'LEGAL_FOLDER_BY_PARENT_ID__ID_DESC',
  LegalFolderByParentIdModifiedAsc = 'LEGAL_FOLDER_BY_PARENT_ID__MODIFIED_ASC',
  LegalFolderByParentIdModifiedDesc = 'LEGAL_FOLDER_BY_PARENT_ID__MODIFIED_DESC',
  LegalFolderByParentIdNameAsc = 'LEGAL_FOLDER_BY_PARENT_ID__NAME_ASC',
  LegalFolderByParentIdNameDesc = 'LEGAL_FOLDER_BY_PARENT_ID__NAME_DESC',
  LegalFolderByParentIdParentIdAsc = 'LEGAL_FOLDER_BY_PARENT_ID__PARENT_ID_ASC',
  LegalFolderByParentIdParentIdDesc = 'LEGAL_FOLDER_BY_PARENT_ID__PARENT_ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  ParentIdAsc = 'PARENT_ID_ASC',
  ParentIdDesc = 'PARENT_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type MapPoint = {
  __typename?: 'MapPoint';
  created: Scalars['Datetime']['output'];
  id: Scalars['UUID']['output'];
  latitude: Scalars['Float']['output'];
  longitude: Scalars['Float']['output'];
  modified: Scalars['Datetime']['output'];
  name?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `Property`. */
  properties: PropertiesConnection;
};


export type MapPointPropertiesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PropertyCondition>;
  filter?: InputMaybe<PropertyFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PropertiesOrderBy>>;
};

/**
 * A condition to be used against `MapPoint` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type MapPointCondition = {
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `latitude` field. */
  latitude?: InputMaybe<Scalars['Float']['input']>;
  /** Checks for equality with the object’s `longitude` field. */
  longitude?: InputMaybe<Scalars['Float']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `MapPoint` object types. All fields are combined with a logical ‘and.’ */
export type MapPointFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<MapPointFilter>>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `latitude` field. */
  latitude?: InputMaybe<FloatFilter>;
  /** Filter by the object’s `longitude` field. */
  longitude?: InputMaybe<FloatFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<MapPointFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<MapPointFilter>>;
  /** Filter by the object’s `properties` relation. */
  properties?: InputMaybe<MapPointToManyPropertyFilter>;
  /** Some related `properties` exist. */
  propertiesExist?: InputMaybe<Scalars['Boolean']['input']>;
};

/** An input for mutations affecting `MapPoint` */
export type MapPointInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  latitude: Scalars['Float']['input'];
  longitude: Scalars['Float']['input'];
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  propertiesUsingId?: InputMaybe<FkPropertyMapPointMapPointIdInverseInput>;
};

/** The fields on `mapPoint` to look up the row to update. */
export type MapPointOnPropertyForFkPropertyMapPointMapPointIdUsingPkMapPointUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `mapPoint` being updated. */
  patch: UpdateMapPointOnPropertyForFkPropertyMapPointMapPointIdPatch;
};

/** Represents an update to a `MapPoint`. Fields that are set will be updated. */
export type MapPointPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  latitude?: InputMaybe<Scalars['Float']['input']>;
  longitude?: InputMaybe<Scalars['Float']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  propertiesUsingId?: InputMaybe<FkPropertyMapPointMapPointIdInverseInput>;
};

/** The fields on `mapPoint` to look up the row to connect. */
export type MapPointPkMapPointConnect = {
  id: Scalars['UUID']['input'];
};

/** The fields on `mapPoint` to look up the row to delete. */
export type MapPointPkMapPointDelete = {
  id: Scalars['UUID']['input'];
};

/** A filter to be used against many `Property` object types. All fields are combined with a logical ‘and.’ */
export type MapPointToManyPropertyFilter = {
  /** Every related `Property` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<PropertyFilter>;
  /** No related `Property` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<PropertyFilter>;
  /** Some related `Property` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<PropertyFilter>;
};

/** A connection to a list of `MapPoint` values. */
export type MapPointsConnection = {
  __typename?: 'MapPointsConnection';
  /** A list of edges which contains the `MapPoint` and cursor to aid in pagination. */
  edges: Array<MapPointsEdge>;
  /** A list of `MapPoint` objects. */
  nodes: Array<Maybe<MapPoint>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `MapPoint` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `MapPoint` edge in the connection. */
export type MapPointsEdge = {
  __typename?: 'MapPointsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `MapPoint` at the end of the edge. */
  node?: Maybe<MapPoint>;
};

/** Methods to use when ordering `MapPoint`. */
export enum MapPointsOrderBy {
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LatitudeAsc = 'LATITUDE_ASC',
  LatitudeDesc = 'LATITUDE_DESC',
  LongitudeAsc = 'LONGITUDE_ASC',
  LongitudeDesc = 'LONGITUDE_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  PropertiesByMapPointIdCountAsc = 'PROPERTIES_BY_MAP_POINT_ID__COUNT_ASC',
  PropertiesByMapPointIdCountDesc = 'PROPERTIES_BY_MAP_POINT_ID__COUNT_DESC'
}

/** A connection to a list of `MediaGallery` values. */
export type MediaGalleriesConnection = {
  __typename?: 'MediaGalleriesConnection';
  /** A list of edges which contains the `MediaGallery` and cursor to aid in pagination. */
  edges: Array<MediaGalleriesEdge>;
  /** A list of `MediaGallery` objects. */
  nodes: Array<Maybe<MediaGallery>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `MediaGallery` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `MediaGallery` edge in the connection. */
export type MediaGalleriesEdge = {
  __typename?: 'MediaGalleriesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `MediaGallery` at the end of the edge. */
  node?: Maybe<MediaGallery>;
};

/** Methods to use when ordering `MediaGallery`. */
export enum MediaGalleriesOrderBy {
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  DestinationsByGalleryIdCountAsc = 'DESTINATIONS_BY_GALLERY_ID__COUNT_ASC',
  DestinationsByGalleryIdCountDesc = 'DESTINATIONS_BY_GALLERY_ID__COUNT_DESC',
  DestinationFeaturesByGalleryIdCountAsc = 'DESTINATION_FEATURES_BY_GALLERY_ID__COUNT_ASC',
  DestinationFeaturesByGalleryIdCountDesc = 'DESTINATION_FEATURES_BY_GALLERY_ID__COUNT_DESC',
  FeaturesByGalleryIdCountAsc = 'FEATURES_BY_GALLERY_ID__COUNT_ASC',
  FeaturesByGalleryIdCountDesc = 'FEATURES_BY_GALLERY_ID__COUNT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IsProtectedAsc = 'IS_PROTECTED_ASC',
  IsProtectedDesc = 'IS_PROTECTED_DESC',
  MediaGalleriesByParentIdCountAsc = 'MEDIA_GALLERIES_BY_PARENT_ID__COUNT_ASC',
  MediaGalleriesByParentIdCountDesc = 'MEDIA_GALLERIES_BY_PARENT_ID__COUNT_DESC',
  MediaGalleryByParentIdCreatedAsc = 'MEDIA_GALLERY_BY_PARENT_ID__CREATED_ASC',
  MediaGalleryByParentIdCreatedDesc = 'MEDIA_GALLERY_BY_PARENT_ID__CREATED_DESC',
  MediaGalleryByParentIdIdAsc = 'MEDIA_GALLERY_BY_PARENT_ID__ID_ASC',
  MediaGalleryByParentIdIdDesc = 'MEDIA_GALLERY_BY_PARENT_ID__ID_DESC',
  MediaGalleryByParentIdIsProtectedAsc = 'MEDIA_GALLERY_BY_PARENT_ID__IS_PROTECTED_ASC',
  MediaGalleryByParentIdIsProtectedDesc = 'MEDIA_GALLERY_BY_PARENT_ID__IS_PROTECTED_DESC',
  MediaGalleryByParentIdModifiedAsc = 'MEDIA_GALLERY_BY_PARENT_ID__MODIFIED_ASC',
  MediaGalleryByParentIdModifiedDesc = 'MEDIA_GALLERY_BY_PARENT_ID__MODIFIED_DESC',
  MediaGalleryByParentIdNameAsc = 'MEDIA_GALLERY_BY_PARENT_ID__NAME_ASC',
  MediaGalleryByParentIdNameDesc = 'MEDIA_GALLERY_BY_PARENT_ID__NAME_DESC',
  MediaGalleryByParentIdParentIdAsc = 'MEDIA_GALLERY_BY_PARENT_ID__PARENT_ID_ASC',
  MediaGalleryByParentIdParentIdDesc = 'MEDIA_GALLERY_BY_PARENT_ID__PARENT_ID_DESC',
  MediaGalleryItemsByMediaGalleryIdCountAsc = 'MEDIA_GALLERY_ITEMS_BY_MEDIA_GALLERY_ID__COUNT_ASC',
  MediaGalleryItemsByMediaGalleryIdCountDesc = 'MEDIA_GALLERY_ITEMS_BY_MEDIA_GALLERY_ID__COUNT_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  ParentIdAsc = 'PARENT_ID_ASC',
  ParentIdDesc = 'PARENT_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  PropertiesByGalleryIdCountAsc = 'PROPERTIES_BY_GALLERY_ID__COUNT_ASC',
  PropertiesByGalleryIdCountDesc = 'PROPERTIES_BY_GALLERY_ID__COUNT_DESC',
  SuppliersByGalleryIdCountAsc = 'SUPPLIERS_BY_GALLERY_ID__COUNT_ASC',
  SuppliersByGalleryIdCountDesc = 'SUPPLIERS_BY_GALLERY_ID__COUNT_DESC',
  TripsByMediaGalleryIdCountAsc = 'TRIPS_BY_MEDIA_GALLERY_ID__COUNT_ASC',
  TripsByMediaGalleryIdCountDesc = 'TRIPS_BY_MEDIA_GALLERY_ID__COUNT_DESC'
}

export type MediaGallery = {
  __typename?: 'MediaGallery';
  /** Reads and enables pagination through a set of `MediaGallery`. */
  childMediaGalleries: MediaGalleriesConnection;
  created: Scalars['Datetime']['output'];
  /** Reads and enables pagination through a set of `DestinationFeature`. */
  destinationFeaturesByGalleryId: DestinationFeaturesConnection;
  /** Reads and enables pagination through a set of `Destination`. */
  destinationsByGalleryId: DestinationsConnection;
  /** Reads and enables pagination through a set of `Feature`. */
  featuresByGalleryId: FeaturesConnection;
  id: Scalars['UUID']['output'];
  isProtected: Scalars['Boolean']['output'];
  /** Reads and enables pagination through a set of `MediaGalleryItem`. */
  mediaGalleryItems: MediaGalleryItemsConnection;
  modified: Scalars['Datetime']['output'];
  name?: Maybe<Scalars['String']['output']>;
  /** Reads a single `MediaGallery` that is related to this `MediaGallery`. */
  parent?: Maybe<MediaGallery>;
  parentId?: Maybe<Scalars['UUID']['output']>;
  /** Reads and enables pagination through a set of `Property`. */
  propertiesByGalleryId: PropertiesConnection;
  /** Reads and enables pagination through a set of `Supplier`. */
  suppliersByGalleryId: SuppliersConnection;
  /** Reads and enables pagination through a set of `Trip`. */
  trips: TripsConnection;
};


export type MediaGalleryChildMediaGalleriesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<MediaGalleryCondition>;
  filter?: InputMaybe<MediaGalleryFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MediaGalleriesOrderBy>>;
};


export type MediaGalleryDestinationFeaturesByGalleryIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DestinationFeatureCondition>;
  filter?: InputMaybe<DestinationFeatureFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DestinationFeaturesOrderBy>>;
};


export type MediaGalleryDestinationsByGalleryIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DestinationCondition>;
  filter?: InputMaybe<DestinationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DestinationsOrderBy>>;
};


export type MediaGalleryFeaturesByGalleryIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FeatureCondition>;
  filter?: InputMaybe<FeatureFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FeaturesOrderBy>>;
};


export type MediaGalleryMediaGalleryItemsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<MediaGalleryItemCondition>;
  filter?: InputMaybe<MediaGalleryItemFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MediaGalleryItemsOrderBy>>;
};


export type MediaGalleryPropertiesByGalleryIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PropertyCondition>;
  filter?: InputMaybe<PropertyFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PropertiesOrderBy>>;
};


export type MediaGallerySuppliersByGalleryIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SupplierCondition>;
  filter?: InputMaybe<SupplierFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SuppliersOrderBy>>;
};


export type MediaGalleryTripsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TripCondition>;
  filter?: InputMaybe<TripFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TripsOrderBy>>;
};

/**
 * A condition to be used against `MediaGallery` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type MediaGalleryCondition = {
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `isProtected` field. */
  isProtected?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `parentId` field. */
  parentId?: InputMaybe<Scalars['UUID']['input']>;
};

/** A filter to be used against `MediaGallery` object types. All fields are combined with a logical ‘and.’ */
export type MediaGalleryFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<MediaGalleryFilter>>;
  /** Filter by the object’s `childMediaGalleries` relation. */
  childMediaGalleries?: InputMaybe<MediaGalleryToManyMediaGalleryFilter>;
  /** Some related `childMediaGalleries` exist. */
  childMediaGalleriesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `destinationFeaturesByGalleryId` relation. */
  destinationFeaturesByGalleryId?: InputMaybe<MediaGalleryToManyDestinationFeatureFilter>;
  /** Some related `destinationFeaturesByGalleryId` exist. */
  destinationFeaturesByGalleryIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `destinationsByGalleryId` relation. */
  destinationsByGalleryId?: InputMaybe<MediaGalleryToManyDestinationFilter>;
  /** Some related `destinationsByGalleryId` exist. */
  destinationsByGalleryIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `featuresByGalleryId` relation. */
  featuresByGalleryId?: InputMaybe<MediaGalleryToManyFeatureFilter>;
  /** Some related `featuresByGalleryId` exist. */
  featuresByGalleryIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `isProtected` field. */
  isProtected?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `mediaGalleryItems` relation. */
  mediaGalleryItems?: InputMaybe<MediaGalleryToManyMediaGalleryItemFilter>;
  /** Some related `mediaGalleryItems` exist. */
  mediaGalleryItemsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<MediaGalleryFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<MediaGalleryFilter>>;
  /** Filter by the object’s `parent` relation. */
  parent?: InputMaybe<MediaGalleryFilter>;
  /** A related `parent` exists. */
  parentExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `parentId` field. */
  parentId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `propertiesByGalleryId` relation. */
  propertiesByGalleryId?: InputMaybe<MediaGalleryToManyPropertyFilter>;
  /** Some related `propertiesByGalleryId` exist. */
  propertiesByGalleryIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `suppliersByGalleryId` relation. */
  suppliersByGalleryId?: InputMaybe<MediaGalleryToManySupplierFilter>;
  /** Some related `suppliersByGalleryId` exist. */
  suppliersByGalleryIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `trips` relation. */
  trips?: InputMaybe<MediaGalleryToManyTripFilter>;
  /** Some related `trips` exist. */
  tripsExist?: InputMaybe<Scalars['Boolean']['input']>;
};

/** An input for mutations affecting `MediaGallery` */
export type MediaGalleryInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationFeaturesUsingId?: InputMaybe<FkDestinationFeatureMediaGalleryGalleryIdInverseInput>;
  destinationsUsingId?: InputMaybe<FkDestinationMediaGalleryGalleryIdInverseInput>;
  featuresUsingId?: InputMaybe<FkFeatureMediaGalleryGalleryIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  isProtected?: InputMaybe<Scalars['Boolean']['input']>;
  mediaGalleryItemsUsingId?: InputMaybe<FkMediaGalleryItemMediaGalleryMediaGalleryIdInverseInput>;
  mediaGalleryToParentId?: InputMaybe<FkMediaGalleryMediaGalleryParentIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  parentId?: InputMaybe<Scalars['UUID']['input']>;
  propertiesUsingId?: InputMaybe<FkPropertyMediaGalleryGalleryIdInverseInput>;
  suppliersUsingId?: InputMaybe<FkSupplierMediaGalleryGalleryIdInverseInput>;
  tripsUsingId?: InputMaybe<FkTripMediaGalleryMediaGalleryIdInverseInput>;
};

export type MediaGalleryItem = {
  __typename?: 'MediaGalleryItem';
  created: Scalars['Datetime']['output'];
  id: Scalars['UUID']['output'];
  isHero: Scalars['Boolean']['output'];
  /** Reads a single `MediaGallery` that is related to this `MediaGalleryItem`. */
  mediaGallery?: Maybe<MediaGallery>;
  mediaGalleryId: Scalars['UUID']['output'];
  /** Reads a single `MediaItem` that is related to this `MediaGalleryItem`. */
  mediaItem?: Maybe<MediaItem>;
  mediaItemId: Scalars['UUID']['output'];
  modified: Scalars['Datetime']['output'];
};

/**
 * A condition to be used against `MediaGalleryItem` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type MediaGalleryItemCondition = {
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `isHero` field. */
  isHero?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `mediaGalleryId` field. */
  mediaGalleryId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `mediaItemId` field. */
  mediaItemId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A filter to be used against `MediaGalleryItem` object types. All fields are combined with a logical ‘and.’ */
export type MediaGalleryItemFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<MediaGalleryItemFilter>>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `isHero` field. */
  isHero?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `mediaGallery` relation. */
  mediaGallery?: InputMaybe<MediaGalleryFilter>;
  /** Filter by the object’s `mediaGalleryId` field. */
  mediaGalleryId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `mediaItem` relation. */
  mediaItem?: InputMaybe<MediaItemFilter>;
  /** Filter by the object’s `mediaItemId` field. */
  mediaItemId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<MediaGalleryItemFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<MediaGalleryItemFilter>>;
};

/** An input for mutations affecting `MediaGalleryItem` */
export type MediaGalleryItemInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  isHero?: InputMaybe<Scalars['Boolean']['input']>;
  mediaGalleryId?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryToMediaGalleryId?: InputMaybe<FkMediaGalleryItemMediaGalleryMediaGalleryIdInput>;
  mediaItemId?: InputMaybe<Scalars['UUID']['input']>;
  mediaItemToMediaItemId?: InputMaybe<FkMediaGalleryItemMediaItemMediaItemIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The fields on `mediaGalleryItem` to look up the row to update. */
export type MediaGalleryItemOnMediaGalleryItemForFkMediaGalleryItemMediaGalleryMediaGalleryIdUsingPkMediaGalleryItemUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `mediaGalleryItem` being updated. */
  patch: UpdateMediaGalleryItemOnMediaGalleryItemForFkMediaGalleryItemMediaGalleryMediaGalleryIdPatch;
};

/** The fields on `mediaGalleryItem` to look up the row to update. */
export type MediaGalleryItemOnMediaGalleryItemForFkMediaGalleryItemMediaItemMediaItemIdUsingPkMediaGalleryItemUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `mediaGalleryItem` being updated. */
  patch: UpdateMediaGalleryItemOnMediaGalleryItemForFkMediaGalleryItemMediaItemMediaItemIdPatch;
};

/** Represents an update to a `MediaGalleryItem`. Fields that are set will be updated. */
export type MediaGalleryItemPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  isHero?: InputMaybe<Scalars['Boolean']['input']>;
  mediaGalleryId?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryToMediaGalleryId?: InputMaybe<FkMediaGalleryItemMediaGalleryMediaGalleryIdInput>;
  mediaItemId?: InputMaybe<Scalars['UUID']['input']>;
  mediaItemToMediaItemId?: InputMaybe<FkMediaGalleryItemMediaItemMediaItemIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The fields on `mediaGalleryItem` to look up the row to connect. */
export type MediaGalleryItemPkMediaGalleryItemConnect = {
  id: Scalars['UUID']['input'];
};

/** The fields on `mediaGalleryItem` to look up the row to delete. */
export type MediaGalleryItemPkMediaGalleryItemDelete = {
  id: Scalars['UUID']['input'];
};

/** A connection to a list of `MediaGalleryItem` values. */
export type MediaGalleryItemsConnection = {
  __typename?: 'MediaGalleryItemsConnection';
  /** A list of edges which contains the `MediaGalleryItem` and cursor to aid in pagination. */
  edges: Array<MediaGalleryItemsEdge>;
  /** A list of `MediaGalleryItem` objects. */
  nodes: Array<Maybe<MediaGalleryItem>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `MediaGalleryItem` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `MediaGalleryItem` edge in the connection. */
export type MediaGalleryItemsEdge = {
  __typename?: 'MediaGalleryItemsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `MediaGalleryItem` at the end of the edge. */
  node?: Maybe<MediaGalleryItem>;
};

/** Methods to use when ordering `MediaGalleryItem`. */
export enum MediaGalleryItemsOrderBy {
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IsHeroAsc = 'IS_HERO_ASC',
  IsHeroDesc = 'IS_HERO_DESC',
  MediaGalleryByMediaGalleryIdCreatedAsc = 'MEDIA_GALLERY_BY_MEDIA_GALLERY_ID__CREATED_ASC',
  MediaGalleryByMediaGalleryIdCreatedDesc = 'MEDIA_GALLERY_BY_MEDIA_GALLERY_ID__CREATED_DESC',
  MediaGalleryByMediaGalleryIdIdAsc = 'MEDIA_GALLERY_BY_MEDIA_GALLERY_ID__ID_ASC',
  MediaGalleryByMediaGalleryIdIdDesc = 'MEDIA_GALLERY_BY_MEDIA_GALLERY_ID__ID_DESC',
  MediaGalleryByMediaGalleryIdIsProtectedAsc = 'MEDIA_GALLERY_BY_MEDIA_GALLERY_ID__IS_PROTECTED_ASC',
  MediaGalleryByMediaGalleryIdIsProtectedDesc = 'MEDIA_GALLERY_BY_MEDIA_GALLERY_ID__IS_PROTECTED_DESC',
  MediaGalleryByMediaGalleryIdModifiedAsc = 'MEDIA_GALLERY_BY_MEDIA_GALLERY_ID__MODIFIED_ASC',
  MediaGalleryByMediaGalleryIdModifiedDesc = 'MEDIA_GALLERY_BY_MEDIA_GALLERY_ID__MODIFIED_DESC',
  MediaGalleryByMediaGalleryIdNameAsc = 'MEDIA_GALLERY_BY_MEDIA_GALLERY_ID__NAME_ASC',
  MediaGalleryByMediaGalleryIdNameDesc = 'MEDIA_GALLERY_BY_MEDIA_GALLERY_ID__NAME_DESC',
  MediaGalleryByMediaGalleryIdParentIdAsc = 'MEDIA_GALLERY_BY_MEDIA_GALLERY_ID__PARENT_ID_ASC',
  MediaGalleryByMediaGalleryIdParentIdDesc = 'MEDIA_GALLERY_BY_MEDIA_GALLERY_ID__PARENT_ID_DESC',
  MediaGalleryIdAsc = 'MEDIA_GALLERY_ID_ASC',
  MediaGalleryIdDesc = 'MEDIA_GALLERY_ID_DESC',
  MediaItemByMediaItemIdContentTypeAsc = 'MEDIA_ITEM_BY_MEDIA_ITEM_ID__CONTENT_TYPE_ASC',
  MediaItemByMediaItemIdContentTypeDesc = 'MEDIA_ITEM_BY_MEDIA_ITEM_ID__CONTENT_TYPE_DESC',
  MediaItemByMediaItemIdCreatedAsc = 'MEDIA_ITEM_BY_MEDIA_ITEM_ID__CREATED_ASC',
  MediaItemByMediaItemIdCreatedDesc = 'MEDIA_ITEM_BY_MEDIA_ITEM_ID__CREATED_DESC',
  MediaItemByMediaItemIdFileNameAsc = 'MEDIA_ITEM_BY_MEDIA_ITEM_ID__FILE_NAME_ASC',
  MediaItemByMediaItemIdFileNameDesc = 'MEDIA_ITEM_BY_MEDIA_ITEM_ID__FILE_NAME_DESC',
  MediaItemByMediaItemIdHashAsc = 'MEDIA_ITEM_BY_MEDIA_ITEM_ID__HASH_ASC',
  MediaItemByMediaItemIdHashDesc = 'MEDIA_ITEM_BY_MEDIA_ITEM_ID__HASH_DESC',
  MediaItemByMediaItemIdIdAsc = 'MEDIA_ITEM_BY_MEDIA_ITEM_ID__ID_ASC',
  MediaItemByMediaItemIdIdDesc = 'MEDIA_ITEM_BY_MEDIA_ITEM_ID__ID_DESC',
  MediaItemByMediaItemIdModifiedAsc = 'MEDIA_ITEM_BY_MEDIA_ITEM_ID__MODIFIED_ASC',
  MediaItemByMediaItemIdModifiedDesc = 'MEDIA_ITEM_BY_MEDIA_ITEM_ID__MODIFIED_DESC',
  MediaItemByMediaItemIdNameAsc = 'MEDIA_ITEM_BY_MEDIA_ITEM_ID__NAME_ASC',
  MediaItemByMediaItemIdNameDesc = 'MEDIA_ITEM_BY_MEDIA_ITEM_ID__NAME_DESC',
  MediaItemByMediaItemIdSummaryAsc = 'MEDIA_ITEM_BY_MEDIA_ITEM_ID__SUMMARY_ASC',
  MediaItemByMediaItemIdSummaryDesc = 'MEDIA_ITEM_BY_MEDIA_ITEM_ID__SUMMARY_DESC',
  MediaItemIdAsc = 'MEDIA_ITEM_ID_ASC',
  MediaItemIdDesc = 'MEDIA_ITEM_ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** The fields on `mediaGallery` to look up the row to update. */
export type MediaGalleryOnDestinationFeatureForFkDestinationFeatureMediaGalleryGalleryIdUsingPkMediaGalleryUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `mediaGallery` being updated. */
  patch: UpdateMediaGalleryOnDestinationFeatureForFkDestinationFeatureMediaGalleryGalleryIdPatch;
};

/** The fields on `mediaGallery` to look up the row to update. */
export type MediaGalleryOnDestinationForFkDestinationMediaGalleryGalleryIdUsingPkMediaGalleryUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `mediaGallery` being updated. */
  patch: UpdateMediaGalleryOnDestinationForFkDestinationMediaGalleryGalleryIdPatch;
};

/** The fields on `mediaGallery` to look up the row to update. */
export type MediaGalleryOnFeatureForFkFeatureMediaGalleryGalleryIdUsingPkMediaGalleryUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `mediaGallery` being updated. */
  patch: UpdateMediaGalleryOnFeatureForFkFeatureMediaGalleryGalleryIdPatch;
};

/** The fields on `mediaGallery` to look up the row to update. */
export type MediaGalleryOnMediaGalleryForFkMediaGalleryMediaGalleryParentIdUsingPkMediaGalleryUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `mediaGallery` being updated. */
  patch: UpdateMediaGalleryOnMediaGalleryForFkMediaGalleryMediaGalleryParentIdPatch;
};

/** The fields on `mediaGallery` to look up the row to update. */
export type MediaGalleryOnMediaGalleryItemForFkMediaGalleryItemMediaGalleryMediaGalleryIdUsingPkMediaGalleryUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `mediaGallery` being updated. */
  patch: UpdateMediaGalleryOnMediaGalleryItemForFkMediaGalleryItemMediaGalleryMediaGalleryIdPatch;
};

/** The fields on `mediaGallery` to look up the row to update. */
export type MediaGalleryOnPropertyForFkPropertyMediaGalleryGalleryIdUsingPkMediaGalleryUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `mediaGallery` being updated. */
  patch: UpdateMediaGalleryOnPropertyForFkPropertyMediaGalleryGalleryIdPatch;
};

/** The fields on `mediaGallery` to look up the row to update. */
export type MediaGalleryOnSupplierForFkSupplierMediaGalleryGalleryIdUsingPkMediaGalleryUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `mediaGallery` being updated. */
  patch: UpdateMediaGalleryOnSupplierForFkSupplierMediaGalleryGalleryIdPatch;
};

/** The fields on `mediaGallery` to look up the row to update. */
export type MediaGalleryOnTripForFkTripMediaGalleryMediaGalleryIdUsingPkMediaGalleryUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `mediaGallery` being updated. */
  patch: UpdateMediaGalleryOnTripForFkTripMediaGalleryMediaGalleryIdPatch;
};

/** Represents an update to a `MediaGallery`. Fields that are set will be updated. */
export type MediaGalleryPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationFeaturesUsingId?: InputMaybe<FkDestinationFeatureMediaGalleryGalleryIdInverseInput>;
  destinationsUsingId?: InputMaybe<FkDestinationMediaGalleryGalleryIdInverseInput>;
  featuresUsingId?: InputMaybe<FkFeatureMediaGalleryGalleryIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  isProtected?: InputMaybe<Scalars['Boolean']['input']>;
  mediaGalleryItemsUsingId?: InputMaybe<FkMediaGalleryItemMediaGalleryMediaGalleryIdInverseInput>;
  mediaGalleryToParentId?: InputMaybe<FkMediaGalleryMediaGalleryParentIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  parentId?: InputMaybe<Scalars['UUID']['input']>;
  propertiesUsingId?: InputMaybe<FkPropertyMediaGalleryGalleryIdInverseInput>;
  suppliersUsingId?: InputMaybe<FkSupplierMediaGalleryGalleryIdInverseInput>;
  tripsUsingId?: InputMaybe<FkTripMediaGalleryMediaGalleryIdInverseInput>;
};

/** The fields on `mediaGallery` to look up the row to connect. */
export type MediaGalleryPkMediaGalleryConnect = {
  id: Scalars['UUID']['input'];
};

/** The fields on `mediaGallery` to look up the row to delete. */
export type MediaGalleryPkMediaGalleryDelete = {
  id: Scalars['UUID']['input'];
};

/** A filter to be used against many `DestinationFeature` object types. All fields are combined with a logical ‘and.’ */
export type MediaGalleryToManyDestinationFeatureFilter = {
  /** Every related `DestinationFeature` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<DestinationFeatureFilter>;
  /** No related `DestinationFeature` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<DestinationFeatureFilter>;
  /** Some related `DestinationFeature` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<DestinationFeatureFilter>;
};

/** A filter to be used against many `Destination` object types. All fields are combined with a logical ‘and.’ */
export type MediaGalleryToManyDestinationFilter = {
  /** Every related `Destination` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<DestinationFilter>;
  /** No related `Destination` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<DestinationFilter>;
  /** Some related `Destination` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<DestinationFilter>;
};

/** A filter to be used against many `Feature` object types. All fields are combined with a logical ‘and.’ */
export type MediaGalleryToManyFeatureFilter = {
  /** Every related `Feature` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<FeatureFilter>;
  /** No related `Feature` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<FeatureFilter>;
  /** Some related `Feature` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<FeatureFilter>;
};

/** A filter to be used against many `MediaGallery` object types. All fields are combined with a logical ‘and.’ */
export type MediaGalleryToManyMediaGalleryFilter = {
  /** Every related `MediaGallery` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<MediaGalleryFilter>;
  /** No related `MediaGallery` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<MediaGalleryFilter>;
  /** Some related `MediaGallery` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<MediaGalleryFilter>;
};

/** A filter to be used against many `MediaGalleryItem` object types. All fields are combined with a logical ‘and.’ */
export type MediaGalleryToManyMediaGalleryItemFilter = {
  /** Every related `MediaGalleryItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<MediaGalleryItemFilter>;
  /** No related `MediaGalleryItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<MediaGalleryItemFilter>;
  /** Some related `MediaGalleryItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<MediaGalleryItemFilter>;
};

/** A filter to be used against many `Property` object types. All fields are combined with a logical ‘and.’ */
export type MediaGalleryToManyPropertyFilter = {
  /** Every related `Property` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<PropertyFilter>;
  /** No related `Property` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<PropertyFilter>;
  /** Some related `Property` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<PropertyFilter>;
};

/** A filter to be used against many `Supplier` object types. All fields are combined with a logical ‘and.’ */
export type MediaGalleryToManySupplierFilter = {
  /** Every related `Supplier` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<SupplierFilter>;
  /** No related `Supplier` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<SupplierFilter>;
  /** Some related `Supplier` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<SupplierFilter>;
};

/** A filter to be used against many `Trip` object types. All fields are combined with a logical ‘and.’ */
export type MediaGalleryToManyTripFilter = {
  /** Every related `Trip` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<TripFilter>;
  /** No related `Trip` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<TripFilter>;
  /** Some related `Trip` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<TripFilter>;
};

export type MediaItem = {
  __typename?: 'MediaItem';
  /** Reads and enables pagination through a set of `Agency`. */
  agenciesByLogoId: AgenciesConnection;
  contentType?: Maybe<Scalars['String']['output']>;
  created: Scalars['Datetime']['output'];
  /** Reads and enables pagination through a set of `Destination`. */
  destinationsByHeroMediaId: DestinationsConnection;
  fileName?: Maybe<Scalars['String']['output']>;
  hash?: Maybe<Scalars['String']['output']>;
  id: Scalars['UUID']['output'];
  /** Reads and enables pagination through a set of `MediaGalleryItem`. */
  mediaGalleryItems: MediaGalleryItemsConnection;
  modified: Scalars['Datetime']['output'];
  name?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `Property`. */
  propertiesByHeroMediaId: PropertiesConnection;
  /** Reads and enables pagination through a set of `QuoteHero`. */
  quoteHeroesByImageId: QuoteHeroesConnection;
  /** Reads and enables pagination through a set of `Quote`. */
  quotesByHeroImageId: QuotesConnection;
  summary?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `SupplierInvoice`. */
  supplierInvoices: SupplierInvoicesConnection;
};


export type MediaItemAgenciesByLogoIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AgencyCondition>;
  filter?: InputMaybe<AgencyFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AgenciesOrderBy>>;
};


export type MediaItemDestinationsByHeroMediaIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DestinationCondition>;
  filter?: InputMaybe<DestinationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DestinationsOrderBy>>;
};


export type MediaItemMediaGalleryItemsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<MediaGalleryItemCondition>;
  filter?: InputMaybe<MediaGalleryItemFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MediaGalleryItemsOrderBy>>;
};


export type MediaItemPropertiesByHeroMediaIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PropertyCondition>;
  filter?: InputMaybe<PropertyFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PropertiesOrderBy>>;
};


export type MediaItemQuoteHeroesByImageIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<QuoteHeroCondition>;
  filter?: InputMaybe<QuoteHeroFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuoteHeroesOrderBy>>;
};


export type MediaItemQuotesByHeroImageIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<QuoteCondition>;
  filter?: InputMaybe<QuoteFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuotesOrderBy>>;
};


export type MediaItemSupplierInvoicesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SupplierInvoiceCondition>;
  filter?: InputMaybe<SupplierInvoiceFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SupplierInvoicesOrderBy>>;
};

/**
 * A condition to be used against `MediaItem` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type MediaItemCondition = {
  /** Checks for equality with the object’s `contentType` field. */
  contentType?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `fileName` field. */
  fileName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `hash` field. */
  hash?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `summary` field. */
  summary?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `MediaItem` object types. All fields are combined with a logical ‘and.’ */
export type MediaItemFilter = {
  /** Filter by the object’s `agenciesByLogoId` relation. */
  agenciesByLogoId?: InputMaybe<MediaItemToManyAgencyFilter>;
  /** Some related `agenciesByLogoId` exist. */
  agenciesByLogoIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<MediaItemFilter>>;
  /** Filter by the object’s `contentType` field. */
  contentType?: InputMaybe<StringFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `destinationsByHeroMediaId` relation. */
  destinationsByHeroMediaId?: InputMaybe<MediaItemToManyDestinationFilter>;
  /** Some related `destinationsByHeroMediaId` exist. */
  destinationsByHeroMediaIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `fileName` field. */
  fileName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `hash` field. */
  hash?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `mediaGalleryItems` relation. */
  mediaGalleryItems?: InputMaybe<MediaItemToManyMediaGalleryItemFilter>;
  /** Some related `mediaGalleryItems` exist. */
  mediaGalleryItemsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<MediaItemFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<MediaItemFilter>>;
  /** Filter by the object’s `propertiesByHeroMediaId` relation. */
  propertiesByHeroMediaId?: InputMaybe<MediaItemToManyPropertyFilter>;
  /** Some related `propertiesByHeroMediaId` exist. */
  propertiesByHeroMediaIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `quoteHeroesByImageId` relation. */
  quoteHeroesByImageId?: InputMaybe<MediaItemToManyQuoteHeroFilter>;
  /** Some related `quoteHeroesByImageId` exist. */
  quoteHeroesByImageIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `quotesByHeroImageId` relation. */
  quotesByHeroImageId?: InputMaybe<MediaItemToManyQuoteFilter>;
  /** Some related `quotesByHeroImageId` exist. */
  quotesByHeroImageIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `summary` field. */
  summary?: InputMaybe<StringFilter>;
  /** Filter by the object’s `supplierInvoices` relation. */
  supplierInvoices?: InputMaybe<MediaItemToManySupplierInvoiceFilter>;
  /** Some related `supplierInvoices` exist. */
  supplierInvoicesExist?: InputMaybe<Scalars['Boolean']['input']>;
};

/** An input for mutations affecting `MediaItem` */
export type MediaItemInput = {
  agenciesUsingId?: InputMaybe<FkAgencyMediaItemLogoIdInverseInput>;
  contentType?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationsUsingId?: InputMaybe<DestinationHeroMediaIdFkeyInverseInput>;
  fileName?: InputMaybe<Scalars['String']['input']>;
  hash?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryItemsUsingId?: InputMaybe<FkMediaGalleryItemMediaItemMediaItemIdInverseInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  propertiesUsingId?: InputMaybe<FkPropertyMediaItemHeroMediaIdInverseInput>;
  quoteHeroesUsingId?: InputMaybe<FkQuoteHeroMediaItemImageIdInverseInput>;
  quotesUsingId?: InputMaybe<FkQuoteMediaItemHeroImageIdInverseInput>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceMediaItemMediaItemIdInverseInput>;
};

/** The fields on `mediaItem` to look up the row to update. */
export type MediaItemOnAgencyForFkAgencyMediaItemLogoIdUsingPkMediaItemUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `mediaItem` being updated. */
  patch: UpdateMediaItemOnAgencyForFkAgencyMediaItemLogoIdPatch;
};

/** The fields on `mediaItem` to look up the row to update. */
export type MediaItemOnDestinationForDestinationHeroMediaIdFkeyUsingPkMediaItemUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `mediaItem` being updated. */
  patch: UpdateMediaItemOnDestinationForDestinationHeroMediaIdFkeyPatch;
};

/** The fields on `mediaItem` to look up the row to update. */
export type MediaItemOnMediaGalleryItemForFkMediaGalleryItemMediaItemMediaItemIdUsingPkMediaItemUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `mediaItem` being updated. */
  patch: UpdateMediaItemOnMediaGalleryItemForFkMediaGalleryItemMediaItemMediaItemIdPatch;
};

/** The fields on `mediaItem` to look up the row to update. */
export type MediaItemOnPropertyForFkPropertyMediaItemHeroMediaIdUsingPkMediaItemUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `mediaItem` being updated. */
  patch: UpdateMediaItemOnPropertyForFkPropertyMediaItemHeroMediaIdPatch;
};

/** The fields on `mediaItem` to look up the row to update. */
export type MediaItemOnQuoteForFkQuoteMediaItemHeroImageIdUsingPkMediaItemUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `mediaItem` being updated. */
  patch: UpdateMediaItemOnQuoteForFkQuoteMediaItemHeroImageIdPatch;
};

/** The fields on `mediaItem` to look up the row to update. */
export type MediaItemOnQuoteHeroForFkQuoteHeroMediaItemImageIdUsingPkMediaItemUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `mediaItem` being updated. */
  patch: UpdateMediaItemOnQuoteHeroForFkQuoteHeroMediaItemImageIdPatch;
};

/** The fields on `mediaItem` to look up the row to update. */
export type MediaItemOnSupplierInvoiceForFkSupplierInvoiceMediaItemMediaItemIdUsingPkMediaItemUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `mediaItem` being updated. */
  patch: UpdateMediaItemOnSupplierInvoiceForFkSupplierInvoiceMediaItemMediaItemIdPatch;
};

/** Represents an update to a `MediaItem`. Fields that are set will be updated. */
export type MediaItemPatch = {
  agenciesUsingId?: InputMaybe<FkAgencyMediaItemLogoIdInverseInput>;
  contentType?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationsUsingId?: InputMaybe<DestinationHeroMediaIdFkeyInverseInput>;
  fileName?: InputMaybe<Scalars['String']['input']>;
  hash?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryItemsUsingId?: InputMaybe<FkMediaGalleryItemMediaItemMediaItemIdInverseInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  propertiesUsingId?: InputMaybe<FkPropertyMediaItemHeroMediaIdInverseInput>;
  quoteHeroesUsingId?: InputMaybe<FkQuoteHeroMediaItemImageIdInverseInput>;
  quotesUsingId?: InputMaybe<FkQuoteMediaItemHeroImageIdInverseInput>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceMediaItemMediaItemIdInverseInput>;
};

/** The fields on `mediaItem` to look up the row to connect. */
export type MediaItemPkMediaItemConnect = {
  id: Scalars['UUID']['input'];
};

/** The fields on `mediaItem` to look up the row to delete. */
export type MediaItemPkMediaItemDelete = {
  id: Scalars['UUID']['input'];
};

/** A filter to be used against many `Agency` object types. All fields are combined with a logical ‘and.’ */
export type MediaItemToManyAgencyFilter = {
  /** Every related `Agency` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<AgencyFilter>;
  /** No related `Agency` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<AgencyFilter>;
  /** Some related `Agency` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<AgencyFilter>;
};

/** A filter to be used against many `Destination` object types. All fields are combined with a logical ‘and.’ */
export type MediaItemToManyDestinationFilter = {
  /** Every related `Destination` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<DestinationFilter>;
  /** No related `Destination` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<DestinationFilter>;
  /** Some related `Destination` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<DestinationFilter>;
};

/** A filter to be used against many `MediaGalleryItem` object types. All fields are combined with a logical ‘and.’ */
export type MediaItemToManyMediaGalleryItemFilter = {
  /** Every related `MediaGalleryItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<MediaGalleryItemFilter>;
  /** No related `MediaGalleryItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<MediaGalleryItemFilter>;
  /** Some related `MediaGalleryItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<MediaGalleryItemFilter>;
};

/** A filter to be used against many `Property` object types. All fields are combined with a logical ‘and.’ */
export type MediaItemToManyPropertyFilter = {
  /** Every related `Property` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<PropertyFilter>;
  /** No related `Property` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<PropertyFilter>;
  /** Some related `Property` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<PropertyFilter>;
};

/** A filter to be used against many `Quote` object types. All fields are combined with a logical ‘and.’ */
export type MediaItemToManyQuoteFilter = {
  /** Every related `Quote` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<QuoteFilter>;
  /** No related `Quote` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<QuoteFilter>;
  /** Some related `Quote` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<QuoteFilter>;
};

/** A filter to be used against many `QuoteHero` object types. All fields are combined with a logical ‘and.’ */
export type MediaItemToManyQuoteHeroFilter = {
  /** Every related `QuoteHero` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<QuoteHeroFilter>;
  /** No related `QuoteHero` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<QuoteHeroFilter>;
  /** Some related `QuoteHero` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<QuoteHeroFilter>;
};

/** A filter to be used against many `SupplierInvoice` object types. All fields are combined with a logical ‘and.’ */
export type MediaItemToManySupplierInvoiceFilter = {
  /** Every related `SupplierInvoice` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<SupplierInvoiceFilter>;
  /** No related `SupplierInvoice` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<SupplierInvoiceFilter>;
  /** Some related `SupplierInvoice` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<SupplierInvoiceFilter>;
};

/** A connection to a list of `MediaItem` values. */
export type MediaItemsConnection = {
  __typename?: 'MediaItemsConnection';
  /** A list of edges which contains the `MediaItem` and cursor to aid in pagination. */
  edges: Array<MediaItemsEdge>;
  /** A list of `MediaItem` objects. */
  nodes: Array<Maybe<MediaItem>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `MediaItem` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `MediaItem` edge in the connection. */
export type MediaItemsEdge = {
  __typename?: 'MediaItemsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `MediaItem` at the end of the edge. */
  node?: Maybe<MediaItem>;
};

/** Methods to use when ordering `MediaItem`. */
export enum MediaItemsOrderBy {
  AgenciesByLogoIdCountAsc = 'AGENCIES_BY_LOGO_ID__COUNT_ASC',
  AgenciesByLogoIdCountDesc = 'AGENCIES_BY_LOGO_ID__COUNT_DESC',
  ContentTypeAsc = 'CONTENT_TYPE_ASC',
  ContentTypeDesc = 'CONTENT_TYPE_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  DestinationsByHeroMediaIdCountAsc = 'DESTINATIONS_BY_HERO_MEDIA_ID__COUNT_ASC',
  DestinationsByHeroMediaIdCountDesc = 'DESTINATIONS_BY_HERO_MEDIA_ID__COUNT_DESC',
  FileNameAsc = 'FILE_NAME_ASC',
  FileNameDesc = 'FILE_NAME_DESC',
  HashAsc = 'HASH_ASC',
  HashDesc = 'HASH_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  MediaGalleryItemsByMediaItemIdCountAsc = 'MEDIA_GALLERY_ITEMS_BY_MEDIA_ITEM_ID__COUNT_ASC',
  MediaGalleryItemsByMediaItemIdCountDesc = 'MEDIA_GALLERY_ITEMS_BY_MEDIA_ITEM_ID__COUNT_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  PropertiesByHeroMediaIdCountAsc = 'PROPERTIES_BY_HERO_MEDIA_ID__COUNT_ASC',
  PropertiesByHeroMediaIdCountDesc = 'PROPERTIES_BY_HERO_MEDIA_ID__COUNT_DESC',
  QuotesByHeroImageIdCountAsc = 'QUOTES_BY_HERO_IMAGE_ID__COUNT_ASC',
  QuotesByHeroImageIdCountDesc = 'QUOTES_BY_HERO_IMAGE_ID__COUNT_DESC',
  QuoteHeroesByImageIdCountAsc = 'QUOTE_HEROES_BY_IMAGE_ID__COUNT_ASC',
  QuoteHeroesByImageIdCountDesc = 'QUOTE_HEROES_BY_IMAGE_ID__COUNT_DESC',
  SummaryAsc = 'SUMMARY_ASC',
  SummaryDesc = 'SUMMARY_DESC',
  SupplierInvoicesByMediaItemIdCountAsc = 'SUPPLIER_INVOICES_BY_MEDIA_ITEM_ID__COUNT_ASC',
  SupplierInvoicesByMediaItemIdCountDesc = 'SUPPLIER_INVOICES_BY_MEDIA_ITEM_ID__COUNT_DESC'
}

/** All input for the `mergePropertyInto` mutation. */
export type MergePropertyIntoInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  fSource?: InputMaybe<Scalars['UUID']['input']>;
  fTarget?: InputMaybe<Scalars['UUID']['input']>;
};

/** The output of our `mergePropertyInto` mutation. */
export type MergePropertyIntoPayload = {
  __typename?: 'MergePropertyIntoPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

/** The root mutation type which contains root level fields which mutate data. */
export type Mutation = {
  __typename?: 'Mutation';
  acceptQuote?: Maybe<GenericResponse>;
  /** Creates a single `Account`. */
  createAccount?: Maybe<CreateAccountPayload>;
  /** Creates a single `Agency`. */
  createAgency?: Maybe<CreateAgencyPayload>;
  /** Creates a single `AgencyMember`. */
  createAgencyMember?: Maybe<CreateAgencyMemberPayload>;
  /** Creates a single `Airport`. */
  createAirport?: Maybe<CreateAirportPayload>;
  /** Creates a single `Country`. */
  createCountry?: Maybe<CreateCountryPayload>;
  /** Creates a single `Customer`. */
  createCustomer?: Maybe<CreateCustomerPayload>;
  /** Creates a single `CustomerTraveller`. */
  createCustomerTraveller?: Maybe<CreateCustomerTravellerPayload>;
  /** Creates a single `Destination`. */
  createDestination?: Maybe<CreateDestinationPayload>;
  /** Creates a single `DestinationFeature`. */
  createDestinationFeature?: Maybe<CreateDestinationFeaturePayload>;
  /** Creates a single `DestinationGuide`. */
  createDestinationGuide?: Maybe<CreateDestinationGuidePayload>;
  /** Creates a single `Email`. */
  createEmail?: Maybe<CreateEmailPayload>;
  /** Creates a single `Enquiry`. */
  createEnquiry?: Maybe<CreateEnquiryPayload>;
  /** Creates a single `Expense`. */
  createExpense?: Maybe<CreateExpensePayload>;
  /** Creates a single `Feature`. */
  createFeature?: Maybe<CreateFeaturePayload>;
  /** Creates a single `FinanceCategory`. */
  createFinanceCategory?: Maybe<CreateFinanceCategoryPayload>;
  /** Creates a single `Invoice`. */
  createInvoice?: Maybe<CreateInvoicePayload>;
  /** Creates a single `LegalDocument`. */
  createLegalDocument?: Maybe<CreateLegalDocumentPayload>;
  /** Creates a single `LegalFolder`. */
  createLegalFolder?: Maybe<CreateLegalFolderPayload>;
  /** Creates a single `MapPoint`. */
  createMapPoint?: Maybe<CreateMapPointPayload>;
  /** Creates a single `MediaGallery`. */
  createMediaGallery?: Maybe<CreateMediaGalleryPayload>;
  /** Creates a single `MediaGalleryItem`. */
  createMediaGalleryItem?: Maybe<CreateMediaGalleryItemPayload>;
  /** Creates a single `MediaItem`. */
  createMediaItem?: Maybe<CreateMediaItemPayload>;
  /** Creates a single `Note`. */
  createNote?: Maybe<CreateNotePayload>;
  /** Creates a single `Passport`. */
  createPassport?: Maybe<CreatePassportPayload>;
  /** Creates a single `Payment`. */
  createPayment?: Maybe<CreatePaymentPayload>;
  /** Creates a single `Property`. */
  createProperty?: Maybe<CreatePropertyPayload>;
  /** Creates a single `Quote`. */
  createQuote?: Maybe<CreateQuotePayload>;
  /** Creates a single `QuoteAcceptance`. */
  createQuoteAcceptance?: Maybe<CreateQuoteAcceptancePayload>;
  /** Creates a single `QuoteAccommodationDetail`. */
  createQuoteAccommodationDetail?: Maybe<CreateQuoteAccommodationDetailPayload>;
  /** Creates a single `QuoteCurrency`. */
  createQuoteCurrency?: Maybe<CreateQuoteCurrencyPayload>;
  /** Creates a single `QuoteDay`. */
  createQuoteDay?: Maybe<CreateQuoteDayPayload>;
  /** Creates a single `QuoteDayDestination`. */
  createQuoteDayDestination?: Maybe<CreateQuoteDayDestinationPayload>;
  /** Creates a single `QuoteFinanceLineItem`. */
  createQuoteFinanceLineItem?: Maybe<CreateQuoteFinanceLineItemPayload>;
  /** Creates a single `QuoteHero`. */
  createQuoteHero?: Maybe<CreateQuoteHeroPayload>;
  /** Creates a single `QuoteLegalDocument`. */
  createQuoteLegalDocument?: Maybe<CreateQuoteLegalDocumentPayload>;
  /** Creates a single `QuotePublic`. */
  createQuotePublic?: Maybe<CreateQuotePublicPayload>;
  /** Creates a single `QuoteStatus`. */
  createQuoteStatus?: Maybe<CreateQuoteStatusPayload>;
  /** Creates a single `QuoteView`. */
  createQuoteView?: Maybe<CreateQuoteViewPayload>;
  /** Creates a single `Reminder`. */
  createReminder?: Maybe<CreateReminderPayload>;
  createStripeInvoice?: Maybe<GenericResponse>;
  /** Creates a single `Supplier`. */
  createSupplier?: Maybe<CreateSupplierPayload>;
  /** Creates a single `SupplierInvoice`. */
  createSupplierInvoice?: Maybe<CreateSupplierInvoicePayload>;
  /** Creates a single `Testimonial`. */
  createTestimonial?: Maybe<CreateTestimonialPayload>;
  /** Creates a single `Timezone`. */
  createTimezone?: Maybe<CreateTimezonePayload>;
  /** Creates a single `Transaction`. */
  createTransaction?: Maybe<CreateTransactionPayload>;
  /** Creates a single `TransactionImportBatch`. */
  createTransactionImportBatch?: Maybe<CreateTransactionImportBatchPayload>;
  /** Creates a single `TransactionLink`. */
  createTransactionLink?: Maybe<CreateTransactionLinkPayload>;
  /** Creates a single `TransactionNote`. */
  createTransactionNote?: Maybe<CreateTransactionNotePayload>;
  /** Creates a single `Traveller`. */
  createTraveller?: Maybe<CreateTravellerPayload>;
  /** Creates a single `Trip`. */
  createTrip?: Maybe<CreateTripPayload>;
  /** Creates a single `TripFlight`. */
  createTripFlight?: Maybe<CreateTripFlightPayload>;
  /** Creates a single `TripTraveller`. */
  createTripTraveller?: Maybe<CreateTripTravellerPayload>;
  /** Creates a single `User`. */
  createUser?: Maybe<CreateUserPayload>;
  /** Creates a single `VisaRequirement`. */
  createVisaRequirement?: Maybe<CreateVisaRequirementPayload>;
  dateWeek?: Maybe<DateWeekPayload>;
  /** Deletes a single `Account` using a unique key. */
  deleteAccount?: Maybe<DeleteAccountPayload>;
  /** Deletes a single `Agency` using a unique key. */
  deleteAgency?: Maybe<DeleteAgencyPayload>;
  /** Deletes a single `AgencyMember` using a unique key. */
  deleteAgencyMember?: Maybe<DeleteAgencyMemberPayload>;
  /** Deletes a single `Airport` using a unique key. */
  deleteAirport?: Maybe<DeleteAirportPayload>;
  /** Deletes a single `Country` using a unique key. */
  deleteCountry?: Maybe<DeleteCountryPayload>;
  /** Deletes a single `Customer` using a unique key. */
  deleteCustomer?: Maybe<DeleteCustomerPayload>;
  /** Deletes a single `CustomerTraveller` using a unique key. */
  deleteCustomerTraveller?: Maybe<DeleteCustomerTravellerPayload>;
  /** Deletes a single `Destination` using a unique key. */
  deleteDestination?: Maybe<DeleteDestinationPayload>;
  /** Deletes a single `Destination` using a unique key. */
  deleteDestinationByCountryIdAndAlias?: Maybe<DeleteDestinationPayload>;
  /** Deletes a single `DestinationFeature` using a unique key. */
  deleteDestinationFeature?: Maybe<DeleteDestinationFeaturePayload>;
  /** Deletes a single `DestinationGuide` using a unique key. */
  deleteDestinationGuide?: Maybe<DeleteDestinationGuidePayload>;
  /** Deletes a single `Email` using a unique key. */
  deleteEmail?: Maybe<DeleteEmailPayload>;
  /** Deletes a single `Enquiry` using a unique key. */
  deleteEnquiry?: Maybe<DeleteEnquiryPayload>;
  /** Deletes a single `Expense` using a unique key. */
  deleteExpense?: Maybe<DeleteExpensePayload>;
  /** Deletes a single `Feature` using a unique key. */
  deleteFeature?: Maybe<DeleteFeaturePayload>;
  /** Deletes a single `FinanceCategory` using a unique key. */
  deleteFinanceCategory?: Maybe<DeleteFinanceCategoryPayload>;
  /** Deletes a single `Invoice` using a unique key. */
  deleteInvoice?: Maybe<DeleteInvoicePayload>;
  /** Deletes a single `LegalDocument` using a unique key. */
  deleteLegalDocument?: Maybe<DeleteLegalDocumentPayload>;
  /** Deletes a single `LegalFolder` using a unique key. */
  deleteLegalFolder?: Maybe<DeleteLegalFolderPayload>;
  /** Deletes a single `MapPoint` using a unique key. */
  deleteMapPoint?: Maybe<DeleteMapPointPayload>;
  /** Deletes a single `MediaGallery` using a unique key. */
  deleteMediaGallery?: Maybe<DeleteMediaGalleryPayload>;
  /** Deletes a single `MediaGalleryItem` using a unique key. */
  deleteMediaGalleryItem?: Maybe<DeleteMediaGalleryItemPayload>;
  /** Deletes a single `MediaItem` using a unique key. */
  deleteMediaItem?: Maybe<DeleteMediaItemPayload>;
  /** Deletes a single `Note` using a unique key. */
  deleteNote?: Maybe<DeleteNotePayload>;
  /** Deletes a single `Passport` using a unique key. */
  deletePassport?: Maybe<DeletePassportPayload>;
  /** Deletes a single `Payment` using a unique key. */
  deletePayment?: Maybe<DeletePaymentPayload>;
  /** Deletes a single `Property` using a unique key. */
  deleteProperty?: Maybe<DeletePropertyPayload>;
  /** Deletes a single `Quote` using a unique key. */
  deleteQuote?: Maybe<DeleteQuotePayload>;
  /** Deletes a single `QuoteAcceptance` using a unique key. */
  deleteQuoteAcceptance?: Maybe<DeleteQuoteAcceptancePayload>;
  /** Deletes a single `QuoteAccommodationDetail` using a unique key. */
  deleteQuoteAccommodationDetail?: Maybe<DeleteQuoteAccommodationDetailPayload>;
  /** Deletes a single `Quote` using a unique key. */
  deleteQuoteByKey?: Maybe<DeleteQuotePayload>;
  /** Deletes a single `QuoteCurrency` using a unique key. */
  deleteQuoteCurrency?: Maybe<DeleteQuoteCurrencyPayload>;
  /** Deletes a single `QuoteDay` using a unique key. */
  deleteQuoteDay?: Maybe<DeleteQuoteDayPayload>;
  /** Deletes a single `QuoteDayDestination` using a unique key. */
  deleteQuoteDayDestination?: Maybe<DeleteQuoteDayDestinationPayload>;
  /** Deletes a single `QuoteFinanceLineItem` using a unique key. */
  deleteQuoteFinanceLineItem?: Maybe<DeleteQuoteFinanceLineItemPayload>;
  /** Deletes a single `QuoteHero` using a unique key. */
  deleteQuoteHero?: Maybe<DeleteQuoteHeroPayload>;
  /** Deletes a single `QuoteLegalDocument` using a unique key. */
  deleteQuoteLegalDocument?: Maybe<DeleteQuoteLegalDocumentPayload>;
  /** Deletes a single `QuotePublic` using a unique key. */
  deleteQuotePublic?: Maybe<DeleteQuotePublicPayload>;
  /** Deletes a single `QuoteStatus` using a unique key. */
  deleteQuoteStatus?: Maybe<DeleteQuoteStatusPayload>;
  /** Deletes a single `QuoteView` using a unique key. */
  deleteQuoteView?: Maybe<DeleteQuoteViewPayload>;
  /** Deletes a single `Reminder` using a unique key. */
  deleteReminder?: Maybe<DeleteReminderPayload>;
  /** Deletes a single `Supplier` using a unique key. */
  deleteSupplier?: Maybe<DeleteSupplierPayload>;
  /** Deletes a single `SupplierInvoice` using a unique key. */
  deleteSupplierInvoice?: Maybe<DeleteSupplierInvoicePayload>;
  /** Deletes a single `Testimonial` using a unique key. */
  deleteTestimonial?: Maybe<DeleteTestimonialPayload>;
  /** Deletes a single `Timezone` using a unique key. */
  deleteTimezone?: Maybe<DeleteTimezonePayload>;
  /** Deletes a single `Transaction` using a unique key. */
  deleteTransaction?: Maybe<DeleteTransactionPayload>;
  /** Deletes a single `TransactionImportBatch` using a unique key. */
  deleteTransactionImportBatch?: Maybe<DeleteTransactionImportBatchPayload>;
  /** Deletes a single `TransactionLink` using a unique key. */
  deleteTransactionLink?: Maybe<DeleteTransactionLinkPayload>;
  /** Deletes a single `TransactionNote` using a unique key. */
  deleteTransactionNote?: Maybe<DeleteTransactionNotePayload>;
  /** Deletes a single `Traveller` using a unique key. */
  deleteTraveller?: Maybe<DeleteTravellerPayload>;
  /** Deletes a single `Trip` using a unique key. */
  deleteTrip?: Maybe<DeleteTripPayload>;
  /** Deletes a single `TripFlight` using a unique key. */
  deleteTripFlight?: Maybe<DeleteTripFlightPayload>;
  /** Deletes a single `TripTraveller` using a unique key. */
  deleteTripTraveller?: Maybe<DeleteTripTravellerPayload>;
  /** Deletes a single `User` using a unique key. */
  deleteUser?: Maybe<DeleteUserPayload>;
  /** Deletes a single `VisaRequirement` using a unique key. */
  deleteVisaRequirement?: Maybe<DeleteVisaRequirementPayload>;
  executePayment?: Maybe<GenericResponse>;
  generateUploadUrl?: Maybe<Scalars['String']['output']>;
  gptItineraryImport?: Maybe<GptItineraryImportOutput>;
  housekeeping?: Maybe<Scalars['Boolean']['output']>;
  importWetu?: Maybe<GenericResponse>;
  mergePropertyInto?: Maybe<MergePropertyIntoPayload>;
  quotePdf: Scalars['String']['output'];
  randomString?: Maybe<RandomStringPayload>;
  submitEnquiry?: Maybe<GenericResponse>;
  trackQuoteView?: Maybe<GenericResponse>;
  /** Updates a single `Account` using a unique key and a patch. */
  updateAccount?: Maybe<UpdateAccountPayload>;
  /** Updates a single `Agency` using a unique key and a patch. */
  updateAgency?: Maybe<UpdateAgencyPayload>;
  /** Updates a single `AgencyMember` using a unique key and a patch. */
  updateAgencyMember?: Maybe<UpdateAgencyMemberPayload>;
  /** Updates a single `Airport` using a unique key and a patch. */
  updateAirport?: Maybe<UpdateAirportPayload>;
  /** Updates a single `Country` using a unique key and a patch. */
  updateCountry?: Maybe<UpdateCountryPayload>;
  /** Updates a single `Customer` using a unique key and a patch. */
  updateCustomer?: Maybe<UpdateCustomerPayload>;
  /** Updates a single `CustomerTraveller` using a unique key and a patch. */
  updateCustomerTraveller?: Maybe<UpdateCustomerTravellerPayload>;
  /** Updates a single `Destination` using a unique key and a patch. */
  updateDestination?: Maybe<UpdateDestinationPayload>;
  /** Updates a single `Destination` using a unique key and a patch. */
  updateDestinationByCountryIdAndAlias?: Maybe<UpdateDestinationPayload>;
  /** Updates a single `DestinationFeature` using a unique key and a patch. */
  updateDestinationFeature?: Maybe<UpdateDestinationFeaturePayload>;
  /** Updates a single `DestinationGuide` using a unique key and a patch. */
  updateDestinationGuide?: Maybe<UpdateDestinationGuidePayload>;
  /** Updates a single `Email` using a unique key and a patch. */
  updateEmail?: Maybe<UpdateEmailPayload>;
  /** Updates a single `Enquiry` using a unique key and a patch. */
  updateEnquiry?: Maybe<UpdateEnquiryPayload>;
  /** Updates a single `Expense` using a unique key and a patch. */
  updateExpense?: Maybe<UpdateExpensePayload>;
  /** Updates a single `Feature` using a unique key and a patch. */
  updateFeature?: Maybe<UpdateFeaturePayload>;
  /** Updates a single `FinanceCategory` using a unique key and a patch. */
  updateFinanceCategory?: Maybe<UpdateFinanceCategoryPayload>;
  /** Updates a single `Invoice` using a unique key and a patch. */
  updateInvoice?: Maybe<UpdateInvoicePayload>;
  /** Updates a single `LegalDocument` using a unique key and a patch. */
  updateLegalDocument?: Maybe<UpdateLegalDocumentPayload>;
  /** Updates a single `LegalFolder` using a unique key and a patch. */
  updateLegalFolder?: Maybe<UpdateLegalFolderPayload>;
  /** Updates a single `MapPoint` using a unique key and a patch. */
  updateMapPoint?: Maybe<UpdateMapPointPayload>;
  /** Updates a single `MediaGallery` using a unique key and a patch. */
  updateMediaGallery?: Maybe<UpdateMediaGalleryPayload>;
  /** Updates a single `MediaGalleryItem` using a unique key and a patch. */
  updateMediaGalleryItem?: Maybe<UpdateMediaGalleryItemPayload>;
  /** Updates a single `MediaItem` using a unique key and a patch. */
  updateMediaItem?: Maybe<UpdateMediaItemPayload>;
  /** Updates a single `Note` using a unique key and a patch. */
  updateNote?: Maybe<UpdateNotePayload>;
  /** Updates a single `Passport` using a unique key and a patch. */
  updatePassport?: Maybe<UpdatePassportPayload>;
  /** Updates a single `Payment` using a unique key and a patch. */
  updatePayment?: Maybe<UpdatePaymentPayload>;
  /** Updates a single `Property` using a unique key and a patch. */
  updateProperty?: Maybe<UpdatePropertyPayload>;
  /** Updates a single `Quote` using a unique key and a patch. */
  updateQuote?: Maybe<UpdateQuotePayload>;
  /** Updates a single `QuoteAcceptance` using a unique key and a patch. */
  updateQuoteAcceptance?: Maybe<UpdateQuoteAcceptancePayload>;
  /** Updates a single `QuoteAccommodationDetail` using a unique key and a patch. */
  updateQuoteAccommodationDetail?: Maybe<UpdateQuoteAccommodationDetailPayload>;
  /** Updates a single `Quote` using a unique key and a patch. */
  updateQuoteByKey?: Maybe<UpdateQuotePayload>;
  /** Updates a single `QuoteCurrency` using a unique key and a patch. */
  updateQuoteCurrency?: Maybe<UpdateQuoteCurrencyPayload>;
  /** Updates a single `QuoteDay` using a unique key and a patch. */
  updateQuoteDay?: Maybe<UpdateQuoteDayPayload>;
  /** Updates a single `QuoteDayDestination` using a unique key and a patch. */
  updateQuoteDayDestination?: Maybe<UpdateQuoteDayDestinationPayload>;
  /** Updates a single `QuoteFinanceLineItem` using a unique key and a patch. */
  updateQuoteFinanceLineItem?: Maybe<UpdateQuoteFinanceLineItemPayload>;
  /** Updates a single `QuoteHero` using a unique key and a patch. */
  updateQuoteHero?: Maybe<UpdateQuoteHeroPayload>;
  /** Updates a single `QuoteLegalDocument` using a unique key and a patch. */
  updateQuoteLegalDocument?: Maybe<UpdateQuoteLegalDocumentPayload>;
  /** Updates a single `QuotePublic` using a unique key and a patch. */
  updateQuotePublic?: Maybe<UpdateQuotePublicPayload>;
  /** Updates a single `QuoteStatus` using a unique key and a patch. */
  updateQuoteStatus?: Maybe<UpdateQuoteStatusPayload>;
  /** Updates a single `QuoteView` using a unique key and a patch. */
  updateQuoteView?: Maybe<UpdateQuoteViewPayload>;
  /** Updates a single `Reminder` using a unique key and a patch. */
  updateReminder?: Maybe<UpdateReminderPayload>;
  /** Updates a single `Supplier` using a unique key and a patch. */
  updateSupplier?: Maybe<UpdateSupplierPayload>;
  /** Updates a single `SupplierInvoice` using a unique key and a patch. */
  updateSupplierInvoice?: Maybe<UpdateSupplierInvoicePayload>;
  /** Updates a single `Testimonial` using a unique key and a patch. */
  updateTestimonial?: Maybe<UpdateTestimonialPayload>;
  /** Updates a single `Timezone` using a unique key and a patch. */
  updateTimezone?: Maybe<UpdateTimezonePayload>;
  /** Updates a single `Transaction` using a unique key and a patch. */
  updateTransaction?: Maybe<UpdateTransactionPayload>;
  /** Updates a single `TransactionImportBatch` using a unique key and a patch. */
  updateTransactionImportBatch?: Maybe<UpdateTransactionImportBatchPayload>;
  /** Updates a single `TransactionLink` using a unique key and a patch. */
  updateTransactionLink?: Maybe<UpdateTransactionLinkPayload>;
  /** Updates a single `TransactionNote` using a unique key and a patch. */
  updateTransactionNote?: Maybe<UpdateTransactionNotePayload>;
  /** Updates a single `Traveller` using a unique key and a patch. */
  updateTraveller?: Maybe<UpdateTravellerPayload>;
  /** Updates a single `Trip` using a unique key and a patch. */
  updateTrip?: Maybe<UpdateTripPayload>;
  /** Updates a single `TripFlight` using a unique key and a patch. */
  updateTripFlight?: Maybe<UpdateTripFlightPayload>;
  /** Updates a single `TripTraveller` using a unique key and a patch. */
  updateTripTraveller?: Maybe<UpdateTripTravellerPayload>;
  /** Updates a single `User` using a unique key and a patch. */
  updateUser?: Maybe<UpdateUserPayload>;
  /** Updates a single `VisaRequirement` using a unique key and a patch. */
  updateVisaRequirement?: Maybe<UpdateVisaRequirementPayload>;
  weeklyDigest?: Maybe<Scalars['Boolean']['output']>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationAcceptQuoteArgs = {
  input: AcceptQuoteInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateAccountArgs = {
  input: CreateAccountInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateAgencyArgs = {
  input: CreateAgencyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateAgencyMemberArgs = {
  input: CreateAgencyMemberInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateAirportArgs = {
  input: CreateAirportInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCountryArgs = {
  input: CreateCountryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCustomerArgs = {
  input: CreateCustomerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCustomerTravellerArgs = {
  input: CreateCustomerTravellerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDestinationArgs = {
  input: CreateDestinationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDestinationFeatureArgs = {
  input: CreateDestinationFeatureInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDestinationGuideArgs = {
  input: CreateDestinationGuideInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateEmailArgs = {
  input: CreateEmailInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateEnquiryArgs = {
  input: CreateEnquiryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateExpenseArgs = {
  input: CreateExpenseInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateFeatureArgs = {
  input: CreateFeatureInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateFinanceCategoryArgs = {
  input: CreateFinanceCategoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateInvoiceArgs = {
  input: CreateInvoiceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateLegalDocumentArgs = {
  input: CreateLegalDocumentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateLegalFolderArgs = {
  input: CreateLegalFolderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateMapPointArgs = {
  input: CreateMapPointInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateMediaGalleryArgs = {
  input: CreateMediaGalleryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateMediaGalleryItemArgs = {
  input: CreateMediaGalleryItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateMediaItemArgs = {
  input: CreateMediaItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateNoteArgs = {
  input: CreateNoteInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePassportArgs = {
  input: CreatePassportInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePaymentArgs = {
  input: CreatePaymentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePropertyArgs = {
  input: CreatePropertyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateQuoteArgs = {
  input: CreateQuoteInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateQuoteAcceptanceArgs = {
  input: CreateQuoteAcceptanceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateQuoteAccommodationDetailArgs = {
  input: CreateQuoteAccommodationDetailInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateQuoteCurrencyArgs = {
  input: CreateQuoteCurrencyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateQuoteDayArgs = {
  input: CreateQuoteDayInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateQuoteDayDestinationArgs = {
  input: CreateQuoteDayDestinationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateQuoteFinanceLineItemArgs = {
  input: CreateQuoteFinanceLineItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateQuoteHeroArgs = {
  input: CreateQuoteHeroInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateQuoteLegalDocumentArgs = {
  input: CreateQuoteLegalDocumentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateQuotePublicArgs = {
  input: CreateQuotePublicInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateQuoteStatusArgs = {
  input: CreateQuoteStatusInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateQuoteViewArgs = {
  input: CreateQuoteViewInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateReminderArgs = {
  input: CreateReminderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateStripeInvoiceArgs = {
  input: CreateStripeInvoiceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateSupplierArgs = {
  input: CreateSupplierInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateSupplierInvoiceArgs = {
  input: CreateSupplierInvoiceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTestimonialArgs = {
  input: CreateTestimonialInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTimezoneArgs = {
  input: CreateTimezoneInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTransactionArgs = {
  input: CreateTransactionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTransactionImportBatchArgs = {
  input: CreateTransactionImportBatchInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTransactionLinkArgs = {
  input: CreateTransactionLinkInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTransactionNoteArgs = {
  input: CreateTransactionNoteInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTravellerArgs = {
  input: CreateTravellerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTripArgs = {
  input: CreateTripInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTripFlightArgs = {
  input: CreateTripFlightInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTripTravellerArgs = {
  input: CreateTripTravellerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateUserArgs = {
  input: CreateUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateVisaRequirementArgs = {
  input: CreateVisaRequirementInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDateWeekArgs = {
  input: DateWeekInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAccountArgs = {
  input: DeleteAccountInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAgencyArgs = {
  input: DeleteAgencyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAgencyMemberArgs = {
  input: DeleteAgencyMemberInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAirportArgs = {
  input: DeleteAirportInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCountryArgs = {
  input: DeleteCountryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCustomerArgs = {
  input: DeleteCustomerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCustomerTravellerArgs = {
  input: DeleteCustomerTravellerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDestinationArgs = {
  input: DeleteDestinationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDestinationByCountryIdAndAliasArgs = {
  input: DeleteDestinationByCountryIdAndAliasInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDestinationFeatureArgs = {
  input: DeleteDestinationFeatureInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDestinationGuideArgs = {
  input: DeleteDestinationGuideInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteEmailArgs = {
  input: DeleteEmailInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteEnquiryArgs = {
  input: DeleteEnquiryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteExpenseArgs = {
  input: DeleteExpenseInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFeatureArgs = {
  input: DeleteFeatureInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFinanceCategoryArgs = {
  input: DeleteFinanceCategoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteInvoiceArgs = {
  input: DeleteInvoiceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLegalDocumentArgs = {
  input: DeleteLegalDocumentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLegalFolderArgs = {
  input: DeleteLegalFolderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteMapPointArgs = {
  input: DeleteMapPointInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteMediaGalleryArgs = {
  input: DeleteMediaGalleryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteMediaGalleryItemArgs = {
  input: DeleteMediaGalleryItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteMediaItemArgs = {
  input: DeleteMediaItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteNoteArgs = {
  input: DeleteNoteInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePassportArgs = {
  input: DeletePassportInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePaymentArgs = {
  input: DeletePaymentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePropertyArgs = {
  input: DeletePropertyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteQuoteArgs = {
  input: DeleteQuoteInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteQuoteAcceptanceArgs = {
  input: DeleteQuoteAcceptanceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteQuoteAccommodationDetailArgs = {
  input: DeleteQuoteAccommodationDetailInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteQuoteByKeyArgs = {
  input: DeleteQuoteByKeyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteQuoteCurrencyArgs = {
  input: DeleteQuoteCurrencyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteQuoteDayArgs = {
  input: DeleteQuoteDayInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteQuoteDayDestinationArgs = {
  input: DeleteQuoteDayDestinationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteQuoteFinanceLineItemArgs = {
  input: DeleteQuoteFinanceLineItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteQuoteHeroArgs = {
  input: DeleteQuoteHeroInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteQuoteLegalDocumentArgs = {
  input: DeleteQuoteLegalDocumentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteQuotePublicArgs = {
  input: DeleteQuotePublicInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteQuoteStatusArgs = {
  input: DeleteQuoteStatusInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteQuoteViewArgs = {
  input: DeleteQuoteViewInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteReminderArgs = {
  input: DeleteReminderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSupplierArgs = {
  input: DeleteSupplierInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSupplierInvoiceArgs = {
  input: DeleteSupplierInvoiceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTestimonialArgs = {
  input: DeleteTestimonialInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTimezoneArgs = {
  input: DeleteTimezoneInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTransactionArgs = {
  input: DeleteTransactionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTransactionImportBatchArgs = {
  input: DeleteTransactionImportBatchInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTransactionLinkArgs = {
  input: DeleteTransactionLinkInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTransactionNoteArgs = {
  input: DeleteTransactionNoteInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTravellerArgs = {
  input: DeleteTravellerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTripArgs = {
  input: DeleteTripInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTripFlightArgs = {
  input: DeleteTripFlightInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTripTravellerArgs = {
  input: DeleteTripTravellerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserArgs = {
  input: DeleteUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteVisaRequirementArgs = {
  input: DeleteVisaRequirementInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationExecutePaymentArgs = {
  input: ExecutePaymentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationGenerateUploadUrlArgs = {
  input: GenerateUploadUrlInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationGptItineraryImportArgs = {
  input: GptItineraryImport;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationImportWetuArgs = {
  input: ImportWetuInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationMergePropertyIntoArgs = {
  input: MergePropertyIntoInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationQuotePdfArgs = {
  key: Scalars['String']['input'];
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationRandomStringArgs = {
  input: RandomStringInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationSubmitEnquiryArgs = {
  input: SubmitEnquiryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationTrackQuoteViewArgs = {
  input: TrackQuoteViewInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAccountArgs = {
  input: UpdateAccountInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAgencyArgs = {
  input: UpdateAgencyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAgencyMemberArgs = {
  input: UpdateAgencyMemberInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAirportArgs = {
  input: UpdateAirportInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCountryArgs = {
  input: UpdateCountryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCustomerArgs = {
  input: UpdateCustomerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCustomerTravellerArgs = {
  input: UpdateCustomerTravellerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDestinationArgs = {
  input: UpdateDestinationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDestinationByCountryIdAndAliasArgs = {
  input: UpdateDestinationByCountryIdAndAliasInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDestinationFeatureArgs = {
  input: UpdateDestinationFeatureInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDestinationGuideArgs = {
  input: UpdateDestinationGuideInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateEmailArgs = {
  input: UpdateEmailInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateEnquiryArgs = {
  input: UpdateEnquiryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateExpenseArgs = {
  input: UpdateExpenseInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFeatureArgs = {
  input: UpdateFeatureInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFinanceCategoryArgs = {
  input: UpdateFinanceCategoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateInvoiceArgs = {
  input: UpdateInvoiceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLegalDocumentArgs = {
  input: UpdateLegalDocumentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLegalFolderArgs = {
  input: UpdateLegalFolderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateMapPointArgs = {
  input: UpdateMapPointInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateMediaGalleryArgs = {
  input: UpdateMediaGalleryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateMediaGalleryItemArgs = {
  input: UpdateMediaGalleryItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateMediaItemArgs = {
  input: UpdateMediaItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateNoteArgs = {
  input: UpdateNoteInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePassportArgs = {
  input: UpdatePassportInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePaymentArgs = {
  input: UpdatePaymentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePropertyArgs = {
  input: UpdatePropertyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateQuoteArgs = {
  input: UpdateQuoteInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateQuoteAcceptanceArgs = {
  input: UpdateQuoteAcceptanceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateQuoteAccommodationDetailArgs = {
  input: UpdateQuoteAccommodationDetailInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateQuoteByKeyArgs = {
  input: UpdateQuoteByKeyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateQuoteCurrencyArgs = {
  input: UpdateQuoteCurrencyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateQuoteDayArgs = {
  input: UpdateQuoteDayInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateQuoteDayDestinationArgs = {
  input: UpdateQuoteDayDestinationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateQuoteFinanceLineItemArgs = {
  input: UpdateQuoteFinanceLineItemInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateQuoteHeroArgs = {
  input: UpdateQuoteHeroInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateQuoteLegalDocumentArgs = {
  input: UpdateQuoteLegalDocumentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateQuotePublicArgs = {
  input: UpdateQuotePublicInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateQuoteStatusArgs = {
  input: UpdateQuoteStatusInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateQuoteViewArgs = {
  input: UpdateQuoteViewInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateReminderArgs = {
  input: UpdateReminderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSupplierArgs = {
  input: UpdateSupplierInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSupplierInvoiceArgs = {
  input: UpdateSupplierInvoiceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTestimonialArgs = {
  input: UpdateTestimonialInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTimezoneArgs = {
  input: UpdateTimezoneInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTransactionArgs = {
  input: UpdateTransactionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTransactionImportBatchArgs = {
  input: UpdateTransactionImportBatchInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTransactionLinkArgs = {
  input: UpdateTransactionLinkInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTransactionNoteArgs = {
  input: UpdateTransactionNoteInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTravellerArgs = {
  input: UpdateTravellerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTripArgs = {
  input: UpdateTripInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTripFlightArgs = {
  input: UpdateTripFlightInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTripTravellerArgs = {
  input: UpdateTripTravellerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserArgs = {
  input: UpdateUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateVisaRequirementArgs = {
  input: UpdateVisaRequirementInput;
};

export type Note = {
  __typename?: 'Note';
  body?: Maybe<Scalars['String']['output']>;
  created: Scalars['Datetime']['output'];
  id: Scalars['UUID']['output'];
  modified: Scalars['Datetime']['output'];
  title?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Trip` that is related to this `Note`. */
  trip?: Maybe<Trip>;
  tripId?: Maybe<Scalars['UUID']['output']>;
  /** Reads a single `User` that is related to this `Note`. */
  user?: Maybe<User>;
  userId: Scalars['UUID']['output'];
};

/** A condition to be used against `Note` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type NoteCondition = {
  /** Checks for equality with the object’s `body` field. */
  body?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `title` field. */
  title?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `tripId` field. */
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['UUID']['input']>;
};

/** A filter to be used against `Note` object types. All fields are combined with a logical ‘and.’ */
export type NoteFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<NoteFilter>>;
  /** Filter by the object’s `body` field. */
  body?: InputMaybe<StringFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<NoteFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<NoteFilter>>;
  /** Filter by the object’s `title` field. */
  title?: InputMaybe<StringFilter>;
  /** Filter by the object’s `trip` relation. */
  trip?: InputMaybe<TripFilter>;
  /** A related `trip` exists. */
  tripExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `tripId` field. */
  tripId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `user` relation. */
  user?: InputMaybe<UserFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<UuidFilter>;
};

/** An input for mutations affecting `Note` */
export type NoteInput = {
  body?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkNoteTripTripIdInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkNoteUserUserIdInput>;
};

/** The fields on `note` to look up the row to update. */
export type NoteOnNoteForFkNoteTripTripIdUsingPkNoteUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `note` being updated. */
  patch: UpdateNoteOnNoteForFkNoteTripTripIdPatch;
};

/** The fields on `note` to look up the row to update. */
export type NoteOnNoteForFkNoteUserUserIdUsingPkNoteUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `note` being updated. */
  patch: UpdateNoteOnNoteForFkNoteUserUserIdPatch;
};

/** Represents an update to a `Note`. Fields that are set will be updated. */
export type NotePatch = {
  body?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkNoteTripTripIdInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkNoteUserUserIdInput>;
};

/** The fields on `note` to look up the row to connect. */
export type NotePkNoteConnect = {
  id: Scalars['UUID']['input'];
};

/** The fields on `note` to look up the row to delete. */
export type NotePkNoteDelete = {
  id: Scalars['UUID']['input'];
};

/** A connection to a list of `Note` values. */
export type NotesConnection = {
  __typename?: 'NotesConnection';
  /** A list of edges which contains the `Note` and cursor to aid in pagination. */
  edges: Array<NotesEdge>;
  /** A list of `Note` objects. */
  nodes: Array<Maybe<Note>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Note` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Note` edge in the connection. */
export type NotesEdge = {
  __typename?: 'NotesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Note` at the end of the edge. */
  node?: Maybe<Note>;
};

/** Methods to use when ordering `Note`. */
export enum NotesOrderBy {
  BodyAsc = 'BODY_ASC',
  BodyDesc = 'BODY_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC',
  TripByTripIdActiveQuoteIdAsc = 'TRIP_BY_TRIP_ID__ACTIVE_QUOTE_ID_ASC',
  TripByTripIdActiveQuoteIdDesc = 'TRIP_BY_TRIP_ID__ACTIVE_QUOTE_ID_DESC',
  TripByTripIdAgencyIdAsc = 'TRIP_BY_TRIP_ID__AGENCY_ID_ASC',
  TripByTripIdAgencyIdDesc = 'TRIP_BY_TRIP_ID__AGENCY_ID_DESC',
  TripByTripIdAgencyMemberIdAsc = 'TRIP_BY_TRIP_ID__AGENCY_MEMBER_ID_ASC',
  TripByTripIdAgencyMemberIdDesc = 'TRIP_BY_TRIP_ID__AGENCY_MEMBER_ID_DESC',
  TripByTripIdArchivedAsc = 'TRIP_BY_TRIP_ID__ARCHIVED_ASC',
  TripByTripIdArchivedDesc = 'TRIP_BY_TRIP_ID__ARCHIVED_DESC',
  TripByTripIdBaseCurrencyAsc = 'TRIP_BY_TRIP_ID__BASE_CURRENCY_ASC',
  TripByTripIdBaseCurrencyDesc = 'TRIP_BY_TRIP_ID__BASE_CURRENCY_DESC',
  TripByTripIdCreatedAsc = 'TRIP_BY_TRIP_ID__CREATED_ASC',
  TripByTripIdCreatedDesc = 'TRIP_BY_TRIP_ID__CREATED_DESC',
  TripByTripIdCustomerIdAsc = 'TRIP_BY_TRIP_ID__CUSTOMER_ID_ASC',
  TripByTripIdCustomerIdDesc = 'TRIP_BY_TRIP_ID__CUSTOMER_ID_DESC',
  TripByTripIdDatesAsc = 'TRIP_BY_TRIP_ID__DATES_ASC',
  TripByTripIdDatesDesc = 'TRIP_BY_TRIP_ID__DATES_DESC',
  TripByTripIdDestinationAsc = 'TRIP_BY_TRIP_ID__DESTINATION_ASC',
  TripByTripIdDestinationDesc = 'TRIP_BY_TRIP_ID__DESTINATION_DESC',
  TripByTripIdDurationAsc = 'TRIP_BY_TRIP_ID__DURATION_ASC',
  TripByTripIdDurationDesc = 'TRIP_BY_TRIP_ID__DURATION_DESC',
  TripByTripIdIdAsc = 'TRIP_BY_TRIP_ID__ID_ASC',
  TripByTripIdIdDesc = 'TRIP_BY_TRIP_ID__ID_DESC',
  TripByTripIdMediaGalleryIdAsc = 'TRIP_BY_TRIP_ID__MEDIA_GALLERY_ID_ASC',
  TripByTripIdMediaGalleryIdDesc = 'TRIP_BY_TRIP_ID__MEDIA_GALLERY_ID_DESC',
  TripByTripIdModifiedAsc = 'TRIP_BY_TRIP_ID__MODIFIED_ASC',
  TripByTripIdModifiedDesc = 'TRIP_BY_TRIP_ID__MODIFIED_DESC',
  TripByTripIdNameAsc = 'TRIP_BY_TRIP_ID__NAME_ASC',
  TripByTripIdNameDesc = 'TRIP_BY_TRIP_ID__NAME_DESC',
  TripByTripIdStartAsc = 'TRIP_BY_TRIP_ID__START_ASC',
  TripByTripIdStartDesc = 'TRIP_BY_TRIP_ID__START_DESC',
  TripByTripIdStatusAsc = 'TRIP_BY_TRIP_ID__STATUS_ASC',
  TripByTripIdStatusDesc = 'TRIP_BY_TRIP_ID__STATUS_DESC',
  TripByTripIdSummaryAsc = 'TRIP_BY_TRIP_ID__SUMMARY_ASC',
  TripByTripIdSummaryDesc = 'TRIP_BY_TRIP_ID__SUMMARY_DESC',
  TripByTripIdUserIdAsc = 'TRIP_BY_TRIP_ID__USER_ID_ASC',
  TripByTripIdUserIdDesc = 'TRIP_BY_TRIP_ID__USER_ID_DESC',
  TripIdAsc = 'TRIP_ID_ASC',
  TripIdDesc = 'TRIP_ID_DESC',
  UserByUserIdCreatedAsc = 'USER_BY_USER_ID__CREATED_ASC',
  UserByUserIdCreatedDesc = 'USER_BY_USER_ID__CREATED_DESC',
  UserByUserIdEmailAsc = 'USER_BY_USER_ID__EMAIL_ASC',
  UserByUserIdEmailDesc = 'USER_BY_USER_ID__EMAIL_DESC',
  UserByUserIdExternalIdAsc = 'USER_BY_USER_ID__EXTERNAL_ID_ASC',
  UserByUserIdExternalIdDesc = 'USER_BY_USER_ID__EXTERNAL_ID_DESC',
  UserByUserIdFirstNameAsc = 'USER_BY_USER_ID__FIRST_NAME_ASC',
  UserByUserIdFirstNameDesc = 'USER_BY_USER_ID__FIRST_NAME_DESC',
  UserByUserIdGenderPrepositionAsc = 'USER_BY_USER_ID__GENDER_PREPOSITION_ASC',
  UserByUserIdGenderPrepositionDesc = 'USER_BY_USER_ID__GENDER_PREPOSITION_DESC',
  UserByUserIdIdAsc = 'USER_BY_USER_ID__ID_ASC',
  UserByUserIdIdDesc = 'USER_BY_USER_ID__ID_DESC',
  UserByUserIdLastNameAsc = 'USER_BY_USER_ID__LAST_NAME_ASC',
  UserByUserIdLastNameDesc = 'USER_BY_USER_ID__LAST_NAME_DESC',
  UserByUserIdModifiedAsc = 'USER_BY_USER_ID__MODIFIED_ASC',
  UserByUserIdModifiedDesc = 'USER_BY_USER_ID__MODIFIED_DESC',
  UserByUserIdNameAsc = 'USER_BY_USER_ID__NAME_ASC',
  UserByUserIdNameDesc = 'USER_BY_USER_ID__NAME_DESC',
  UserByUserIdPasswordAsc = 'USER_BY_USER_ID__PASSWORD_ASC',
  UserByUserIdPasswordDesc = 'USER_BY_USER_ID__PASSWORD_DESC',
  UserByUserIdPhoneAsc = 'USER_BY_USER_ID__PHONE_ASC',
  UserByUserIdPhoneDesc = 'USER_BY_USER_ID__PHONE_DESC',
  UserByUserIdSkypeAsc = 'USER_BY_USER_ID__SKYPE_ASC',
  UserByUserIdSkypeDesc = 'USER_BY_USER_ID__SKYPE_DESC',
  UserByUserIdTitleAsc = 'USER_BY_USER_ID__TITLE_ASC',
  UserByUserIdTitleDesc = 'USER_BY_USER_ID__TITLE_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['Cursor']['output']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean']['output'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean']['output'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['Cursor']['output']>;
};

export type Passport = {
  __typename?: 'Passport';
  /** Reads a single `Country` that is related to this `Passport`. */
  country?: Maybe<Country>;
  countryId?: Maybe<Scalars['UUID']['output']>;
  countryOfIssue?: Maybe<Scalars['String']['output']>;
  created: Scalars['Datetime']['output'];
  expiry: Scalars['Datetime']['output'];
  id: Scalars['UUID']['output'];
  modified: Scalars['Datetime']['output'];
  number?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Traveller` that is related to this `Passport`. */
  traveller?: Maybe<Traveller>;
  travellerId: Scalars['UUID']['output'];
};

/**
 * A condition to be used against `Passport` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type PassportCondition = {
  /** Checks for equality with the object’s `countryId` field. */
  countryId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `countryOfIssue` field. */
  countryOfIssue?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `expiry` field. */
  expiry?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `number` field. */
  number?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `travellerId` field. */
  travellerId?: InputMaybe<Scalars['UUID']['input']>;
};

/** The `country` to be created by this mutation. */
export type PassportCountry2IdFkeyCountryCreateInput = {
  airportsUsingId?: InputMaybe<FkAirportCountryCountryIdInverseInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationsUsingId?: InputMaybe<FkDestinationCountryCountryIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  iso2?: InputMaybe<Scalars['String']['input']>;
  iso3?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  passportsUsingId?: InputMaybe<PassportCountry2IdFkeyInverseInput>;
  propertiesUsingId?: InputMaybe<FkPropertyCountryCountryIdInverseInput>;
};

/** Input for the nested mutation of `country` in the `PassportInput` mutation. */
export type PassportCountry2IdFkeyInput = {
  /** The primary key(s) for `country` for the far side of the relationship. */
  connectById?: InputMaybe<CountryPkCountryConnect>;
  /** A `CountryInput` object that will be created and connected to this object. */
  create?: InputMaybe<PassportCountry2IdFkeyCountryCreateInput>;
  /** The primary key(s) for `country` for the far side of the relationship. */
  deleteById?: InputMaybe<CountryPkCountryDelete>;
  /** The primary key(s) and patch data for `country` for the far side of the relationship. */
  updateById?: InputMaybe<CountryOnPassportForPassportCountry2IdFkeyUsingPkCountryUpdate>;
};

/** Input for the nested mutation of `passport` in the `CountryInput` mutation. */
export type PassportCountry2IdFkeyInverseInput = {
  /** The primary key(s) for `passport` for the far side of the relationship. */
  connectById?: InputMaybe<Array<PassportPkPassportConnect>>;
  /** A `PassportInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<PassportCountry2IdFkeyPassportCreateInput>>;
  /** The primary key(s) for `passport` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<PassportPkPassportDelete>>;
  /** Flag indicating whether all other `passport` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `passport` for the far side of the relationship. */
  updateById?: InputMaybe<Array<PassportOnPassportForPassportCountry2IdFkeyUsingPkPassportUpdate>>;
};

/** The `passport` to be created by this mutation. */
export type PassportCountry2IdFkeyPassportCreateInput = {
  countryOfIssue?: InputMaybe<Scalars['String']['input']>;
  countryToCountryId?: InputMaybe<PassportCountry2IdFkeyInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  expiry: Scalars['Datetime']['input'];
  id?: InputMaybe<Scalars['UUID']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  number?: InputMaybe<Scalars['String']['input']>;
  travellerId?: InputMaybe<Scalars['UUID']['input']>;
  travellerToTravellerId?: InputMaybe<FkPassportTravellerTravellerIdInput>;
};

/** A filter to be used against `Passport` object types. All fields are combined with a logical ‘and.’ */
export type PassportFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<PassportFilter>>;
  /** Filter by the object’s `country` relation. */
  country?: InputMaybe<CountryFilter>;
  /** A related `country` exists. */
  countryExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `countryId` field. */
  countryId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `countryOfIssue` field. */
  countryOfIssue?: InputMaybe<StringFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `expiry` field. */
  expiry?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<PassportFilter>;
  /** Filter by the object’s `number` field. */
  number?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<PassportFilter>>;
  /** Filter by the object’s `traveller` relation. */
  traveller?: InputMaybe<TravellerFilter>;
  /** Filter by the object’s `travellerId` field. */
  travellerId?: InputMaybe<UuidFilter>;
};

/** An input for mutations affecting `Passport` */
export type PassportInput = {
  countryId?: InputMaybe<Scalars['UUID']['input']>;
  countryOfIssue?: InputMaybe<Scalars['String']['input']>;
  countryToCountryId?: InputMaybe<PassportCountry2IdFkeyInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  expiry: Scalars['Datetime']['input'];
  id?: InputMaybe<Scalars['UUID']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  number?: InputMaybe<Scalars['String']['input']>;
  travellerId?: InputMaybe<Scalars['UUID']['input']>;
  travellerToTravellerId?: InputMaybe<FkPassportTravellerTravellerIdInput>;
};

/** The fields on `passport` to look up the row to update. */
export type PassportOnPassportForFkPassportTravellerTravellerIdUsingPkPassportUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `passport` being updated. */
  patch: UpdatePassportOnPassportForFkPassportTravellerTravellerIdPatch;
};

/** The fields on `passport` to look up the row to update. */
export type PassportOnPassportForPassportCountry2IdFkeyUsingPkPassportUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `passport` being updated. */
  patch: UpdatePassportOnPassportForPassportCountry2IdFkeyPatch;
};

/** Represents an update to a `Passport`. Fields that are set will be updated. */
export type PassportPatch = {
  countryId?: InputMaybe<Scalars['UUID']['input']>;
  countryOfIssue?: InputMaybe<Scalars['String']['input']>;
  countryToCountryId?: InputMaybe<PassportCountry2IdFkeyInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  expiry?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  number?: InputMaybe<Scalars['String']['input']>;
  travellerId?: InputMaybe<Scalars['UUID']['input']>;
  travellerToTravellerId?: InputMaybe<FkPassportTravellerTravellerIdInput>;
};

/** The fields on `passport` to look up the row to connect. */
export type PassportPkPassportConnect = {
  id: Scalars['UUID']['input'];
};

/** The fields on `passport` to look up the row to delete. */
export type PassportPkPassportDelete = {
  id: Scalars['UUID']['input'];
};

/** A connection to a list of `Passport` values. */
export type PassportsConnection = {
  __typename?: 'PassportsConnection';
  /** A list of edges which contains the `Passport` and cursor to aid in pagination. */
  edges: Array<PassportsEdge>;
  /** A list of `Passport` objects. */
  nodes: Array<Maybe<Passport>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Passport` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Passport` edge in the connection. */
export type PassportsEdge = {
  __typename?: 'PassportsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Passport` at the end of the edge. */
  node?: Maybe<Passport>;
};

/** Methods to use when ordering `Passport`. */
export enum PassportsOrderBy {
  CountryByCountryIdCreatedAsc = 'COUNTRY_BY_COUNTRY_ID__CREATED_ASC',
  CountryByCountryIdCreatedDesc = 'COUNTRY_BY_COUNTRY_ID__CREATED_DESC',
  CountryByCountryIdIdAsc = 'COUNTRY_BY_COUNTRY_ID__ID_ASC',
  CountryByCountryIdIdDesc = 'COUNTRY_BY_COUNTRY_ID__ID_DESC',
  CountryByCountryIdIso2Asc = 'COUNTRY_BY_COUNTRY_ID__ISO2_ASC',
  CountryByCountryIdIso2Desc = 'COUNTRY_BY_COUNTRY_ID__ISO2_DESC',
  CountryByCountryIdIso3Asc = 'COUNTRY_BY_COUNTRY_ID__ISO3_ASC',
  CountryByCountryIdIso3Desc = 'COUNTRY_BY_COUNTRY_ID__ISO3_DESC',
  CountryByCountryIdModifiedAsc = 'COUNTRY_BY_COUNTRY_ID__MODIFIED_ASC',
  CountryByCountryIdModifiedDesc = 'COUNTRY_BY_COUNTRY_ID__MODIFIED_DESC',
  CountryByCountryIdNameAsc = 'COUNTRY_BY_COUNTRY_ID__NAME_ASC',
  CountryByCountryIdNameDesc = 'COUNTRY_BY_COUNTRY_ID__NAME_DESC',
  CountryIdAsc = 'COUNTRY_ID_ASC',
  CountryIdDesc = 'COUNTRY_ID_DESC',
  CountryOfIssueAsc = 'COUNTRY_OF_ISSUE_ASC',
  CountryOfIssueDesc = 'COUNTRY_OF_ISSUE_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  ExpiryAsc = 'EXPIRY_ASC',
  ExpiryDesc = 'EXPIRY_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  Natural = 'NATURAL',
  NumberAsc = 'NUMBER_ASC',
  NumberDesc = 'NUMBER_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TravellerByTravellerIdCreatedAsc = 'TRAVELLER_BY_TRAVELLER_ID__CREATED_ASC',
  TravellerByTravellerIdCreatedDesc = 'TRAVELLER_BY_TRAVELLER_ID__CREATED_DESC',
  TravellerByTravellerIdDateOfBirthAsc = 'TRAVELLER_BY_TRAVELLER_ID__DATE_OF_BIRTH_ASC',
  TravellerByTravellerIdDateOfBirthDesc = 'TRAVELLER_BY_TRAVELLER_ID__DATE_OF_BIRTH_DESC',
  TravellerByTravellerIdDietaryRequirementsAsc = 'TRAVELLER_BY_TRAVELLER_ID__DIETARY_REQUIREMENTS_ASC',
  TravellerByTravellerIdDietaryRequirementsDesc = 'TRAVELLER_BY_TRAVELLER_ID__DIETARY_REQUIREMENTS_DESC',
  TravellerByTravellerIdEmailAsc = 'TRAVELLER_BY_TRAVELLER_ID__EMAIL_ASC',
  TravellerByTravellerIdEmailDesc = 'TRAVELLER_BY_TRAVELLER_ID__EMAIL_DESC',
  TravellerByTravellerIdEmergencyContactAsc = 'TRAVELLER_BY_TRAVELLER_ID__EMERGENCY_CONTACT_ASC',
  TravellerByTravellerIdEmergencyContactDesc = 'TRAVELLER_BY_TRAVELLER_ID__EMERGENCY_CONTACT_DESC',
  TravellerByTravellerIdFirstNameAsc = 'TRAVELLER_BY_TRAVELLER_ID__FIRST_NAME_ASC',
  TravellerByTravellerIdFirstNameDesc = 'TRAVELLER_BY_TRAVELLER_ID__FIRST_NAME_DESC',
  TravellerByTravellerIdHeightAsc = 'TRAVELLER_BY_TRAVELLER_ID__HEIGHT_ASC',
  TravellerByTravellerIdHeightDesc = 'TRAVELLER_BY_TRAVELLER_ID__HEIGHT_DESC',
  TravellerByTravellerIdIdAsc = 'TRAVELLER_BY_TRAVELLER_ID__ID_ASC',
  TravellerByTravellerIdIdDesc = 'TRAVELLER_BY_TRAVELLER_ID__ID_DESC',
  TravellerByTravellerIdInsuranceDetailsAsc = 'TRAVELLER_BY_TRAVELLER_ID__INSURANCE_DETAILS_ASC',
  TravellerByTravellerIdInsuranceDetailsDesc = 'TRAVELLER_BY_TRAVELLER_ID__INSURANCE_DETAILS_DESC',
  TravellerByTravellerIdLastNameAsc = 'TRAVELLER_BY_TRAVELLER_ID__LAST_NAME_ASC',
  TravellerByTravellerIdLastNameDesc = 'TRAVELLER_BY_TRAVELLER_ID__LAST_NAME_DESC',
  TravellerByTravellerIdMedicalConditionsAsc = 'TRAVELLER_BY_TRAVELLER_ID__MEDICAL_CONDITIONS_ASC',
  TravellerByTravellerIdMedicalConditionsDesc = 'TRAVELLER_BY_TRAVELLER_ID__MEDICAL_CONDITIONS_DESC',
  TravellerByTravellerIdMiddleNameAsc = 'TRAVELLER_BY_TRAVELLER_ID__MIDDLE_NAME_ASC',
  TravellerByTravellerIdMiddleNameDesc = 'TRAVELLER_BY_TRAVELLER_ID__MIDDLE_NAME_DESC',
  TravellerByTravellerIdModifiedAsc = 'TRAVELLER_BY_TRAVELLER_ID__MODIFIED_ASC',
  TravellerByTravellerIdModifiedDesc = 'TRAVELLER_BY_TRAVELLER_ID__MODIFIED_DESC',
  TravellerByTravellerIdNationalityAsc = 'TRAVELLER_BY_TRAVELLER_ID__NATIONALITY_ASC',
  TravellerByTravellerIdNationalityDesc = 'TRAVELLER_BY_TRAVELLER_ID__NATIONALITY_DESC',
  TravellerByTravellerIdNotesAsc = 'TRAVELLER_BY_TRAVELLER_ID__NOTES_ASC',
  TravellerByTravellerIdNotesDesc = 'TRAVELLER_BY_TRAVELLER_ID__NOTES_DESC',
  TravellerByTravellerIdPhoneAsc = 'TRAVELLER_BY_TRAVELLER_ID__PHONE_ASC',
  TravellerByTravellerIdPhoneDesc = 'TRAVELLER_BY_TRAVELLER_ID__PHONE_DESC',
  TravellerByTravellerIdWeightAsc = 'TRAVELLER_BY_TRAVELLER_ID__WEIGHT_ASC',
  TravellerByTravellerIdWeightDesc = 'TRAVELLER_BY_TRAVELLER_ID__WEIGHT_DESC',
  TravellerIdAsc = 'TRAVELLER_ID_ASC',
  TravellerIdDesc = 'TRAVELLER_ID_DESC'
}

export type Payment = {
  __typename?: 'Payment';
  amount: Scalars['BigFloat']['output'];
  amountActual: Scalars['BigFloat']['output'];
  /** Reads a single `FinanceCategory` that is related to this `Payment`. */
  category?: Maybe<FinanceCategory>;
  categoryId?: Maybe<Scalars['UUID']['output']>;
  created: Scalars['Datetime']['output'];
  currency?: Maybe<Scalars['String']['output']>;
  id: Scalars['UUID']['output'];
  /** Reads a single `Invoice` that is related to this `Payment`. */
  invoice?: Maybe<Invoice>;
  invoiceId: Scalars['UUID']['output'];
  modified: Scalars['Datetime']['output'];
  paid: Scalars['Datetime']['output'];
  reference?: Maybe<Scalars['String']['output']>;
  summary?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `TransactionLink`. */
  transactionLinks: TransactionLinksConnection;
  /** Reads a single `Trip` that is related to this `Payment`. */
  trip?: Maybe<Trip>;
  tripId?: Maybe<Scalars['UUID']['output']>;
  type: Scalars['Int']['output'];
};


export type PaymentTransactionLinksArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TransactionLinkCondition>;
  filter?: InputMaybe<TransactionLinkFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TransactionLinksOrderBy>>;
};

/** A condition to be used against `Payment` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type PaymentCondition = {
  /** Checks for equality with the object’s `amount` field. */
  amount?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `amountActual` field. */
  amountActual?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `categoryId` field. */
  categoryId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `currency` field. */
  currency?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `invoiceId` field. */
  invoiceId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `paid` field. */
  paid?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `reference` field. */
  reference?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `summary` field. */
  summary?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `tripId` field. */
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `type` field. */
  type?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `Payment` object types. All fields are combined with a logical ‘and.’ */
export type PaymentFilter = {
  /** Filter by the object’s `amount` field. */
  amount?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `amountActual` field. */
  amountActual?: InputMaybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<PaymentFilter>>;
  /** Filter by the object’s `category` relation. */
  category?: InputMaybe<FinanceCategoryFilter>;
  /** A related `category` exists. */
  categoryExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `categoryId` field. */
  categoryId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `currency` field. */
  currency?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `invoice` relation. */
  invoice?: InputMaybe<InvoiceFilter>;
  /** Filter by the object’s `invoiceId` field. */
  invoiceId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<PaymentFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<PaymentFilter>>;
  /** Filter by the object’s `paid` field. */
  paid?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `reference` field. */
  reference?: InputMaybe<StringFilter>;
  /** Filter by the object’s `summary` field. */
  summary?: InputMaybe<StringFilter>;
  /** Filter by the object’s `transactionLinks` relation. */
  transactionLinks?: InputMaybe<PaymentToManyTransactionLinkFilter>;
  /** Some related `transactionLinks` exist. */
  transactionLinksExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `trip` relation. */
  trip?: InputMaybe<TripFilter>;
  /** A related `trip` exists. */
  tripExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `tripId` field. */
  tripId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `type` field. */
  type?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `Payment` */
export type PaymentInput = {
  amount: Scalars['BigFloat']['input'];
  amountActual: Scalars['BigFloat']['input'];
  categoryId?: InputMaybe<Scalars['UUID']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  financeCategoryToCategoryId?: InputMaybe<FkPaymentFinanceCategoryCategoryIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoiceId?: InputMaybe<Scalars['UUID']['input']>;
  invoiceToInvoiceId?: InputMaybe<FkPaymentInvoiceInvoiceIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  paid: Scalars['Datetime']['input'];
  reference?: InputMaybe<Scalars['String']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  transactionLinksUsingId?: InputMaybe<FkTransactionLinkPaymentPaymentIdInverseInput>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkPaymentTripTripIdInput>;
  type?: InputMaybe<Scalars['Int']['input']>;
};

/** The fields on `payment` to look up the row to update. */
export type PaymentOnPaymentForFkPaymentFinanceCategoryCategoryIdUsingPkPaymentUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `payment` being updated. */
  patch: UpdatePaymentOnPaymentForFkPaymentFinanceCategoryCategoryIdPatch;
};

/** The fields on `payment` to look up the row to update. */
export type PaymentOnPaymentForFkPaymentInvoiceInvoiceIdUsingPkPaymentUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `payment` being updated. */
  patch: UpdatePaymentOnPaymentForFkPaymentInvoiceInvoiceIdPatch;
};

/** The fields on `payment` to look up the row to update. */
export type PaymentOnPaymentForFkPaymentTripTripIdUsingPkPaymentUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `payment` being updated. */
  patch: UpdatePaymentOnPaymentForFkPaymentTripTripIdPatch;
};

/** The fields on `payment` to look up the row to update. */
export type PaymentOnTransactionLinkForFkTransactionLinkPaymentPaymentIdUsingPkPaymentUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `payment` being updated. */
  patch: UpdatePaymentOnTransactionLinkForFkTransactionLinkPaymentPaymentIdPatch;
};

/** Represents an update to a `Payment`. Fields that are set will be updated. */
export type PaymentPatch = {
  amount?: InputMaybe<Scalars['BigFloat']['input']>;
  amountActual?: InputMaybe<Scalars['BigFloat']['input']>;
  categoryId?: InputMaybe<Scalars['UUID']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  financeCategoryToCategoryId?: InputMaybe<FkPaymentFinanceCategoryCategoryIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoiceId?: InputMaybe<Scalars['UUID']['input']>;
  invoiceToInvoiceId?: InputMaybe<FkPaymentInvoiceInvoiceIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  paid?: InputMaybe<Scalars['Datetime']['input']>;
  reference?: InputMaybe<Scalars['String']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  transactionLinksUsingId?: InputMaybe<FkTransactionLinkPaymentPaymentIdInverseInput>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkPaymentTripTripIdInput>;
  type?: InputMaybe<Scalars['Int']['input']>;
};

/** The fields on `payment` to look up the row to connect. */
export type PaymentPkPaymentConnect = {
  id: Scalars['UUID']['input'];
};

/** The fields on `payment` to look up the row to delete. */
export type PaymentPkPaymentDelete = {
  id: Scalars['UUID']['input'];
};

/** A filter to be used against many `TransactionLink` object types. All fields are combined with a logical ‘and.’ */
export type PaymentToManyTransactionLinkFilter = {
  /** Every related `TransactionLink` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<TransactionLinkFilter>;
  /** No related `TransactionLink` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<TransactionLinkFilter>;
  /** Some related `TransactionLink` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<TransactionLinkFilter>;
};

/** A connection to a list of `Payment` values. */
export type PaymentsConnection = {
  __typename?: 'PaymentsConnection';
  /** A list of edges which contains the `Payment` and cursor to aid in pagination. */
  edges: Array<PaymentsEdge>;
  /** A list of `Payment` objects. */
  nodes: Array<Maybe<Payment>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Payment` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Payment` edge in the connection. */
export type PaymentsEdge = {
  __typename?: 'PaymentsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Payment` at the end of the edge. */
  node?: Maybe<Payment>;
};

/** Methods to use when ordering `Payment`. */
export enum PaymentsOrderBy {
  AmountActualAsc = 'AMOUNT_ACTUAL_ASC',
  AmountActualDesc = 'AMOUNT_ACTUAL_DESC',
  AmountAsc = 'AMOUNT_ASC',
  AmountDesc = 'AMOUNT_DESC',
  CategoryIdAsc = 'CATEGORY_ID_ASC',
  CategoryIdDesc = 'CATEGORY_ID_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  CurrencyAsc = 'CURRENCY_ASC',
  CurrencyDesc = 'CURRENCY_DESC',
  FinanceCategoryByCategoryIdCodeAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__CODE_ASC',
  FinanceCategoryByCategoryIdCodeDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__CODE_DESC',
  FinanceCategoryByCategoryIdCreatedAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__CREATED_ASC',
  FinanceCategoryByCategoryIdCreatedDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__CREATED_DESC',
  FinanceCategoryByCategoryIdIdAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__ID_ASC',
  FinanceCategoryByCategoryIdIdDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__ID_DESC',
  FinanceCategoryByCategoryIdModifiedAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__MODIFIED_ASC',
  FinanceCategoryByCategoryIdModifiedDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__MODIFIED_DESC',
  FinanceCategoryByCategoryIdNameAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__NAME_ASC',
  FinanceCategoryByCategoryIdNameDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__NAME_DESC',
  FinanceCategoryByCategoryIdSummaryAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__SUMMARY_ASC',
  FinanceCategoryByCategoryIdSummaryDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__SUMMARY_DESC',
  FinanceCategoryByCategoryIdTypeAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__TYPE_ASC',
  FinanceCategoryByCategoryIdTypeDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__TYPE_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  InvoiceByInvoiceIdAmountAsc = 'INVOICE_BY_INVOICE_ID__AMOUNT_ASC',
  InvoiceByInvoiceIdAmountDesc = 'INVOICE_BY_INVOICE_ID__AMOUNT_DESC',
  InvoiceByInvoiceIdCategoryIdAsc = 'INVOICE_BY_INVOICE_ID__CATEGORY_ID_ASC',
  InvoiceByInvoiceIdCategoryIdDesc = 'INVOICE_BY_INVOICE_ID__CATEGORY_ID_DESC',
  InvoiceByInvoiceIdCreatedAsc = 'INVOICE_BY_INVOICE_ID__CREATED_ASC',
  InvoiceByInvoiceIdCreatedDesc = 'INVOICE_BY_INVOICE_ID__CREATED_DESC',
  InvoiceByInvoiceIdCurrencyAsc = 'INVOICE_BY_INVOICE_ID__CURRENCY_ASC',
  InvoiceByInvoiceIdCurrencyDesc = 'INVOICE_BY_INVOICE_ID__CURRENCY_DESC',
  InvoiceByInvoiceIdDueAsc = 'INVOICE_BY_INVOICE_ID__DUE_ASC',
  InvoiceByInvoiceIdDueDesc = 'INVOICE_BY_INVOICE_ID__DUE_DESC',
  InvoiceByInvoiceIdIdAsc = 'INVOICE_BY_INVOICE_ID__ID_ASC',
  InvoiceByInvoiceIdIdDesc = 'INVOICE_BY_INVOICE_ID__ID_DESC',
  InvoiceByInvoiceIdInvoicedAsc = 'INVOICE_BY_INVOICE_ID__INVOICED_ASC',
  InvoiceByInvoiceIdInvoicedDesc = 'INVOICE_BY_INVOICE_ID__INVOICED_DESC',
  InvoiceByInvoiceIdKeyAsc = 'INVOICE_BY_INVOICE_ID__KEY_ASC',
  InvoiceByInvoiceIdKeyDesc = 'INVOICE_BY_INVOICE_ID__KEY_DESC',
  InvoiceByInvoiceIdLockedAsc = 'INVOICE_BY_INVOICE_ID__LOCKED_ASC',
  InvoiceByInvoiceIdLockedDesc = 'INVOICE_BY_INVOICE_ID__LOCKED_DESC',
  InvoiceByInvoiceIdModifiedAsc = 'INVOICE_BY_INVOICE_ID__MODIFIED_ASC',
  InvoiceByInvoiceIdModifiedDesc = 'INVOICE_BY_INVOICE_ID__MODIFIED_DESC',
  InvoiceByInvoiceIdNoteAsc = 'INVOICE_BY_INVOICE_ID__NOTE_ASC',
  InvoiceByInvoiceIdNoteDesc = 'INVOICE_BY_INVOICE_ID__NOTE_DESC',
  InvoiceByInvoiceIdNumberAsc = 'INVOICE_BY_INVOICE_ID__NUMBER_ASC',
  InvoiceByInvoiceIdNumberDesc = 'INVOICE_BY_INVOICE_ID__NUMBER_DESC',
  InvoiceByInvoiceIdPaidAsc = 'INVOICE_BY_INVOICE_ID__PAID_ASC',
  InvoiceByInvoiceIdPaidDesc = 'INVOICE_BY_INVOICE_ID__PAID_DESC',
  InvoiceByInvoiceIdQuoteIdAsc = 'INVOICE_BY_INVOICE_ID__QUOTE_ID_ASC',
  InvoiceByInvoiceIdQuoteIdDesc = 'INVOICE_BY_INVOICE_ID__QUOTE_ID_DESC',
  InvoiceByInvoiceIdSummaryAsc = 'INVOICE_BY_INVOICE_ID__SUMMARY_ASC',
  InvoiceByInvoiceIdSummaryDesc = 'INVOICE_BY_INVOICE_ID__SUMMARY_DESC',
  InvoiceByInvoiceIdTripIdAsc = 'INVOICE_BY_INVOICE_ID__TRIP_ID_ASC',
  InvoiceByInvoiceIdTripIdDesc = 'INVOICE_BY_INVOICE_ID__TRIP_ID_DESC',
  InvoiceByInvoiceIdTypeAsc = 'INVOICE_BY_INVOICE_ID__TYPE_ASC',
  InvoiceByInvoiceIdTypeDesc = 'INVOICE_BY_INVOICE_ID__TYPE_DESC',
  InvoiceByInvoiceIdVoidedAsc = 'INVOICE_BY_INVOICE_ID__VOIDED_ASC',
  InvoiceByInvoiceIdVoidedDesc = 'INVOICE_BY_INVOICE_ID__VOIDED_DESC',
  InvoiceIdAsc = 'INVOICE_ID_ASC',
  InvoiceIdDesc = 'INVOICE_ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  Natural = 'NATURAL',
  PaidAsc = 'PAID_ASC',
  PaidDesc = 'PAID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ReferenceAsc = 'REFERENCE_ASC',
  ReferenceDesc = 'REFERENCE_DESC',
  SummaryAsc = 'SUMMARY_ASC',
  SummaryDesc = 'SUMMARY_DESC',
  TransactionLinksByPaymentIdCountAsc = 'TRANSACTION_LINKS_BY_PAYMENT_ID__COUNT_ASC',
  TransactionLinksByPaymentIdCountDesc = 'TRANSACTION_LINKS_BY_PAYMENT_ID__COUNT_DESC',
  TripByTripIdActiveQuoteIdAsc = 'TRIP_BY_TRIP_ID__ACTIVE_QUOTE_ID_ASC',
  TripByTripIdActiveQuoteIdDesc = 'TRIP_BY_TRIP_ID__ACTIVE_QUOTE_ID_DESC',
  TripByTripIdAgencyIdAsc = 'TRIP_BY_TRIP_ID__AGENCY_ID_ASC',
  TripByTripIdAgencyIdDesc = 'TRIP_BY_TRIP_ID__AGENCY_ID_DESC',
  TripByTripIdAgencyMemberIdAsc = 'TRIP_BY_TRIP_ID__AGENCY_MEMBER_ID_ASC',
  TripByTripIdAgencyMemberIdDesc = 'TRIP_BY_TRIP_ID__AGENCY_MEMBER_ID_DESC',
  TripByTripIdArchivedAsc = 'TRIP_BY_TRIP_ID__ARCHIVED_ASC',
  TripByTripIdArchivedDesc = 'TRIP_BY_TRIP_ID__ARCHIVED_DESC',
  TripByTripIdBaseCurrencyAsc = 'TRIP_BY_TRIP_ID__BASE_CURRENCY_ASC',
  TripByTripIdBaseCurrencyDesc = 'TRIP_BY_TRIP_ID__BASE_CURRENCY_DESC',
  TripByTripIdCreatedAsc = 'TRIP_BY_TRIP_ID__CREATED_ASC',
  TripByTripIdCreatedDesc = 'TRIP_BY_TRIP_ID__CREATED_DESC',
  TripByTripIdCustomerIdAsc = 'TRIP_BY_TRIP_ID__CUSTOMER_ID_ASC',
  TripByTripIdCustomerIdDesc = 'TRIP_BY_TRIP_ID__CUSTOMER_ID_DESC',
  TripByTripIdDatesAsc = 'TRIP_BY_TRIP_ID__DATES_ASC',
  TripByTripIdDatesDesc = 'TRIP_BY_TRIP_ID__DATES_DESC',
  TripByTripIdDestinationAsc = 'TRIP_BY_TRIP_ID__DESTINATION_ASC',
  TripByTripIdDestinationDesc = 'TRIP_BY_TRIP_ID__DESTINATION_DESC',
  TripByTripIdDurationAsc = 'TRIP_BY_TRIP_ID__DURATION_ASC',
  TripByTripIdDurationDesc = 'TRIP_BY_TRIP_ID__DURATION_DESC',
  TripByTripIdIdAsc = 'TRIP_BY_TRIP_ID__ID_ASC',
  TripByTripIdIdDesc = 'TRIP_BY_TRIP_ID__ID_DESC',
  TripByTripIdMediaGalleryIdAsc = 'TRIP_BY_TRIP_ID__MEDIA_GALLERY_ID_ASC',
  TripByTripIdMediaGalleryIdDesc = 'TRIP_BY_TRIP_ID__MEDIA_GALLERY_ID_DESC',
  TripByTripIdModifiedAsc = 'TRIP_BY_TRIP_ID__MODIFIED_ASC',
  TripByTripIdModifiedDesc = 'TRIP_BY_TRIP_ID__MODIFIED_DESC',
  TripByTripIdNameAsc = 'TRIP_BY_TRIP_ID__NAME_ASC',
  TripByTripIdNameDesc = 'TRIP_BY_TRIP_ID__NAME_DESC',
  TripByTripIdStartAsc = 'TRIP_BY_TRIP_ID__START_ASC',
  TripByTripIdStartDesc = 'TRIP_BY_TRIP_ID__START_DESC',
  TripByTripIdStatusAsc = 'TRIP_BY_TRIP_ID__STATUS_ASC',
  TripByTripIdStatusDesc = 'TRIP_BY_TRIP_ID__STATUS_DESC',
  TripByTripIdSummaryAsc = 'TRIP_BY_TRIP_ID__SUMMARY_ASC',
  TripByTripIdSummaryDesc = 'TRIP_BY_TRIP_ID__SUMMARY_DESC',
  TripByTripIdUserIdAsc = 'TRIP_BY_TRIP_ID__USER_ID_ASC',
  TripByTripIdUserIdDesc = 'TRIP_BY_TRIP_ID__USER_ID_DESC',
  TripIdAsc = 'TRIP_ID_ASC',
  TripIdDesc = 'TRIP_ID_DESC',
  TypeAsc = 'TYPE_ASC',
  TypeDesc = 'TYPE_DESC'
}

/** A connection to a list of `Property` values. */
export type PropertiesConnection = {
  __typename?: 'PropertiesConnection';
  /** A list of edges which contains the `Property` and cursor to aid in pagination. */
  edges: Array<PropertiesEdge>;
  /** A list of `Property` objects. */
  nodes: Array<Maybe<Property>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Property` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Property` edge in the connection. */
export type PropertiesEdge = {
  __typename?: 'PropertiesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Property` at the end of the edge. */
  node?: Maybe<Property>;
};

/** Methods to use when ordering `Property`. */
export enum PropertiesOrderBy {
  AliasAsc = 'ALIAS_ASC',
  AliasDesc = 'ALIAS_DESC',
  ArchivedAsc = 'ARCHIVED_ASC',
  ArchivedDesc = 'ARCHIVED_DESC',
  CityAsc = 'CITY_ASC',
  CityDesc = 'CITY_DESC',
  ContactEmailAsc = 'CONTACT_EMAIL_ASC',
  ContactEmailDesc = 'CONTACT_EMAIL_DESC',
  ContactNumberAsc = 'CONTACT_NUMBER_ASC',
  ContactNumberDesc = 'CONTACT_NUMBER_DESC',
  CountryByCountryIdCreatedAsc = 'COUNTRY_BY_COUNTRY_ID__CREATED_ASC',
  CountryByCountryIdCreatedDesc = 'COUNTRY_BY_COUNTRY_ID__CREATED_DESC',
  CountryByCountryIdIdAsc = 'COUNTRY_BY_COUNTRY_ID__ID_ASC',
  CountryByCountryIdIdDesc = 'COUNTRY_BY_COUNTRY_ID__ID_DESC',
  CountryByCountryIdIso2Asc = 'COUNTRY_BY_COUNTRY_ID__ISO2_ASC',
  CountryByCountryIdIso2Desc = 'COUNTRY_BY_COUNTRY_ID__ISO2_DESC',
  CountryByCountryIdIso3Asc = 'COUNTRY_BY_COUNTRY_ID__ISO3_ASC',
  CountryByCountryIdIso3Desc = 'COUNTRY_BY_COUNTRY_ID__ISO3_DESC',
  CountryByCountryIdModifiedAsc = 'COUNTRY_BY_COUNTRY_ID__MODIFIED_ASC',
  CountryByCountryIdModifiedDesc = 'COUNTRY_BY_COUNTRY_ID__MODIFIED_DESC',
  CountryByCountryIdNameAsc = 'COUNTRY_BY_COUNTRY_ID__NAME_ASC',
  CountryByCountryIdNameDesc = 'COUNTRY_BY_COUNTRY_ID__NAME_DESC',
  CountryIdAsc = 'COUNTRY_ID_ASC',
  CountryIdDesc = 'COUNTRY_ID_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  DestinationByDestinationIdAliasAsc = 'DESTINATION_BY_DESTINATION_ID__ALIAS_ASC',
  DestinationByDestinationIdAliasDesc = 'DESTINATION_BY_DESTINATION_ID__ALIAS_DESC',
  DestinationByDestinationIdBodyAsc = 'DESTINATION_BY_DESTINATION_ID__BODY_ASC',
  DestinationByDestinationIdBodyDesc = 'DESTINATION_BY_DESTINATION_ID__BODY_DESC',
  DestinationByDestinationIdCountryIdAsc = 'DESTINATION_BY_DESTINATION_ID__COUNTRY_ID_ASC',
  DestinationByDestinationIdCountryIdDesc = 'DESTINATION_BY_DESTINATION_ID__COUNTRY_ID_DESC',
  DestinationByDestinationIdCreatedAsc = 'DESTINATION_BY_DESTINATION_ID__CREATED_ASC',
  DestinationByDestinationIdCreatedDesc = 'DESTINATION_BY_DESTINATION_ID__CREATED_DESC',
  DestinationByDestinationIdGalleryIdAsc = 'DESTINATION_BY_DESTINATION_ID__GALLERY_ID_ASC',
  DestinationByDestinationIdGalleryIdDesc = 'DESTINATION_BY_DESTINATION_ID__GALLERY_ID_DESC',
  DestinationByDestinationIdHeroMediaIdAsc = 'DESTINATION_BY_DESTINATION_ID__HERO_MEDIA_ID_ASC',
  DestinationByDestinationIdHeroMediaIdDesc = 'DESTINATION_BY_DESTINATION_ID__HERO_MEDIA_ID_DESC',
  DestinationByDestinationIdIdAsc = 'DESTINATION_BY_DESTINATION_ID__ID_ASC',
  DestinationByDestinationIdIdDesc = 'DESTINATION_BY_DESTINATION_ID__ID_DESC',
  DestinationByDestinationIdLatitudeAsc = 'DESTINATION_BY_DESTINATION_ID__LATITUDE_ASC',
  DestinationByDestinationIdLatitudeDesc = 'DESTINATION_BY_DESTINATION_ID__LATITUDE_DESC',
  DestinationByDestinationIdLongitudeAsc = 'DESTINATION_BY_DESTINATION_ID__LONGITUDE_ASC',
  DestinationByDestinationIdLongitudeDesc = 'DESTINATION_BY_DESTINATION_ID__LONGITUDE_DESC',
  DestinationByDestinationIdModifiedAsc = 'DESTINATION_BY_DESTINATION_ID__MODIFIED_ASC',
  DestinationByDestinationIdModifiedDesc = 'DESTINATION_BY_DESTINATION_ID__MODIFIED_DESC',
  DestinationByDestinationIdNameAsc = 'DESTINATION_BY_DESTINATION_ID__NAME_ASC',
  DestinationByDestinationIdNameDesc = 'DESTINATION_BY_DESTINATION_ID__NAME_DESC',
  DestinationByDestinationIdParentIdAsc = 'DESTINATION_BY_DESTINATION_ID__PARENT_ID_ASC',
  DestinationByDestinationIdParentIdDesc = 'DESTINATION_BY_DESTINATION_ID__PARENT_ID_DESC',
  DestinationIdAsc = 'DESTINATION_ID_ASC',
  DestinationIdDesc = 'DESTINATION_ID_DESC',
  ExternalReferenceAsc = 'EXTERNAL_REFERENCE_ASC',
  ExternalReferenceDesc = 'EXTERNAL_REFERENCE_DESC',
  FeaturedAsc = 'FEATURED_ASC',
  FeaturedDesc = 'FEATURED_DESC',
  FeatureCopyAsc = 'FEATURE_COPY_ASC',
  FeatureCopyDesc = 'FEATURE_COPY_DESC',
  GalleryIdAsc = 'GALLERY_ID_ASC',
  GalleryIdDesc = 'GALLERY_ID_DESC',
  HeroMediaIdAsc = 'HERO_MEDIA_ID_ASC',
  HeroMediaIdDesc = 'HERO_MEDIA_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LatitudeAsc = 'LATITUDE_ASC',
  LatitudeDesc = 'LATITUDE_DESC',
  LongitudeAsc = 'LONGITUDE_ASC',
  LongitudeDesc = 'LONGITUDE_DESC',
  MapPointByMapPointIdCreatedAsc = 'MAP_POINT_BY_MAP_POINT_ID__CREATED_ASC',
  MapPointByMapPointIdCreatedDesc = 'MAP_POINT_BY_MAP_POINT_ID__CREATED_DESC',
  MapPointByMapPointIdIdAsc = 'MAP_POINT_BY_MAP_POINT_ID__ID_ASC',
  MapPointByMapPointIdIdDesc = 'MAP_POINT_BY_MAP_POINT_ID__ID_DESC',
  MapPointByMapPointIdLatitudeAsc = 'MAP_POINT_BY_MAP_POINT_ID__LATITUDE_ASC',
  MapPointByMapPointIdLatitudeDesc = 'MAP_POINT_BY_MAP_POINT_ID__LATITUDE_DESC',
  MapPointByMapPointIdLongitudeAsc = 'MAP_POINT_BY_MAP_POINT_ID__LONGITUDE_ASC',
  MapPointByMapPointIdLongitudeDesc = 'MAP_POINT_BY_MAP_POINT_ID__LONGITUDE_DESC',
  MapPointByMapPointIdModifiedAsc = 'MAP_POINT_BY_MAP_POINT_ID__MODIFIED_ASC',
  MapPointByMapPointIdModifiedDesc = 'MAP_POINT_BY_MAP_POINT_ID__MODIFIED_DESC',
  MapPointByMapPointIdNameAsc = 'MAP_POINT_BY_MAP_POINT_ID__NAME_ASC',
  MapPointByMapPointIdNameDesc = 'MAP_POINT_BY_MAP_POINT_ID__NAME_DESC',
  MapPointIdAsc = 'MAP_POINT_ID_ASC',
  MapPointIdDesc = 'MAP_POINT_ID_DESC',
  MediaGalleryByGalleryIdCreatedAsc = 'MEDIA_GALLERY_BY_GALLERY_ID__CREATED_ASC',
  MediaGalleryByGalleryIdCreatedDesc = 'MEDIA_GALLERY_BY_GALLERY_ID__CREATED_DESC',
  MediaGalleryByGalleryIdIdAsc = 'MEDIA_GALLERY_BY_GALLERY_ID__ID_ASC',
  MediaGalleryByGalleryIdIdDesc = 'MEDIA_GALLERY_BY_GALLERY_ID__ID_DESC',
  MediaGalleryByGalleryIdIsProtectedAsc = 'MEDIA_GALLERY_BY_GALLERY_ID__IS_PROTECTED_ASC',
  MediaGalleryByGalleryIdIsProtectedDesc = 'MEDIA_GALLERY_BY_GALLERY_ID__IS_PROTECTED_DESC',
  MediaGalleryByGalleryIdModifiedAsc = 'MEDIA_GALLERY_BY_GALLERY_ID__MODIFIED_ASC',
  MediaGalleryByGalleryIdModifiedDesc = 'MEDIA_GALLERY_BY_GALLERY_ID__MODIFIED_DESC',
  MediaGalleryByGalleryIdNameAsc = 'MEDIA_GALLERY_BY_GALLERY_ID__NAME_ASC',
  MediaGalleryByGalleryIdNameDesc = 'MEDIA_GALLERY_BY_GALLERY_ID__NAME_DESC',
  MediaGalleryByGalleryIdParentIdAsc = 'MEDIA_GALLERY_BY_GALLERY_ID__PARENT_ID_ASC',
  MediaGalleryByGalleryIdParentIdDesc = 'MEDIA_GALLERY_BY_GALLERY_ID__PARENT_ID_DESC',
  MediaItemByHeroMediaIdContentTypeAsc = 'MEDIA_ITEM_BY_HERO_MEDIA_ID__CONTENT_TYPE_ASC',
  MediaItemByHeroMediaIdContentTypeDesc = 'MEDIA_ITEM_BY_HERO_MEDIA_ID__CONTENT_TYPE_DESC',
  MediaItemByHeroMediaIdCreatedAsc = 'MEDIA_ITEM_BY_HERO_MEDIA_ID__CREATED_ASC',
  MediaItemByHeroMediaIdCreatedDesc = 'MEDIA_ITEM_BY_HERO_MEDIA_ID__CREATED_DESC',
  MediaItemByHeroMediaIdFileNameAsc = 'MEDIA_ITEM_BY_HERO_MEDIA_ID__FILE_NAME_ASC',
  MediaItemByHeroMediaIdFileNameDesc = 'MEDIA_ITEM_BY_HERO_MEDIA_ID__FILE_NAME_DESC',
  MediaItemByHeroMediaIdHashAsc = 'MEDIA_ITEM_BY_HERO_MEDIA_ID__HASH_ASC',
  MediaItemByHeroMediaIdHashDesc = 'MEDIA_ITEM_BY_HERO_MEDIA_ID__HASH_DESC',
  MediaItemByHeroMediaIdIdAsc = 'MEDIA_ITEM_BY_HERO_MEDIA_ID__ID_ASC',
  MediaItemByHeroMediaIdIdDesc = 'MEDIA_ITEM_BY_HERO_MEDIA_ID__ID_DESC',
  MediaItemByHeroMediaIdModifiedAsc = 'MEDIA_ITEM_BY_HERO_MEDIA_ID__MODIFIED_ASC',
  MediaItemByHeroMediaIdModifiedDesc = 'MEDIA_ITEM_BY_HERO_MEDIA_ID__MODIFIED_DESC',
  MediaItemByHeroMediaIdNameAsc = 'MEDIA_ITEM_BY_HERO_MEDIA_ID__NAME_ASC',
  MediaItemByHeroMediaIdNameDesc = 'MEDIA_ITEM_BY_HERO_MEDIA_ID__NAME_DESC',
  MediaItemByHeroMediaIdSummaryAsc = 'MEDIA_ITEM_BY_HERO_MEDIA_ID__SUMMARY_ASC',
  MediaItemByHeroMediaIdSummaryDesc = 'MEDIA_ITEM_BY_HERO_MEDIA_ID__SUMMARY_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  NearestAirportAsc = 'NEAREST_AIRPORT_ASC',
  NearestAirportDesc = 'NEAREST_AIRPORT_DESC',
  NotesAsc = 'NOTES_ASC',
  NotesDesc = 'NOTES_DESC',
  PlusCodeAsc = 'PLUS_CODE_ASC',
  PlusCodeDesc = 'PLUS_CODE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QuoteAccommodationDetailsByPropertyIdCountAsc = 'QUOTE_ACCOMMODATION_DETAILS_BY_PROPERTY_ID__COUNT_ASC',
  QuoteAccommodationDetailsByPropertyIdCountDesc = 'QUOTE_ACCOMMODATION_DETAILS_BY_PROPERTY_ID__COUNT_DESC',
  QuoteDaysByPropertyIdCountAsc = 'QUOTE_DAYS_BY_PROPERTY_ID__COUNT_ASC',
  QuoteDaysByPropertyIdCountDesc = 'QUOTE_DAYS_BY_PROPERTY_ID__COUNT_DESC',
  RegionAsc = 'REGION_ASC',
  RegionDesc = 'REGION_DESC',
  SummaryAsc = 'SUMMARY_ASC',
  SummaryDesc = 'SUMMARY_DESC',
  TimezoneAsc = 'TIMEZONE_ASC',
  TimezoneDesc = 'TIMEZONE_DESC',
  UrlAsc = 'URL_ASC',
  UrlDesc = 'URL_DESC'
}

export type Property = {
  __typename?: 'Property';
  alias?: Maybe<Scalars['String']['output']>;
  archived?: Maybe<Scalars['Datetime']['output']>;
  city?: Maybe<Scalars['String']['output']>;
  contactEmail?: Maybe<Scalars['String']['output']>;
  contactNumber?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Country` that is related to this `Property`. */
  country?: Maybe<Country>;
  countryId: Scalars['UUID']['output'];
  created: Scalars['Datetime']['output'];
  /** Reads a single `Destination` that is related to this `Property`. */
  destination?: Maybe<Destination>;
  destinationId?: Maybe<Scalars['UUID']['output']>;
  externalReference?: Maybe<Scalars['String']['output']>;
  featureCopy?: Maybe<Scalars['String']['output']>;
  featured?: Maybe<Scalars['Datetime']['output']>;
  /** Reads a single `MediaGallery` that is related to this `Property`. */
  gallery?: Maybe<MediaGallery>;
  galleryId?: Maybe<Scalars['UUID']['output']>;
  /** Reads a single `MediaItem` that is related to this `Property`. */
  heroMedia?: Maybe<MediaItem>;
  heroMediaId?: Maybe<Scalars['UUID']['output']>;
  id: Scalars['UUID']['output'];
  latitude?: Maybe<Scalars['Float']['output']>;
  longitude?: Maybe<Scalars['Float']['output']>;
  /** Reads a single `MapPoint` that is related to this `Property`. */
  mapPoint?: Maybe<MapPoint>;
  mapPointId?: Maybe<Scalars['UUID']['output']>;
  modified: Scalars['Datetime']['output'];
  name?: Maybe<Scalars['String']['output']>;
  nearestAirport?: Maybe<Scalars['String']['output']>;
  notes?: Maybe<Scalars['String']['output']>;
  plusCode?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `QuoteAccommodationDetail`. */
  quoteAccommodationDetails: QuoteAccommodationDetailsConnection;
  /** Reads and enables pagination through a set of `QuoteDay`. */
  quoteDays: QuoteDaysConnection;
  region?: Maybe<Scalars['String']['output']>;
  summary?: Maybe<Scalars['String']['output']>;
  timezone?: Maybe<Scalars['String']['output']>;
  url?: Maybe<Scalars['String']['output']>;
};


export type PropertyQuoteAccommodationDetailsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<QuoteAccommodationDetailCondition>;
  filter?: InputMaybe<QuoteAccommodationDetailFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuoteAccommodationDetailsOrderBy>>;
};


export type PropertyQuoteDaysArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<QuoteDayCondition>;
  filter?: InputMaybe<QuoteDayFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuoteDaysOrderBy>>;
};

/**
 * A condition to be used against `Property` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type PropertyCondition = {
  /** Checks for equality with the object’s `alias` field. */
  alias?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `archived` field. */
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `city` field. */
  city?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `contactEmail` field. */
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `contactNumber` field. */
  contactNumber?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `countryId` field. */
  countryId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `destinationId` field. */
  destinationId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `externalReference` field. */
  externalReference?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `featureCopy` field. */
  featureCopy?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `featured` field. */
  featured?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `galleryId` field. */
  galleryId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `heroMediaId` field. */
  heroMediaId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `latitude` field. */
  latitude?: InputMaybe<Scalars['Float']['input']>;
  /** Checks for equality with the object’s `longitude` field. */
  longitude?: InputMaybe<Scalars['Float']['input']>;
  /** Checks for equality with the object’s `mapPointId` field. */
  mapPointId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `nearestAirport` field. */
  nearestAirport?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `plusCode` field. */
  plusCode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `region` field. */
  region?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `summary` field. */
  summary?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `timezone` field. */
  timezone?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `url` field. */
  url?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `Property` object types. All fields are combined with a logical ‘and.’ */
export type PropertyFilter = {
  /** Filter by the object’s `alias` field. */
  alias?: InputMaybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<PropertyFilter>>;
  /** Filter by the object’s `archived` field. */
  archived?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `city` field. */
  city?: InputMaybe<StringFilter>;
  /** Filter by the object’s `contactEmail` field. */
  contactEmail?: InputMaybe<StringFilter>;
  /** Filter by the object’s `contactNumber` field. */
  contactNumber?: InputMaybe<StringFilter>;
  /** Filter by the object’s `country` relation. */
  country?: InputMaybe<CountryFilter>;
  /** Filter by the object’s `countryId` field. */
  countryId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `destination` relation. */
  destination?: InputMaybe<DestinationFilter>;
  /** A related `destination` exists. */
  destinationExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `destinationId` field. */
  destinationId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `externalReference` field. */
  externalReference?: InputMaybe<StringFilter>;
  /** Filter by the object’s `featureCopy` field. */
  featureCopy?: InputMaybe<StringFilter>;
  /** Filter by the object’s `featured` field. */
  featured?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `gallery` relation. */
  gallery?: InputMaybe<MediaGalleryFilter>;
  /** A related `gallery` exists. */
  galleryExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `galleryId` field. */
  galleryId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `heroMedia` relation. */
  heroMedia?: InputMaybe<MediaItemFilter>;
  /** A related `heroMedia` exists. */
  heroMediaExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `heroMediaId` field. */
  heroMediaId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `latitude` field. */
  latitude?: InputMaybe<FloatFilter>;
  /** Filter by the object’s `longitude` field. */
  longitude?: InputMaybe<FloatFilter>;
  /** Filter by the object’s `mapPoint` relation. */
  mapPoint?: InputMaybe<MapPointFilter>;
  /** A related `mapPoint` exists. */
  mapPointExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `mapPointId` field. */
  mapPointId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Filter by the object’s `nearestAirport` field. */
  nearestAirport?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<PropertyFilter>;
  /** Filter by the object’s `notes` field. */
  notes?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<PropertyFilter>>;
  /** Filter by the object’s `plusCode` field. */
  plusCode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `quoteAccommodationDetails` relation. */
  quoteAccommodationDetails?: InputMaybe<PropertyToManyQuoteAccommodationDetailFilter>;
  /** Some related `quoteAccommodationDetails` exist. */
  quoteAccommodationDetailsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `quoteDays` relation. */
  quoteDays?: InputMaybe<PropertyToManyQuoteDayFilter>;
  /** Some related `quoteDays` exist. */
  quoteDaysExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `region` field. */
  region?: InputMaybe<StringFilter>;
  /** Filter by the object’s `summary` field. */
  summary?: InputMaybe<StringFilter>;
  /** Filter by the object’s `timezone` field. */
  timezone?: InputMaybe<StringFilter>;
  /** Filter by the object’s `url` field. */
  url?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `Property` */
export type PropertyInput = {
  alias?: InputMaybe<Scalars['String']['input']>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  contactNumber?: InputMaybe<Scalars['String']['input']>;
  countryId?: InputMaybe<Scalars['UUID']['input']>;
  countryToCountryId?: InputMaybe<FkPropertyCountryCountryIdInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationId?: InputMaybe<Scalars['UUID']['input']>;
  destinationToDestinationId?: InputMaybe<FkPropertyDestinationInput>;
  externalReference?: InputMaybe<Scalars['String']['input']>;
  featureCopy?: InputMaybe<Scalars['String']['input']>;
  featured?: InputMaybe<Scalars['Datetime']['input']>;
  galleryId?: InputMaybe<Scalars['UUID']['input']>;
  heroMediaId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  latitude?: InputMaybe<Scalars['Float']['input']>;
  longitude?: InputMaybe<Scalars['Float']['input']>;
  mapPointId?: InputMaybe<Scalars['UUID']['input']>;
  mapPointToMapPointId?: InputMaybe<FkPropertyMapPointMapPointIdInput>;
  mediaGalleryToGalleryId?: InputMaybe<FkPropertyMediaGalleryGalleryIdInput>;
  mediaItemToHeroMediaId?: InputMaybe<FkPropertyMediaItemHeroMediaIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  nearestAirport?: InputMaybe<Scalars['String']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  plusCode?: InputMaybe<Scalars['String']['input']>;
  quoteAccommodationDetailsUsingId?: InputMaybe<FkQuoteAccommodationDetailPropertyPropertyIdInverseInput>;
  quoteDaysUsingId?: InputMaybe<QuoteDayPropertyIdFkeyInverseInput>;
  region?: InputMaybe<Scalars['String']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  timezone?: InputMaybe<Scalars['String']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
};

/** The fields on `property` to look up the row to update. */
export type PropertyOnPropertyForFkPropertyCountryCountryIdUsingPkPropertyUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `property` being updated. */
  patch: UpdatePropertyOnPropertyForFkPropertyCountryCountryIdPatch;
};

/** The fields on `property` to look up the row to update. */
export type PropertyOnPropertyForFkPropertyDestinationUsingPkPropertyUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `property` being updated. */
  patch: UpdatePropertyOnPropertyForFkPropertyDestinationPatch;
};

/** The fields on `property` to look up the row to update. */
export type PropertyOnPropertyForFkPropertyMapPointMapPointIdUsingPkPropertyUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `property` being updated. */
  patch: UpdatePropertyOnPropertyForFkPropertyMapPointMapPointIdPatch;
};

/** The fields on `property` to look up the row to update. */
export type PropertyOnPropertyForFkPropertyMediaGalleryGalleryIdUsingPkPropertyUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `property` being updated. */
  patch: UpdatePropertyOnPropertyForFkPropertyMediaGalleryGalleryIdPatch;
};

/** The fields on `property` to look up the row to update. */
export type PropertyOnPropertyForFkPropertyMediaItemHeroMediaIdUsingPkPropertyUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `property` being updated. */
  patch: UpdatePropertyOnPropertyForFkPropertyMediaItemHeroMediaIdPatch;
};

/** The fields on `property` to look up the row to update. */
export type PropertyOnQuoteAccommodationDetailForFkQuoteAccommodationDetailPropertyPropertyIdUsingPkPropertyUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `property` being updated. */
  patch: UpdatePropertyOnQuoteAccommodationDetailForFkQuoteAccommodationDetailPropertyPropertyIdPatch;
};

/** The fields on `property` to look up the row to update. */
export type PropertyOnQuoteDayForQuoteDayPropertyIdFkeyUsingPkPropertyUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `property` being updated. */
  patch: UpdatePropertyOnQuoteDayForQuoteDayPropertyIdFkeyPatch;
};

/** Represents an update to a `Property`. Fields that are set will be updated. */
export type PropertyPatch = {
  alias?: InputMaybe<Scalars['String']['input']>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  contactNumber?: InputMaybe<Scalars['String']['input']>;
  countryId?: InputMaybe<Scalars['UUID']['input']>;
  countryToCountryId?: InputMaybe<FkPropertyCountryCountryIdInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationId?: InputMaybe<Scalars['UUID']['input']>;
  destinationToDestinationId?: InputMaybe<FkPropertyDestinationInput>;
  externalReference?: InputMaybe<Scalars['String']['input']>;
  featureCopy?: InputMaybe<Scalars['String']['input']>;
  featured?: InputMaybe<Scalars['Datetime']['input']>;
  galleryId?: InputMaybe<Scalars['UUID']['input']>;
  heroMediaId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  latitude?: InputMaybe<Scalars['Float']['input']>;
  longitude?: InputMaybe<Scalars['Float']['input']>;
  mapPointId?: InputMaybe<Scalars['UUID']['input']>;
  mapPointToMapPointId?: InputMaybe<FkPropertyMapPointMapPointIdInput>;
  mediaGalleryToGalleryId?: InputMaybe<FkPropertyMediaGalleryGalleryIdInput>;
  mediaItemToHeroMediaId?: InputMaybe<FkPropertyMediaItemHeroMediaIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  nearestAirport?: InputMaybe<Scalars['String']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  plusCode?: InputMaybe<Scalars['String']['input']>;
  quoteAccommodationDetailsUsingId?: InputMaybe<FkQuoteAccommodationDetailPropertyPropertyIdInverseInput>;
  quoteDaysUsingId?: InputMaybe<QuoteDayPropertyIdFkeyInverseInput>;
  region?: InputMaybe<Scalars['String']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  timezone?: InputMaybe<Scalars['String']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
};

/** The fields on `property` to look up the row to connect. */
export type PropertyPkPropertyConnect = {
  id: Scalars['UUID']['input'];
};

/** The fields on `property` to look up the row to delete. */
export type PropertyPkPropertyDelete = {
  id: Scalars['UUID']['input'];
};

export type PropertySummaryInput = {
  country: Scalars['String']['input'];
  name: Scalars['String']['input'];
};

export type PropertySummaryOutput = {
  __typename?: 'PropertySummaryOutput';
  latitude: Scalars['Float']['output'];
  longitude: Scalars['Float']['output'];
  summary: Scalars['String']['output'];
};

/** A filter to be used against many `QuoteAccommodationDetail` object types. All fields are combined with a logical ‘and.’ */
export type PropertyToManyQuoteAccommodationDetailFilter = {
  /** Every related `QuoteAccommodationDetail` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<QuoteAccommodationDetailFilter>;
  /** No related `QuoteAccommodationDetail` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<QuoteAccommodationDetailFilter>;
  /** Some related `QuoteAccommodationDetail` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<QuoteAccommodationDetailFilter>;
};

/** A filter to be used against many `QuoteDay` object types. All fields are combined with a logical ‘and.’ */
export type PropertyToManyQuoteDayFilter = {
  /** Every related `QuoteDay` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<QuoteDayFilter>;
  /** No related `QuoteDay` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<QuoteDayFilter>;
  /** Some related `QuoteDay` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<QuoteDayFilter>;
};

/** The root query type which gives access points into the data universe. */
export type Query = {
  __typename?: 'Query';
  account?: Maybe<Account>;
  /** Reads and enables pagination through a set of `Account`. */
  accounts?: Maybe<AccountsConnection>;
  /** Reads and enables pagination through a set of `Agency`. */
  agencies?: Maybe<AgenciesConnection>;
  agency?: Maybe<Agency>;
  agencyMember?: Maybe<AgencyMember>;
  /** Reads and enables pagination through a set of `AgencyMember`. */
  agencyMembers?: Maybe<AgencyMembersConnection>;
  airport?: Maybe<Airport>;
  /** Reads and enables pagination through a set of `Airport`. */
  airports?: Maybe<AirportsConnection>;
  /** Reads and enables pagination through a set of `Country`. */
  countries?: Maybe<CountriesConnection>;
  country?: Maybe<Country>;
  currentUserRoles?: Maybe<Scalars['String']['output']>;
  currentUserSub?: Maybe<Scalars['String']['output']>;
  customer?: Maybe<Customer>;
  customerTraveller?: Maybe<CustomerTraveller>;
  /** Reads and enables pagination through a set of `CustomerTraveller`. */
  customerTravellers?: Maybe<CustomerTravellersConnection>;
  /** Reads and enables pagination through a set of `Customer`. */
  customers?: Maybe<CustomersConnection>;
  destination?: Maybe<Destination>;
  destinationByCountryIdAndAlias?: Maybe<Destination>;
  destinationFeature?: Maybe<DestinationFeature>;
  /** Reads and enables pagination through a set of `DestinationFeature`. */
  destinationFeatures?: Maybe<DestinationFeaturesConnection>;
  destinationGuide?: Maybe<DestinationGuide>;
  /** Reads and enables pagination through a set of `DestinationGuide`. */
  destinationGuides?: Maybe<DestinationGuidesConnection>;
  /** Reads and enables pagination through a set of `Destination`. */
  destinations?: Maybe<DestinationsConnection>;
  email?: Maybe<Email>;
  /** Reads and enables pagination through a set of `Email`. */
  emails?: Maybe<EmailsConnection>;
  /** Reads and enables pagination through a set of `Enquiry`. */
  enquiries?: Maybe<EnquiriesConnection>;
  enquiry?: Maybe<Enquiry>;
  expense?: Maybe<Expense>;
  /** Reads and enables pagination through a set of `Expense`. */
  expenses?: Maybe<ExpensesConnection>;
  feature?: Maybe<Feature>;
  featuredProperty?: Maybe<Property>;
  /** Reads and enables pagination through a set of `Feature`. */
  features?: Maybe<FeaturesConnection>;
  /** Reads and enables pagination through a set of `FinanceCategory`. */
  financeCategories?: Maybe<FinanceCategoriesConnection>;
  financeCategory?: Maybe<FinanceCategory>;
  gptItinerary?: Maybe<GptItineraryOutput>;
  invoice?: Maybe<Invoice>;
  invoicePublic?: Maybe<InvoicePublic>;
  /** Reads and enables pagination through a set of `InvoicePublic`. */
  invoicePublics?: Maybe<InvoicePublicsConnection>;
  /** Reads and enables pagination through a set of `InvoiceSummary`. */
  invoiceSummaries?: Maybe<InvoiceSummariesConnection>;
  /** Reads and enables pagination through a set of `Invoice`. */
  invoices?: Maybe<InvoicesConnection>;
  legalDocument?: Maybe<LegalDocument>;
  /** Reads and enables pagination through a set of `LegalDocument`. */
  legalDocuments?: Maybe<LegalDocumentsConnection>;
  legalFolder?: Maybe<LegalFolder>;
  /** Reads and enables pagination through a set of `LegalFolder`. */
  legalFolders?: Maybe<LegalFoldersConnection>;
  mapPoint?: Maybe<MapPoint>;
  /** Reads and enables pagination through a set of `MapPoint`. */
  mapPoints?: Maybe<MapPointsConnection>;
  /** Reads and enables pagination through a set of `MediaGallery`. */
  mediaGalleries?: Maybe<MediaGalleriesConnection>;
  mediaGallery?: Maybe<MediaGallery>;
  mediaGalleryItem?: Maybe<MediaGalleryItem>;
  /** Reads and enables pagination through a set of `MediaGalleryItem`. */
  mediaGalleryItems?: Maybe<MediaGalleryItemsConnection>;
  mediaItem?: Maybe<MediaItem>;
  /** Reads and enables pagination through a set of `MediaItem`. */
  mediaItems?: Maybe<MediaItemsConnection>;
  note?: Maybe<Note>;
  /** Reads and enables pagination through a set of `Note`. */
  notes?: Maybe<NotesConnection>;
  passport?: Maybe<Passport>;
  /** Reads and enables pagination through a set of `Passport`. */
  passports?: Maybe<PassportsConnection>;
  payment?: Maybe<Payment>;
  /** Reads and enables pagination through a set of `Payment`. */
  payments?: Maybe<PaymentsConnection>;
  /** Reads and enables pagination through a set of `Property`. */
  properties?: Maybe<PropertiesConnection>;
  property?: Maybe<Property>;
  propertySummary?: Maybe<PropertySummaryOutput>;
  /**
   * Exposes the root query type nested one level down. This is helpful for Relay 1
   * which can only query top level fields if they are in a particular form.
   */
  query: Query;
  quote?: Maybe<Quote>;
  quoteAcceptance?: Maybe<QuoteAcceptance>;
  /** Reads and enables pagination through a set of `QuoteAcceptance`. */
  quoteAcceptances?: Maybe<QuoteAcceptancesConnection>;
  quoteAccommodationDetail?: Maybe<QuoteAccommodationDetail>;
  /** Reads and enables pagination through a set of `QuoteAccommodationDetail`. */
  quoteAccommodationDetails?: Maybe<QuoteAccommodationDetailsConnection>;
  quoteByKey?: Maybe<Quote>;
  /** Reads and enables pagination through a set of `QuoteCurrency`. */
  quoteCurrencies?: Maybe<QuoteCurrenciesConnection>;
  quoteCurrency?: Maybe<QuoteCurrency>;
  quoteDay?: Maybe<QuoteDay>;
  quoteDayDestination?: Maybe<QuoteDayDestination>;
  /** Reads and enables pagination through a set of `QuoteDayDestination`. */
  quoteDayDestinations?: Maybe<QuoteDayDestinationsConnection>;
  /** Reads and enables pagination through a set of `QuoteDay`. */
  quoteDays?: Maybe<QuoteDaysConnection>;
  quoteFinanceLineItem?: Maybe<QuoteFinanceLineItem>;
  /** Reads and enables pagination through a set of `QuoteFinanceLineItemSummary`. */
  quoteFinanceLineItemSummaries?: Maybe<QuoteFinanceLineItemSummariesConnection>;
  /** Reads and enables pagination through a set of `QuoteFinanceLineItem`. */
  quoteFinanceLineItems?: Maybe<QuoteFinanceLineItemsConnection>;
  /** Reads and enables pagination through a set of `QuoteFinanceSummary`. */
  quoteFinanceSummaries?: Maybe<QuoteFinanceSummariesConnection>;
  quoteHero?: Maybe<QuoteHero>;
  /** Reads and enables pagination through a set of `QuoteHero`. */
  quoteHeroes?: Maybe<QuoteHeroesConnection>;
  quoteLegalDocument?: Maybe<QuoteLegalDocument>;
  /** Reads and enables pagination through a set of `QuoteLegalDocument`. */
  quoteLegalDocuments?: Maybe<QuoteLegalDocumentsConnection>;
  quotePublic?: Maybe<QuotePublic>;
  quoteStatus?: Maybe<QuoteStatus>;
  /** Reads and enables pagination through a set of `QuoteStatus`. */
  quoteStatuses?: Maybe<QuoteStatusesConnection>;
  /** Reads and enables pagination through a set of `QuoteTotalSummary`. */
  quoteTotalSummaries?: Maybe<QuoteTotalSummariesConnection>;
  quoteView?: Maybe<QuoteView>;
  /** Reads and enables pagination through a set of `QuoteView`. */
  quoteViews?: Maybe<QuoteViewsConnection>;
  /** Reads and enables pagination through a set of `Quote`. */
  quotes?: Maybe<QuotesConnection>;
  rates?: Maybe<Array<Maybe<RatesResponse>>>;
  reminder?: Maybe<Reminder>;
  /** Reads and enables pagination through a set of `Reminder`. */
  reminders?: Maybe<RemindersConnection>;
  supplier?: Maybe<Supplier>;
  supplierInvoice?: Maybe<SupplierInvoice>;
  /** Reads and enables pagination through a set of `SupplierInvoice`. */
  supplierInvoices?: Maybe<SupplierInvoicesConnection>;
  /** Reads and enables pagination through a set of `Supplier`. */
  suppliers?: Maybe<SuppliersConnection>;
  testimonial?: Maybe<Testimonial>;
  /** Reads and enables pagination through a set of `Testimonial`. */
  testimonials?: Maybe<TestimonialsConnection>;
  /** Reads and enables pagination through a set of `Timeline`. */
  timelines?: Maybe<TimelinesConnection>;
  timezone?: Maybe<Timezone>;
  /** Reads and enables pagination through a set of `Timezone`. */
  timezones?: Maybe<TimezonesConnection>;
  transaction?: Maybe<Transaction>;
  transactionImportBatch?: Maybe<TransactionImportBatch>;
  /** Reads and enables pagination through a set of `TransactionImportBatch`. */
  transactionImportBatches?: Maybe<TransactionImportBatchesConnection>;
  transactionLink?: Maybe<TransactionLink>;
  /** Reads and enables pagination through a set of `TransactionLink`. */
  transactionLinks?: Maybe<TransactionLinksConnection>;
  transactionNote?: Maybe<TransactionNote>;
  /** Reads and enables pagination through a set of `TransactionNote`. */
  transactionNotes?: Maybe<TransactionNotesConnection>;
  /** Reads and enables pagination through a set of `Transaction`. */
  transactions?: Maybe<TransactionsConnection>;
  traveller?: Maybe<Traveller>;
  /** Reads and enables pagination through a set of `Traveller`. */
  travellers?: Maybe<TravellersConnection>;
  trip?: Maybe<Trip>;
  tripFlight?: Maybe<TripFlight>;
  /** Reads and enables pagination through a set of `TripFlight`. */
  tripFlights?: Maybe<TripFlightsConnection>;
  tripTraveller?: Maybe<TripTraveller>;
  /** Reads and enables pagination through a set of `TripTraveller`. */
  tripTravellers?: Maybe<TripTravellersConnection>;
  /** Reads and enables pagination through a set of `Trip`. */
  trips?: Maybe<TripsConnection>;
  user?: Maybe<User>;
  userCan?: Maybe<Scalars['Boolean']['output']>;
  /** Reads and enables pagination through a set of `User`. */
  users?: Maybe<UsersConnection>;
  visaRequirement?: Maybe<VisaRequirement>;
  /** Reads and enables pagination through a set of `VisaRequirement`. */
  visaRequirements?: Maybe<VisaRequirementsConnection>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAccountArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAccountsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AccountCondition>;
  filter?: InputMaybe<AccountFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AccountsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAgenciesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AgencyCondition>;
  filter?: InputMaybe<AgencyFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AgenciesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAgencyArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAgencyMemberArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAgencyMembersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AgencyMemberCondition>;
  filter?: InputMaybe<AgencyMemberFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AgencyMembersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAirportArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAirportsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AirportCondition>;
  filter?: InputMaybe<AirportFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AirportsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCountriesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CountryCondition>;
  filter?: InputMaybe<CountryFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CountriesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCountryArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCustomerArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCustomerTravellerArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCustomerTravellersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CustomerTravellerCondition>;
  filter?: InputMaybe<CustomerTravellerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CustomerTravellersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCustomersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CustomerCondition>;
  filter?: InputMaybe<CustomerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CustomersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDestinationArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDestinationByCountryIdAndAliasArgs = {
  alias: Scalars['String']['input'];
  countryId: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDestinationFeatureArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDestinationFeaturesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DestinationFeatureCondition>;
  filter?: InputMaybe<DestinationFeatureFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DestinationFeaturesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDestinationGuideArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDestinationGuidesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DestinationGuideCondition>;
  filter?: InputMaybe<DestinationGuideFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DestinationGuidesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDestinationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DestinationCondition>;
  filter?: InputMaybe<DestinationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DestinationsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryEmailArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEmailsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EmailCondition>;
  filter?: InputMaybe<EmailFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EmailsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryEnquiriesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EnquiryCondition>;
  filter?: InputMaybe<EnquiryFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EnquiriesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryEnquiryArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryExpenseArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryExpensesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ExpenseCondition>;
  filter?: InputMaybe<ExpenseFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ExpensesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryFeatureArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFeaturesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FeatureCondition>;
  filter?: InputMaybe<FeatureFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FeaturesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryFinanceCategoriesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FinanceCategoryCondition>;
  filter?: InputMaybe<FinanceCategoryFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FinanceCategoriesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryFinanceCategoryArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGptItineraryArgs = {
  input: GptItineraryInput;
};


/** The root query type which gives access points into the data universe. */
export type QueryInvoiceArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryInvoicePublicArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryInvoicePublicsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<InvoicePublicCondition>;
  filter?: InputMaybe<InvoicePublicFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<InvoicePublicsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryInvoiceSummariesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<InvoiceSummaryCondition>;
  filter?: InputMaybe<InvoiceSummaryFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<InvoiceSummariesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryInvoicesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<InvoiceCondition>;
  filter?: InputMaybe<InvoiceFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<InvoicesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryLegalDocumentArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLegalDocumentsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<LegalDocumentCondition>;
  filter?: InputMaybe<LegalDocumentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LegalDocumentsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryLegalFolderArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLegalFoldersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<LegalFolderCondition>;
  filter?: InputMaybe<LegalFolderFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LegalFoldersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryMapPointArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMapPointsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<MapPointCondition>;
  filter?: InputMaybe<MapPointFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MapPointsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryMediaGalleriesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<MediaGalleryCondition>;
  filter?: InputMaybe<MediaGalleryFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MediaGalleriesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryMediaGalleryArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMediaGalleryItemArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMediaGalleryItemsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<MediaGalleryItemCondition>;
  filter?: InputMaybe<MediaGalleryItemFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MediaGalleryItemsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryMediaItemArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMediaItemsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<MediaItemCondition>;
  filter?: InputMaybe<MediaItemFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MediaItemsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryNoteArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryNotesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<NoteCondition>;
  filter?: InputMaybe<NoteFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<NotesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPassportArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPassportsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PassportCondition>;
  filter?: InputMaybe<PassportFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PassportsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPaymentArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPaymentsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PaymentCondition>;
  filter?: InputMaybe<PaymentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PaymentsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPropertiesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PropertyCondition>;
  filter?: InputMaybe<PropertyFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PropertiesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPropertyArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPropertySummaryArgs = {
  input: PropertySummaryInput;
};


/** The root query type which gives access points into the data universe. */
export type QueryQuoteArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryQuoteAcceptanceArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryQuoteAcceptancesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<QuoteAcceptanceCondition>;
  filter?: InputMaybe<QuoteAcceptanceFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuoteAcceptancesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryQuoteAccommodationDetailArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryQuoteAccommodationDetailsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<QuoteAccommodationDetailCondition>;
  filter?: InputMaybe<QuoteAccommodationDetailFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuoteAccommodationDetailsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryQuoteByKeyArgs = {
  key: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryQuoteCurrenciesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<QuoteCurrencyCondition>;
  filter?: InputMaybe<QuoteCurrencyFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuoteCurrenciesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryQuoteCurrencyArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryQuoteDayArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryQuoteDayDestinationArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryQuoteDayDestinationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<QuoteDayDestinationCondition>;
  filter?: InputMaybe<QuoteDayDestinationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuoteDayDestinationsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryQuoteDaysArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<QuoteDayCondition>;
  filter?: InputMaybe<QuoteDayFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuoteDaysOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryQuoteFinanceLineItemArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryQuoteFinanceLineItemSummariesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<QuoteFinanceLineItemSummaryCondition>;
  filter?: InputMaybe<QuoteFinanceLineItemSummaryFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuoteFinanceLineItemSummariesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryQuoteFinanceLineItemsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<QuoteFinanceLineItemCondition>;
  filter?: InputMaybe<QuoteFinanceLineItemFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuoteFinanceLineItemsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryQuoteFinanceSummariesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<QuoteFinanceSummaryCondition>;
  filter?: InputMaybe<QuoteFinanceSummaryFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuoteFinanceSummariesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryQuoteHeroArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryQuoteHeroesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<QuoteHeroCondition>;
  filter?: InputMaybe<QuoteHeroFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuoteHeroesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryQuoteLegalDocumentArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryQuoteLegalDocumentsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<QuoteLegalDocumentCondition>;
  filter?: InputMaybe<QuoteLegalDocumentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuoteLegalDocumentsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryQuotePublicArgs = {
  key: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryQuoteStatusArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryQuoteStatusesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<QuoteStatusCondition>;
  filter?: InputMaybe<QuoteStatusFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuoteStatusesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryQuoteTotalSummariesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<QuoteTotalSummaryCondition>;
  filter?: InputMaybe<QuoteTotalSummaryFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuoteTotalSummariesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryQuoteViewArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryQuoteViewsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<QuoteViewCondition>;
  filter?: InputMaybe<QuoteViewFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuoteViewsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryQuotesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<QuoteCondition>;
  filter?: InputMaybe<QuoteFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuotesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryReminderArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryRemindersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ReminderCondition>;
  filter?: InputMaybe<ReminderFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RemindersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QuerySupplierArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySupplierInvoiceArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySupplierInvoicesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SupplierInvoiceCondition>;
  filter?: InputMaybe<SupplierInvoiceFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SupplierInvoicesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QuerySuppliersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SupplierCondition>;
  filter?: InputMaybe<SupplierFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SuppliersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTestimonialArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTestimonialsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TestimonialCondition>;
  filter?: InputMaybe<TestimonialFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TestimonialsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTimelinesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TimelineCondition>;
  filter?: InputMaybe<TimelineFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TimelinesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTimezoneArgs = {
  ogcFid: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTimezonesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TimezoneCondition>;
  filter?: InputMaybe<TimezoneFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TimezonesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTransactionArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTransactionImportBatchArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTransactionImportBatchesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TransactionImportBatchCondition>;
  filter?: InputMaybe<TransactionImportBatchFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TransactionImportBatchesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTransactionLinkArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTransactionLinksArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TransactionLinkCondition>;
  filter?: InputMaybe<TransactionLinkFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TransactionLinksOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTransactionNoteArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTransactionNotesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TransactionNoteCondition>;
  filter?: InputMaybe<TransactionNoteFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TransactionNotesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTransactionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TransactionCondition>;
  filter?: InputMaybe<TransactionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TransactionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTravellerArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTravellersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TravellerCondition>;
  filter?: InputMaybe<TravellerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TravellersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTripArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTripFlightArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTripFlightsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TripFlightCondition>;
  filter?: InputMaybe<TripFlightFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TripFlightsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTripTravellerArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTripTravellersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TripTravellerCondition>;
  filter?: InputMaybe<TripTravellerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TripTravellersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTripsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TripCondition>;
  filter?: InputMaybe<TripFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TripsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryUserArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserCanArgs = {
  task?: InputMaybe<Scalars['String']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserCondition>;
  filter?: InputMaybe<UserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryVisaRequirementArgs = {
  id: Scalars['UUID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVisaRequirementsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<VisaRequirementCondition>;
  filter?: InputMaybe<VisaRequirementFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<VisaRequirementsOrderBy>>;
};

export type Quote = {
  __typename?: 'Quote';
  adjustment: Scalars['BigFloat']['output'];
  agentMargin: Scalars['BigFloat']['output'];
  archived?: Maybe<Scalars['Datetime']['output']>;
  baseCurrency?: Maybe<Scalars['String']['output']>;
  created: Scalars['Datetime']['output'];
  deposit: Scalars['BigFloat']['output'];
  duration: Scalars['Int']['output'];
  /** Reads and enables pagination through a set of `Email`. */
  emails: EmailsConnection;
  exclusions?: Maybe<Scalars['String']['output']>;
  expires: Scalars['Datetime']['output'];
  /** Reads a single `QuoteHero` that is related to this `Quote`. */
  hero?: Maybe<QuoteHero>;
  heroId?: Maybe<Scalars['UUID']['output']>;
  /** Reads a single `MediaItem` that is related to this `Quote`. */
  heroImage?: Maybe<MediaItem>;
  heroImageId?: Maybe<Scalars['UUID']['output']>;
  id: Scalars['UUID']['output'];
  inclusions?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `Invoice`. */
  invoices: InvoicesConnection;
  key?: Maybe<Scalars['String']['output']>;
  lastViewed?: Maybe<Scalars['Datetime']['output']>;
  locked?: Maybe<Scalars['Datetime']['output']>;
  margin: Scalars['BigFloat']['output'];
  modified: Scalars['Datetime']['output'];
  /** Reads and enables pagination through a set of `QuoteAcceptance`. */
  quoteAcceptances: QuoteAcceptancesConnection;
  /** Reads and enables pagination through a set of `QuoteAccommodationDetail`. */
  quoteAccommodationDetails: QuoteAccommodationDetailsConnection;
  /** Reads and enables pagination through a set of `QuoteCurrency`. */
  quoteCurrencies: QuoteCurrenciesConnection;
  /** Reads and enables pagination through a set of `QuoteDay`. */
  quoteDays: QuoteDaysConnection;
  /** Reads and enables pagination through a set of `QuoteFinanceLineItem`. */
  quoteFinanceLineItems: QuoteFinanceLineItemsConnection;
  /** Reads and enables pagination through a set of `QuoteLegalDocument`. */
  quoteLegalDocuments: QuoteLegalDocumentsConnection;
  /** Reads a single `QuoteStatus` that is related to this `Quote`. */
  quoteStatusByStatus?: Maybe<QuoteStatus>;
  /** Reads and enables pagination through a set of `QuoteView`. */
  quoteViews: QuoteViewsConnection;
  shortDescription?: Maybe<Scalars['String']['output']>;
  start?: Maybe<Scalars['Datetime']['output']>;
  status: Scalars['Int']['output'];
  summary?: Maybe<Scalars['String']['output']>;
  total?: Maybe<Scalars['BigFloat']['output']>;
  travellerCount: Scalars['Int']['output'];
  /** Reads a single `Trip` that is related to this `Quote`. */
  trip?: Maybe<Trip>;
  tripId: Scalars['UUID']['output'];
  /** Reads and enables pagination through a set of `Trip`. */
  tripsByActiveQuoteId: TripsConnection;
  /** Reads a single `User` that is related to this `Quote`. */
  user?: Maybe<User>;
  userId?: Maybe<Scalars['UUID']['output']>;
};


export type QuoteEmailsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EmailCondition>;
  filter?: InputMaybe<EmailFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EmailsOrderBy>>;
};


export type QuoteInvoicesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<InvoiceCondition>;
  filter?: InputMaybe<InvoiceFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<InvoicesOrderBy>>;
};


export type QuoteQuoteAcceptancesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<QuoteAcceptanceCondition>;
  filter?: InputMaybe<QuoteAcceptanceFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuoteAcceptancesOrderBy>>;
};


export type QuoteQuoteAccommodationDetailsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<QuoteAccommodationDetailCondition>;
  filter?: InputMaybe<QuoteAccommodationDetailFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuoteAccommodationDetailsOrderBy>>;
};


export type QuoteQuoteCurrenciesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<QuoteCurrencyCondition>;
  filter?: InputMaybe<QuoteCurrencyFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuoteCurrenciesOrderBy>>;
};


export type QuoteQuoteDaysArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<QuoteDayCondition>;
  filter?: InputMaybe<QuoteDayFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuoteDaysOrderBy>>;
};


export type QuoteQuoteFinanceLineItemsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<QuoteFinanceLineItemCondition>;
  filter?: InputMaybe<QuoteFinanceLineItemFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuoteFinanceLineItemsOrderBy>>;
};


export type QuoteQuoteLegalDocumentsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<QuoteLegalDocumentCondition>;
  filter?: InputMaybe<QuoteLegalDocumentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuoteLegalDocumentsOrderBy>>;
};


export type QuoteQuoteViewsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<QuoteViewCondition>;
  filter?: InputMaybe<QuoteViewFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuoteViewsOrderBy>>;
};


export type QuoteTripsByActiveQuoteIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TripCondition>;
  filter?: InputMaybe<TripFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TripsOrderBy>>;
};

export type QuoteAcceptance = {
  __typename?: 'QuoteAcceptance';
  accepted: Scalars['Datetime']['output'];
  created: Scalars['Datetime']['output'];
  email: Scalars['String']['output'];
  id: Scalars['UUID']['output'];
  modified: Scalars['Datetime']['output'];
  name: Scalars['String']['output'];
  /** Reads a single `Quote` that is related to this `QuoteAcceptance`. */
  quote?: Maybe<Quote>;
  quoteId: Scalars['UUID']['output'];
  voided?: Maybe<Scalars['Datetime']['output']>;
};

/**
 * A condition to be used against `QuoteAcceptance` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type QuoteAcceptanceCondition = {
  /** Checks for equality with the object’s `accepted` field. */
  accepted?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `email` field. */
  email?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `quoteId` field. */
  quoteId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `voided` field. */
  voided?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A filter to be used against `QuoteAcceptance` object types. All fields are combined with a logical ‘and.’ */
export type QuoteAcceptanceFilter = {
  /** Filter by the object’s `accepted` field. */
  accepted?: InputMaybe<DatetimeFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<QuoteAcceptanceFilter>>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `email` field. */
  email?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<QuoteAcceptanceFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<QuoteAcceptanceFilter>>;
  /** Filter by the object’s `quote` relation. */
  quote?: InputMaybe<QuoteFilter>;
  /** Filter by the object’s `quoteId` field. */
  quoteId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `voided` field. */
  voided?: InputMaybe<DatetimeFilter>;
};

/** An input for mutations affecting `QuoteAcceptance` */
export type QuoteAcceptanceInput = {
  accepted: Scalars['Datetime']['input'];
  created?: InputMaybe<Scalars['Datetime']['input']>;
  email: Scalars['String']['input'];
  id?: InputMaybe<Scalars['UUID']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name: Scalars['String']['input'];
  quoteId?: InputMaybe<Scalars['UUID']['input']>;
  quoteToQuoteId?: InputMaybe<FkQuoteAcceptanceQuoteInput>;
  voided?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The fields on `quoteAcceptance` to look up the row to update. */
export type QuoteAcceptanceOnQuoteAcceptanceForFkQuoteAcceptanceQuoteUsingPkQuoteAcceptanceUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `quoteAcceptance` being updated. */
  patch: UpdateQuoteAcceptanceOnQuoteAcceptanceForFkQuoteAcceptanceQuotePatch;
};

/** Represents an update to a `QuoteAcceptance`. Fields that are set will be updated. */
export type QuoteAcceptancePatch = {
  accepted?: InputMaybe<Scalars['Datetime']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  quoteId?: InputMaybe<Scalars['UUID']['input']>;
  quoteToQuoteId?: InputMaybe<FkQuoteAcceptanceQuoteInput>;
  voided?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The fields on `quoteAcceptance` to look up the row to connect. */
export type QuoteAcceptancePkQuoteAcceptanceConnect = {
  id: Scalars['UUID']['input'];
};

/** The fields on `quoteAcceptance` to look up the row to delete. */
export type QuoteAcceptancePkQuoteAcceptanceDelete = {
  id: Scalars['UUID']['input'];
};

/** A connection to a list of `QuoteAcceptance` values. */
export type QuoteAcceptancesConnection = {
  __typename?: 'QuoteAcceptancesConnection';
  /** A list of edges which contains the `QuoteAcceptance` and cursor to aid in pagination. */
  edges: Array<QuoteAcceptancesEdge>;
  /** A list of `QuoteAcceptance` objects. */
  nodes: Array<Maybe<QuoteAcceptance>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `QuoteAcceptance` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `QuoteAcceptance` edge in the connection. */
export type QuoteAcceptancesEdge = {
  __typename?: 'QuoteAcceptancesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `QuoteAcceptance` at the end of the edge. */
  node?: Maybe<QuoteAcceptance>;
};

/** Methods to use when ordering `QuoteAcceptance`. */
export enum QuoteAcceptancesOrderBy {
  AcceptedAsc = 'ACCEPTED_ASC',
  AcceptedDesc = 'ACCEPTED_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  EmailAsc = 'EMAIL_ASC',
  EmailDesc = 'EMAIL_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QuoteByQuoteIdAdjustmentAsc = 'QUOTE_BY_QUOTE_ID__ADJUSTMENT_ASC',
  QuoteByQuoteIdAdjustmentDesc = 'QUOTE_BY_QUOTE_ID__ADJUSTMENT_DESC',
  QuoteByQuoteIdAgentMarginAsc = 'QUOTE_BY_QUOTE_ID__AGENT_MARGIN_ASC',
  QuoteByQuoteIdAgentMarginDesc = 'QUOTE_BY_QUOTE_ID__AGENT_MARGIN_DESC',
  QuoteByQuoteIdArchivedAsc = 'QUOTE_BY_QUOTE_ID__ARCHIVED_ASC',
  QuoteByQuoteIdArchivedDesc = 'QUOTE_BY_QUOTE_ID__ARCHIVED_DESC',
  QuoteByQuoteIdBaseCurrencyAsc = 'QUOTE_BY_QUOTE_ID__BASE_CURRENCY_ASC',
  QuoteByQuoteIdBaseCurrencyDesc = 'QUOTE_BY_QUOTE_ID__BASE_CURRENCY_DESC',
  QuoteByQuoteIdCreatedAsc = 'QUOTE_BY_QUOTE_ID__CREATED_ASC',
  QuoteByQuoteIdCreatedDesc = 'QUOTE_BY_QUOTE_ID__CREATED_DESC',
  QuoteByQuoteIdDepositAsc = 'QUOTE_BY_QUOTE_ID__DEPOSIT_ASC',
  QuoteByQuoteIdDepositDesc = 'QUOTE_BY_QUOTE_ID__DEPOSIT_DESC',
  QuoteByQuoteIdDurationAsc = 'QUOTE_BY_QUOTE_ID__DURATION_ASC',
  QuoteByQuoteIdDurationDesc = 'QUOTE_BY_QUOTE_ID__DURATION_DESC',
  QuoteByQuoteIdExclusionsAsc = 'QUOTE_BY_QUOTE_ID__EXCLUSIONS_ASC',
  QuoteByQuoteIdExclusionsDesc = 'QUOTE_BY_QUOTE_ID__EXCLUSIONS_DESC',
  QuoteByQuoteIdExpiresAsc = 'QUOTE_BY_QUOTE_ID__EXPIRES_ASC',
  QuoteByQuoteIdExpiresDesc = 'QUOTE_BY_QUOTE_ID__EXPIRES_DESC',
  QuoteByQuoteIdHeroIdAsc = 'QUOTE_BY_QUOTE_ID__HERO_ID_ASC',
  QuoteByQuoteIdHeroIdDesc = 'QUOTE_BY_QUOTE_ID__HERO_ID_DESC',
  QuoteByQuoteIdHeroImageIdAsc = 'QUOTE_BY_QUOTE_ID__HERO_IMAGE_ID_ASC',
  QuoteByQuoteIdHeroImageIdDesc = 'QUOTE_BY_QUOTE_ID__HERO_IMAGE_ID_DESC',
  QuoteByQuoteIdIdAsc = 'QUOTE_BY_QUOTE_ID__ID_ASC',
  QuoteByQuoteIdIdDesc = 'QUOTE_BY_QUOTE_ID__ID_DESC',
  QuoteByQuoteIdInclusionsAsc = 'QUOTE_BY_QUOTE_ID__INCLUSIONS_ASC',
  QuoteByQuoteIdInclusionsDesc = 'QUOTE_BY_QUOTE_ID__INCLUSIONS_DESC',
  QuoteByQuoteIdKeyAsc = 'QUOTE_BY_QUOTE_ID__KEY_ASC',
  QuoteByQuoteIdKeyDesc = 'QUOTE_BY_QUOTE_ID__KEY_DESC',
  QuoteByQuoteIdLockedAsc = 'QUOTE_BY_QUOTE_ID__LOCKED_ASC',
  QuoteByQuoteIdLockedDesc = 'QUOTE_BY_QUOTE_ID__LOCKED_DESC',
  QuoteByQuoteIdMarginAsc = 'QUOTE_BY_QUOTE_ID__MARGIN_ASC',
  QuoteByQuoteIdMarginDesc = 'QUOTE_BY_QUOTE_ID__MARGIN_DESC',
  QuoteByQuoteIdModifiedAsc = 'QUOTE_BY_QUOTE_ID__MODIFIED_ASC',
  QuoteByQuoteIdModifiedDesc = 'QUOTE_BY_QUOTE_ID__MODIFIED_DESC',
  QuoteByQuoteIdShortDescriptionAsc = 'QUOTE_BY_QUOTE_ID__SHORT_DESCRIPTION_ASC',
  QuoteByQuoteIdShortDescriptionDesc = 'QUOTE_BY_QUOTE_ID__SHORT_DESCRIPTION_DESC',
  QuoteByQuoteIdStartAsc = 'QUOTE_BY_QUOTE_ID__START_ASC',
  QuoteByQuoteIdStartDesc = 'QUOTE_BY_QUOTE_ID__START_DESC',
  QuoteByQuoteIdStatusAsc = 'QUOTE_BY_QUOTE_ID__STATUS_ASC',
  QuoteByQuoteIdStatusDesc = 'QUOTE_BY_QUOTE_ID__STATUS_DESC',
  QuoteByQuoteIdSummaryAsc = 'QUOTE_BY_QUOTE_ID__SUMMARY_ASC',
  QuoteByQuoteIdSummaryDesc = 'QUOTE_BY_QUOTE_ID__SUMMARY_DESC',
  QuoteByQuoteIdTravellerCountAsc = 'QUOTE_BY_QUOTE_ID__TRAVELLER_COUNT_ASC',
  QuoteByQuoteIdTravellerCountDesc = 'QUOTE_BY_QUOTE_ID__TRAVELLER_COUNT_DESC',
  QuoteByQuoteIdTripIdAsc = 'QUOTE_BY_QUOTE_ID__TRIP_ID_ASC',
  QuoteByQuoteIdTripIdDesc = 'QUOTE_BY_QUOTE_ID__TRIP_ID_DESC',
  QuoteByQuoteIdUserIdAsc = 'QUOTE_BY_QUOTE_ID__USER_ID_ASC',
  QuoteByQuoteIdUserIdDesc = 'QUOTE_BY_QUOTE_ID__USER_ID_DESC',
  QuoteIdAsc = 'QUOTE_ID_ASC',
  QuoteIdDesc = 'QUOTE_ID_DESC',
  VoidedAsc = 'VOIDED_ASC',
  VoidedDesc = 'VOIDED_DESC'
}

export type QuoteAccommodationDetail = {
  __typename?: 'QuoteAccommodationDetail';
  basis?: Maybe<Scalars['String']['output']>;
  beverageInclusions?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  confirmation?: Maybe<Scalars['String']['output']>;
  foodInclusions?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  id: Scalars['UUID']['output'];
  nights: Scalars['Int']['output'];
  notes?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Property` that is related to this `QuoteAccommodationDetail`. */
  property?: Maybe<Property>;
  propertyId?: Maybe<Scalars['UUID']['output']>;
  /** Reads a single `Quote` that is related to this `QuoteAccommodationDetail`. */
  quote?: Maybe<Quote>;
  /** Reads and enables pagination through a set of `QuoteDay`. */
  quoteDaysByAccommodationId: QuoteDaysConnection;
  quoteId?: Maybe<Scalars['UUID']['output']>;
  /** Reads a single `QuotePublic` that is related to this `QuoteAccommodationDetail`. */
  quotePublic?: Maybe<QuotePublic>;
  roomType?: Maybe<Scalars['String']['output']>;
  sortOrder: Scalars['Int']['output'];
  summary?: Maybe<Scalars['String']['output']>;
};


export type QuoteAccommodationDetailQuoteDaysByAccommodationIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<QuoteDayCondition>;
  filter?: InputMaybe<QuoteDayFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuoteDaysOrderBy>>;
};

/**
 * A condition to be used against `QuoteAccommodationDetail` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type QuoteAccommodationDetailCondition = {
  /** Checks for equality with the object’s `basis` field. */
  basis?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `beverageInclusions` field. */
  beverageInclusions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Checks for equality with the object’s `confirmation` field. */
  confirmation?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `foodInclusions` field. */
  foodInclusions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `nights` field. */
  nights?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `propertyId` field. */
  propertyId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `quoteId` field. */
  quoteId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `roomType` field. */
  roomType?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sortOrder` field. */
  sortOrder?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `summary` field. */
  summary?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `QuoteAccommodationDetail` object types. All fields are combined with a logical ‘and.’ */
export type QuoteAccommodationDetailFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<QuoteAccommodationDetailFilter>>;
  /** Filter by the object’s `basis` field. */
  basis?: InputMaybe<StringFilter>;
  /** Filter by the object’s `beverageInclusions` field. */
  beverageInclusions?: InputMaybe<StringListFilter>;
  /** Filter by the object’s `confirmation` field. */
  confirmation?: InputMaybe<StringFilter>;
  /** Filter by the object’s `foodInclusions` field. */
  foodInclusions?: InputMaybe<StringListFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `nights` field. */
  nights?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<QuoteAccommodationDetailFilter>;
  /** Filter by the object’s `notes` field. */
  notes?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<QuoteAccommodationDetailFilter>>;
  /** Filter by the object’s `property` relation. */
  property?: InputMaybe<PropertyFilter>;
  /** A related `property` exists. */
  propertyExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `propertyId` field. */
  propertyId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `quote` relation. */
  quote?: InputMaybe<QuoteFilter>;
  /** Filter by the object’s `quoteDaysByAccommodationId` relation. */
  quoteDaysByAccommodationId?: InputMaybe<QuoteAccommodationDetailToManyQuoteDayFilter>;
  /** Some related `quoteDaysByAccommodationId` exist. */
  quoteDaysByAccommodationIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** A related `quote` exists. */
  quoteExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `quoteId` field. */
  quoteId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `quotePublic` relation. */
  quotePublic?: InputMaybe<QuotePublicFilter>;
  /** A related `quotePublic` exists. */
  quotePublicExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `roomType` field. */
  roomType?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sortOrder` field. */
  sortOrder?: InputMaybe<IntFilter>;
  /** Filter by the object’s `summary` field. */
  summary?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `QuoteAccommodationDetail` */
export type QuoteAccommodationDetailInput = {
  basis?: InputMaybe<Scalars['String']['input']>;
  beverageInclusions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  confirmation?: InputMaybe<Scalars['String']['input']>;
  foodInclusions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  nights: Scalars['Int']['input'];
  notes?: InputMaybe<Scalars['String']['input']>;
  propertyId?: InputMaybe<Scalars['UUID']['input']>;
  propertyToPropertyId?: InputMaybe<FkQuoteAccommodationDetailPropertyPropertyIdInput>;
  quoteDaysUsingId?: InputMaybe<FkQuoteDayQuoteAccommodationDetailAccommodationIdInverseInput>;
  quoteId?: InputMaybe<Scalars['UUID']['input']>;
  quotePublic?: InputMaybe<FakePublicQuoteAccommodationDetailForeignKey0Input>;
  quoteToQuoteId?: InputMaybe<FkQuoteAccommodationDetailQuoteQuoteIdInput>;
  roomType?: InputMaybe<Scalars['String']['input']>;
  sortOrder: Scalars['Int']['input'];
  summary?: InputMaybe<Scalars['String']['input']>;
};

/** The fields on `quoteAccommodationDetail` to look up the row to update. */
export type QuoteAccommodationDetailOnQuoteAccommodationDetailForFakePublicQuoteAccommodationDetailForeignKey0UsingPkQuoteAccommodationDetailUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `quoteAccommodationDetail` being updated. */
  patch: UpdateQuoteAccommodationDetailOnQuoteAccommodationDetailForFakePublicQuoteAccommodationDetailForeignKey0Patch;
};

/** The fields on `quoteAccommodationDetail` to look up the row to update. */
export type QuoteAccommodationDetailOnQuoteAccommodationDetailForFkQuoteAccommodationDetailPropertyPropertyIdUsingPkQuoteAccommodationDetailUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `quoteAccommodationDetail` being updated. */
  patch: UpdateQuoteAccommodationDetailOnQuoteAccommodationDetailForFkQuoteAccommodationDetailPropertyPropertyIdPatch;
};

/** The fields on `quoteAccommodationDetail` to look up the row to update. */
export type QuoteAccommodationDetailOnQuoteAccommodationDetailForFkQuoteAccommodationDetailQuoteQuoteIdUsingPkQuoteAccommodationDetailUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `quoteAccommodationDetail` being updated. */
  patch: UpdateQuoteAccommodationDetailOnQuoteAccommodationDetailForFkQuoteAccommodationDetailQuoteQuoteIdPatch;
};

/** The fields on `quoteAccommodationDetail` to look up the row to update. */
export type QuoteAccommodationDetailOnQuoteDayForFkQuoteDayQuoteAccommodationDetailAccommodationIdUsingPkQuoteAccommodationDetailUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `quoteAccommodationDetail` being updated. */
  patch: UpdateQuoteAccommodationDetailOnQuoteDayForFkQuoteDayQuoteAccommodationDetailAccommodationIdPatch;
};

/** Represents an update to a `QuoteAccommodationDetail`. Fields that are set will be updated. */
export type QuoteAccommodationDetailPatch = {
  basis?: InputMaybe<Scalars['String']['input']>;
  beverageInclusions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  confirmation?: InputMaybe<Scalars['String']['input']>;
  foodInclusions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  nights?: InputMaybe<Scalars['Int']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  propertyId?: InputMaybe<Scalars['UUID']['input']>;
  propertyToPropertyId?: InputMaybe<FkQuoteAccommodationDetailPropertyPropertyIdInput>;
  quoteDaysUsingId?: InputMaybe<FkQuoteDayQuoteAccommodationDetailAccommodationIdInverseInput>;
  quoteId?: InputMaybe<Scalars['UUID']['input']>;
  quotePublic?: InputMaybe<FakePublicQuoteAccommodationDetailForeignKey0Input>;
  quoteToQuoteId?: InputMaybe<FkQuoteAccommodationDetailQuoteQuoteIdInput>;
  roomType?: InputMaybe<Scalars['String']['input']>;
  sortOrder?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
};

/** The fields on `quoteAccommodationDetail` to look up the row to connect. */
export type QuoteAccommodationDetailPkQuoteAccommodationDetailConnect = {
  id: Scalars['UUID']['input'];
};

/** The fields on `quoteAccommodationDetail` to look up the row to delete. */
export type QuoteAccommodationDetailPkQuoteAccommodationDetailDelete = {
  id: Scalars['UUID']['input'];
};

/** A filter to be used against many `QuoteDay` object types. All fields are combined with a logical ‘and.’ */
export type QuoteAccommodationDetailToManyQuoteDayFilter = {
  /** Every related `QuoteDay` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<QuoteDayFilter>;
  /** No related `QuoteDay` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<QuoteDayFilter>;
  /** Some related `QuoteDay` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<QuoteDayFilter>;
};

/** A connection to a list of `QuoteAccommodationDetail` values. */
export type QuoteAccommodationDetailsConnection = {
  __typename?: 'QuoteAccommodationDetailsConnection';
  /** A list of edges which contains the `QuoteAccommodationDetail` and cursor to aid in pagination. */
  edges: Array<QuoteAccommodationDetailsEdge>;
  /** A list of `QuoteAccommodationDetail` objects. */
  nodes: Array<Maybe<QuoteAccommodationDetail>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `QuoteAccommodationDetail` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `QuoteAccommodationDetail` edge in the connection. */
export type QuoteAccommodationDetailsEdge = {
  __typename?: 'QuoteAccommodationDetailsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `QuoteAccommodationDetail` at the end of the edge. */
  node?: Maybe<QuoteAccommodationDetail>;
};

/** Methods to use when ordering `QuoteAccommodationDetail`. */
export enum QuoteAccommodationDetailsOrderBy {
  BasisAsc = 'BASIS_ASC',
  BasisDesc = 'BASIS_DESC',
  BeverageInclusionsAsc = 'BEVERAGE_INCLUSIONS_ASC',
  BeverageInclusionsDesc = 'BEVERAGE_INCLUSIONS_DESC',
  ConfirmationAsc = 'CONFIRMATION_ASC',
  ConfirmationDesc = 'CONFIRMATION_DESC',
  FoodInclusionsAsc = 'FOOD_INCLUSIONS_ASC',
  FoodInclusionsDesc = 'FOOD_INCLUSIONS_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  NightsAsc = 'NIGHTS_ASC',
  NightsDesc = 'NIGHTS_DESC',
  NotesAsc = 'NOTES_ASC',
  NotesDesc = 'NOTES_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  PropertyByPropertyIdAliasAsc = 'PROPERTY_BY_PROPERTY_ID__ALIAS_ASC',
  PropertyByPropertyIdAliasDesc = 'PROPERTY_BY_PROPERTY_ID__ALIAS_DESC',
  PropertyByPropertyIdArchivedAsc = 'PROPERTY_BY_PROPERTY_ID__ARCHIVED_ASC',
  PropertyByPropertyIdArchivedDesc = 'PROPERTY_BY_PROPERTY_ID__ARCHIVED_DESC',
  PropertyByPropertyIdCityAsc = 'PROPERTY_BY_PROPERTY_ID__CITY_ASC',
  PropertyByPropertyIdCityDesc = 'PROPERTY_BY_PROPERTY_ID__CITY_DESC',
  PropertyByPropertyIdContactEmailAsc = 'PROPERTY_BY_PROPERTY_ID__CONTACT_EMAIL_ASC',
  PropertyByPropertyIdContactEmailDesc = 'PROPERTY_BY_PROPERTY_ID__CONTACT_EMAIL_DESC',
  PropertyByPropertyIdContactNumberAsc = 'PROPERTY_BY_PROPERTY_ID__CONTACT_NUMBER_ASC',
  PropertyByPropertyIdContactNumberDesc = 'PROPERTY_BY_PROPERTY_ID__CONTACT_NUMBER_DESC',
  PropertyByPropertyIdCountryIdAsc = 'PROPERTY_BY_PROPERTY_ID__COUNTRY_ID_ASC',
  PropertyByPropertyIdCountryIdDesc = 'PROPERTY_BY_PROPERTY_ID__COUNTRY_ID_DESC',
  PropertyByPropertyIdCreatedAsc = 'PROPERTY_BY_PROPERTY_ID__CREATED_ASC',
  PropertyByPropertyIdCreatedDesc = 'PROPERTY_BY_PROPERTY_ID__CREATED_DESC',
  PropertyByPropertyIdDestinationIdAsc = 'PROPERTY_BY_PROPERTY_ID__DESTINATION_ID_ASC',
  PropertyByPropertyIdDestinationIdDesc = 'PROPERTY_BY_PROPERTY_ID__DESTINATION_ID_DESC',
  PropertyByPropertyIdExternalReferenceAsc = 'PROPERTY_BY_PROPERTY_ID__EXTERNAL_REFERENCE_ASC',
  PropertyByPropertyIdExternalReferenceDesc = 'PROPERTY_BY_PROPERTY_ID__EXTERNAL_REFERENCE_DESC',
  PropertyByPropertyIdFeaturedAsc = 'PROPERTY_BY_PROPERTY_ID__FEATURED_ASC',
  PropertyByPropertyIdFeaturedDesc = 'PROPERTY_BY_PROPERTY_ID__FEATURED_DESC',
  PropertyByPropertyIdFeatureCopyAsc = 'PROPERTY_BY_PROPERTY_ID__FEATURE_COPY_ASC',
  PropertyByPropertyIdFeatureCopyDesc = 'PROPERTY_BY_PROPERTY_ID__FEATURE_COPY_DESC',
  PropertyByPropertyIdGalleryIdAsc = 'PROPERTY_BY_PROPERTY_ID__GALLERY_ID_ASC',
  PropertyByPropertyIdGalleryIdDesc = 'PROPERTY_BY_PROPERTY_ID__GALLERY_ID_DESC',
  PropertyByPropertyIdHeroMediaIdAsc = 'PROPERTY_BY_PROPERTY_ID__HERO_MEDIA_ID_ASC',
  PropertyByPropertyIdHeroMediaIdDesc = 'PROPERTY_BY_PROPERTY_ID__HERO_MEDIA_ID_DESC',
  PropertyByPropertyIdIdAsc = 'PROPERTY_BY_PROPERTY_ID__ID_ASC',
  PropertyByPropertyIdIdDesc = 'PROPERTY_BY_PROPERTY_ID__ID_DESC',
  PropertyByPropertyIdLatitudeAsc = 'PROPERTY_BY_PROPERTY_ID__LATITUDE_ASC',
  PropertyByPropertyIdLatitudeDesc = 'PROPERTY_BY_PROPERTY_ID__LATITUDE_DESC',
  PropertyByPropertyIdLongitudeAsc = 'PROPERTY_BY_PROPERTY_ID__LONGITUDE_ASC',
  PropertyByPropertyIdLongitudeDesc = 'PROPERTY_BY_PROPERTY_ID__LONGITUDE_DESC',
  PropertyByPropertyIdMapPointIdAsc = 'PROPERTY_BY_PROPERTY_ID__MAP_POINT_ID_ASC',
  PropertyByPropertyIdMapPointIdDesc = 'PROPERTY_BY_PROPERTY_ID__MAP_POINT_ID_DESC',
  PropertyByPropertyIdModifiedAsc = 'PROPERTY_BY_PROPERTY_ID__MODIFIED_ASC',
  PropertyByPropertyIdModifiedDesc = 'PROPERTY_BY_PROPERTY_ID__MODIFIED_DESC',
  PropertyByPropertyIdNameAsc = 'PROPERTY_BY_PROPERTY_ID__NAME_ASC',
  PropertyByPropertyIdNameDesc = 'PROPERTY_BY_PROPERTY_ID__NAME_DESC',
  PropertyByPropertyIdNearestAirportAsc = 'PROPERTY_BY_PROPERTY_ID__NEAREST_AIRPORT_ASC',
  PropertyByPropertyIdNearestAirportDesc = 'PROPERTY_BY_PROPERTY_ID__NEAREST_AIRPORT_DESC',
  PropertyByPropertyIdNotesAsc = 'PROPERTY_BY_PROPERTY_ID__NOTES_ASC',
  PropertyByPropertyIdNotesDesc = 'PROPERTY_BY_PROPERTY_ID__NOTES_DESC',
  PropertyByPropertyIdPlusCodeAsc = 'PROPERTY_BY_PROPERTY_ID__PLUS_CODE_ASC',
  PropertyByPropertyIdPlusCodeDesc = 'PROPERTY_BY_PROPERTY_ID__PLUS_CODE_DESC',
  PropertyByPropertyIdRegionAsc = 'PROPERTY_BY_PROPERTY_ID__REGION_ASC',
  PropertyByPropertyIdRegionDesc = 'PROPERTY_BY_PROPERTY_ID__REGION_DESC',
  PropertyByPropertyIdSummaryAsc = 'PROPERTY_BY_PROPERTY_ID__SUMMARY_ASC',
  PropertyByPropertyIdSummaryDesc = 'PROPERTY_BY_PROPERTY_ID__SUMMARY_DESC',
  PropertyByPropertyIdTimezoneAsc = 'PROPERTY_BY_PROPERTY_ID__TIMEZONE_ASC',
  PropertyByPropertyIdTimezoneDesc = 'PROPERTY_BY_PROPERTY_ID__TIMEZONE_DESC',
  PropertyByPropertyIdUrlAsc = 'PROPERTY_BY_PROPERTY_ID__URL_ASC',
  PropertyByPropertyIdUrlDesc = 'PROPERTY_BY_PROPERTY_ID__URL_DESC',
  PropertyIdAsc = 'PROPERTY_ID_ASC',
  PropertyIdDesc = 'PROPERTY_ID_DESC',
  QuoteByQuoteIdAdjustmentAsc = 'QUOTE_BY_QUOTE_ID__ADJUSTMENT_ASC',
  QuoteByQuoteIdAdjustmentDesc = 'QUOTE_BY_QUOTE_ID__ADJUSTMENT_DESC',
  QuoteByQuoteIdAgentMarginAsc = 'QUOTE_BY_QUOTE_ID__AGENT_MARGIN_ASC',
  QuoteByQuoteIdAgentMarginDesc = 'QUOTE_BY_QUOTE_ID__AGENT_MARGIN_DESC',
  QuoteByQuoteIdArchivedAsc = 'QUOTE_BY_QUOTE_ID__ARCHIVED_ASC',
  QuoteByQuoteIdArchivedDesc = 'QUOTE_BY_QUOTE_ID__ARCHIVED_DESC',
  QuoteByQuoteIdBaseCurrencyAsc = 'QUOTE_BY_QUOTE_ID__BASE_CURRENCY_ASC',
  QuoteByQuoteIdBaseCurrencyDesc = 'QUOTE_BY_QUOTE_ID__BASE_CURRENCY_DESC',
  QuoteByQuoteIdCreatedAsc = 'QUOTE_BY_QUOTE_ID__CREATED_ASC',
  QuoteByQuoteIdCreatedDesc = 'QUOTE_BY_QUOTE_ID__CREATED_DESC',
  QuoteByQuoteIdDepositAsc = 'QUOTE_BY_QUOTE_ID__DEPOSIT_ASC',
  QuoteByQuoteIdDepositDesc = 'QUOTE_BY_QUOTE_ID__DEPOSIT_DESC',
  QuoteByQuoteIdDurationAsc = 'QUOTE_BY_QUOTE_ID__DURATION_ASC',
  QuoteByQuoteIdDurationDesc = 'QUOTE_BY_QUOTE_ID__DURATION_DESC',
  QuoteByQuoteIdExclusionsAsc = 'QUOTE_BY_QUOTE_ID__EXCLUSIONS_ASC',
  QuoteByQuoteIdExclusionsDesc = 'QUOTE_BY_QUOTE_ID__EXCLUSIONS_DESC',
  QuoteByQuoteIdExpiresAsc = 'QUOTE_BY_QUOTE_ID__EXPIRES_ASC',
  QuoteByQuoteIdExpiresDesc = 'QUOTE_BY_QUOTE_ID__EXPIRES_DESC',
  QuoteByQuoteIdHeroIdAsc = 'QUOTE_BY_QUOTE_ID__HERO_ID_ASC',
  QuoteByQuoteIdHeroIdDesc = 'QUOTE_BY_QUOTE_ID__HERO_ID_DESC',
  QuoteByQuoteIdHeroImageIdAsc = 'QUOTE_BY_QUOTE_ID__HERO_IMAGE_ID_ASC',
  QuoteByQuoteIdHeroImageIdDesc = 'QUOTE_BY_QUOTE_ID__HERO_IMAGE_ID_DESC',
  QuoteByQuoteIdIdAsc = 'QUOTE_BY_QUOTE_ID__ID_ASC',
  QuoteByQuoteIdIdDesc = 'QUOTE_BY_QUOTE_ID__ID_DESC',
  QuoteByQuoteIdInclusionsAsc = 'QUOTE_BY_QUOTE_ID__INCLUSIONS_ASC',
  QuoteByQuoteIdInclusionsDesc = 'QUOTE_BY_QUOTE_ID__INCLUSIONS_DESC',
  QuoteByQuoteIdKeyAsc = 'QUOTE_BY_QUOTE_ID__KEY_ASC',
  QuoteByQuoteIdKeyDesc = 'QUOTE_BY_QUOTE_ID__KEY_DESC',
  QuoteByQuoteIdLockedAsc = 'QUOTE_BY_QUOTE_ID__LOCKED_ASC',
  QuoteByQuoteIdLockedDesc = 'QUOTE_BY_QUOTE_ID__LOCKED_DESC',
  QuoteByQuoteIdMarginAsc = 'QUOTE_BY_QUOTE_ID__MARGIN_ASC',
  QuoteByQuoteIdMarginDesc = 'QUOTE_BY_QUOTE_ID__MARGIN_DESC',
  QuoteByQuoteIdModifiedAsc = 'QUOTE_BY_QUOTE_ID__MODIFIED_ASC',
  QuoteByQuoteIdModifiedDesc = 'QUOTE_BY_QUOTE_ID__MODIFIED_DESC',
  QuoteByQuoteIdShortDescriptionAsc = 'QUOTE_BY_QUOTE_ID__SHORT_DESCRIPTION_ASC',
  QuoteByQuoteIdShortDescriptionDesc = 'QUOTE_BY_QUOTE_ID__SHORT_DESCRIPTION_DESC',
  QuoteByQuoteIdStartAsc = 'QUOTE_BY_QUOTE_ID__START_ASC',
  QuoteByQuoteIdStartDesc = 'QUOTE_BY_QUOTE_ID__START_DESC',
  QuoteByQuoteIdStatusAsc = 'QUOTE_BY_QUOTE_ID__STATUS_ASC',
  QuoteByQuoteIdStatusDesc = 'QUOTE_BY_QUOTE_ID__STATUS_DESC',
  QuoteByQuoteIdSummaryAsc = 'QUOTE_BY_QUOTE_ID__SUMMARY_ASC',
  QuoteByQuoteIdSummaryDesc = 'QUOTE_BY_QUOTE_ID__SUMMARY_DESC',
  QuoteByQuoteIdTravellerCountAsc = 'QUOTE_BY_QUOTE_ID__TRAVELLER_COUNT_ASC',
  QuoteByQuoteIdTravellerCountDesc = 'QUOTE_BY_QUOTE_ID__TRAVELLER_COUNT_DESC',
  QuoteByQuoteIdTripIdAsc = 'QUOTE_BY_QUOTE_ID__TRIP_ID_ASC',
  QuoteByQuoteIdTripIdDesc = 'QUOTE_BY_QUOTE_ID__TRIP_ID_DESC',
  QuoteByQuoteIdUserIdAsc = 'QUOTE_BY_QUOTE_ID__USER_ID_ASC',
  QuoteByQuoteIdUserIdDesc = 'QUOTE_BY_QUOTE_ID__USER_ID_DESC',
  QuoteDaysByAccommodationIdCountAsc = 'QUOTE_DAYS_BY_ACCOMMODATION_ID__COUNT_ASC',
  QuoteDaysByAccommodationIdCountDesc = 'QUOTE_DAYS_BY_ACCOMMODATION_ID__COUNT_DESC',
  QuoteIdAsc = 'QUOTE_ID_ASC',
  QuoteIdDesc = 'QUOTE_ID_DESC',
  QuotePublicByQuoteIdAcceptedAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__ACCEPTED_ASC',
  QuotePublicByQuoteIdAcceptedDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__ACCEPTED_DESC',
  QuotePublicByQuoteIdBaseCurrencyAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__BASE_CURRENCY_ASC',
  QuotePublicByQuoteIdBaseCurrencyDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__BASE_CURRENCY_DESC',
  QuotePublicByQuoteIdDepositAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__DEPOSIT_ASC',
  QuotePublicByQuoteIdDepositDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__DEPOSIT_DESC',
  QuotePublicByQuoteIdDurationAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__DURATION_ASC',
  QuotePublicByQuoteIdDurationDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__DURATION_DESC',
  QuotePublicByQuoteIdExclusionsAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__EXCLUSIONS_ASC',
  QuotePublicByQuoteIdExclusionsDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__EXCLUSIONS_DESC',
  QuotePublicByQuoteIdExpiresAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__EXPIRES_ASC',
  QuotePublicByQuoteIdExpiresDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__EXPIRES_DESC',
  QuotePublicByQuoteIdHeroIdAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__HERO_ID_ASC',
  QuotePublicByQuoteIdHeroIdDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__HERO_ID_DESC',
  QuotePublicByQuoteIdIdAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__ID_ASC',
  QuotePublicByQuoteIdIdDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__ID_DESC',
  QuotePublicByQuoteIdInclusionsAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__INCLUSIONS_ASC',
  QuotePublicByQuoteIdInclusionsDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__INCLUSIONS_DESC',
  QuotePublicByQuoteIdKeyAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__KEY_ASC',
  QuotePublicByQuoteIdKeyDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__KEY_DESC',
  QuotePublicByQuoteIdLockedAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__LOCKED_ASC',
  QuotePublicByQuoteIdLockedDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__LOCKED_DESC',
  QuotePublicByQuoteIdStartAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__START_ASC',
  QuotePublicByQuoteIdStartDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__START_DESC',
  QuotePublicByQuoteIdStatusAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__STATUS_ASC',
  QuotePublicByQuoteIdStatusDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__STATUS_DESC',
  QuotePublicByQuoteIdTotalAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__TOTAL_ASC',
  QuotePublicByQuoteIdTotalDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__TOTAL_DESC',
  QuotePublicByQuoteIdTravellerCountAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__TRAVELLER_COUNT_ASC',
  QuotePublicByQuoteIdTravellerCountDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__TRAVELLER_COUNT_DESC',
  QuotePublicByQuoteIdTripIdAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__TRIP_ID_ASC',
  QuotePublicByQuoteIdTripIdDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__TRIP_ID_DESC',
  QuotePublicByQuoteIdUserIdAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__USER_ID_ASC',
  QuotePublicByQuoteIdUserIdDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__USER_ID_DESC',
  RoomTypeAsc = 'ROOM_TYPE_ASC',
  RoomTypeDesc = 'ROOM_TYPE_DESC',
  SortOrderAsc = 'SORT_ORDER_ASC',
  SortOrderDesc = 'SORT_ORDER_DESC',
  SummaryAsc = 'SUMMARY_ASC',
  SummaryDesc = 'SUMMARY_DESC'
}

/** A condition to be used against `Quote` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type QuoteCondition = {
  /** Checks for equality with the object’s `adjustment` field. */
  adjustment?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `agentMargin` field. */
  agentMargin?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `archived` field. */
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `baseCurrency` field. */
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `deposit` field. */
  deposit?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `duration` field. */
  duration?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `exclusions` field. */
  exclusions?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `expires` field. */
  expires?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `heroId` field. */
  heroId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `heroImageId` field. */
  heroImageId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `inclusions` field. */
  inclusions?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `key` field. */
  key?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `locked` field. */
  locked?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `margin` field. */
  margin?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `shortDescription` field. */
  shortDescription?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `start` field. */
  start?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `summary` field. */
  summary?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `travellerCount` field. */
  travellerCount?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `tripId` field. */
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['UUID']['input']>;
};

/** A connection to a list of `QuoteCurrency` values. */
export type QuoteCurrenciesConnection = {
  __typename?: 'QuoteCurrenciesConnection';
  /** A list of edges which contains the `QuoteCurrency` and cursor to aid in pagination. */
  edges: Array<QuoteCurrenciesEdge>;
  /** A list of `QuoteCurrency` objects. */
  nodes: Array<Maybe<QuoteCurrency>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `QuoteCurrency` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `QuoteCurrency` edge in the connection. */
export type QuoteCurrenciesEdge = {
  __typename?: 'QuoteCurrenciesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `QuoteCurrency` at the end of the edge. */
  node?: Maybe<QuoteCurrency>;
};

/** Methods to use when ordering `QuoteCurrency`. */
export enum QuoteCurrenciesOrderBy {
  CodeAsc = 'CODE_ASC',
  CodeDesc = 'CODE_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QuoteByQuoteIdAdjustmentAsc = 'QUOTE_BY_QUOTE_ID__ADJUSTMENT_ASC',
  QuoteByQuoteIdAdjustmentDesc = 'QUOTE_BY_QUOTE_ID__ADJUSTMENT_DESC',
  QuoteByQuoteIdAgentMarginAsc = 'QUOTE_BY_QUOTE_ID__AGENT_MARGIN_ASC',
  QuoteByQuoteIdAgentMarginDesc = 'QUOTE_BY_QUOTE_ID__AGENT_MARGIN_DESC',
  QuoteByQuoteIdArchivedAsc = 'QUOTE_BY_QUOTE_ID__ARCHIVED_ASC',
  QuoteByQuoteIdArchivedDesc = 'QUOTE_BY_QUOTE_ID__ARCHIVED_DESC',
  QuoteByQuoteIdBaseCurrencyAsc = 'QUOTE_BY_QUOTE_ID__BASE_CURRENCY_ASC',
  QuoteByQuoteIdBaseCurrencyDesc = 'QUOTE_BY_QUOTE_ID__BASE_CURRENCY_DESC',
  QuoteByQuoteIdCreatedAsc = 'QUOTE_BY_QUOTE_ID__CREATED_ASC',
  QuoteByQuoteIdCreatedDesc = 'QUOTE_BY_QUOTE_ID__CREATED_DESC',
  QuoteByQuoteIdDepositAsc = 'QUOTE_BY_QUOTE_ID__DEPOSIT_ASC',
  QuoteByQuoteIdDepositDesc = 'QUOTE_BY_QUOTE_ID__DEPOSIT_DESC',
  QuoteByQuoteIdDurationAsc = 'QUOTE_BY_QUOTE_ID__DURATION_ASC',
  QuoteByQuoteIdDurationDesc = 'QUOTE_BY_QUOTE_ID__DURATION_DESC',
  QuoteByQuoteIdExclusionsAsc = 'QUOTE_BY_QUOTE_ID__EXCLUSIONS_ASC',
  QuoteByQuoteIdExclusionsDesc = 'QUOTE_BY_QUOTE_ID__EXCLUSIONS_DESC',
  QuoteByQuoteIdExpiresAsc = 'QUOTE_BY_QUOTE_ID__EXPIRES_ASC',
  QuoteByQuoteIdExpiresDesc = 'QUOTE_BY_QUOTE_ID__EXPIRES_DESC',
  QuoteByQuoteIdHeroIdAsc = 'QUOTE_BY_QUOTE_ID__HERO_ID_ASC',
  QuoteByQuoteIdHeroIdDesc = 'QUOTE_BY_QUOTE_ID__HERO_ID_DESC',
  QuoteByQuoteIdHeroImageIdAsc = 'QUOTE_BY_QUOTE_ID__HERO_IMAGE_ID_ASC',
  QuoteByQuoteIdHeroImageIdDesc = 'QUOTE_BY_QUOTE_ID__HERO_IMAGE_ID_DESC',
  QuoteByQuoteIdIdAsc = 'QUOTE_BY_QUOTE_ID__ID_ASC',
  QuoteByQuoteIdIdDesc = 'QUOTE_BY_QUOTE_ID__ID_DESC',
  QuoteByQuoteIdInclusionsAsc = 'QUOTE_BY_QUOTE_ID__INCLUSIONS_ASC',
  QuoteByQuoteIdInclusionsDesc = 'QUOTE_BY_QUOTE_ID__INCLUSIONS_DESC',
  QuoteByQuoteIdKeyAsc = 'QUOTE_BY_QUOTE_ID__KEY_ASC',
  QuoteByQuoteIdKeyDesc = 'QUOTE_BY_QUOTE_ID__KEY_DESC',
  QuoteByQuoteIdLockedAsc = 'QUOTE_BY_QUOTE_ID__LOCKED_ASC',
  QuoteByQuoteIdLockedDesc = 'QUOTE_BY_QUOTE_ID__LOCKED_DESC',
  QuoteByQuoteIdMarginAsc = 'QUOTE_BY_QUOTE_ID__MARGIN_ASC',
  QuoteByQuoteIdMarginDesc = 'QUOTE_BY_QUOTE_ID__MARGIN_DESC',
  QuoteByQuoteIdModifiedAsc = 'QUOTE_BY_QUOTE_ID__MODIFIED_ASC',
  QuoteByQuoteIdModifiedDesc = 'QUOTE_BY_QUOTE_ID__MODIFIED_DESC',
  QuoteByQuoteIdShortDescriptionAsc = 'QUOTE_BY_QUOTE_ID__SHORT_DESCRIPTION_ASC',
  QuoteByQuoteIdShortDescriptionDesc = 'QUOTE_BY_QUOTE_ID__SHORT_DESCRIPTION_DESC',
  QuoteByQuoteIdStartAsc = 'QUOTE_BY_QUOTE_ID__START_ASC',
  QuoteByQuoteIdStartDesc = 'QUOTE_BY_QUOTE_ID__START_DESC',
  QuoteByQuoteIdStatusAsc = 'QUOTE_BY_QUOTE_ID__STATUS_ASC',
  QuoteByQuoteIdStatusDesc = 'QUOTE_BY_QUOTE_ID__STATUS_DESC',
  QuoteByQuoteIdSummaryAsc = 'QUOTE_BY_QUOTE_ID__SUMMARY_ASC',
  QuoteByQuoteIdSummaryDesc = 'QUOTE_BY_QUOTE_ID__SUMMARY_DESC',
  QuoteByQuoteIdTravellerCountAsc = 'QUOTE_BY_QUOTE_ID__TRAVELLER_COUNT_ASC',
  QuoteByQuoteIdTravellerCountDesc = 'QUOTE_BY_QUOTE_ID__TRAVELLER_COUNT_DESC',
  QuoteByQuoteIdTripIdAsc = 'QUOTE_BY_QUOTE_ID__TRIP_ID_ASC',
  QuoteByQuoteIdTripIdDesc = 'QUOTE_BY_QUOTE_ID__TRIP_ID_DESC',
  QuoteByQuoteIdUserIdAsc = 'QUOTE_BY_QUOTE_ID__USER_ID_ASC',
  QuoteByQuoteIdUserIdDesc = 'QUOTE_BY_QUOTE_ID__USER_ID_DESC',
  QuoteIdAsc = 'QUOTE_ID_ASC',
  QuoteIdDesc = 'QUOTE_ID_DESC',
  RateAsc = 'RATE_ASC',
  RateDesc = 'RATE_DESC'
}

export type QuoteCurrency = {
  __typename?: 'QuoteCurrency';
  code?: Maybe<Scalars['String']['output']>;
  id: Scalars['UUID']['output'];
  /** Reads a single `Quote` that is related to this `QuoteCurrency`. */
  quote?: Maybe<Quote>;
  quoteId?: Maybe<Scalars['UUID']['output']>;
  rate: Scalars['BigFloat']['output'];
};

/**
 * A condition to be used against `QuoteCurrency` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type QuoteCurrencyCondition = {
  /** Checks for equality with the object’s `code` field. */
  code?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `quoteId` field. */
  quoteId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `rate` field. */
  rate?: InputMaybe<Scalars['BigFloat']['input']>;
};

/** A filter to be used against `QuoteCurrency` object types. All fields are combined with a logical ‘and.’ */
export type QuoteCurrencyFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<QuoteCurrencyFilter>>;
  /** Filter by the object’s `code` field. */
  code?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Negates the expression. */
  not?: InputMaybe<QuoteCurrencyFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<QuoteCurrencyFilter>>;
  /** Filter by the object’s `quote` relation. */
  quote?: InputMaybe<QuoteFilter>;
  /** A related `quote` exists. */
  quoteExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `quoteId` field. */
  quoteId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `rate` field. */
  rate?: InputMaybe<BigFloatFilter>;
};

/** An input for mutations affecting `QuoteCurrency` */
export type QuoteCurrencyInput = {
  code?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  quoteId?: InputMaybe<Scalars['UUID']['input']>;
  quoteToQuoteId?: InputMaybe<FkQuoteCurrencyQuoteQuoteIdInput>;
  rate: Scalars['BigFloat']['input'];
};

/** The fields on `quoteCurrency` to look up the row to update. */
export type QuoteCurrencyOnQuoteCurrencyForFkQuoteCurrencyQuoteQuoteIdUsingPkQuoteCurrencyUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `quoteCurrency` being updated. */
  patch: UpdateQuoteCurrencyOnQuoteCurrencyForFkQuoteCurrencyQuoteQuoteIdPatch;
};

/** Represents an update to a `QuoteCurrency`. Fields that are set will be updated. */
export type QuoteCurrencyPatch = {
  code?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  quoteId?: InputMaybe<Scalars['UUID']['input']>;
  quoteToQuoteId?: InputMaybe<FkQuoteCurrencyQuoteQuoteIdInput>;
  rate?: InputMaybe<Scalars['BigFloat']['input']>;
};

/** The fields on `quoteCurrency` to look up the row to connect. */
export type QuoteCurrencyPkQuoteCurrencyConnect = {
  id: Scalars['UUID']['input'];
};

/** The fields on `quoteCurrency` to look up the row to delete. */
export type QuoteCurrencyPkQuoteCurrencyDelete = {
  id: Scalars['UUID']['input'];
};

export type QuoteDay = {
  __typename?: 'QuoteDay';
  /** Reads a single `QuoteAccommodationDetail` that is related to this `QuoteDay`. */
  accommodation?: Maybe<QuoteAccommodationDetail>;
  accommodationId?: Maybe<Scalars['UUID']['output']>;
  activityDetail?: Maybe<Scalars['String']['output']>;
  activitySummary?: Maybe<Scalars['String']['output']>;
  date?: Maybe<Scalars['Datetime']['output']>;
  id: Scalars['UUID']['output'];
  /** Reads a single `Property` that is related to this `QuoteDay`. */
  property?: Maybe<Property>;
  propertyId?: Maybe<Scalars['UUID']['output']>;
  /** Reads a single `Quote` that is related to this `QuoteDay`. */
  quote?: Maybe<Quote>;
  /** Reads and enables pagination through a set of `QuoteDayDestination`. */
  quoteDayDestinationsByDayId: QuoteDayDestinationsConnection;
  quoteId?: Maybe<Scalars['UUID']['output']>;
  /** Reads a single `QuotePublic` that is related to this `QuoteDay`. */
  quotePublic?: Maybe<QuotePublic>;
  sortOrder: Scalars['Int']['output'];
};


export type QuoteDayQuoteDayDestinationsByDayIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<QuoteDayDestinationCondition>;
  filter?: InputMaybe<QuoteDayDestinationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuoteDayDestinationsOrderBy>>;
};

/**
 * A condition to be used against `QuoteDay` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type QuoteDayCondition = {
  /** Checks for equality with the object’s `accommodationId` field. */
  accommodationId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `activityDetail` field. */
  activityDetail?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `activitySummary` field. */
  activitySummary?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `date` field. */
  date?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `propertyId` field. */
  propertyId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `quoteId` field. */
  quoteId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `sortOrder` field. */
  sortOrder?: InputMaybe<Scalars['Int']['input']>;
};

export type QuoteDayDestination = {
  __typename?: 'QuoteDayDestination';
  /** Reads a single `QuoteDay` that is related to this `QuoteDayDestination`. */
  day?: Maybe<QuoteDay>;
  dayId: Scalars['UUID']['output'];
  /** Reads a single `Destination` that is related to this `QuoteDayDestination`. */
  destination?: Maybe<Destination>;
  destinationId: Scalars['UUID']['output'];
  id: Scalars['UUID']['output'];
  sortOrder: Scalars['Int']['output'];
};

/**
 * A condition to be used against `QuoteDayDestination` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type QuoteDayDestinationCondition = {
  /** Checks for equality with the object’s `dayId` field. */
  dayId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `destinationId` field. */
  destinationId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `sortOrder` field. */
  sortOrder?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `QuoteDayDestination` object types. All fields are combined with a logical ‘and.’ */
export type QuoteDayDestinationFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<QuoteDayDestinationFilter>>;
  /** Filter by the object’s `day` relation. */
  day?: InputMaybe<QuoteDayFilter>;
  /** Filter by the object’s `dayId` field. */
  dayId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `destination` relation. */
  destination?: InputMaybe<DestinationFilter>;
  /** Filter by the object’s `destinationId` field. */
  destinationId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Negates the expression. */
  not?: InputMaybe<QuoteDayDestinationFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<QuoteDayDestinationFilter>>;
  /** Filter by the object’s `sortOrder` field. */
  sortOrder?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `QuoteDayDestination` */
export type QuoteDayDestinationInput = {
  dayId?: InputMaybe<Scalars['UUID']['input']>;
  destinationId?: InputMaybe<Scalars['UUID']['input']>;
  destinationToDestinationId?: InputMaybe<FkQuoteDayDestinationDestinationDestinationIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  quoteDayToDayId?: InputMaybe<FkQuoteDayDestinationQuoteDayDayIdInput>;
  sortOrder: Scalars['Int']['input'];
};

/** The fields on `quoteDayDestination` to look up the row to update. */
export type QuoteDayDestinationOnQuoteDayDestinationForFkQuoteDayDestinationDestinationDestinationIdUsingPkQuoteDayDestinationUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `quoteDayDestination` being updated. */
  patch: UpdateQuoteDayDestinationOnQuoteDayDestinationForFkQuoteDayDestinationDestinationDestinationIdPatch;
};

/** The fields on `quoteDayDestination` to look up the row to update. */
export type QuoteDayDestinationOnQuoteDayDestinationForFkQuoteDayDestinationQuoteDayDayIdUsingPkQuoteDayDestinationUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `quoteDayDestination` being updated. */
  patch: UpdateQuoteDayDestinationOnQuoteDayDestinationForFkQuoteDayDestinationQuoteDayDayIdPatch;
};

/** Represents an update to a `QuoteDayDestination`. Fields that are set will be updated. */
export type QuoteDayDestinationPatch = {
  dayId?: InputMaybe<Scalars['UUID']['input']>;
  destinationId?: InputMaybe<Scalars['UUID']['input']>;
  destinationToDestinationId?: InputMaybe<FkQuoteDayDestinationDestinationDestinationIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  quoteDayToDayId?: InputMaybe<FkQuoteDayDestinationQuoteDayDayIdInput>;
  sortOrder?: InputMaybe<Scalars['Int']['input']>;
};

/** The fields on `quoteDayDestination` to look up the row to connect. */
export type QuoteDayDestinationPkQuoteDayDestinationConnect = {
  id: Scalars['UUID']['input'];
};

/** The fields on `quoteDayDestination` to look up the row to delete. */
export type QuoteDayDestinationPkQuoteDayDestinationDelete = {
  id: Scalars['UUID']['input'];
};

/** A connection to a list of `QuoteDayDestination` values. */
export type QuoteDayDestinationsConnection = {
  __typename?: 'QuoteDayDestinationsConnection';
  /** A list of edges which contains the `QuoteDayDestination` and cursor to aid in pagination. */
  edges: Array<QuoteDayDestinationsEdge>;
  /** A list of `QuoteDayDestination` objects. */
  nodes: Array<Maybe<QuoteDayDestination>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `QuoteDayDestination` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `QuoteDayDestination` edge in the connection. */
export type QuoteDayDestinationsEdge = {
  __typename?: 'QuoteDayDestinationsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `QuoteDayDestination` at the end of the edge. */
  node?: Maybe<QuoteDayDestination>;
};

/** Methods to use when ordering `QuoteDayDestination`. */
export enum QuoteDayDestinationsOrderBy {
  DayIdAsc = 'DAY_ID_ASC',
  DayIdDesc = 'DAY_ID_DESC',
  DestinationByDestinationIdAliasAsc = 'DESTINATION_BY_DESTINATION_ID__ALIAS_ASC',
  DestinationByDestinationIdAliasDesc = 'DESTINATION_BY_DESTINATION_ID__ALIAS_DESC',
  DestinationByDestinationIdBodyAsc = 'DESTINATION_BY_DESTINATION_ID__BODY_ASC',
  DestinationByDestinationIdBodyDesc = 'DESTINATION_BY_DESTINATION_ID__BODY_DESC',
  DestinationByDestinationIdCountryIdAsc = 'DESTINATION_BY_DESTINATION_ID__COUNTRY_ID_ASC',
  DestinationByDestinationIdCountryIdDesc = 'DESTINATION_BY_DESTINATION_ID__COUNTRY_ID_DESC',
  DestinationByDestinationIdCreatedAsc = 'DESTINATION_BY_DESTINATION_ID__CREATED_ASC',
  DestinationByDestinationIdCreatedDesc = 'DESTINATION_BY_DESTINATION_ID__CREATED_DESC',
  DestinationByDestinationIdGalleryIdAsc = 'DESTINATION_BY_DESTINATION_ID__GALLERY_ID_ASC',
  DestinationByDestinationIdGalleryIdDesc = 'DESTINATION_BY_DESTINATION_ID__GALLERY_ID_DESC',
  DestinationByDestinationIdHeroMediaIdAsc = 'DESTINATION_BY_DESTINATION_ID__HERO_MEDIA_ID_ASC',
  DestinationByDestinationIdHeroMediaIdDesc = 'DESTINATION_BY_DESTINATION_ID__HERO_MEDIA_ID_DESC',
  DestinationByDestinationIdIdAsc = 'DESTINATION_BY_DESTINATION_ID__ID_ASC',
  DestinationByDestinationIdIdDesc = 'DESTINATION_BY_DESTINATION_ID__ID_DESC',
  DestinationByDestinationIdLatitudeAsc = 'DESTINATION_BY_DESTINATION_ID__LATITUDE_ASC',
  DestinationByDestinationIdLatitudeDesc = 'DESTINATION_BY_DESTINATION_ID__LATITUDE_DESC',
  DestinationByDestinationIdLongitudeAsc = 'DESTINATION_BY_DESTINATION_ID__LONGITUDE_ASC',
  DestinationByDestinationIdLongitudeDesc = 'DESTINATION_BY_DESTINATION_ID__LONGITUDE_DESC',
  DestinationByDestinationIdModifiedAsc = 'DESTINATION_BY_DESTINATION_ID__MODIFIED_ASC',
  DestinationByDestinationIdModifiedDesc = 'DESTINATION_BY_DESTINATION_ID__MODIFIED_DESC',
  DestinationByDestinationIdNameAsc = 'DESTINATION_BY_DESTINATION_ID__NAME_ASC',
  DestinationByDestinationIdNameDesc = 'DESTINATION_BY_DESTINATION_ID__NAME_DESC',
  DestinationByDestinationIdParentIdAsc = 'DESTINATION_BY_DESTINATION_ID__PARENT_ID_ASC',
  DestinationByDestinationIdParentIdDesc = 'DESTINATION_BY_DESTINATION_ID__PARENT_ID_DESC',
  DestinationIdAsc = 'DESTINATION_ID_ASC',
  DestinationIdDesc = 'DESTINATION_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QuoteDayByDayIdAccommodationIdAsc = 'QUOTE_DAY_BY_DAY_ID__ACCOMMODATION_ID_ASC',
  QuoteDayByDayIdAccommodationIdDesc = 'QUOTE_DAY_BY_DAY_ID__ACCOMMODATION_ID_DESC',
  QuoteDayByDayIdActivityDetailAsc = 'QUOTE_DAY_BY_DAY_ID__ACTIVITY_DETAIL_ASC',
  QuoteDayByDayIdActivityDetailDesc = 'QUOTE_DAY_BY_DAY_ID__ACTIVITY_DETAIL_DESC',
  QuoteDayByDayIdActivitySummaryAsc = 'QUOTE_DAY_BY_DAY_ID__ACTIVITY_SUMMARY_ASC',
  QuoteDayByDayIdActivitySummaryDesc = 'QUOTE_DAY_BY_DAY_ID__ACTIVITY_SUMMARY_DESC',
  QuoteDayByDayIdDateAsc = 'QUOTE_DAY_BY_DAY_ID__DATE_ASC',
  QuoteDayByDayIdDateDesc = 'QUOTE_DAY_BY_DAY_ID__DATE_DESC',
  QuoteDayByDayIdIdAsc = 'QUOTE_DAY_BY_DAY_ID__ID_ASC',
  QuoteDayByDayIdIdDesc = 'QUOTE_DAY_BY_DAY_ID__ID_DESC',
  QuoteDayByDayIdPropertyIdAsc = 'QUOTE_DAY_BY_DAY_ID__PROPERTY_ID_ASC',
  QuoteDayByDayIdPropertyIdDesc = 'QUOTE_DAY_BY_DAY_ID__PROPERTY_ID_DESC',
  QuoteDayByDayIdQuoteIdAsc = 'QUOTE_DAY_BY_DAY_ID__QUOTE_ID_ASC',
  QuoteDayByDayIdQuoteIdDesc = 'QUOTE_DAY_BY_DAY_ID__QUOTE_ID_DESC',
  QuoteDayByDayIdSortOrderAsc = 'QUOTE_DAY_BY_DAY_ID__SORT_ORDER_ASC',
  QuoteDayByDayIdSortOrderDesc = 'QUOTE_DAY_BY_DAY_ID__SORT_ORDER_DESC',
  SortOrderAsc = 'SORT_ORDER_ASC',
  SortOrderDesc = 'SORT_ORDER_DESC'
}

/** A filter to be used against `QuoteDay` object types. All fields are combined with a logical ‘and.’ */
export type QuoteDayFilter = {
  /** Filter by the object’s `accommodation` relation. */
  accommodation?: InputMaybe<QuoteAccommodationDetailFilter>;
  /** A related `accommodation` exists. */
  accommodationExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `accommodationId` field. */
  accommodationId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `activityDetail` field. */
  activityDetail?: InputMaybe<StringFilter>;
  /** Filter by the object’s `activitySummary` field. */
  activitySummary?: InputMaybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<QuoteDayFilter>>;
  /** Filter by the object’s `date` field. */
  date?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Negates the expression. */
  not?: InputMaybe<QuoteDayFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<QuoteDayFilter>>;
  /** Filter by the object’s `property` relation. */
  property?: InputMaybe<PropertyFilter>;
  /** A related `property` exists. */
  propertyExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `propertyId` field. */
  propertyId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `quote` relation. */
  quote?: InputMaybe<QuoteFilter>;
  /** Filter by the object’s `quoteDayDestinationsByDayId` relation. */
  quoteDayDestinationsByDayId?: InputMaybe<QuoteDayToManyQuoteDayDestinationFilter>;
  /** Some related `quoteDayDestinationsByDayId` exist. */
  quoteDayDestinationsByDayIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** A related `quote` exists. */
  quoteExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `quoteId` field. */
  quoteId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `quotePublic` relation. */
  quotePublic?: InputMaybe<QuotePublicFilter>;
  /** A related `quotePublic` exists. */
  quotePublicExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `sortOrder` field. */
  sortOrder?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `QuoteDay` */
export type QuoteDayInput = {
  accommodationId?: InputMaybe<Scalars['UUID']['input']>;
  activityDetail?: InputMaybe<Scalars['String']['input']>;
  activitySummary?: InputMaybe<Scalars['String']['input']>;
  date?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  propertyId?: InputMaybe<Scalars['UUID']['input']>;
  propertyToPropertyId?: InputMaybe<QuoteDayPropertyIdFkeyInput>;
  quoteAccommodationDetailToAccommodationId?: InputMaybe<FkQuoteDayQuoteAccommodationDetailAccommodationIdInput>;
  quoteDayDestinationsUsingId?: InputMaybe<FkQuoteDayDestinationQuoteDayDayIdInverseInput>;
  quoteId?: InputMaybe<Scalars['UUID']['input']>;
  quotePublic?: InputMaybe<FakePublicQuoteDayForeignKey0Input>;
  quoteToQuoteId?: InputMaybe<FkQuoteDayQuoteQuoteIdInput>;
  sortOrder: Scalars['Int']['input'];
};

/** The fields on `quoteDay` to look up the row to update. */
export type QuoteDayOnQuoteDayDestinationForFkQuoteDayDestinationQuoteDayDayIdUsingPkQuoteDayUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `quoteDay` being updated. */
  patch: UpdateQuoteDayOnQuoteDayDestinationForFkQuoteDayDestinationQuoteDayDayIdPatch;
};

/** The fields on `quoteDay` to look up the row to update. */
export type QuoteDayOnQuoteDayForFakePublicQuoteDayForeignKey0UsingPkQuoteDayUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `quoteDay` being updated. */
  patch: UpdateQuoteDayOnQuoteDayForFakePublicQuoteDayForeignKey0Patch;
};

/** The fields on `quoteDay` to look up the row to update. */
export type QuoteDayOnQuoteDayForFkQuoteDayQuoteAccommodationDetailAccommodationIdUsingPkQuoteDayUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `quoteDay` being updated. */
  patch: UpdateQuoteDayOnQuoteDayForFkQuoteDayQuoteAccommodationDetailAccommodationIdPatch;
};

/** The fields on `quoteDay` to look up the row to update. */
export type QuoteDayOnQuoteDayForFkQuoteDayQuoteQuoteIdUsingPkQuoteDayUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `quoteDay` being updated. */
  patch: UpdateQuoteDayOnQuoteDayForFkQuoteDayQuoteQuoteIdPatch;
};

/** The fields on `quoteDay` to look up the row to update. */
export type QuoteDayOnQuoteDayForQuoteDayPropertyIdFkeyUsingPkQuoteDayUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `quoteDay` being updated. */
  patch: UpdateQuoteDayOnQuoteDayForQuoteDayPropertyIdFkeyPatch;
};

/** Represents an update to a `QuoteDay`. Fields that are set will be updated. */
export type QuoteDayPatch = {
  accommodationId?: InputMaybe<Scalars['UUID']['input']>;
  activityDetail?: InputMaybe<Scalars['String']['input']>;
  activitySummary?: InputMaybe<Scalars['String']['input']>;
  date?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  propertyId?: InputMaybe<Scalars['UUID']['input']>;
  propertyToPropertyId?: InputMaybe<QuoteDayPropertyIdFkeyInput>;
  quoteAccommodationDetailToAccommodationId?: InputMaybe<FkQuoteDayQuoteAccommodationDetailAccommodationIdInput>;
  quoteDayDestinationsUsingId?: InputMaybe<FkQuoteDayDestinationQuoteDayDayIdInverseInput>;
  quoteId?: InputMaybe<Scalars['UUID']['input']>;
  quotePublic?: InputMaybe<FakePublicQuoteDayForeignKey0Input>;
  quoteToQuoteId?: InputMaybe<FkQuoteDayQuoteQuoteIdInput>;
  sortOrder?: InputMaybe<Scalars['Int']['input']>;
};

/** The fields on `quoteDay` to look up the row to connect. */
export type QuoteDayPkQuoteDayConnect = {
  id: Scalars['UUID']['input'];
};

/** The fields on `quoteDay` to look up the row to delete. */
export type QuoteDayPkQuoteDayDelete = {
  id: Scalars['UUID']['input'];
};

/** Input for the nested mutation of `property` in the `QuoteDayInput` mutation. */
export type QuoteDayPropertyIdFkeyInput = {
  /** The primary key(s) for `property` for the far side of the relationship. */
  connectById?: InputMaybe<PropertyPkPropertyConnect>;
  /** A `PropertyInput` object that will be created and connected to this object. */
  create?: InputMaybe<QuoteDayPropertyIdFkeyPropertyCreateInput>;
  /** The primary key(s) for `property` for the far side of the relationship. */
  deleteById?: InputMaybe<PropertyPkPropertyDelete>;
  /** The primary key(s) and patch data for `property` for the far side of the relationship. */
  updateById?: InputMaybe<PropertyOnQuoteDayForQuoteDayPropertyIdFkeyUsingPkPropertyUpdate>;
};

/** Input for the nested mutation of `quoteDay` in the `PropertyInput` mutation. */
export type QuoteDayPropertyIdFkeyInverseInput = {
  /** The primary key(s) for `quoteDay` for the far side of the relationship. */
  connectById?: InputMaybe<Array<QuoteDayPkQuoteDayConnect>>;
  /** A `QuoteDayInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<QuoteDayPropertyIdFkeyQuoteDayCreateInput>>;
  /** The primary key(s) for `quoteDay` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<QuoteDayPkQuoteDayDelete>>;
  /** Flag indicating whether all other `quoteDay` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `quoteDay` for the far side of the relationship. */
  updateById?: InputMaybe<Array<QuoteDayOnQuoteDayForQuoteDayPropertyIdFkeyUsingPkQuoteDayUpdate>>;
};

/** The `property` to be created by this mutation. */
export type QuoteDayPropertyIdFkeyPropertyCreateInput = {
  alias?: InputMaybe<Scalars['String']['input']>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  contactNumber?: InputMaybe<Scalars['String']['input']>;
  countryId?: InputMaybe<Scalars['UUID']['input']>;
  countryToCountryId?: InputMaybe<FkPropertyCountryCountryIdInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationId?: InputMaybe<Scalars['UUID']['input']>;
  destinationToDestinationId?: InputMaybe<FkPropertyDestinationInput>;
  externalReference?: InputMaybe<Scalars['String']['input']>;
  featureCopy?: InputMaybe<Scalars['String']['input']>;
  featured?: InputMaybe<Scalars['Datetime']['input']>;
  galleryId?: InputMaybe<Scalars['UUID']['input']>;
  heroMediaId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  latitude?: InputMaybe<Scalars['Float']['input']>;
  longitude?: InputMaybe<Scalars['Float']['input']>;
  mapPointId?: InputMaybe<Scalars['UUID']['input']>;
  mapPointToMapPointId?: InputMaybe<FkPropertyMapPointMapPointIdInput>;
  mediaGalleryToGalleryId?: InputMaybe<FkPropertyMediaGalleryGalleryIdInput>;
  mediaItemToHeroMediaId?: InputMaybe<FkPropertyMediaItemHeroMediaIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  nearestAirport?: InputMaybe<Scalars['String']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  plusCode?: InputMaybe<Scalars['String']['input']>;
  quoteAccommodationDetailsUsingId?: InputMaybe<FkQuoteAccommodationDetailPropertyPropertyIdInverseInput>;
  quoteDaysUsingId?: InputMaybe<QuoteDayPropertyIdFkeyInverseInput>;
  region?: InputMaybe<Scalars['String']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  timezone?: InputMaybe<Scalars['String']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
};

/** The `quoteDay` to be created by this mutation. */
export type QuoteDayPropertyIdFkeyQuoteDayCreateInput = {
  accommodationId?: InputMaybe<Scalars['UUID']['input']>;
  activityDetail?: InputMaybe<Scalars['String']['input']>;
  activitySummary?: InputMaybe<Scalars['String']['input']>;
  date?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  propertyToPropertyId?: InputMaybe<QuoteDayPropertyIdFkeyInput>;
  quoteAccommodationDetailToAccommodationId?: InputMaybe<FkQuoteDayQuoteAccommodationDetailAccommodationIdInput>;
  quoteDayDestinationsUsingId?: InputMaybe<FkQuoteDayDestinationQuoteDayDayIdInverseInput>;
  quoteId?: InputMaybe<Scalars['UUID']['input']>;
  quotePublic?: InputMaybe<FakePublicQuoteDayForeignKey0Input>;
  quoteToQuoteId?: InputMaybe<FkQuoteDayQuoteQuoteIdInput>;
  sortOrder: Scalars['Int']['input'];
};

/** A filter to be used against many `QuoteDayDestination` object types. All fields are combined with a logical ‘and.’ */
export type QuoteDayToManyQuoteDayDestinationFilter = {
  /** Every related `QuoteDayDestination` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<QuoteDayDestinationFilter>;
  /** No related `QuoteDayDestination` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<QuoteDayDestinationFilter>;
  /** Some related `QuoteDayDestination` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<QuoteDayDestinationFilter>;
};

/** A connection to a list of `QuoteDay` values. */
export type QuoteDaysConnection = {
  __typename?: 'QuoteDaysConnection';
  /** A list of edges which contains the `QuoteDay` and cursor to aid in pagination. */
  edges: Array<QuoteDaysEdge>;
  /** A list of `QuoteDay` objects. */
  nodes: Array<Maybe<QuoteDay>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `QuoteDay` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `QuoteDay` edge in the connection. */
export type QuoteDaysEdge = {
  __typename?: 'QuoteDaysEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `QuoteDay` at the end of the edge. */
  node?: Maybe<QuoteDay>;
};

/** Methods to use when ordering `QuoteDay`. */
export enum QuoteDaysOrderBy {
  AccommodationIdAsc = 'ACCOMMODATION_ID_ASC',
  AccommodationIdDesc = 'ACCOMMODATION_ID_DESC',
  ActivityDetailAsc = 'ACTIVITY_DETAIL_ASC',
  ActivityDetailDesc = 'ACTIVITY_DETAIL_DESC',
  ActivitySummaryAsc = 'ACTIVITY_SUMMARY_ASC',
  ActivitySummaryDesc = 'ACTIVITY_SUMMARY_DESC',
  DateAsc = 'DATE_ASC',
  DateDesc = 'DATE_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  PropertyByPropertyIdAliasAsc = 'PROPERTY_BY_PROPERTY_ID__ALIAS_ASC',
  PropertyByPropertyIdAliasDesc = 'PROPERTY_BY_PROPERTY_ID__ALIAS_DESC',
  PropertyByPropertyIdArchivedAsc = 'PROPERTY_BY_PROPERTY_ID__ARCHIVED_ASC',
  PropertyByPropertyIdArchivedDesc = 'PROPERTY_BY_PROPERTY_ID__ARCHIVED_DESC',
  PropertyByPropertyIdCityAsc = 'PROPERTY_BY_PROPERTY_ID__CITY_ASC',
  PropertyByPropertyIdCityDesc = 'PROPERTY_BY_PROPERTY_ID__CITY_DESC',
  PropertyByPropertyIdContactEmailAsc = 'PROPERTY_BY_PROPERTY_ID__CONTACT_EMAIL_ASC',
  PropertyByPropertyIdContactEmailDesc = 'PROPERTY_BY_PROPERTY_ID__CONTACT_EMAIL_DESC',
  PropertyByPropertyIdContactNumberAsc = 'PROPERTY_BY_PROPERTY_ID__CONTACT_NUMBER_ASC',
  PropertyByPropertyIdContactNumberDesc = 'PROPERTY_BY_PROPERTY_ID__CONTACT_NUMBER_DESC',
  PropertyByPropertyIdCountryIdAsc = 'PROPERTY_BY_PROPERTY_ID__COUNTRY_ID_ASC',
  PropertyByPropertyIdCountryIdDesc = 'PROPERTY_BY_PROPERTY_ID__COUNTRY_ID_DESC',
  PropertyByPropertyIdCreatedAsc = 'PROPERTY_BY_PROPERTY_ID__CREATED_ASC',
  PropertyByPropertyIdCreatedDesc = 'PROPERTY_BY_PROPERTY_ID__CREATED_DESC',
  PropertyByPropertyIdDestinationIdAsc = 'PROPERTY_BY_PROPERTY_ID__DESTINATION_ID_ASC',
  PropertyByPropertyIdDestinationIdDesc = 'PROPERTY_BY_PROPERTY_ID__DESTINATION_ID_DESC',
  PropertyByPropertyIdExternalReferenceAsc = 'PROPERTY_BY_PROPERTY_ID__EXTERNAL_REFERENCE_ASC',
  PropertyByPropertyIdExternalReferenceDesc = 'PROPERTY_BY_PROPERTY_ID__EXTERNAL_REFERENCE_DESC',
  PropertyByPropertyIdFeaturedAsc = 'PROPERTY_BY_PROPERTY_ID__FEATURED_ASC',
  PropertyByPropertyIdFeaturedDesc = 'PROPERTY_BY_PROPERTY_ID__FEATURED_DESC',
  PropertyByPropertyIdFeatureCopyAsc = 'PROPERTY_BY_PROPERTY_ID__FEATURE_COPY_ASC',
  PropertyByPropertyIdFeatureCopyDesc = 'PROPERTY_BY_PROPERTY_ID__FEATURE_COPY_DESC',
  PropertyByPropertyIdGalleryIdAsc = 'PROPERTY_BY_PROPERTY_ID__GALLERY_ID_ASC',
  PropertyByPropertyIdGalleryIdDesc = 'PROPERTY_BY_PROPERTY_ID__GALLERY_ID_DESC',
  PropertyByPropertyIdHeroMediaIdAsc = 'PROPERTY_BY_PROPERTY_ID__HERO_MEDIA_ID_ASC',
  PropertyByPropertyIdHeroMediaIdDesc = 'PROPERTY_BY_PROPERTY_ID__HERO_MEDIA_ID_DESC',
  PropertyByPropertyIdIdAsc = 'PROPERTY_BY_PROPERTY_ID__ID_ASC',
  PropertyByPropertyIdIdDesc = 'PROPERTY_BY_PROPERTY_ID__ID_DESC',
  PropertyByPropertyIdLatitudeAsc = 'PROPERTY_BY_PROPERTY_ID__LATITUDE_ASC',
  PropertyByPropertyIdLatitudeDesc = 'PROPERTY_BY_PROPERTY_ID__LATITUDE_DESC',
  PropertyByPropertyIdLongitudeAsc = 'PROPERTY_BY_PROPERTY_ID__LONGITUDE_ASC',
  PropertyByPropertyIdLongitudeDesc = 'PROPERTY_BY_PROPERTY_ID__LONGITUDE_DESC',
  PropertyByPropertyIdMapPointIdAsc = 'PROPERTY_BY_PROPERTY_ID__MAP_POINT_ID_ASC',
  PropertyByPropertyIdMapPointIdDesc = 'PROPERTY_BY_PROPERTY_ID__MAP_POINT_ID_DESC',
  PropertyByPropertyIdModifiedAsc = 'PROPERTY_BY_PROPERTY_ID__MODIFIED_ASC',
  PropertyByPropertyIdModifiedDesc = 'PROPERTY_BY_PROPERTY_ID__MODIFIED_DESC',
  PropertyByPropertyIdNameAsc = 'PROPERTY_BY_PROPERTY_ID__NAME_ASC',
  PropertyByPropertyIdNameDesc = 'PROPERTY_BY_PROPERTY_ID__NAME_DESC',
  PropertyByPropertyIdNearestAirportAsc = 'PROPERTY_BY_PROPERTY_ID__NEAREST_AIRPORT_ASC',
  PropertyByPropertyIdNearestAirportDesc = 'PROPERTY_BY_PROPERTY_ID__NEAREST_AIRPORT_DESC',
  PropertyByPropertyIdNotesAsc = 'PROPERTY_BY_PROPERTY_ID__NOTES_ASC',
  PropertyByPropertyIdNotesDesc = 'PROPERTY_BY_PROPERTY_ID__NOTES_DESC',
  PropertyByPropertyIdPlusCodeAsc = 'PROPERTY_BY_PROPERTY_ID__PLUS_CODE_ASC',
  PropertyByPropertyIdPlusCodeDesc = 'PROPERTY_BY_PROPERTY_ID__PLUS_CODE_DESC',
  PropertyByPropertyIdRegionAsc = 'PROPERTY_BY_PROPERTY_ID__REGION_ASC',
  PropertyByPropertyIdRegionDesc = 'PROPERTY_BY_PROPERTY_ID__REGION_DESC',
  PropertyByPropertyIdSummaryAsc = 'PROPERTY_BY_PROPERTY_ID__SUMMARY_ASC',
  PropertyByPropertyIdSummaryDesc = 'PROPERTY_BY_PROPERTY_ID__SUMMARY_DESC',
  PropertyByPropertyIdTimezoneAsc = 'PROPERTY_BY_PROPERTY_ID__TIMEZONE_ASC',
  PropertyByPropertyIdTimezoneDesc = 'PROPERTY_BY_PROPERTY_ID__TIMEZONE_DESC',
  PropertyByPropertyIdUrlAsc = 'PROPERTY_BY_PROPERTY_ID__URL_ASC',
  PropertyByPropertyIdUrlDesc = 'PROPERTY_BY_PROPERTY_ID__URL_DESC',
  PropertyIdAsc = 'PROPERTY_ID_ASC',
  PropertyIdDesc = 'PROPERTY_ID_DESC',
  QuoteAccommodationDetailByAccommodationIdBasisAsc = 'QUOTE_ACCOMMODATION_DETAIL_BY_ACCOMMODATION_ID__BASIS_ASC',
  QuoteAccommodationDetailByAccommodationIdBasisDesc = 'QUOTE_ACCOMMODATION_DETAIL_BY_ACCOMMODATION_ID__BASIS_DESC',
  QuoteAccommodationDetailByAccommodationIdBeverageInclusionsAsc = 'QUOTE_ACCOMMODATION_DETAIL_BY_ACCOMMODATION_ID__BEVERAGE_INCLUSIONS_ASC',
  QuoteAccommodationDetailByAccommodationIdBeverageInclusionsDesc = 'QUOTE_ACCOMMODATION_DETAIL_BY_ACCOMMODATION_ID__BEVERAGE_INCLUSIONS_DESC',
  QuoteAccommodationDetailByAccommodationIdConfirmationAsc = 'QUOTE_ACCOMMODATION_DETAIL_BY_ACCOMMODATION_ID__CONFIRMATION_ASC',
  QuoteAccommodationDetailByAccommodationIdConfirmationDesc = 'QUOTE_ACCOMMODATION_DETAIL_BY_ACCOMMODATION_ID__CONFIRMATION_DESC',
  QuoteAccommodationDetailByAccommodationIdFoodInclusionsAsc = 'QUOTE_ACCOMMODATION_DETAIL_BY_ACCOMMODATION_ID__FOOD_INCLUSIONS_ASC',
  QuoteAccommodationDetailByAccommodationIdFoodInclusionsDesc = 'QUOTE_ACCOMMODATION_DETAIL_BY_ACCOMMODATION_ID__FOOD_INCLUSIONS_DESC',
  QuoteAccommodationDetailByAccommodationIdIdAsc = 'QUOTE_ACCOMMODATION_DETAIL_BY_ACCOMMODATION_ID__ID_ASC',
  QuoteAccommodationDetailByAccommodationIdIdDesc = 'QUOTE_ACCOMMODATION_DETAIL_BY_ACCOMMODATION_ID__ID_DESC',
  QuoteAccommodationDetailByAccommodationIdNightsAsc = 'QUOTE_ACCOMMODATION_DETAIL_BY_ACCOMMODATION_ID__NIGHTS_ASC',
  QuoteAccommodationDetailByAccommodationIdNightsDesc = 'QUOTE_ACCOMMODATION_DETAIL_BY_ACCOMMODATION_ID__NIGHTS_DESC',
  QuoteAccommodationDetailByAccommodationIdNotesAsc = 'QUOTE_ACCOMMODATION_DETAIL_BY_ACCOMMODATION_ID__NOTES_ASC',
  QuoteAccommodationDetailByAccommodationIdNotesDesc = 'QUOTE_ACCOMMODATION_DETAIL_BY_ACCOMMODATION_ID__NOTES_DESC',
  QuoteAccommodationDetailByAccommodationIdPropertyIdAsc = 'QUOTE_ACCOMMODATION_DETAIL_BY_ACCOMMODATION_ID__PROPERTY_ID_ASC',
  QuoteAccommodationDetailByAccommodationIdPropertyIdDesc = 'QUOTE_ACCOMMODATION_DETAIL_BY_ACCOMMODATION_ID__PROPERTY_ID_DESC',
  QuoteAccommodationDetailByAccommodationIdQuoteIdAsc = 'QUOTE_ACCOMMODATION_DETAIL_BY_ACCOMMODATION_ID__QUOTE_ID_ASC',
  QuoteAccommodationDetailByAccommodationIdQuoteIdDesc = 'QUOTE_ACCOMMODATION_DETAIL_BY_ACCOMMODATION_ID__QUOTE_ID_DESC',
  QuoteAccommodationDetailByAccommodationIdRoomTypeAsc = 'QUOTE_ACCOMMODATION_DETAIL_BY_ACCOMMODATION_ID__ROOM_TYPE_ASC',
  QuoteAccommodationDetailByAccommodationIdRoomTypeDesc = 'QUOTE_ACCOMMODATION_DETAIL_BY_ACCOMMODATION_ID__ROOM_TYPE_DESC',
  QuoteAccommodationDetailByAccommodationIdSortOrderAsc = 'QUOTE_ACCOMMODATION_DETAIL_BY_ACCOMMODATION_ID__SORT_ORDER_ASC',
  QuoteAccommodationDetailByAccommodationIdSortOrderDesc = 'QUOTE_ACCOMMODATION_DETAIL_BY_ACCOMMODATION_ID__SORT_ORDER_DESC',
  QuoteAccommodationDetailByAccommodationIdSummaryAsc = 'QUOTE_ACCOMMODATION_DETAIL_BY_ACCOMMODATION_ID__SUMMARY_ASC',
  QuoteAccommodationDetailByAccommodationIdSummaryDesc = 'QUOTE_ACCOMMODATION_DETAIL_BY_ACCOMMODATION_ID__SUMMARY_DESC',
  QuoteByQuoteIdAdjustmentAsc = 'QUOTE_BY_QUOTE_ID__ADJUSTMENT_ASC',
  QuoteByQuoteIdAdjustmentDesc = 'QUOTE_BY_QUOTE_ID__ADJUSTMENT_DESC',
  QuoteByQuoteIdAgentMarginAsc = 'QUOTE_BY_QUOTE_ID__AGENT_MARGIN_ASC',
  QuoteByQuoteIdAgentMarginDesc = 'QUOTE_BY_QUOTE_ID__AGENT_MARGIN_DESC',
  QuoteByQuoteIdArchivedAsc = 'QUOTE_BY_QUOTE_ID__ARCHIVED_ASC',
  QuoteByQuoteIdArchivedDesc = 'QUOTE_BY_QUOTE_ID__ARCHIVED_DESC',
  QuoteByQuoteIdBaseCurrencyAsc = 'QUOTE_BY_QUOTE_ID__BASE_CURRENCY_ASC',
  QuoteByQuoteIdBaseCurrencyDesc = 'QUOTE_BY_QUOTE_ID__BASE_CURRENCY_DESC',
  QuoteByQuoteIdCreatedAsc = 'QUOTE_BY_QUOTE_ID__CREATED_ASC',
  QuoteByQuoteIdCreatedDesc = 'QUOTE_BY_QUOTE_ID__CREATED_DESC',
  QuoteByQuoteIdDepositAsc = 'QUOTE_BY_QUOTE_ID__DEPOSIT_ASC',
  QuoteByQuoteIdDepositDesc = 'QUOTE_BY_QUOTE_ID__DEPOSIT_DESC',
  QuoteByQuoteIdDurationAsc = 'QUOTE_BY_QUOTE_ID__DURATION_ASC',
  QuoteByQuoteIdDurationDesc = 'QUOTE_BY_QUOTE_ID__DURATION_DESC',
  QuoteByQuoteIdExclusionsAsc = 'QUOTE_BY_QUOTE_ID__EXCLUSIONS_ASC',
  QuoteByQuoteIdExclusionsDesc = 'QUOTE_BY_QUOTE_ID__EXCLUSIONS_DESC',
  QuoteByQuoteIdExpiresAsc = 'QUOTE_BY_QUOTE_ID__EXPIRES_ASC',
  QuoteByQuoteIdExpiresDesc = 'QUOTE_BY_QUOTE_ID__EXPIRES_DESC',
  QuoteByQuoteIdHeroIdAsc = 'QUOTE_BY_QUOTE_ID__HERO_ID_ASC',
  QuoteByQuoteIdHeroIdDesc = 'QUOTE_BY_QUOTE_ID__HERO_ID_DESC',
  QuoteByQuoteIdHeroImageIdAsc = 'QUOTE_BY_QUOTE_ID__HERO_IMAGE_ID_ASC',
  QuoteByQuoteIdHeroImageIdDesc = 'QUOTE_BY_QUOTE_ID__HERO_IMAGE_ID_DESC',
  QuoteByQuoteIdIdAsc = 'QUOTE_BY_QUOTE_ID__ID_ASC',
  QuoteByQuoteIdIdDesc = 'QUOTE_BY_QUOTE_ID__ID_DESC',
  QuoteByQuoteIdInclusionsAsc = 'QUOTE_BY_QUOTE_ID__INCLUSIONS_ASC',
  QuoteByQuoteIdInclusionsDesc = 'QUOTE_BY_QUOTE_ID__INCLUSIONS_DESC',
  QuoteByQuoteIdKeyAsc = 'QUOTE_BY_QUOTE_ID__KEY_ASC',
  QuoteByQuoteIdKeyDesc = 'QUOTE_BY_QUOTE_ID__KEY_DESC',
  QuoteByQuoteIdLockedAsc = 'QUOTE_BY_QUOTE_ID__LOCKED_ASC',
  QuoteByQuoteIdLockedDesc = 'QUOTE_BY_QUOTE_ID__LOCKED_DESC',
  QuoteByQuoteIdMarginAsc = 'QUOTE_BY_QUOTE_ID__MARGIN_ASC',
  QuoteByQuoteIdMarginDesc = 'QUOTE_BY_QUOTE_ID__MARGIN_DESC',
  QuoteByQuoteIdModifiedAsc = 'QUOTE_BY_QUOTE_ID__MODIFIED_ASC',
  QuoteByQuoteIdModifiedDesc = 'QUOTE_BY_QUOTE_ID__MODIFIED_DESC',
  QuoteByQuoteIdShortDescriptionAsc = 'QUOTE_BY_QUOTE_ID__SHORT_DESCRIPTION_ASC',
  QuoteByQuoteIdShortDescriptionDesc = 'QUOTE_BY_QUOTE_ID__SHORT_DESCRIPTION_DESC',
  QuoteByQuoteIdStartAsc = 'QUOTE_BY_QUOTE_ID__START_ASC',
  QuoteByQuoteIdStartDesc = 'QUOTE_BY_QUOTE_ID__START_DESC',
  QuoteByQuoteIdStatusAsc = 'QUOTE_BY_QUOTE_ID__STATUS_ASC',
  QuoteByQuoteIdStatusDesc = 'QUOTE_BY_QUOTE_ID__STATUS_DESC',
  QuoteByQuoteIdSummaryAsc = 'QUOTE_BY_QUOTE_ID__SUMMARY_ASC',
  QuoteByQuoteIdSummaryDesc = 'QUOTE_BY_QUOTE_ID__SUMMARY_DESC',
  QuoteByQuoteIdTravellerCountAsc = 'QUOTE_BY_QUOTE_ID__TRAVELLER_COUNT_ASC',
  QuoteByQuoteIdTravellerCountDesc = 'QUOTE_BY_QUOTE_ID__TRAVELLER_COUNT_DESC',
  QuoteByQuoteIdTripIdAsc = 'QUOTE_BY_QUOTE_ID__TRIP_ID_ASC',
  QuoteByQuoteIdTripIdDesc = 'QUOTE_BY_QUOTE_ID__TRIP_ID_DESC',
  QuoteByQuoteIdUserIdAsc = 'QUOTE_BY_QUOTE_ID__USER_ID_ASC',
  QuoteByQuoteIdUserIdDesc = 'QUOTE_BY_QUOTE_ID__USER_ID_DESC',
  QuoteDayDestinationsByDayIdCountAsc = 'QUOTE_DAY_DESTINATIONS_BY_DAY_ID__COUNT_ASC',
  QuoteDayDestinationsByDayIdCountDesc = 'QUOTE_DAY_DESTINATIONS_BY_DAY_ID__COUNT_DESC',
  QuoteIdAsc = 'QUOTE_ID_ASC',
  QuoteIdDesc = 'QUOTE_ID_DESC',
  QuotePublicByQuoteIdAcceptedAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__ACCEPTED_ASC',
  QuotePublicByQuoteIdAcceptedDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__ACCEPTED_DESC',
  QuotePublicByQuoteIdBaseCurrencyAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__BASE_CURRENCY_ASC',
  QuotePublicByQuoteIdBaseCurrencyDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__BASE_CURRENCY_DESC',
  QuotePublicByQuoteIdDepositAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__DEPOSIT_ASC',
  QuotePublicByQuoteIdDepositDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__DEPOSIT_DESC',
  QuotePublicByQuoteIdDurationAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__DURATION_ASC',
  QuotePublicByQuoteIdDurationDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__DURATION_DESC',
  QuotePublicByQuoteIdExclusionsAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__EXCLUSIONS_ASC',
  QuotePublicByQuoteIdExclusionsDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__EXCLUSIONS_DESC',
  QuotePublicByQuoteIdExpiresAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__EXPIRES_ASC',
  QuotePublicByQuoteIdExpiresDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__EXPIRES_DESC',
  QuotePublicByQuoteIdHeroIdAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__HERO_ID_ASC',
  QuotePublicByQuoteIdHeroIdDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__HERO_ID_DESC',
  QuotePublicByQuoteIdIdAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__ID_ASC',
  QuotePublicByQuoteIdIdDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__ID_DESC',
  QuotePublicByQuoteIdInclusionsAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__INCLUSIONS_ASC',
  QuotePublicByQuoteIdInclusionsDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__INCLUSIONS_DESC',
  QuotePublicByQuoteIdKeyAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__KEY_ASC',
  QuotePublicByQuoteIdKeyDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__KEY_DESC',
  QuotePublicByQuoteIdLockedAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__LOCKED_ASC',
  QuotePublicByQuoteIdLockedDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__LOCKED_DESC',
  QuotePublicByQuoteIdStartAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__START_ASC',
  QuotePublicByQuoteIdStartDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__START_DESC',
  QuotePublicByQuoteIdStatusAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__STATUS_ASC',
  QuotePublicByQuoteIdStatusDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__STATUS_DESC',
  QuotePublicByQuoteIdTotalAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__TOTAL_ASC',
  QuotePublicByQuoteIdTotalDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__TOTAL_DESC',
  QuotePublicByQuoteIdTravellerCountAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__TRAVELLER_COUNT_ASC',
  QuotePublicByQuoteIdTravellerCountDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__TRAVELLER_COUNT_DESC',
  QuotePublicByQuoteIdTripIdAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__TRIP_ID_ASC',
  QuotePublicByQuoteIdTripIdDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__TRIP_ID_DESC',
  QuotePublicByQuoteIdUserIdAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__USER_ID_ASC',
  QuotePublicByQuoteIdUserIdDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__USER_ID_DESC',
  SortOrderAsc = 'SORT_ORDER_ASC',
  SortOrderDesc = 'SORT_ORDER_DESC'
}

/** A filter to be used against `Quote` object types. All fields are combined with a logical ‘and.’ */
export type QuoteFilter = {
  /** Filter by the object’s `adjustment` field. */
  adjustment?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `agentMargin` field. */
  agentMargin?: InputMaybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<QuoteFilter>>;
  /** Filter by the object’s `archived` field. */
  archived?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `baseCurrency` field. */
  baseCurrency?: InputMaybe<StringFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `deposit` field. */
  deposit?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `duration` field. */
  duration?: InputMaybe<IntFilter>;
  /** Filter by the object’s `emails` relation. */
  emails?: InputMaybe<QuoteToManyEmailFilter>;
  /** Some related `emails` exist. */
  emailsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `exclusions` field. */
  exclusions?: InputMaybe<StringFilter>;
  /** Filter by the object’s `expires` field. */
  expires?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `hero` relation. */
  hero?: InputMaybe<QuoteHeroFilter>;
  /** A related `hero` exists. */
  heroExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `heroId` field. */
  heroId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `heroImage` relation. */
  heroImage?: InputMaybe<MediaItemFilter>;
  /** A related `heroImage` exists. */
  heroImageExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `heroImageId` field. */
  heroImageId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `inclusions` field. */
  inclusions?: InputMaybe<StringFilter>;
  /** Filter by the object’s `invoices` relation. */
  invoices?: InputMaybe<QuoteToManyInvoiceFilter>;
  /** Some related `invoices` exist. */
  invoicesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `key` field. */
  key?: InputMaybe<StringFilter>;
  /** Filter by the object’s `lastViewed` field. */
  lastViewed?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `locked` field. */
  locked?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `margin` field. */
  margin?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<QuoteFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<QuoteFilter>>;
  /** Filter by the object’s `quoteAcceptances` relation. */
  quoteAcceptances?: InputMaybe<QuoteToManyQuoteAcceptanceFilter>;
  /** Some related `quoteAcceptances` exist. */
  quoteAcceptancesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `quoteAccommodationDetails` relation. */
  quoteAccommodationDetails?: InputMaybe<QuoteToManyQuoteAccommodationDetailFilter>;
  /** Some related `quoteAccommodationDetails` exist. */
  quoteAccommodationDetailsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `quoteCurrencies` relation. */
  quoteCurrencies?: InputMaybe<QuoteToManyQuoteCurrencyFilter>;
  /** Some related `quoteCurrencies` exist. */
  quoteCurrenciesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `quoteDays` relation. */
  quoteDays?: InputMaybe<QuoteToManyQuoteDayFilter>;
  /** Some related `quoteDays` exist. */
  quoteDaysExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `quoteFinanceLineItems` relation. */
  quoteFinanceLineItems?: InputMaybe<QuoteToManyQuoteFinanceLineItemFilter>;
  /** Some related `quoteFinanceLineItems` exist. */
  quoteFinanceLineItemsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `quoteLegalDocuments` relation. */
  quoteLegalDocuments?: InputMaybe<QuoteToManyQuoteLegalDocumentFilter>;
  /** Some related `quoteLegalDocuments` exist. */
  quoteLegalDocumentsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `quoteStatusByStatus` relation. */
  quoteStatusByStatus?: InputMaybe<QuoteStatusFilter>;
  /** Filter by the object’s `quoteViews` relation. */
  quoteViews?: InputMaybe<QuoteToManyQuoteViewFilter>;
  /** Some related `quoteViews` exist. */
  quoteViewsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `shortDescription` field. */
  shortDescription?: InputMaybe<StringFilter>;
  /** Filter by the object’s `start` field. */
  start?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `status` field. */
  status?: InputMaybe<IntFilter>;
  /** Filter by the object’s `summary` field. */
  summary?: InputMaybe<StringFilter>;
  /** Filter by the object’s `total` field. */
  total?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `travellerCount` field. */
  travellerCount?: InputMaybe<IntFilter>;
  /** Filter by the object’s `trip` relation. */
  trip?: InputMaybe<TripFilter>;
  /** Filter by the object’s `tripId` field. */
  tripId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `tripsByActiveQuoteId` relation. */
  tripsByActiveQuoteId?: InputMaybe<QuoteToManyTripFilter>;
  /** Some related `tripsByActiveQuoteId` exist. */
  tripsByActiveQuoteIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `user` relation. */
  user?: InputMaybe<UserFilter>;
  /** A related `user` exists. */
  userExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<UuidFilter>;
};

export type QuoteFinanceLineItem = {
  __typename?: 'QuoteFinanceLineItem';
  amount: Scalars['BigFloat']['output'];
  confirmation?: Maybe<Scalars['String']['output']>;
  currency?: Maybe<Scalars['String']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  excludeMargin: Scalars['Boolean']['output'];
  id: Scalars['UUID']['output'];
  marginOverride?: Maybe<Scalars['BigFloat']['output']>;
  notes?: Maybe<Scalars['String']['output']>;
  quantity: Scalars['Int']['output'];
  /** Reads a single `Quote` that is related to this `QuoteFinanceLineItem`. */
  quote?: Maybe<Quote>;
  quoteId?: Maybe<Scalars['UUID']['output']>;
  sortOrder: Scalars['Int']['output'];
  /** Reads a single `Supplier` that is related to this `QuoteFinanceLineItem`. */
  supplier?: Maybe<Supplier>;
  supplierId: Scalars['UUID']['output'];
};

/**
 * A condition to be used against `QuoteFinanceLineItem` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type QuoteFinanceLineItemCondition = {
  /** Checks for equality with the object’s `amount` field. */
  amount?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `confirmation` field. */
  confirmation?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `currency` field. */
  currency?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `excludeMargin` field. */
  excludeMargin?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `marginOverride` field. */
  marginOverride?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `quantity` field. */
  quantity?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `quoteId` field. */
  quoteId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `sortOrder` field. */
  sortOrder?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `supplierId` field. */
  supplierId?: InputMaybe<Scalars['UUID']['input']>;
};

/** A filter to be used against `QuoteFinanceLineItem` object types. All fields are combined with a logical ‘and.’ */
export type QuoteFinanceLineItemFilter = {
  /** Filter by the object’s `amount` field. */
  amount?: InputMaybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<QuoteFinanceLineItemFilter>>;
  /** Filter by the object’s `confirmation` field. */
  confirmation?: InputMaybe<StringFilter>;
  /** Filter by the object’s `currency` field. */
  currency?: InputMaybe<StringFilter>;
  /** Filter by the object’s `description` field. */
  description?: InputMaybe<StringFilter>;
  /** Filter by the object’s `excludeMargin` field. */
  excludeMargin?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `marginOverride` field. */
  marginOverride?: InputMaybe<BigFloatFilter>;
  /** Negates the expression. */
  not?: InputMaybe<QuoteFinanceLineItemFilter>;
  /** Filter by the object’s `notes` field. */
  notes?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<QuoteFinanceLineItemFilter>>;
  /** Filter by the object’s `quantity` field. */
  quantity?: InputMaybe<IntFilter>;
  /** Filter by the object’s `quote` relation. */
  quote?: InputMaybe<QuoteFilter>;
  /** A related `quote` exists. */
  quoteExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `quoteId` field. */
  quoteId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `sortOrder` field. */
  sortOrder?: InputMaybe<IntFilter>;
  /** Filter by the object’s `supplier` relation. */
  supplier?: InputMaybe<SupplierFilter>;
  /** Filter by the object’s `supplierId` field. */
  supplierId?: InputMaybe<UuidFilter>;
};

/** An input for mutations affecting `QuoteFinanceLineItem` */
export type QuoteFinanceLineItemInput = {
  amount: Scalars['BigFloat']['input'];
  confirmation?: InputMaybe<Scalars['String']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  excludeMargin?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  marginOverride?: InputMaybe<Scalars['BigFloat']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  quantity: Scalars['Int']['input'];
  quoteId?: InputMaybe<Scalars['UUID']['input']>;
  quoteToQuoteId?: InputMaybe<FkQuoteFinanceLineItemQuoteQuoteIdInput>;
  sortOrder: Scalars['Int']['input'];
  supplierId?: InputMaybe<Scalars['UUID']['input']>;
  supplierToSupplierId?: InputMaybe<FkQuoteFinanceLineItemSupplierSupplierIdInput>;
};

/** The fields on `quoteFinanceLineItem` to look up the row to update. */
export type QuoteFinanceLineItemOnQuoteFinanceLineItemForFkQuoteFinanceLineItemQuoteQuoteIdUsingPkQuoteFinanceLineItemUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `quoteFinanceLineItem` being updated. */
  patch: UpdateQuoteFinanceLineItemOnQuoteFinanceLineItemForFkQuoteFinanceLineItemQuoteQuoteIdPatch;
};

/** The fields on `quoteFinanceLineItem` to look up the row to update. */
export type QuoteFinanceLineItemOnQuoteFinanceLineItemForFkQuoteFinanceLineItemSupplierSupplierIdUsingPkQuoteFinanceLineItemUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `quoteFinanceLineItem` being updated. */
  patch: UpdateQuoteFinanceLineItemOnQuoteFinanceLineItemForFkQuoteFinanceLineItemSupplierSupplierIdPatch;
};

/** Represents an update to a `QuoteFinanceLineItem`. Fields that are set will be updated. */
export type QuoteFinanceLineItemPatch = {
  amount?: InputMaybe<Scalars['BigFloat']['input']>;
  confirmation?: InputMaybe<Scalars['String']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  excludeMargin?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  marginOverride?: InputMaybe<Scalars['BigFloat']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  quoteId?: InputMaybe<Scalars['UUID']['input']>;
  quoteToQuoteId?: InputMaybe<FkQuoteFinanceLineItemQuoteQuoteIdInput>;
  sortOrder?: InputMaybe<Scalars['Int']['input']>;
  supplierId?: InputMaybe<Scalars['UUID']['input']>;
  supplierToSupplierId?: InputMaybe<FkQuoteFinanceLineItemSupplierSupplierIdInput>;
};

/** The fields on `quoteFinanceLineItem` to look up the row to connect. */
export type QuoteFinanceLineItemPkQuoteFinanceLineItemConnect = {
  id: Scalars['UUID']['input'];
};

/** The fields on `quoteFinanceLineItem` to look up the row to delete. */
export type QuoteFinanceLineItemPkQuoteFinanceLineItemDelete = {
  id: Scalars['UUID']['input'];
};

/** A connection to a list of `QuoteFinanceLineItemSummary` values. */
export type QuoteFinanceLineItemSummariesConnection = {
  __typename?: 'QuoteFinanceLineItemSummariesConnection';
  /** A list of edges which contains the `QuoteFinanceLineItemSummary` and cursor to aid in pagination. */
  edges: Array<QuoteFinanceLineItemSummariesEdge>;
  /** A list of `QuoteFinanceLineItemSummary` objects. */
  nodes: Array<Maybe<QuoteFinanceLineItemSummary>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `QuoteFinanceLineItemSummary` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `QuoteFinanceLineItemSummary` edge in the connection. */
export type QuoteFinanceLineItemSummariesEdge = {
  __typename?: 'QuoteFinanceLineItemSummariesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `QuoteFinanceLineItemSummary` at the end of the edge. */
  node?: Maybe<QuoteFinanceLineItemSummary>;
};

/** Methods to use when ordering `QuoteFinanceLineItemSummary`. */
export enum QuoteFinanceLineItemSummariesOrderBy {
  AgentMarginAmountActualAsc = 'AGENT_MARGIN_AMOUNT_ACTUAL_ASC',
  AgentMarginAmountActualDesc = 'AGENT_MARGIN_AMOUNT_ACTUAL_DESC',
  AgentMarginAmountAsc = 'AGENT_MARGIN_AMOUNT_ASC',
  AgentMarginAmountDesc = 'AGENT_MARGIN_AMOUNT_DESC',
  CurrencyActualAsc = 'CURRENCY_ACTUAL_ASC',
  CurrencyActualDesc = 'CURRENCY_ACTUAL_DESC',
  CurrencyAsc = 'CURRENCY_ASC',
  CurrencyDesc = 'CURRENCY_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  MarginAmountActualAsc = 'MARGIN_AMOUNT_ACTUAL_ASC',
  MarginAmountActualDesc = 'MARGIN_AMOUNT_ACTUAL_DESC',
  MarginAmountAsc = 'MARGIN_AMOUNT_ASC',
  MarginAmountDesc = 'MARGIN_AMOUNT_DESC',
  Natural = 'NATURAL',
  QuoteIdAsc = 'QUOTE_ID_ASC',
  QuoteIdDesc = 'QUOTE_ID_DESC',
  SubtotalAsc = 'SUBTOTAL_ASC',
  SubtotalDesc = 'SUBTOTAL_DESC',
  TotalActualAsc = 'TOTAL_ACTUAL_ASC',
  TotalActualDesc = 'TOTAL_ACTUAL_DESC',
  TotalAsc = 'TOTAL_ASC',
  TotalDesc = 'TOTAL_DESC'
}

export type QuoteFinanceLineItemSummary = {
  __typename?: 'QuoteFinanceLineItemSummary';
  agentMarginAmount?: Maybe<Scalars['BigFloat']['output']>;
  agentMarginAmountActual?: Maybe<Scalars['BigFloat']['output']>;
  currency?: Maybe<Scalars['String']['output']>;
  currencyActual?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['UUID']['output']>;
  marginAmount?: Maybe<Scalars['BigFloat']['output']>;
  marginAmountActual?: Maybe<Scalars['BigFloat']['output']>;
  quoteId?: Maybe<Scalars['UUID']['output']>;
  subtotal?: Maybe<Scalars['BigFloat']['output']>;
  total?: Maybe<Scalars['BigFloat']['output']>;
  totalActual?: Maybe<Scalars['BigFloat']['output']>;
};

/**
 * A condition to be used against `QuoteFinanceLineItemSummary` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type QuoteFinanceLineItemSummaryCondition = {
  /** Checks for equality with the object’s `agentMarginAmount` field. */
  agentMarginAmount?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `agentMarginAmountActual` field. */
  agentMarginAmountActual?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `currency` field. */
  currency?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `currencyActual` field. */
  currencyActual?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `marginAmount` field. */
  marginAmount?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `marginAmountActual` field. */
  marginAmountActual?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `quoteId` field. */
  quoteId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `subtotal` field. */
  subtotal?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `total` field. */
  total?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `totalActual` field. */
  totalActual?: InputMaybe<Scalars['BigFloat']['input']>;
};

/** A filter to be used against `QuoteFinanceLineItemSummary` object types. All fields are combined with a logical ‘and.’ */
export type QuoteFinanceLineItemSummaryFilter = {
  /** Filter by the object’s `agentMarginAmount` field. */
  agentMarginAmount?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `agentMarginAmountActual` field. */
  agentMarginAmountActual?: InputMaybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<QuoteFinanceLineItemSummaryFilter>>;
  /** Filter by the object’s `currency` field. */
  currency?: InputMaybe<StringFilter>;
  /** Filter by the object’s `currencyActual` field. */
  currencyActual?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `marginAmount` field. */
  marginAmount?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `marginAmountActual` field. */
  marginAmountActual?: InputMaybe<BigFloatFilter>;
  /** Negates the expression. */
  not?: InputMaybe<QuoteFinanceLineItemSummaryFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<QuoteFinanceLineItemSummaryFilter>>;
  /** Filter by the object’s `quoteId` field. */
  quoteId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `subtotal` field. */
  subtotal?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `total` field. */
  total?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `totalActual` field. */
  totalActual?: InputMaybe<BigFloatFilter>;
};

/** A connection to a list of `QuoteFinanceLineItem` values. */
export type QuoteFinanceLineItemsConnection = {
  __typename?: 'QuoteFinanceLineItemsConnection';
  /** A list of edges which contains the `QuoteFinanceLineItem` and cursor to aid in pagination. */
  edges: Array<QuoteFinanceLineItemsEdge>;
  /** A list of `QuoteFinanceLineItem` objects. */
  nodes: Array<Maybe<QuoteFinanceLineItem>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `QuoteFinanceLineItem` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `QuoteFinanceLineItem` edge in the connection. */
export type QuoteFinanceLineItemsEdge = {
  __typename?: 'QuoteFinanceLineItemsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `QuoteFinanceLineItem` at the end of the edge. */
  node?: Maybe<QuoteFinanceLineItem>;
};

/** Methods to use when ordering `QuoteFinanceLineItem`. */
export enum QuoteFinanceLineItemsOrderBy {
  AmountAsc = 'AMOUNT_ASC',
  AmountDesc = 'AMOUNT_DESC',
  ConfirmationAsc = 'CONFIRMATION_ASC',
  ConfirmationDesc = 'CONFIRMATION_DESC',
  CurrencyAsc = 'CURRENCY_ASC',
  CurrencyDesc = 'CURRENCY_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  ExcludeMarginAsc = 'EXCLUDE_MARGIN_ASC',
  ExcludeMarginDesc = 'EXCLUDE_MARGIN_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  MarginOverrideAsc = 'MARGIN_OVERRIDE_ASC',
  MarginOverrideDesc = 'MARGIN_OVERRIDE_DESC',
  Natural = 'NATURAL',
  NotesAsc = 'NOTES_ASC',
  NotesDesc = 'NOTES_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QuantityAsc = 'QUANTITY_ASC',
  QuantityDesc = 'QUANTITY_DESC',
  QuoteByQuoteIdAdjustmentAsc = 'QUOTE_BY_QUOTE_ID__ADJUSTMENT_ASC',
  QuoteByQuoteIdAdjustmentDesc = 'QUOTE_BY_QUOTE_ID__ADJUSTMENT_DESC',
  QuoteByQuoteIdAgentMarginAsc = 'QUOTE_BY_QUOTE_ID__AGENT_MARGIN_ASC',
  QuoteByQuoteIdAgentMarginDesc = 'QUOTE_BY_QUOTE_ID__AGENT_MARGIN_DESC',
  QuoteByQuoteIdArchivedAsc = 'QUOTE_BY_QUOTE_ID__ARCHIVED_ASC',
  QuoteByQuoteIdArchivedDesc = 'QUOTE_BY_QUOTE_ID__ARCHIVED_DESC',
  QuoteByQuoteIdBaseCurrencyAsc = 'QUOTE_BY_QUOTE_ID__BASE_CURRENCY_ASC',
  QuoteByQuoteIdBaseCurrencyDesc = 'QUOTE_BY_QUOTE_ID__BASE_CURRENCY_DESC',
  QuoteByQuoteIdCreatedAsc = 'QUOTE_BY_QUOTE_ID__CREATED_ASC',
  QuoteByQuoteIdCreatedDesc = 'QUOTE_BY_QUOTE_ID__CREATED_DESC',
  QuoteByQuoteIdDepositAsc = 'QUOTE_BY_QUOTE_ID__DEPOSIT_ASC',
  QuoteByQuoteIdDepositDesc = 'QUOTE_BY_QUOTE_ID__DEPOSIT_DESC',
  QuoteByQuoteIdDurationAsc = 'QUOTE_BY_QUOTE_ID__DURATION_ASC',
  QuoteByQuoteIdDurationDesc = 'QUOTE_BY_QUOTE_ID__DURATION_DESC',
  QuoteByQuoteIdExclusionsAsc = 'QUOTE_BY_QUOTE_ID__EXCLUSIONS_ASC',
  QuoteByQuoteIdExclusionsDesc = 'QUOTE_BY_QUOTE_ID__EXCLUSIONS_DESC',
  QuoteByQuoteIdExpiresAsc = 'QUOTE_BY_QUOTE_ID__EXPIRES_ASC',
  QuoteByQuoteIdExpiresDesc = 'QUOTE_BY_QUOTE_ID__EXPIRES_DESC',
  QuoteByQuoteIdHeroIdAsc = 'QUOTE_BY_QUOTE_ID__HERO_ID_ASC',
  QuoteByQuoteIdHeroIdDesc = 'QUOTE_BY_QUOTE_ID__HERO_ID_DESC',
  QuoteByQuoteIdHeroImageIdAsc = 'QUOTE_BY_QUOTE_ID__HERO_IMAGE_ID_ASC',
  QuoteByQuoteIdHeroImageIdDesc = 'QUOTE_BY_QUOTE_ID__HERO_IMAGE_ID_DESC',
  QuoteByQuoteIdIdAsc = 'QUOTE_BY_QUOTE_ID__ID_ASC',
  QuoteByQuoteIdIdDesc = 'QUOTE_BY_QUOTE_ID__ID_DESC',
  QuoteByQuoteIdInclusionsAsc = 'QUOTE_BY_QUOTE_ID__INCLUSIONS_ASC',
  QuoteByQuoteIdInclusionsDesc = 'QUOTE_BY_QUOTE_ID__INCLUSIONS_DESC',
  QuoteByQuoteIdKeyAsc = 'QUOTE_BY_QUOTE_ID__KEY_ASC',
  QuoteByQuoteIdKeyDesc = 'QUOTE_BY_QUOTE_ID__KEY_DESC',
  QuoteByQuoteIdLockedAsc = 'QUOTE_BY_QUOTE_ID__LOCKED_ASC',
  QuoteByQuoteIdLockedDesc = 'QUOTE_BY_QUOTE_ID__LOCKED_DESC',
  QuoteByQuoteIdMarginAsc = 'QUOTE_BY_QUOTE_ID__MARGIN_ASC',
  QuoteByQuoteIdMarginDesc = 'QUOTE_BY_QUOTE_ID__MARGIN_DESC',
  QuoteByQuoteIdModifiedAsc = 'QUOTE_BY_QUOTE_ID__MODIFIED_ASC',
  QuoteByQuoteIdModifiedDesc = 'QUOTE_BY_QUOTE_ID__MODIFIED_DESC',
  QuoteByQuoteIdShortDescriptionAsc = 'QUOTE_BY_QUOTE_ID__SHORT_DESCRIPTION_ASC',
  QuoteByQuoteIdShortDescriptionDesc = 'QUOTE_BY_QUOTE_ID__SHORT_DESCRIPTION_DESC',
  QuoteByQuoteIdStartAsc = 'QUOTE_BY_QUOTE_ID__START_ASC',
  QuoteByQuoteIdStartDesc = 'QUOTE_BY_QUOTE_ID__START_DESC',
  QuoteByQuoteIdStatusAsc = 'QUOTE_BY_QUOTE_ID__STATUS_ASC',
  QuoteByQuoteIdStatusDesc = 'QUOTE_BY_QUOTE_ID__STATUS_DESC',
  QuoteByQuoteIdSummaryAsc = 'QUOTE_BY_QUOTE_ID__SUMMARY_ASC',
  QuoteByQuoteIdSummaryDesc = 'QUOTE_BY_QUOTE_ID__SUMMARY_DESC',
  QuoteByQuoteIdTravellerCountAsc = 'QUOTE_BY_QUOTE_ID__TRAVELLER_COUNT_ASC',
  QuoteByQuoteIdTravellerCountDesc = 'QUOTE_BY_QUOTE_ID__TRAVELLER_COUNT_DESC',
  QuoteByQuoteIdTripIdAsc = 'QUOTE_BY_QUOTE_ID__TRIP_ID_ASC',
  QuoteByQuoteIdTripIdDesc = 'QUOTE_BY_QUOTE_ID__TRIP_ID_DESC',
  QuoteByQuoteIdUserIdAsc = 'QUOTE_BY_QUOTE_ID__USER_ID_ASC',
  QuoteByQuoteIdUserIdDesc = 'QUOTE_BY_QUOTE_ID__USER_ID_DESC',
  QuoteIdAsc = 'QUOTE_ID_ASC',
  QuoteIdDesc = 'QUOTE_ID_DESC',
  SortOrderAsc = 'SORT_ORDER_ASC',
  SortOrderDesc = 'SORT_ORDER_DESC',
  SupplierBySupplierIdBankDetailsAsc = 'SUPPLIER_BY_SUPPLIER_ID__BANK_DETAILS_ASC',
  SupplierBySupplierIdBankDetailsDesc = 'SUPPLIER_BY_SUPPLIER_ID__BANK_DETAILS_DESC',
  SupplierBySupplierIdContactEmailAsc = 'SUPPLIER_BY_SUPPLIER_ID__CONTACT_EMAIL_ASC',
  SupplierBySupplierIdContactEmailDesc = 'SUPPLIER_BY_SUPPLIER_ID__CONTACT_EMAIL_DESC',
  SupplierBySupplierIdContactNumberAsc = 'SUPPLIER_BY_SUPPLIER_ID__CONTACT_NUMBER_ASC',
  SupplierBySupplierIdContactNumberDesc = 'SUPPLIER_BY_SUPPLIER_ID__CONTACT_NUMBER_DESC',
  SupplierBySupplierIdCreatedAsc = 'SUPPLIER_BY_SUPPLIER_ID__CREATED_ASC',
  SupplierBySupplierIdCreatedDesc = 'SUPPLIER_BY_SUPPLIER_ID__CREATED_DESC',
  SupplierBySupplierIdGalleryIdAsc = 'SUPPLIER_BY_SUPPLIER_ID__GALLERY_ID_ASC',
  SupplierBySupplierIdGalleryIdDesc = 'SUPPLIER_BY_SUPPLIER_ID__GALLERY_ID_DESC',
  SupplierBySupplierIdIdAsc = 'SUPPLIER_BY_SUPPLIER_ID__ID_ASC',
  SupplierBySupplierIdIdDesc = 'SUPPLIER_BY_SUPPLIER_ID__ID_DESC',
  SupplierBySupplierIdModifiedAsc = 'SUPPLIER_BY_SUPPLIER_ID__MODIFIED_ASC',
  SupplierBySupplierIdModifiedDesc = 'SUPPLIER_BY_SUPPLIER_ID__MODIFIED_DESC',
  SupplierBySupplierIdNameAsc = 'SUPPLIER_BY_SUPPLIER_ID__NAME_ASC',
  SupplierBySupplierIdNameDesc = 'SUPPLIER_BY_SUPPLIER_ID__NAME_DESC',
  SupplierBySupplierIdRegionAsc = 'SUPPLIER_BY_SUPPLIER_ID__REGION_ASC',
  SupplierBySupplierIdRegionDesc = 'SUPPLIER_BY_SUPPLIER_ID__REGION_DESC',
  SupplierBySupplierIdUrlAsc = 'SUPPLIER_BY_SUPPLIER_ID__URL_ASC',
  SupplierBySupplierIdUrlDesc = 'SUPPLIER_BY_SUPPLIER_ID__URL_DESC',
  SupplierIdAsc = 'SUPPLIER_ID_ASC',
  SupplierIdDesc = 'SUPPLIER_ID_DESC'
}

/** A connection to a list of `QuoteFinanceSummary` values. */
export type QuoteFinanceSummariesConnection = {
  __typename?: 'QuoteFinanceSummariesConnection';
  /** A list of edges which contains the `QuoteFinanceSummary` and cursor to aid in pagination. */
  edges: Array<QuoteFinanceSummariesEdge>;
  /** A list of `QuoteFinanceSummary` objects. */
  nodes: Array<Maybe<QuoteFinanceSummary>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `QuoteFinanceSummary` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `QuoteFinanceSummary` edge in the connection. */
export type QuoteFinanceSummariesEdge = {
  __typename?: 'QuoteFinanceSummariesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `QuoteFinanceSummary` at the end of the edge. */
  node?: Maybe<QuoteFinanceSummary>;
};

/** Methods to use when ordering `QuoteFinanceSummary`. */
export enum QuoteFinanceSummariesOrderBy {
  AgentMarginActualAsc = 'AGENT_MARGIN_ACTUAL_ASC',
  AgentMarginActualDesc = 'AGENT_MARGIN_ACTUAL_DESC',
  CurrencyAsc = 'CURRENCY_ASC',
  CurrencyDesc = 'CURRENCY_DESC',
  MarginActualAsc = 'MARGIN_ACTUAL_ASC',
  MarginActualDesc = 'MARGIN_ACTUAL_DESC',
  Natural = 'NATURAL',
  QuoteIdAsc = 'QUOTE_ID_ASC',
  QuoteIdDesc = 'QUOTE_ID_DESC',
  TotalActualAsc = 'TOTAL_ACTUAL_ASC',
  TotalActualDesc = 'TOTAL_ACTUAL_DESC'
}

export type QuoteFinanceSummary = {
  __typename?: 'QuoteFinanceSummary';
  agentMarginActual?: Maybe<Scalars['BigFloat']['output']>;
  currency?: Maybe<Scalars['String']['output']>;
  marginActual?: Maybe<Scalars['BigFloat']['output']>;
  quoteId?: Maybe<Scalars['UUID']['output']>;
  totalActual?: Maybe<Scalars['BigFloat']['output']>;
};

/**
 * A condition to be used against `QuoteFinanceSummary` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type QuoteFinanceSummaryCondition = {
  /** Checks for equality with the object’s `agentMarginActual` field. */
  agentMarginActual?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `currency` field. */
  currency?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `marginActual` field. */
  marginActual?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `quoteId` field. */
  quoteId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `totalActual` field. */
  totalActual?: InputMaybe<Scalars['BigFloat']['input']>;
};

/** A filter to be used against `QuoteFinanceSummary` object types. All fields are combined with a logical ‘and.’ */
export type QuoteFinanceSummaryFilter = {
  /** Filter by the object’s `agentMarginActual` field. */
  agentMarginActual?: InputMaybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<QuoteFinanceSummaryFilter>>;
  /** Filter by the object’s `currency` field. */
  currency?: InputMaybe<StringFilter>;
  /** Filter by the object’s `marginActual` field. */
  marginActual?: InputMaybe<BigFloatFilter>;
  /** Negates the expression. */
  not?: InputMaybe<QuoteFinanceSummaryFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<QuoteFinanceSummaryFilter>>;
  /** Filter by the object’s `quoteId` field. */
  quoteId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `totalActual` field. */
  totalActual?: InputMaybe<BigFloatFilter>;
};

export type QuoteHero = {
  __typename?: 'QuoteHero';
  id: Scalars['UUID']['output'];
  /** Reads a single `MediaItem` that is related to this `QuoteHero`. */
  image?: Maybe<MediaItem>;
  imageId?: Maybe<Scalars['UUID']['output']>;
  /** Reads and enables pagination through a set of `QuotePublic`. */
  quotePublicsByHeroId: QuotePublicsConnection;
  /** Reads and enables pagination through a set of `Quote`. */
  quotesByHeroId: QuotesConnection;
  style?: Maybe<Scalars['String']['output']>;
  subtitle?: Maybe<Scalars['String']['output']>;
  title?: Maybe<Scalars['String']['output']>;
};


export type QuoteHeroQuotePublicsByHeroIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<QuotePublicCondition>;
  filter?: InputMaybe<QuotePublicFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuotePublicsOrderBy>>;
};


export type QuoteHeroQuotesByHeroIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<QuoteCondition>;
  filter?: InputMaybe<QuoteFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuotesOrderBy>>;
};

/**
 * A condition to be used against `QuoteHero` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type QuoteHeroCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `imageId` field. */
  imageId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `style` field. */
  style?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `subtitle` field. */
  subtitle?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `title` field. */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `QuoteHero` object types. All fields are combined with a logical ‘and.’ */
export type QuoteHeroFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<QuoteHeroFilter>>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `image` relation. */
  image?: InputMaybe<MediaItemFilter>;
  /** A related `image` exists. */
  imageExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `imageId` field. */
  imageId?: InputMaybe<UuidFilter>;
  /** Negates the expression. */
  not?: InputMaybe<QuoteHeroFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<QuoteHeroFilter>>;
  /** Filter by the object’s `quotePublicsByHeroId` relation. */
  quotePublicsByHeroId?: InputMaybe<QuoteHeroToManyQuotePublicFilter>;
  /** Some related `quotePublicsByHeroId` exist. */
  quotePublicsByHeroIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `quotesByHeroId` relation. */
  quotesByHeroId?: InputMaybe<QuoteHeroToManyQuoteFilter>;
  /** Some related `quotesByHeroId` exist. */
  quotesByHeroIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `style` field. */
  style?: InputMaybe<StringFilter>;
  /** Filter by the object’s `subtitle` field. */
  subtitle?: InputMaybe<StringFilter>;
  /** Filter by the object’s `title` field. */
  title?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `QuoteHero` */
export type QuoteHeroInput = {
  id?: InputMaybe<Scalars['UUID']['input']>;
  imageId?: InputMaybe<Scalars['UUID']['input']>;
  mediaItemToImageId?: InputMaybe<FkQuoteHeroMediaItemImageIdInput>;
  quotePublicsUsingId?: InputMaybe<FakePublicQuotePublicForeignKey1InverseInput>;
  quotesUsingId?: InputMaybe<FkQuoteQuoteHeroHeroIdInverseInput>;
  style?: InputMaybe<Scalars['String']['input']>;
  subtitle?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** The fields on `quoteHero` to look up the row to update. */
export type QuoteHeroOnQuoteForFkQuoteQuoteHeroHeroIdUsingPkQuoteHeroUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `quoteHero` being updated. */
  patch: UpdateQuoteHeroOnQuoteForFkQuoteQuoteHeroHeroIdPatch;
};

/** The fields on `quoteHero` to look up the row to update. */
export type QuoteHeroOnQuoteHeroForFkQuoteHeroMediaItemImageIdUsingPkQuoteHeroUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `quoteHero` being updated. */
  patch: UpdateQuoteHeroOnQuoteHeroForFkQuoteHeroMediaItemImageIdPatch;
};

/** The fields on `quoteHero` to look up the row to update. */
export type QuoteHeroOnQuotePublicForFakePublicQuotePublicForeignKey1UsingPkQuoteHeroUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `quoteHero` being updated. */
  patch: UpdateQuoteHeroOnQuotePublicForFakePublicQuotePublicForeignKey1Patch;
};

/** Represents an update to a `QuoteHero`. Fields that are set will be updated. */
export type QuoteHeroPatch = {
  id?: InputMaybe<Scalars['UUID']['input']>;
  imageId?: InputMaybe<Scalars['UUID']['input']>;
  mediaItemToImageId?: InputMaybe<FkQuoteHeroMediaItemImageIdInput>;
  quotePublicsUsingId?: InputMaybe<FakePublicQuotePublicForeignKey1InverseInput>;
  quotesUsingId?: InputMaybe<FkQuoteQuoteHeroHeroIdInverseInput>;
  style?: InputMaybe<Scalars['String']['input']>;
  subtitle?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** The fields on `quoteHero` to look up the row to connect. */
export type QuoteHeroPkQuoteHeroConnect = {
  id: Scalars['UUID']['input'];
};

/** The fields on `quoteHero` to look up the row to delete. */
export type QuoteHeroPkQuoteHeroDelete = {
  id: Scalars['UUID']['input'];
};

/** A filter to be used against many `Quote` object types. All fields are combined with a logical ‘and.’ */
export type QuoteHeroToManyQuoteFilter = {
  /** Every related `Quote` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<QuoteFilter>;
  /** No related `Quote` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<QuoteFilter>;
  /** Some related `Quote` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<QuoteFilter>;
};

/** A filter to be used against many `QuotePublic` object types. All fields are combined with a logical ‘and.’ */
export type QuoteHeroToManyQuotePublicFilter = {
  /** Every related `QuotePublic` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<QuotePublicFilter>;
  /** No related `QuotePublic` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<QuotePublicFilter>;
  /** Some related `QuotePublic` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<QuotePublicFilter>;
};

/** A connection to a list of `QuoteHero` values. */
export type QuoteHeroesConnection = {
  __typename?: 'QuoteHeroesConnection';
  /** A list of edges which contains the `QuoteHero` and cursor to aid in pagination. */
  edges: Array<QuoteHeroesEdge>;
  /** A list of `QuoteHero` objects. */
  nodes: Array<Maybe<QuoteHero>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `QuoteHero` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `QuoteHero` edge in the connection. */
export type QuoteHeroesEdge = {
  __typename?: 'QuoteHeroesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `QuoteHero` at the end of the edge. */
  node?: Maybe<QuoteHero>;
};

/** Methods to use when ordering `QuoteHero`. */
export enum QuoteHeroesOrderBy {
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ImageIdAsc = 'IMAGE_ID_ASC',
  ImageIdDesc = 'IMAGE_ID_DESC',
  MediaItemByImageIdContentTypeAsc = 'MEDIA_ITEM_BY_IMAGE_ID__CONTENT_TYPE_ASC',
  MediaItemByImageIdContentTypeDesc = 'MEDIA_ITEM_BY_IMAGE_ID__CONTENT_TYPE_DESC',
  MediaItemByImageIdCreatedAsc = 'MEDIA_ITEM_BY_IMAGE_ID__CREATED_ASC',
  MediaItemByImageIdCreatedDesc = 'MEDIA_ITEM_BY_IMAGE_ID__CREATED_DESC',
  MediaItemByImageIdFileNameAsc = 'MEDIA_ITEM_BY_IMAGE_ID__FILE_NAME_ASC',
  MediaItemByImageIdFileNameDesc = 'MEDIA_ITEM_BY_IMAGE_ID__FILE_NAME_DESC',
  MediaItemByImageIdHashAsc = 'MEDIA_ITEM_BY_IMAGE_ID__HASH_ASC',
  MediaItemByImageIdHashDesc = 'MEDIA_ITEM_BY_IMAGE_ID__HASH_DESC',
  MediaItemByImageIdIdAsc = 'MEDIA_ITEM_BY_IMAGE_ID__ID_ASC',
  MediaItemByImageIdIdDesc = 'MEDIA_ITEM_BY_IMAGE_ID__ID_DESC',
  MediaItemByImageIdModifiedAsc = 'MEDIA_ITEM_BY_IMAGE_ID__MODIFIED_ASC',
  MediaItemByImageIdModifiedDesc = 'MEDIA_ITEM_BY_IMAGE_ID__MODIFIED_DESC',
  MediaItemByImageIdNameAsc = 'MEDIA_ITEM_BY_IMAGE_ID__NAME_ASC',
  MediaItemByImageIdNameDesc = 'MEDIA_ITEM_BY_IMAGE_ID__NAME_DESC',
  MediaItemByImageIdSummaryAsc = 'MEDIA_ITEM_BY_IMAGE_ID__SUMMARY_ASC',
  MediaItemByImageIdSummaryDesc = 'MEDIA_ITEM_BY_IMAGE_ID__SUMMARY_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QuotesByHeroIdCountAsc = 'QUOTES_BY_HERO_ID__COUNT_ASC',
  QuotesByHeroIdCountDesc = 'QUOTES_BY_HERO_ID__COUNT_DESC',
  QuotePublicsByHeroIdCountAsc = 'QUOTE_PUBLICS_BY_HERO_ID__COUNT_ASC',
  QuotePublicsByHeroIdCountDesc = 'QUOTE_PUBLICS_BY_HERO_ID__COUNT_DESC',
  StyleAsc = 'STYLE_ASC',
  StyleDesc = 'STYLE_DESC',
  SubtitleAsc = 'SUBTITLE_ASC',
  SubtitleDesc = 'SUBTITLE_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC'
}

/** An input for mutations affecting `Quote` */
export type QuoteInput = {
  adjustment?: InputMaybe<Scalars['BigFloat']['input']>;
  agentMargin?: InputMaybe<Scalars['BigFloat']['input']>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  deposit?: InputMaybe<Scalars['BigFloat']['input']>;
  duration: Scalars['Int']['input'];
  emailsUsingId?: InputMaybe<FkEmailQuoteQuoteIdInverseInput>;
  exclusions?: InputMaybe<Scalars['String']['input']>;
  expires?: InputMaybe<Scalars['Datetime']['input']>;
  heroId?: InputMaybe<Scalars['UUID']['input']>;
  heroImageId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  inclusions?: InputMaybe<Scalars['String']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceQuoteQuoteIdInverseInput>;
  key?: InputMaybe<Scalars['String']['input']>;
  locked?: InputMaybe<Scalars['Datetime']['input']>;
  margin?: InputMaybe<Scalars['BigFloat']['input']>;
  mediaItemToHeroImageId?: InputMaybe<FkQuoteMediaItemHeroImageIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  quoteAcceptancesUsingId?: InputMaybe<FkQuoteAcceptanceQuoteInverseInput>;
  quoteAccommodationDetailsUsingId?: InputMaybe<FkQuoteAccommodationDetailQuoteQuoteIdInverseInput>;
  quoteCurrenciesUsingId?: InputMaybe<FkQuoteCurrencyQuoteQuoteIdInverseInput>;
  quoteDaysUsingId?: InputMaybe<FkQuoteDayQuoteQuoteIdInverseInput>;
  quoteFinanceLineItemsUsingId?: InputMaybe<FkQuoteFinanceLineItemQuoteQuoteIdInverseInput>;
  quoteHeroToHeroId?: InputMaybe<FkQuoteQuoteHeroHeroIdInput>;
  quoteLegalDocumentsUsingId?: InputMaybe<FkQuoteLegalDocumentQuoteInverseInput>;
  quoteStatusToStatus?: InputMaybe<FkQuoteStatusInput>;
  quoteViewsUsingId?: InputMaybe<FkQuoteViewQuoteQuoteIdInverseInput>;
  shortDescription?: InputMaybe<Scalars['String']['input']>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  travellerCount?: InputMaybe<Scalars['Int']['input']>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkQuoteTripTripIdInput>;
  tripsUsingId?: InputMaybe<FkTripQuoteActiveQuoteIdInverseInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkQuoteUserUserIdInput>;
};

export type QuoteLegalDocument = {
  __typename?: 'QuoteLegalDocument';
  id: Scalars['UUID']['output'];
  /** Reads a single `LegalDocument` that is related to this `QuoteLegalDocument`. */
  legalDocument?: Maybe<LegalDocument>;
  legalDocumentId: Scalars['UUID']['output'];
  /** Reads a single `Quote` that is related to this `QuoteLegalDocument`. */
  quote?: Maybe<Quote>;
  quoteId: Scalars['UUID']['output'];
  /** Reads a single `QuotePublic` that is related to this `QuoteLegalDocument`. */
  quotePublic?: Maybe<QuotePublic>;
  sortOrder: Scalars['Int']['output'];
};

/**
 * A condition to be used against `QuoteLegalDocument` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type QuoteLegalDocumentCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `legalDocumentId` field. */
  legalDocumentId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `quoteId` field. */
  quoteId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `sortOrder` field. */
  sortOrder?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `QuoteLegalDocument` object types. All fields are combined with a logical ‘and.’ */
export type QuoteLegalDocumentFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<QuoteLegalDocumentFilter>>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `legalDocument` relation. */
  legalDocument?: InputMaybe<LegalDocumentFilter>;
  /** Filter by the object’s `legalDocumentId` field. */
  legalDocumentId?: InputMaybe<UuidFilter>;
  /** Negates the expression. */
  not?: InputMaybe<QuoteLegalDocumentFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<QuoteLegalDocumentFilter>>;
  /** Filter by the object’s `quote` relation. */
  quote?: InputMaybe<QuoteFilter>;
  /** Filter by the object’s `quoteId` field. */
  quoteId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `quotePublic` relation. */
  quotePublic?: InputMaybe<QuotePublicFilter>;
  /** Filter by the object’s `sortOrder` field. */
  sortOrder?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `QuoteLegalDocument` */
export type QuoteLegalDocumentInput = {
  id?: InputMaybe<Scalars['UUID']['input']>;
  legalDocumentId?: InputMaybe<Scalars['UUID']['input']>;
  legalDocumentToLegalDocumentId?: InputMaybe<FkQuoteLegalDocumentLegalDocumentInput>;
  quoteId?: InputMaybe<Scalars['UUID']['input']>;
  quotePublic?: InputMaybe<FakePublicQuoteLegalDocumentForeignKey0Input>;
  quoteToQuoteId?: InputMaybe<FkQuoteLegalDocumentQuoteInput>;
  sortOrder?: InputMaybe<Scalars['Int']['input']>;
};

/** The fields on `quoteLegalDocument` to look up the row to update. */
export type QuoteLegalDocumentOnQuoteLegalDocumentForFakePublicQuoteLegalDocumentForeignKey0UsingPkQuoteLegalDocumentUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `quoteLegalDocument` being updated. */
  patch: UpdateQuoteLegalDocumentOnQuoteLegalDocumentForFakePublicQuoteLegalDocumentForeignKey0Patch;
};

/** The fields on `quoteLegalDocument` to look up the row to update. */
export type QuoteLegalDocumentOnQuoteLegalDocumentForFkQuoteLegalDocumentLegalDocumentUsingPkQuoteLegalDocumentUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `quoteLegalDocument` being updated. */
  patch: UpdateQuoteLegalDocumentOnQuoteLegalDocumentForFkQuoteLegalDocumentLegalDocumentPatch;
};

/** The fields on `quoteLegalDocument` to look up the row to update. */
export type QuoteLegalDocumentOnQuoteLegalDocumentForFkQuoteLegalDocumentQuoteUsingPkQuoteLegalDocumentUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `quoteLegalDocument` being updated. */
  patch: UpdateQuoteLegalDocumentOnQuoteLegalDocumentForFkQuoteLegalDocumentQuotePatch;
};

/** Represents an update to a `QuoteLegalDocument`. Fields that are set will be updated. */
export type QuoteLegalDocumentPatch = {
  id?: InputMaybe<Scalars['UUID']['input']>;
  legalDocumentId?: InputMaybe<Scalars['UUID']['input']>;
  legalDocumentToLegalDocumentId?: InputMaybe<FkQuoteLegalDocumentLegalDocumentInput>;
  quoteId?: InputMaybe<Scalars['UUID']['input']>;
  quotePublic?: InputMaybe<FakePublicQuoteLegalDocumentForeignKey0Input>;
  quoteToQuoteId?: InputMaybe<FkQuoteLegalDocumentQuoteInput>;
  sortOrder?: InputMaybe<Scalars['Int']['input']>;
};

/** The fields on `quoteLegalDocument` to look up the row to connect. */
export type QuoteLegalDocumentPkQuoteLegalDocumentConnect = {
  id: Scalars['UUID']['input'];
};

/** The fields on `quoteLegalDocument` to look up the row to delete. */
export type QuoteLegalDocumentPkQuoteLegalDocumentDelete = {
  id: Scalars['UUID']['input'];
};

/** A connection to a list of `QuoteLegalDocument` values. */
export type QuoteLegalDocumentsConnection = {
  __typename?: 'QuoteLegalDocumentsConnection';
  /** A list of edges which contains the `QuoteLegalDocument` and cursor to aid in pagination. */
  edges: Array<QuoteLegalDocumentsEdge>;
  /** A list of `QuoteLegalDocument` objects. */
  nodes: Array<Maybe<QuoteLegalDocument>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `QuoteLegalDocument` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `QuoteLegalDocument` edge in the connection. */
export type QuoteLegalDocumentsEdge = {
  __typename?: 'QuoteLegalDocumentsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `QuoteLegalDocument` at the end of the edge. */
  node?: Maybe<QuoteLegalDocument>;
};

/** Methods to use when ordering `QuoteLegalDocument`. */
export enum QuoteLegalDocumentsOrderBy {
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LegalDocumentByLegalDocumentIdBodyAsc = 'LEGAL_DOCUMENT_BY_LEGAL_DOCUMENT_ID__BODY_ASC',
  LegalDocumentByLegalDocumentIdBodyDesc = 'LEGAL_DOCUMENT_BY_LEGAL_DOCUMENT_ID__BODY_DESC',
  LegalDocumentByLegalDocumentIdCreatedAsc = 'LEGAL_DOCUMENT_BY_LEGAL_DOCUMENT_ID__CREATED_ASC',
  LegalDocumentByLegalDocumentIdCreatedDesc = 'LEGAL_DOCUMENT_BY_LEGAL_DOCUMENT_ID__CREATED_DESC',
  LegalDocumentByLegalDocumentIdFolderIdAsc = 'LEGAL_DOCUMENT_BY_LEGAL_DOCUMENT_ID__FOLDER_ID_ASC',
  LegalDocumentByLegalDocumentIdFolderIdDesc = 'LEGAL_DOCUMENT_BY_LEGAL_DOCUMENT_ID__FOLDER_ID_DESC',
  LegalDocumentByLegalDocumentIdIdAsc = 'LEGAL_DOCUMENT_BY_LEGAL_DOCUMENT_ID__ID_ASC',
  LegalDocumentByLegalDocumentIdIdDesc = 'LEGAL_DOCUMENT_BY_LEGAL_DOCUMENT_ID__ID_DESC',
  LegalDocumentByLegalDocumentIdModifiedAsc = 'LEGAL_DOCUMENT_BY_LEGAL_DOCUMENT_ID__MODIFIED_ASC',
  LegalDocumentByLegalDocumentIdModifiedDesc = 'LEGAL_DOCUMENT_BY_LEGAL_DOCUMENT_ID__MODIFIED_DESC',
  LegalDocumentByLegalDocumentIdNameAsc = 'LEGAL_DOCUMENT_BY_LEGAL_DOCUMENT_ID__NAME_ASC',
  LegalDocumentByLegalDocumentIdNameDesc = 'LEGAL_DOCUMENT_BY_LEGAL_DOCUMENT_ID__NAME_DESC',
  LegalDocumentByLegalDocumentIdValidFromAsc = 'LEGAL_DOCUMENT_BY_LEGAL_DOCUMENT_ID__VALID_FROM_ASC',
  LegalDocumentByLegalDocumentIdValidFromDesc = 'LEGAL_DOCUMENT_BY_LEGAL_DOCUMENT_ID__VALID_FROM_DESC',
  LegalDocumentByLegalDocumentIdValidToAsc = 'LEGAL_DOCUMENT_BY_LEGAL_DOCUMENT_ID__VALID_TO_ASC',
  LegalDocumentByLegalDocumentIdValidToDesc = 'LEGAL_DOCUMENT_BY_LEGAL_DOCUMENT_ID__VALID_TO_DESC',
  LegalDocumentIdAsc = 'LEGAL_DOCUMENT_ID_ASC',
  LegalDocumentIdDesc = 'LEGAL_DOCUMENT_ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QuoteByQuoteIdAdjustmentAsc = 'QUOTE_BY_QUOTE_ID__ADJUSTMENT_ASC',
  QuoteByQuoteIdAdjustmentDesc = 'QUOTE_BY_QUOTE_ID__ADJUSTMENT_DESC',
  QuoteByQuoteIdAgentMarginAsc = 'QUOTE_BY_QUOTE_ID__AGENT_MARGIN_ASC',
  QuoteByQuoteIdAgentMarginDesc = 'QUOTE_BY_QUOTE_ID__AGENT_MARGIN_DESC',
  QuoteByQuoteIdArchivedAsc = 'QUOTE_BY_QUOTE_ID__ARCHIVED_ASC',
  QuoteByQuoteIdArchivedDesc = 'QUOTE_BY_QUOTE_ID__ARCHIVED_DESC',
  QuoteByQuoteIdBaseCurrencyAsc = 'QUOTE_BY_QUOTE_ID__BASE_CURRENCY_ASC',
  QuoteByQuoteIdBaseCurrencyDesc = 'QUOTE_BY_QUOTE_ID__BASE_CURRENCY_DESC',
  QuoteByQuoteIdCreatedAsc = 'QUOTE_BY_QUOTE_ID__CREATED_ASC',
  QuoteByQuoteIdCreatedDesc = 'QUOTE_BY_QUOTE_ID__CREATED_DESC',
  QuoteByQuoteIdDepositAsc = 'QUOTE_BY_QUOTE_ID__DEPOSIT_ASC',
  QuoteByQuoteIdDepositDesc = 'QUOTE_BY_QUOTE_ID__DEPOSIT_DESC',
  QuoteByQuoteIdDurationAsc = 'QUOTE_BY_QUOTE_ID__DURATION_ASC',
  QuoteByQuoteIdDurationDesc = 'QUOTE_BY_QUOTE_ID__DURATION_DESC',
  QuoteByQuoteIdExclusionsAsc = 'QUOTE_BY_QUOTE_ID__EXCLUSIONS_ASC',
  QuoteByQuoteIdExclusionsDesc = 'QUOTE_BY_QUOTE_ID__EXCLUSIONS_DESC',
  QuoteByQuoteIdExpiresAsc = 'QUOTE_BY_QUOTE_ID__EXPIRES_ASC',
  QuoteByQuoteIdExpiresDesc = 'QUOTE_BY_QUOTE_ID__EXPIRES_DESC',
  QuoteByQuoteIdHeroIdAsc = 'QUOTE_BY_QUOTE_ID__HERO_ID_ASC',
  QuoteByQuoteIdHeroIdDesc = 'QUOTE_BY_QUOTE_ID__HERO_ID_DESC',
  QuoteByQuoteIdHeroImageIdAsc = 'QUOTE_BY_QUOTE_ID__HERO_IMAGE_ID_ASC',
  QuoteByQuoteIdHeroImageIdDesc = 'QUOTE_BY_QUOTE_ID__HERO_IMAGE_ID_DESC',
  QuoteByQuoteIdIdAsc = 'QUOTE_BY_QUOTE_ID__ID_ASC',
  QuoteByQuoteIdIdDesc = 'QUOTE_BY_QUOTE_ID__ID_DESC',
  QuoteByQuoteIdInclusionsAsc = 'QUOTE_BY_QUOTE_ID__INCLUSIONS_ASC',
  QuoteByQuoteIdInclusionsDesc = 'QUOTE_BY_QUOTE_ID__INCLUSIONS_DESC',
  QuoteByQuoteIdKeyAsc = 'QUOTE_BY_QUOTE_ID__KEY_ASC',
  QuoteByQuoteIdKeyDesc = 'QUOTE_BY_QUOTE_ID__KEY_DESC',
  QuoteByQuoteIdLockedAsc = 'QUOTE_BY_QUOTE_ID__LOCKED_ASC',
  QuoteByQuoteIdLockedDesc = 'QUOTE_BY_QUOTE_ID__LOCKED_DESC',
  QuoteByQuoteIdMarginAsc = 'QUOTE_BY_QUOTE_ID__MARGIN_ASC',
  QuoteByQuoteIdMarginDesc = 'QUOTE_BY_QUOTE_ID__MARGIN_DESC',
  QuoteByQuoteIdModifiedAsc = 'QUOTE_BY_QUOTE_ID__MODIFIED_ASC',
  QuoteByQuoteIdModifiedDesc = 'QUOTE_BY_QUOTE_ID__MODIFIED_DESC',
  QuoteByQuoteIdShortDescriptionAsc = 'QUOTE_BY_QUOTE_ID__SHORT_DESCRIPTION_ASC',
  QuoteByQuoteIdShortDescriptionDesc = 'QUOTE_BY_QUOTE_ID__SHORT_DESCRIPTION_DESC',
  QuoteByQuoteIdStartAsc = 'QUOTE_BY_QUOTE_ID__START_ASC',
  QuoteByQuoteIdStartDesc = 'QUOTE_BY_QUOTE_ID__START_DESC',
  QuoteByQuoteIdStatusAsc = 'QUOTE_BY_QUOTE_ID__STATUS_ASC',
  QuoteByQuoteIdStatusDesc = 'QUOTE_BY_QUOTE_ID__STATUS_DESC',
  QuoteByQuoteIdSummaryAsc = 'QUOTE_BY_QUOTE_ID__SUMMARY_ASC',
  QuoteByQuoteIdSummaryDesc = 'QUOTE_BY_QUOTE_ID__SUMMARY_DESC',
  QuoteByQuoteIdTravellerCountAsc = 'QUOTE_BY_QUOTE_ID__TRAVELLER_COUNT_ASC',
  QuoteByQuoteIdTravellerCountDesc = 'QUOTE_BY_QUOTE_ID__TRAVELLER_COUNT_DESC',
  QuoteByQuoteIdTripIdAsc = 'QUOTE_BY_QUOTE_ID__TRIP_ID_ASC',
  QuoteByQuoteIdTripIdDesc = 'QUOTE_BY_QUOTE_ID__TRIP_ID_DESC',
  QuoteByQuoteIdUserIdAsc = 'QUOTE_BY_QUOTE_ID__USER_ID_ASC',
  QuoteByQuoteIdUserIdDesc = 'QUOTE_BY_QUOTE_ID__USER_ID_DESC',
  QuoteIdAsc = 'QUOTE_ID_ASC',
  QuoteIdDesc = 'QUOTE_ID_DESC',
  QuotePublicByQuoteIdAcceptedAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__ACCEPTED_ASC',
  QuotePublicByQuoteIdAcceptedDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__ACCEPTED_DESC',
  QuotePublicByQuoteIdBaseCurrencyAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__BASE_CURRENCY_ASC',
  QuotePublicByQuoteIdBaseCurrencyDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__BASE_CURRENCY_DESC',
  QuotePublicByQuoteIdDepositAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__DEPOSIT_ASC',
  QuotePublicByQuoteIdDepositDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__DEPOSIT_DESC',
  QuotePublicByQuoteIdDurationAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__DURATION_ASC',
  QuotePublicByQuoteIdDurationDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__DURATION_DESC',
  QuotePublicByQuoteIdExclusionsAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__EXCLUSIONS_ASC',
  QuotePublicByQuoteIdExclusionsDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__EXCLUSIONS_DESC',
  QuotePublicByQuoteIdExpiresAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__EXPIRES_ASC',
  QuotePublicByQuoteIdExpiresDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__EXPIRES_DESC',
  QuotePublicByQuoteIdHeroIdAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__HERO_ID_ASC',
  QuotePublicByQuoteIdHeroIdDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__HERO_ID_DESC',
  QuotePublicByQuoteIdIdAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__ID_ASC',
  QuotePublicByQuoteIdIdDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__ID_DESC',
  QuotePublicByQuoteIdInclusionsAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__INCLUSIONS_ASC',
  QuotePublicByQuoteIdInclusionsDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__INCLUSIONS_DESC',
  QuotePublicByQuoteIdKeyAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__KEY_ASC',
  QuotePublicByQuoteIdKeyDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__KEY_DESC',
  QuotePublicByQuoteIdLockedAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__LOCKED_ASC',
  QuotePublicByQuoteIdLockedDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__LOCKED_DESC',
  QuotePublicByQuoteIdStartAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__START_ASC',
  QuotePublicByQuoteIdStartDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__START_DESC',
  QuotePublicByQuoteIdStatusAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__STATUS_ASC',
  QuotePublicByQuoteIdStatusDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__STATUS_DESC',
  QuotePublicByQuoteIdTotalAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__TOTAL_ASC',
  QuotePublicByQuoteIdTotalDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__TOTAL_DESC',
  QuotePublicByQuoteIdTravellerCountAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__TRAVELLER_COUNT_ASC',
  QuotePublicByQuoteIdTravellerCountDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__TRAVELLER_COUNT_DESC',
  QuotePublicByQuoteIdTripIdAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__TRIP_ID_ASC',
  QuotePublicByQuoteIdTripIdDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__TRIP_ID_DESC',
  QuotePublicByQuoteIdUserIdAsc = 'QUOTE_PUBLIC_BY_QUOTE_ID__USER_ID_ASC',
  QuotePublicByQuoteIdUserIdDesc = 'QUOTE_PUBLIC_BY_QUOTE_ID__USER_ID_DESC',
  SortOrderAsc = 'SORT_ORDER_ASC',
  SortOrderDesc = 'SORT_ORDER_DESC'
}

/** The fields on `quote` to look up the row to update. */
export type QuoteOnEmailForFkEmailQuoteQuoteIdUsingPkQuoteUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `quote` being updated. */
  patch: UpdateQuoteOnEmailForFkEmailQuoteQuoteIdPatch;
};

/** The fields on `quote` to look up the row to update. */
export type QuoteOnEmailForFkEmailQuoteQuoteIdUsingUqQuoteKeyUpdate = {
  key: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `quote` being updated. */
  patch: UpdateQuoteOnEmailForFkEmailQuoteQuoteIdPatch;
};

/** The fields on `quote` to look up the row to update. */
export type QuoteOnInvoiceForFkInvoiceQuoteQuoteIdUsingPkQuoteUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `quote` being updated. */
  patch: UpdateQuoteOnInvoiceForFkInvoiceQuoteQuoteIdPatch;
};

/** The fields on `quote` to look up the row to update. */
export type QuoteOnInvoiceForFkInvoiceQuoteQuoteIdUsingUqQuoteKeyUpdate = {
  key: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `quote` being updated. */
  patch: UpdateQuoteOnInvoiceForFkInvoiceQuoteQuoteIdPatch;
};

/** The fields on `quote` to look up the row to update. */
export type QuoteOnQuoteAcceptanceForFkQuoteAcceptanceQuoteUsingPkQuoteUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `quote` being updated. */
  patch: UpdateQuoteOnQuoteAcceptanceForFkQuoteAcceptanceQuotePatch;
};

/** The fields on `quote` to look up the row to update. */
export type QuoteOnQuoteAcceptanceForFkQuoteAcceptanceQuoteUsingUqQuoteKeyUpdate = {
  key: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `quote` being updated. */
  patch: UpdateQuoteOnQuoteAcceptanceForFkQuoteAcceptanceQuotePatch;
};

/** The fields on `quote` to look up the row to update. */
export type QuoteOnQuoteAccommodationDetailForFkQuoteAccommodationDetailQuoteQuoteIdUsingPkQuoteUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `quote` being updated. */
  patch: UpdateQuoteOnQuoteAccommodationDetailForFkQuoteAccommodationDetailQuoteQuoteIdPatch;
};

/** The fields on `quote` to look up the row to update. */
export type QuoteOnQuoteAccommodationDetailForFkQuoteAccommodationDetailQuoteQuoteIdUsingUqQuoteKeyUpdate = {
  key: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `quote` being updated. */
  patch: UpdateQuoteOnQuoteAccommodationDetailForFkQuoteAccommodationDetailQuoteQuoteIdPatch;
};

/** The fields on `quote` to look up the row to update. */
export type QuoteOnQuoteCurrencyForFkQuoteCurrencyQuoteQuoteIdUsingPkQuoteUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `quote` being updated. */
  patch: UpdateQuoteOnQuoteCurrencyForFkQuoteCurrencyQuoteQuoteIdPatch;
};

/** The fields on `quote` to look up the row to update. */
export type QuoteOnQuoteCurrencyForFkQuoteCurrencyQuoteQuoteIdUsingUqQuoteKeyUpdate = {
  key: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `quote` being updated. */
  patch: UpdateQuoteOnQuoteCurrencyForFkQuoteCurrencyQuoteQuoteIdPatch;
};

/** The fields on `quote` to look up the row to update. */
export type QuoteOnQuoteDayForFkQuoteDayQuoteQuoteIdUsingPkQuoteUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `quote` being updated. */
  patch: UpdateQuoteOnQuoteDayForFkQuoteDayQuoteQuoteIdPatch;
};

/** The fields on `quote` to look up the row to update. */
export type QuoteOnQuoteDayForFkQuoteDayQuoteQuoteIdUsingUqQuoteKeyUpdate = {
  key: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `quote` being updated. */
  patch: UpdateQuoteOnQuoteDayForFkQuoteDayQuoteQuoteIdPatch;
};

/** The fields on `quote` to look up the row to update. */
export type QuoteOnQuoteFinanceLineItemForFkQuoteFinanceLineItemQuoteQuoteIdUsingPkQuoteUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `quote` being updated. */
  patch: UpdateQuoteOnQuoteFinanceLineItemForFkQuoteFinanceLineItemQuoteQuoteIdPatch;
};

/** The fields on `quote` to look up the row to update. */
export type QuoteOnQuoteFinanceLineItemForFkQuoteFinanceLineItemQuoteQuoteIdUsingUqQuoteKeyUpdate = {
  key: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `quote` being updated. */
  patch: UpdateQuoteOnQuoteFinanceLineItemForFkQuoteFinanceLineItemQuoteQuoteIdPatch;
};

/** The fields on `quote` to look up the row to update. */
export type QuoteOnQuoteForFkQuoteMediaItemHeroImageIdUsingPkQuoteUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `quote` being updated. */
  patch: UpdateQuoteOnQuoteForFkQuoteMediaItemHeroImageIdPatch;
};

/** The fields on `quote` to look up the row to update. */
export type QuoteOnQuoteForFkQuoteMediaItemHeroImageIdUsingUqQuoteKeyUpdate = {
  key: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `quote` being updated. */
  patch: UpdateQuoteOnQuoteForFkQuoteMediaItemHeroImageIdPatch;
};

/** The fields on `quote` to look up the row to update. */
export type QuoteOnQuoteForFkQuoteQuoteHeroHeroIdUsingPkQuoteUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `quote` being updated. */
  patch: UpdateQuoteOnQuoteForFkQuoteQuoteHeroHeroIdPatch;
};

/** The fields on `quote` to look up the row to update. */
export type QuoteOnQuoteForFkQuoteQuoteHeroHeroIdUsingUqQuoteKeyUpdate = {
  key: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `quote` being updated. */
  patch: UpdateQuoteOnQuoteForFkQuoteQuoteHeroHeroIdPatch;
};

/** The fields on `quote` to look up the row to update. */
export type QuoteOnQuoteForFkQuoteStatusUsingPkQuoteUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `quote` being updated. */
  patch: UpdateQuoteOnQuoteForFkQuoteStatusPatch;
};

/** The fields on `quote` to look up the row to update. */
export type QuoteOnQuoteForFkQuoteStatusUsingUqQuoteKeyUpdate = {
  key: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `quote` being updated. */
  patch: UpdateQuoteOnQuoteForFkQuoteStatusPatch;
};

/** The fields on `quote` to look up the row to update. */
export type QuoteOnQuoteForFkQuoteTripTripIdUsingPkQuoteUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `quote` being updated. */
  patch: UpdateQuoteOnQuoteForFkQuoteTripTripIdPatch;
};

/** The fields on `quote` to look up the row to update. */
export type QuoteOnQuoteForFkQuoteTripTripIdUsingUqQuoteKeyUpdate = {
  key: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `quote` being updated. */
  patch: UpdateQuoteOnQuoteForFkQuoteTripTripIdPatch;
};

/** The fields on `quote` to look up the row to update. */
export type QuoteOnQuoteForFkQuoteUserUserIdUsingPkQuoteUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `quote` being updated. */
  patch: UpdateQuoteOnQuoteForFkQuoteUserUserIdPatch;
};

/** The fields on `quote` to look up the row to update. */
export type QuoteOnQuoteForFkQuoteUserUserIdUsingUqQuoteKeyUpdate = {
  key: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `quote` being updated. */
  patch: UpdateQuoteOnQuoteForFkQuoteUserUserIdPatch;
};

/** The fields on `quote` to look up the row to update. */
export type QuoteOnQuoteLegalDocumentForFkQuoteLegalDocumentQuoteUsingPkQuoteUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `quote` being updated. */
  patch: UpdateQuoteOnQuoteLegalDocumentForFkQuoteLegalDocumentQuotePatch;
};

/** The fields on `quote` to look up the row to update. */
export type QuoteOnQuoteLegalDocumentForFkQuoteLegalDocumentQuoteUsingUqQuoteKeyUpdate = {
  key: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `quote` being updated. */
  patch: UpdateQuoteOnQuoteLegalDocumentForFkQuoteLegalDocumentQuotePatch;
};

/** The fields on `quote` to look up the row to update. */
export type QuoteOnQuoteViewForFkQuoteViewQuoteQuoteIdUsingPkQuoteUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `quote` being updated. */
  patch: UpdateQuoteOnQuoteViewForFkQuoteViewQuoteQuoteIdPatch;
};

/** The fields on `quote` to look up the row to update. */
export type QuoteOnQuoteViewForFkQuoteViewQuoteQuoteIdUsingUqQuoteKeyUpdate = {
  key: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `quote` being updated. */
  patch: UpdateQuoteOnQuoteViewForFkQuoteViewQuoteQuoteIdPatch;
};

/** The fields on `quote` to look up the row to update. */
export type QuoteOnTripForFkTripQuoteActiveQuoteIdUsingPkQuoteUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `quote` being updated. */
  patch: UpdateQuoteOnTripForFkTripQuoteActiveQuoteIdPatch;
};

/** The fields on `quote` to look up the row to update. */
export type QuoteOnTripForFkTripQuoteActiveQuoteIdUsingUqQuoteKeyUpdate = {
  key: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `quote` being updated. */
  patch: UpdateQuoteOnTripForFkTripQuoteActiveQuoteIdPatch;
};

/** Represents an update to a `Quote`. Fields that are set will be updated. */
export type QuotePatch = {
  adjustment?: InputMaybe<Scalars['BigFloat']['input']>;
  agentMargin?: InputMaybe<Scalars['BigFloat']['input']>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  deposit?: InputMaybe<Scalars['BigFloat']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  emailsUsingId?: InputMaybe<FkEmailQuoteQuoteIdInverseInput>;
  exclusions?: InputMaybe<Scalars['String']['input']>;
  expires?: InputMaybe<Scalars['Datetime']['input']>;
  heroId?: InputMaybe<Scalars['UUID']['input']>;
  heroImageId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  inclusions?: InputMaybe<Scalars['String']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceQuoteQuoteIdInverseInput>;
  key?: InputMaybe<Scalars['String']['input']>;
  locked?: InputMaybe<Scalars['Datetime']['input']>;
  margin?: InputMaybe<Scalars['BigFloat']['input']>;
  mediaItemToHeroImageId?: InputMaybe<FkQuoteMediaItemHeroImageIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  quoteAcceptancesUsingId?: InputMaybe<FkQuoteAcceptanceQuoteInverseInput>;
  quoteAccommodationDetailsUsingId?: InputMaybe<FkQuoteAccommodationDetailQuoteQuoteIdInverseInput>;
  quoteCurrenciesUsingId?: InputMaybe<FkQuoteCurrencyQuoteQuoteIdInverseInput>;
  quoteDaysUsingId?: InputMaybe<FkQuoteDayQuoteQuoteIdInverseInput>;
  quoteFinanceLineItemsUsingId?: InputMaybe<FkQuoteFinanceLineItemQuoteQuoteIdInverseInput>;
  quoteHeroToHeroId?: InputMaybe<FkQuoteQuoteHeroHeroIdInput>;
  quoteLegalDocumentsUsingId?: InputMaybe<FkQuoteLegalDocumentQuoteInverseInput>;
  quoteStatusToStatus?: InputMaybe<FkQuoteStatusInput>;
  quoteViewsUsingId?: InputMaybe<FkQuoteViewQuoteQuoteIdInverseInput>;
  shortDescription?: InputMaybe<Scalars['String']['input']>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  travellerCount?: InputMaybe<Scalars['Int']['input']>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkQuoteTripTripIdInput>;
  tripsUsingId?: InputMaybe<FkTripQuoteActiveQuoteIdInverseInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkQuoteUserUserIdInput>;
};

/** The fields on `quote` to look up the row to connect. */
export type QuotePkQuoteConnect = {
  id: Scalars['UUID']['input'];
};

/** The fields on `quote` to look up the row to delete. */
export type QuotePkQuoteDelete = {
  id: Scalars['UUID']['input'];
};

export type QuotePublic = {
  __typename?: 'QuotePublic';
  accepted?: Maybe<Scalars['Datetime']['output']>;
  baseCurrency?: Maybe<Scalars['String']['output']>;
  deposit?: Maybe<Scalars['BigFloat']['output']>;
  duration?: Maybe<Scalars['Int']['output']>;
  exclusions?: Maybe<Scalars['String']['output']>;
  expires?: Maybe<Scalars['Datetime']['output']>;
  /** Reads a single `QuoteHero` that is related to this `QuotePublic`. */
  hero?: Maybe<QuoteHero>;
  heroId?: Maybe<Scalars['UUID']['output']>;
  id?: Maybe<Scalars['UUID']['output']>;
  inclusions?: Maybe<Scalars['String']['output']>;
  key: Scalars['String']['output'];
  locked?: Maybe<Scalars['Datetime']['output']>;
  /** Reads and enables pagination through a set of `QuoteAccommodationDetail`. */
  quoteAccommodationDetailsByQuoteId: QuoteAccommodationDetailsConnection;
  /** Reads and enables pagination through a set of `QuoteDay`. */
  quoteDaysByQuoteId: QuoteDaysConnection;
  /** Reads and enables pagination through a set of `QuoteLegalDocument`. */
  quoteLegalDocumentsByQuoteId: QuoteLegalDocumentsConnection;
  start?: Maybe<Scalars['Datetime']['output']>;
  status?: Maybe<Scalars['Int']['output']>;
  total?: Maybe<Scalars['BigFloat']['output']>;
  travellerCount?: Maybe<Scalars['Int']['output']>;
  /** Reads a single `Trip` that is related to this `QuotePublic`. */
  trip?: Maybe<Trip>;
  tripId?: Maybe<Scalars['UUID']['output']>;
  /** Reads a single `User` that is related to this `QuotePublic`. */
  user?: Maybe<User>;
  userId?: Maybe<Scalars['UUID']['output']>;
};


export type QuotePublicQuoteAccommodationDetailsByQuoteIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<QuoteAccommodationDetailCondition>;
  filter?: InputMaybe<QuoteAccommodationDetailFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuoteAccommodationDetailsOrderBy>>;
};


export type QuotePublicQuoteDaysByQuoteIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<QuoteDayCondition>;
  filter?: InputMaybe<QuoteDayFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuoteDaysOrderBy>>;
};


export type QuotePublicQuoteLegalDocumentsByQuoteIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<QuoteLegalDocumentCondition>;
  filter?: InputMaybe<QuoteLegalDocumentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuoteLegalDocumentsOrderBy>>;
};

/**
 * A condition to be used against `QuotePublic` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type QuotePublicCondition = {
  /** Checks for equality with the object’s `accepted` field. */
  accepted?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `baseCurrency` field. */
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `deposit` field. */
  deposit?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `duration` field. */
  duration?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `exclusions` field. */
  exclusions?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `expires` field. */
  expires?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `heroId` field. */
  heroId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `inclusions` field. */
  inclusions?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `key` field. */
  key?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `locked` field. */
  locked?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `start` field. */
  start?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `total` field. */
  total?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `travellerCount` field. */
  travellerCount?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `tripId` field. */
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['UUID']['input']>;
};

/** The fields on `quotePublic` to look up the row to connect. */
export type QuotePublicFakePublicQuotePublicPrimaryKeyConnect = {
  key: Scalars['String']['input'];
};

/** The fields on `quotePublic` to look up the row to delete. */
export type QuotePublicFakePublicQuotePublicPrimaryKeyDelete = {
  key: Scalars['String']['input'];
};

/** A filter to be used against `QuotePublic` object types. All fields are combined with a logical ‘and.’ */
export type QuotePublicFilter = {
  /** Filter by the object’s `accepted` field. */
  accepted?: InputMaybe<DatetimeFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<QuotePublicFilter>>;
  /** Filter by the object’s `baseCurrency` field. */
  baseCurrency?: InputMaybe<StringFilter>;
  /** Filter by the object’s `deposit` field. */
  deposit?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `duration` field. */
  duration?: InputMaybe<IntFilter>;
  /** Filter by the object’s `exclusions` field. */
  exclusions?: InputMaybe<StringFilter>;
  /** Filter by the object’s `expires` field. */
  expires?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `hero` relation. */
  hero?: InputMaybe<QuoteHeroFilter>;
  /** A related `hero` exists. */
  heroExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `heroId` field. */
  heroId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `inclusions` field. */
  inclusions?: InputMaybe<StringFilter>;
  /** Filter by the object’s `key` field. */
  key?: InputMaybe<StringFilter>;
  /** Filter by the object’s `locked` field. */
  locked?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<QuotePublicFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<QuotePublicFilter>>;
  /** Filter by the object’s `quoteAccommodationDetailsByQuoteId` relation. */
  quoteAccommodationDetailsByQuoteId?: InputMaybe<QuotePublicToManyQuoteAccommodationDetailFilter>;
  /** Some related `quoteAccommodationDetailsByQuoteId` exist. */
  quoteAccommodationDetailsByQuoteIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `quoteDaysByQuoteId` relation. */
  quoteDaysByQuoteId?: InputMaybe<QuotePublicToManyQuoteDayFilter>;
  /** Some related `quoteDaysByQuoteId` exist. */
  quoteDaysByQuoteIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `quoteLegalDocumentsByQuoteId` relation. */
  quoteLegalDocumentsByQuoteId?: InputMaybe<QuotePublicToManyQuoteLegalDocumentFilter>;
  /** Some related `quoteLegalDocumentsByQuoteId` exist. */
  quoteLegalDocumentsByQuoteIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `start` field. */
  start?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `status` field. */
  status?: InputMaybe<IntFilter>;
  /** Filter by the object’s `total` field. */
  total?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `travellerCount` field. */
  travellerCount?: InputMaybe<IntFilter>;
  /** Filter by the object’s `trip` relation. */
  trip?: InputMaybe<TripFilter>;
  /** A related `trip` exists. */
  tripExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `tripId` field. */
  tripId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `user` relation. */
  user?: InputMaybe<UserFilter>;
  /** A related `user` exists. */
  userExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<UuidFilter>;
};

/** An input for mutations affecting `QuotePublic` */
export type QuotePublicInput = {
  accepted?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  deposit?: InputMaybe<Scalars['BigFloat']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  exclusions?: InputMaybe<Scalars['String']['input']>;
  expires?: InputMaybe<Scalars['Datetime']['input']>;
  heroId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  inclusions?: InputMaybe<Scalars['String']['input']>;
  key: Scalars['String']['input'];
  locked?: InputMaybe<Scalars['Datetime']['input']>;
  quoteAccommodationDetailsUsingId?: InputMaybe<FakePublicQuoteAccommodationDetailForeignKey0InverseInput>;
  quoteDaysUsingId?: InputMaybe<FakePublicQuoteDayForeignKey0InverseInput>;
  quoteHeroToHeroId?: InputMaybe<FakePublicQuotePublicForeignKey1Input>;
  quoteLegalDocumentsUsingId?: InputMaybe<FakePublicQuoteLegalDocumentForeignKey0InverseInput>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  total?: InputMaybe<Scalars['BigFloat']['input']>;
  travellerCount?: InputMaybe<Scalars['Int']['input']>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FakePublicQuotePublicForeignKey0Input>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FakePublicQuotePublicForeignKey2Input>;
};

/** The fields on `quotePublic` to look up the row to update. */
export type QuotePublicOnQuoteAccommodationDetailForFakePublicQuoteAccommodationDetailForeignKey0UsingFakePublicQuotePublicPrimaryKeyUpdate = {
  key: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `quotePublic` being updated. */
  patch: UpdateQuotePublicOnQuoteAccommodationDetailForFakePublicQuoteAccommodationDetailForeignKey0Patch;
};

/** The fields on `quotePublic` to look up the row to update. */
export type QuotePublicOnQuoteDayForFakePublicQuoteDayForeignKey0UsingFakePublicQuotePublicPrimaryKeyUpdate = {
  key: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `quotePublic` being updated. */
  patch: UpdateQuotePublicOnQuoteDayForFakePublicQuoteDayForeignKey0Patch;
};

/** The fields on `quotePublic` to look up the row to update. */
export type QuotePublicOnQuoteLegalDocumentForFakePublicQuoteLegalDocumentForeignKey0UsingFakePublicQuotePublicPrimaryKeyUpdate = {
  key: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `quotePublic` being updated. */
  patch: UpdateQuotePublicOnQuoteLegalDocumentForFakePublicQuoteLegalDocumentForeignKey0Patch;
};

/** The fields on `quotePublic` to look up the row to update. */
export type QuotePublicOnQuotePublicForFakePublicQuotePublicForeignKey0UsingFakePublicQuotePublicPrimaryKeyUpdate = {
  key: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `quotePublic` being updated. */
  patch: UpdateQuotePublicOnQuotePublicForFakePublicQuotePublicForeignKey0Patch;
};

/** The fields on `quotePublic` to look up the row to update. */
export type QuotePublicOnQuotePublicForFakePublicQuotePublicForeignKey1UsingFakePublicQuotePublicPrimaryKeyUpdate = {
  key: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `quotePublic` being updated. */
  patch: UpdateQuotePublicOnQuotePublicForFakePublicQuotePublicForeignKey1Patch;
};

/** The fields on `quotePublic` to look up the row to update. */
export type QuotePublicOnQuotePublicForFakePublicQuotePublicForeignKey2UsingFakePublicQuotePublicPrimaryKeyUpdate = {
  key: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `quotePublic` being updated. */
  patch: UpdateQuotePublicOnQuotePublicForFakePublicQuotePublicForeignKey2Patch;
};

/** Represents an update to a `QuotePublic`. Fields that are set will be updated. */
export type QuotePublicPatch = {
  accepted?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  deposit?: InputMaybe<Scalars['BigFloat']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  exclusions?: InputMaybe<Scalars['String']['input']>;
  expires?: InputMaybe<Scalars['Datetime']['input']>;
  heroId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  inclusions?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  locked?: InputMaybe<Scalars['Datetime']['input']>;
  quoteAccommodationDetailsUsingId?: InputMaybe<FakePublicQuoteAccommodationDetailForeignKey0InverseInput>;
  quoteDaysUsingId?: InputMaybe<FakePublicQuoteDayForeignKey0InverseInput>;
  quoteHeroToHeroId?: InputMaybe<FakePublicQuotePublicForeignKey1Input>;
  quoteLegalDocumentsUsingId?: InputMaybe<FakePublicQuoteLegalDocumentForeignKey0InverseInput>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  total?: InputMaybe<Scalars['BigFloat']['input']>;
  travellerCount?: InputMaybe<Scalars['Int']['input']>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FakePublicQuotePublicForeignKey0Input>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FakePublicQuotePublicForeignKey2Input>;
};

/** A filter to be used against many `QuoteAccommodationDetail` object types. All fields are combined with a logical ‘and.’ */
export type QuotePublicToManyQuoteAccommodationDetailFilter = {
  /** Every related `QuoteAccommodationDetail` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<QuoteAccommodationDetailFilter>;
  /** No related `QuoteAccommodationDetail` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<QuoteAccommodationDetailFilter>;
  /** Some related `QuoteAccommodationDetail` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<QuoteAccommodationDetailFilter>;
};

/** A filter to be used against many `QuoteDay` object types. All fields are combined with a logical ‘and.’ */
export type QuotePublicToManyQuoteDayFilter = {
  /** Every related `QuoteDay` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<QuoteDayFilter>;
  /** No related `QuoteDay` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<QuoteDayFilter>;
  /** Some related `QuoteDay` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<QuoteDayFilter>;
};

/** A filter to be used against many `QuoteLegalDocument` object types. All fields are combined with a logical ‘and.’ */
export type QuotePublicToManyQuoteLegalDocumentFilter = {
  /** Every related `QuoteLegalDocument` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<QuoteLegalDocumentFilter>;
  /** No related `QuoteLegalDocument` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<QuoteLegalDocumentFilter>;
  /** Some related `QuoteLegalDocument` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<QuoteLegalDocumentFilter>;
};

/** A connection to a list of `QuotePublic` values. */
export type QuotePublicsConnection = {
  __typename?: 'QuotePublicsConnection';
  /** A list of edges which contains the `QuotePublic` and cursor to aid in pagination. */
  edges: Array<QuotePublicsEdge>;
  /** A list of `QuotePublic` objects. */
  nodes: Array<Maybe<QuotePublic>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `QuotePublic` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `QuotePublic` edge in the connection. */
export type QuotePublicsEdge = {
  __typename?: 'QuotePublicsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `QuotePublic` at the end of the edge. */
  node?: Maybe<QuotePublic>;
};

/** Methods to use when ordering `QuotePublic`. */
export enum QuotePublicsOrderBy {
  AcceptedAsc = 'ACCEPTED_ASC',
  AcceptedDesc = 'ACCEPTED_DESC',
  BaseCurrencyAsc = 'BASE_CURRENCY_ASC',
  BaseCurrencyDesc = 'BASE_CURRENCY_DESC',
  DepositAsc = 'DEPOSIT_ASC',
  DepositDesc = 'DEPOSIT_DESC',
  DurationAsc = 'DURATION_ASC',
  DurationDesc = 'DURATION_DESC',
  ExclusionsAsc = 'EXCLUSIONS_ASC',
  ExclusionsDesc = 'EXCLUSIONS_DESC',
  ExpiresAsc = 'EXPIRES_ASC',
  ExpiresDesc = 'EXPIRES_DESC',
  HeroIdAsc = 'HERO_ID_ASC',
  HeroIdDesc = 'HERO_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  InclusionsAsc = 'INCLUSIONS_ASC',
  InclusionsDesc = 'INCLUSIONS_DESC',
  KeyAsc = 'KEY_ASC',
  KeyDesc = 'KEY_DESC',
  LockedAsc = 'LOCKED_ASC',
  LockedDesc = 'LOCKED_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QuoteAccommodationDetailsByQuoteIdCountAsc = 'QUOTE_ACCOMMODATION_DETAILS_BY_QUOTE_ID__COUNT_ASC',
  QuoteAccommodationDetailsByQuoteIdCountDesc = 'QUOTE_ACCOMMODATION_DETAILS_BY_QUOTE_ID__COUNT_DESC',
  QuoteDaysByQuoteIdCountAsc = 'QUOTE_DAYS_BY_QUOTE_ID__COUNT_ASC',
  QuoteDaysByQuoteIdCountDesc = 'QUOTE_DAYS_BY_QUOTE_ID__COUNT_DESC',
  QuoteHeroByHeroIdIdAsc = 'QUOTE_HERO_BY_HERO_ID__ID_ASC',
  QuoteHeroByHeroIdIdDesc = 'QUOTE_HERO_BY_HERO_ID__ID_DESC',
  QuoteHeroByHeroIdImageIdAsc = 'QUOTE_HERO_BY_HERO_ID__IMAGE_ID_ASC',
  QuoteHeroByHeroIdImageIdDesc = 'QUOTE_HERO_BY_HERO_ID__IMAGE_ID_DESC',
  QuoteHeroByHeroIdStyleAsc = 'QUOTE_HERO_BY_HERO_ID__STYLE_ASC',
  QuoteHeroByHeroIdStyleDesc = 'QUOTE_HERO_BY_HERO_ID__STYLE_DESC',
  QuoteHeroByHeroIdSubtitleAsc = 'QUOTE_HERO_BY_HERO_ID__SUBTITLE_ASC',
  QuoteHeroByHeroIdSubtitleDesc = 'QUOTE_HERO_BY_HERO_ID__SUBTITLE_DESC',
  QuoteHeroByHeroIdTitleAsc = 'QUOTE_HERO_BY_HERO_ID__TITLE_ASC',
  QuoteHeroByHeroIdTitleDesc = 'QUOTE_HERO_BY_HERO_ID__TITLE_DESC',
  QuoteLegalDocumentsByQuoteIdCountAsc = 'QUOTE_LEGAL_DOCUMENTS_BY_QUOTE_ID__COUNT_ASC',
  QuoteLegalDocumentsByQuoteIdCountDesc = 'QUOTE_LEGAL_DOCUMENTS_BY_QUOTE_ID__COUNT_DESC',
  StartAsc = 'START_ASC',
  StartDesc = 'START_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  TotalAsc = 'TOTAL_ASC',
  TotalDesc = 'TOTAL_DESC',
  TravellerCountAsc = 'TRAVELLER_COUNT_ASC',
  TravellerCountDesc = 'TRAVELLER_COUNT_DESC',
  TripByTripIdActiveQuoteIdAsc = 'TRIP_BY_TRIP_ID__ACTIVE_QUOTE_ID_ASC',
  TripByTripIdActiveQuoteIdDesc = 'TRIP_BY_TRIP_ID__ACTIVE_QUOTE_ID_DESC',
  TripByTripIdAgencyIdAsc = 'TRIP_BY_TRIP_ID__AGENCY_ID_ASC',
  TripByTripIdAgencyIdDesc = 'TRIP_BY_TRIP_ID__AGENCY_ID_DESC',
  TripByTripIdAgencyMemberIdAsc = 'TRIP_BY_TRIP_ID__AGENCY_MEMBER_ID_ASC',
  TripByTripIdAgencyMemberIdDesc = 'TRIP_BY_TRIP_ID__AGENCY_MEMBER_ID_DESC',
  TripByTripIdArchivedAsc = 'TRIP_BY_TRIP_ID__ARCHIVED_ASC',
  TripByTripIdArchivedDesc = 'TRIP_BY_TRIP_ID__ARCHIVED_DESC',
  TripByTripIdBaseCurrencyAsc = 'TRIP_BY_TRIP_ID__BASE_CURRENCY_ASC',
  TripByTripIdBaseCurrencyDesc = 'TRIP_BY_TRIP_ID__BASE_CURRENCY_DESC',
  TripByTripIdCreatedAsc = 'TRIP_BY_TRIP_ID__CREATED_ASC',
  TripByTripIdCreatedDesc = 'TRIP_BY_TRIP_ID__CREATED_DESC',
  TripByTripIdCustomerIdAsc = 'TRIP_BY_TRIP_ID__CUSTOMER_ID_ASC',
  TripByTripIdCustomerIdDesc = 'TRIP_BY_TRIP_ID__CUSTOMER_ID_DESC',
  TripByTripIdDatesAsc = 'TRIP_BY_TRIP_ID__DATES_ASC',
  TripByTripIdDatesDesc = 'TRIP_BY_TRIP_ID__DATES_DESC',
  TripByTripIdDestinationAsc = 'TRIP_BY_TRIP_ID__DESTINATION_ASC',
  TripByTripIdDestinationDesc = 'TRIP_BY_TRIP_ID__DESTINATION_DESC',
  TripByTripIdDurationAsc = 'TRIP_BY_TRIP_ID__DURATION_ASC',
  TripByTripIdDurationDesc = 'TRIP_BY_TRIP_ID__DURATION_DESC',
  TripByTripIdIdAsc = 'TRIP_BY_TRIP_ID__ID_ASC',
  TripByTripIdIdDesc = 'TRIP_BY_TRIP_ID__ID_DESC',
  TripByTripIdMediaGalleryIdAsc = 'TRIP_BY_TRIP_ID__MEDIA_GALLERY_ID_ASC',
  TripByTripIdMediaGalleryIdDesc = 'TRIP_BY_TRIP_ID__MEDIA_GALLERY_ID_DESC',
  TripByTripIdModifiedAsc = 'TRIP_BY_TRIP_ID__MODIFIED_ASC',
  TripByTripIdModifiedDesc = 'TRIP_BY_TRIP_ID__MODIFIED_DESC',
  TripByTripIdNameAsc = 'TRIP_BY_TRIP_ID__NAME_ASC',
  TripByTripIdNameDesc = 'TRIP_BY_TRIP_ID__NAME_DESC',
  TripByTripIdStartAsc = 'TRIP_BY_TRIP_ID__START_ASC',
  TripByTripIdStartDesc = 'TRIP_BY_TRIP_ID__START_DESC',
  TripByTripIdStatusAsc = 'TRIP_BY_TRIP_ID__STATUS_ASC',
  TripByTripIdStatusDesc = 'TRIP_BY_TRIP_ID__STATUS_DESC',
  TripByTripIdSummaryAsc = 'TRIP_BY_TRIP_ID__SUMMARY_ASC',
  TripByTripIdSummaryDesc = 'TRIP_BY_TRIP_ID__SUMMARY_DESC',
  TripByTripIdUserIdAsc = 'TRIP_BY_TRIP_ID__USER_ID_ASC',
  TripByTripIdUserIdDesc = 'TRIP_BY_TRIP_ID__USER_ID_DESC',
  TripIdAsc = 'TRIP_ID_ASC',
  TripIdDesc = 'TRIP_ID_DESC',
  UserByUserIdCreatedAsc = 'USER_BY_USER_ID__CREATED_ASC',
  UserByUserIdCreatedDesc = 'USER_BY_USER_ID__CREATED_DESC',
  UserByUserIdEmailAsc = 'USER_BY_USER_ID__EMAIL_ASC',
  UserByUserIdEmailDesc = 'USER_BY_USER_ID__EMAIL_DESC',
  UserByUserIdExternalIdAsc = 'USER_BY_USER_ID__EXTERNAL_ID_ASC',
  UserByUserIdExternalIdDesc = 'USER_BY_USER_ID__EXTERNAL_ID_DESC',
  UserByUserIdFirstNameAsc = 'USER_BY_USER_ID__FIRST_NAME_ASC',
  UserByUserIdFirstNameDesc = 'USER_BY_USER_ID__FIRST_NAME_DESC',
  UserByUserIdGenderPrepositionAsc = 'USER_BY_USER_ID__GENDER_PREPOSITION_ASC',
  UserByUserIdGenderPrepositionDesc = 'USER_BY_USER_ID__GENDER_PREPOSITION_DESC',
  UserByUserIdIdAsc = 'USER_BY_USER_ID__ID_ASC',
  UserByUserIdIdDesc = 'USER_BY_USER_ID__ID_DESC',
  UserByUserIdLastNameAsc = 'USER_BY_USER_ID__LAST_NAME_ASC',
  UserByUserIdLastNameDesc = 'USER_BY_USER_ID__LAST_NAME_DESC',
  UserByUserIdModifiedAsc = 'USER_BY_USER_ID__MODIFIED_ASC',
  UserByUserIdModifiedDesc = 'USER_BY_USER_ID__MODIFIED_DESC',
  UserByUserIdNameAsc = 'USER_BY_USER_ID__NAME_ASC',
  UserByUserIdNameDesc = 'USER_BY_USER_ID__NAME_DESC',
  UserByUserIdPasswordAsc = 'USER_BY_USER_ID__PASSWORD_ASC',
  UserByUserIdPasswordDesc = 'USER_BY_USER_ID__PASSWORD_DESC',
  UserByUserIdPhoneAsc = 'USER_BY_USER_ID__PHONE_ASC',
  UserByUserIdPhoneDesc = 'USER_BY_USER_ID__PHONE_DESC',
  UserByUserIdSkypeAsc = 'USER_BY_USER_ID__SKYPE_ASC',
  UserByUserIdSkypeDesc = 'USER_BY_USER_ID__SKYPE_DESC',
  UserByUserIdTitleAsc = 'USER_BY_USER_ID__TITLE_ASC',
  UserByUserIdTitleDesc = 'USER_BY_USER_ID__TITLE_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

export type QuoteStatus = {
  __typename?: 'QuoteStatus';
  id: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  /** Reads and enables pagination through a set of `Quote`. */
  quotesByStatus: QuotesConnection;
};


export type QuoteStatusQuotesByStatusArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<QuoteCondition>;
  filter?: InputMaybe<QuoteFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuotesOrderBy>>;
};

/**
 * A condition to be used against `QuoteStatus` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type QuoteStatusCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `QuoteStatus` object types. All fields are combined with a logical ‘and.’ */
export type QuoteStatusFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<QuoteStatusFilter>>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<QuoteStatusFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<QuoteStatusFilter>>;
  /** Filter by the object’s `quotesByStatus` relation. */
  quotesByStatus?: InputMaybe<QuoteStatusToManyQuoteFilter>;
  /** Some related `quotesByStatus` exist. */
  quotesByStatusExist?: InputMaybe<Scalars['Boolean']['input']>;
};

/** An input for mutations affecting `QuoteStatus` */
export type QuoteStatusInput = {
  id: Scalars['Int']['input'];
  name: Scalars['String']['input'];
  quotesUsingId?: InputMaybe<FkQuoteStatusInverseInput>;
};

/** The fields on `quoteStatus` to look up the row to update. */
export type QuoteStatusOnQuoteForFkQuoteStatusUsingPkQuoteStatusUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `quoteStatus` being updated. */
  patch: UpdateQuoteStatusOnQuoteForFkQuoteStatusPatch;
};

/** Represents an update to a `QuoteStatus`. Fields that are set will be updated. */
export type QuoteStatusPatch = {
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  quotesUsingId?: InputMaybe<FkQuoteStatusInverseInput>;
};

/** The fields on `quoteStatus` to look up the row to connect. */
export type QuoteStatusPkQuoteStatusConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `quoteStatus` to look up the row to delete. */
export type QuoteStatusPkQuoteStatusDelete = {
  id: Scalars['Int']['input'];
};

/** A filter to be used against many `Quote` object types. All fields are combined with a logical ‘and.’ */
export type QuoteStatusToManyQuoteFilter = {
  /** Every related `Quote` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<QuoteFilter>;
  /** No related `Quote` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<QuoteFilter>;
  /** Some related `Quote` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<QuoteFilter>;
};

/** A connection to a list of `QuoteStatus` values. */
export type QuoteStatusesConnection = {
  __typename?: 'QuoteStatusesConnection';
  /** A list of edges which contains the `QuoteStatus` and cursor to aid in pagination. */
  edges: Array<QuoteStatusesEdge>;
  /** A list of `QuoteStatus` objects. */
  nodes: Array<Maybe<QuoteStatus>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `QuoteStatus` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `QuoteStatus` edge in the connection. */
export type QuoteStatusesEdge = {
  __typename?: 'QuoteStatusesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `QuoteStatus` at the end of the edge. */
  node?: Maybe<QuoteStatus>;
};

/** Methods to use when ordering `QuoteStatus`. */
export enum QuoteStatusesOrderBy {
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QuotesByStatusCountAsc = 'QUOTES_BY_STATUS__COUNT_ASC',
  QuotesByStatusCountDesc = 'QUOTES_BY_STATUS__COUNT_DESC'
}

/** A filter to be used against many `Email` object types. All fields are combined with a logical ‘and.’ */
export type QuoteToManyEmailFilter = {
  /** Every related `Email` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<EmailFilter>;
  /** No related `Email` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<EmailFilter>;
  /** Some related `Email` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<EmailFilter>;
};

/** A filter to be used against many `Invoice` object types. All fields are combined with a logical ‘and.’ */
export type QuoteToManyInvoiceFilter = {
  /** Every related `Invoice` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<InvoiceFilter>;
  /** No related `Invoice` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<InvoiceFilter>;
  /** Some related `Invoice` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<InvoiceFilter>;
};

/** A filter to be used against many `QuoteAcceptance` object types. All fields are combined with a logical ‘and.’ */
export type QuoteToManyQuoteAcceptanceFilter = {
  /** Every related `QuoteAcceptance` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<QuoteAcceptanceFilter>;
  /** No related `QuoteAcceptance` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<QuoteAcceptanceFilter>;
  /** Some related `QuoteAcceptance` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<QuoteAcceptanceFilter>;
};

/** A filter to be used against many `QuoteAccommodationDetail` object types. All fields are combined with a logical ‘and.’ */
export type QuoteToManyQuoteAccommodationDetailFilter = {
  /** Every related `QuoteAccommodationDetail` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<QuoteAccommodationDetailFilter>;
  /** No related `QuoteAccommodationDetail` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<QuoteAccommodationDetailFilter>;
  /** Some related `QuoteAccommodationDetail` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<QuoteAccommodationDetailFilter>;
};

/** A filter to be used against many `QuoteCurrency` object types. All fields are combined with a logical ‘and.’ */
export type QuoteToManyQuoteCurrencyFilter = {
  /** Every related `QuoteCurrency` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<QuoteCurrencyFilter>;
  /** No related `QuoteCurrency` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<QuoteCurrencyFilter>;
  /** Some related `QuoteCurrency` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<QuoteCurrencyFilter>;
};

/** A filter to be used against many `QuoteDay` object types. All fields are combined with a logical ‘and.’ */
export type QuoteToManyQuoteDayFilter = {
  /** Every related `QuoteDay` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<QuoteDayFilter>;
  /** No related `QuoteDay` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<QuoteDayFilter>;
  /** Some related `QuoteDay` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<QuoteDayFilter>;
};

/** A filter to be used against many `QuoteFinanceLineItem` object types. All fields are combined with a logical ‘and.’ */
export type QuoteToManyQuoteFinanceLineItemFilter = {
  /** Every related `QuoteFinanceLineItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<QuoteFinanceLineItemFilter>;
  /** No related `QuoteFinanceLineItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<QuoteFinanceLineItemFilter>;
  /** Some related `QuoteFinanceLineItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<QuoteFinanceLineItemFilter>;
};

/** A filter to be used against many `QuoteLegalDocument` object types. All fields are combined with a logical ‘and.’ */
export type QuoteToManyQuoteLegalDocumentFilter = {
  /** Every related `QuoteLegalDocument` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<QuoteLegalDocumentFilter>;
  /** No related `QuoteLegalDocument` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<QuoteLegalDocumentFilter>;
  /** Some related `QuoteLegalDocument` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<QuoteLegalDocumentFilter>;
};

/** A filter to be used against many `QuoteView` object types. All fields are combined with a logical ‘and.’ */
export type QuoteToManyQuoteViewFilter = {
  /** Every related `QuoteView` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<QuoteViewFilter>;
  /** No related `QuoteView` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<QuoteViewFilter>;
  /** Some related `QuoteView` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<QuoteViewFilter>;
};

/** A filter to be used against many `Trip` object types. All fields are combined with a logical ‘and.’ */
export type QuoteToManyTripFilter = {
  /** Every related `Trip` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<TripFilter>;
  /** No related `Trip` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<TripFilter>;
  /** Some related `Trip` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<TripFilter>;
};

/** A connection to a list of `QuoteTotalSummary` values. */
export type QuoteTotalSummariesConnection = {
  __typename?: 'QuoteTotalSummariesConnection';
  /** A list of edges which contains the `QuoteTotalSummary` and cursor to aid in pagination. */
  edges: Array<QuoteTotalSummariesEdge>;
  /** A list of `QuoteTotalSummary` objects. */
  nodes: Array<Maybe<QuoteTotalSummary>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `QuoteTotalSummary` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `QuoteTotalSummary` edge in the connection. */
export type QuoteTotalSummariesEdge = {
  __typename?: 'QuoteTotalSummariesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `QuoteTotalSummary` at the end of the edge. */
  node?: Maybe<QuoteTotalSummary>;
};

/** Methods to use when ordering `QuoteTotalSummary`. */
export enum QuoteTotalSummariesOrderBy {
  AgentMarginAmountAsc = 'AGENT_MARGIN_AMOUNT_ASC',
  AgentMarginAmountDesc = 'AGENT_MARGIN_AMOUNT_DESC',
  MarginAmountAsc = 'MARGIN_AMOUNT_ASC',
  MarginAmountDesc = 'MARGIN_AMOUNT_DESC',
  Natural = 'NATURAL',
  QuoteIdAsc = 'QUOTE_ID_ASC',
  QuoteIdDesc = 'QUOTE_ID_DESC',
  SubtotalAsc = 'SUBTOTAL_ASC',
  SubtotalDesc = 'SUBTOTAL_DESC',
  TotalAsc = 'TOTAL_ASC',
  TotalDesc = 'TOTAL_DESC'
}

export type QuoteTotalSummary = {
  __typename?: 'QuoteTotalSummary';
  agentMarginAmount?: Maybe<Scalars['BigFloat']['output']>;
  marginAmount?: Maybe<Scalars['BigFloat']['output']>;
  quoteId?: Maybe<Scalars['UUID']['output']>;
  subtotal?: Maybe<Scalars['BigFloat']['output']>;
  total?: Maybe<Scalars['BigFloat']['output']>;
};

/**
 * A condition to be used against `QuoteTotalSummary` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type QuoteTotalSummaryCondition = {
  /** Checks for equality with the object’s `agentMarginAmount` field. */
  agentMarginAmount?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `marginAmount` field. */
  marginAmount?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `quoteId` field. */
  quoteId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `subtotal` field. */
  subtotal?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `total` field. */
  total?: InputMaybe<Scalars['BigFloat']['input']>;
};

/** A filter to be used against `QuoteTotalSummary` object types. All fields are combined with a logical ‘and.’ */
export type QuoteTotalSummaryFilter = {
  /** Filter by the object’s `agentMarginAmount` field. */
  agentMarginAmount?: InputMaybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<QuoteTotalSummaryFilter>>;
  /** Filter by the object’s `marginAmount` field. */
  marginAmount?: InputMaybe<BigFloatFilter>;
  /** Negates the expression. */
  not?: InputMaybe<QuoteTotalSummaryFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<QuoteTotalSummaryFilter>>;
  /** Filter by the object’s `quoteId` field. */
  quoteId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `subtotal` field. */
  subtotal?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `total` field. */
  total?: InputMaybe<BigFloatFilter>;
};

/** The fields on `quote` to look up the row to connect. */
export type QuoteUqQuoteKeyConnect = {
  key: Scalars['String']['input'];
};

/** The fields on `quote` to look up the row to delete. */
export type QuoteUqQuoteKeyDelete = {
  key: Scalars['String']['input'];
};

export type QuoteView = {
  __typename?: 'QuoteView';
  city?: Maybe<Scalars['String']['output']>;
  country?: Maybe<Scalars['String']['output']>;
  created: Scalars['Datetime']['output'];
  id: Scalars['UUID']['output'];
  modified: Scalars['Datetime']['output'];
  /** Reads a single `Quote` that is related to this `QuoteView`. */
  quote?: Maybe<Quote>;
  quoteId: Scalars['UUID']['output'];
  timezone?: Maybe<Scalars['String']['output']>;
  userIp?: Maybe<Scalars['String']['output']>;
  viewType?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `QuoteView` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type QuoteViewCondition = {
  /** Checks for equality with the object’s `city` field. */
  city?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `country` field. */
  country?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `quoteId` field. */
  quoteId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `timezone` field. */
  timezone?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `userIp` field. */
  userIp?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `viewType` field. */
  viewType?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `QuoteView` object types. All fields are combined with a logical ‘and.’ */
export type QuoteViewFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<QuoteViewFilter>>;
  /** Filter by the object’s `city` field. */
  city?: InputMaybe<StringFilter>;
  /** Filter by the object’s `country` field. */
  country?: InputMaybe<StringFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<QuoteViewFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<QuoteViewFilter>>;
  /** Filter by the object’s `quote` relation. */
  quote?: InputMaybe<QuoteFilter>;
  /** Filter by the object’s `quoteId` field. */
  quoteId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `timezone` field. */
  timezone?: InputMaybe<StringFilter>;
  /** Filter by the object’s `userIp` field. */
  userIp?: InputMaybe<StringFilter>;
  /** Filter by the object’s `viewType` field. */
  viewType?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `QuoteView` */
export type QuoteViewInput = {
  city?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  quoteId?: InputMaybe<Scalars['UUID']['input']>;
  quoteToQuoteId?: InputMaybe<FkQuoteViewQuoteQuoteIdInput>;
  timezone?: InputMaybe<Scalars['String']['input']>;
  userIp?: InputMaybe<Scalars['String']['input']>;
  viewType?: InputMaybe<Scalars['String']['input']>;
};

/** The fields on `quoteView` to look up the row to update. */
export type QuoteViewOnQuoteViewForFkQuoteViewQuoteQuoteIdUsingPkQuoteViewUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `quoteView` being updated. */
  patch: UpdateQuoteViewOnQuoteViewForFkQuoteViewQuoteQuoteIdPatch;
};

/** Represents an update to a `QuoteView`. Fields that are set will be updated. */
export type QuoteViewPatch = {
  city?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  quoteId?: InputMaybe<Scalars['UUID']['input']>;
  quoteToQuoteId?: InputMaybe<FkQuoteViewQuoteQuoteIdInput>;
  timezone?: InputMaybe<Scalars['String']['input']>;
  userIp?: InputMaybe<Scalars['String']['input']>;
  viewType?: InputMaybe<Scalars['String']['input']>;
};

/** The fields on `quoteView` to look up the row to connect. */
export type QuoteViewPkQuoteViewConnect = {
  id: Scalars['UUID']['input'];
};

/** The fields on `quoteView` to look up the row to delete. */
export type QuoteViewPkQuoteViewDelete = {
  id: Scalars['UUID']['input'];
};

/** A connection to a list of `QuoteView` values. */
export type QuoteViewsConnection = {
  __typename?: 'QuoteViewsConnection';
  /** A list of edges which contains the `QuoteView` and cursor to aid in pagination. */
  edges: Array<QuoteViewsEdge>;
  /** A list of `QuoteView` objects. */
  nodes: Array<Maybe<QuoteView>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `QuoteView` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `QuoteView` edge in the connection. */
export type QuoteViewsEdge = {
  __typename?: 'QuoteViewsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `QuoteView` at the end of the edge. */
  node?: Maybe<QuoteView>;
};

/** Methods to use when ordering `QuoteView`. */
export enum QuoteViewsOrderBy {
  CityAsc = 'CITY_ASC',
  CityDesc = 'CITY_DESC',
  CountryAsc = 'COUNTRY_ASC',
  CountryDesc = 'COUNTRY_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QuoteByQuoteIdAdjustmentAsc = 'QUOTE_BY_QUOTE_ID__ADJUSTMENT_ASC',
  QuoteByQuoteIdAdjustmentDesc = 'QUOTE_BY_QUOTE_ID__ADJUSTMENT_DESC',
  QuoteByQuoteIdAgentMarginAsc = 'QUOTE_BY_QUOTE_ID__AGENT_MARGIN_ASC',
  QuoteByQuoteIdAgentMarginDesc = 'QUOTE_BY_QUOTE_ID__AGENT_MARGIN_DESC',
  QuoteByQuoteIdArchivedAsc = 'QUOTE_BY_QUOTE_ID__ARCHIVED_ASC',
  QuoteByQuoteIdArchivedDesc = 'QUOTE_BY_QUOTE_ID__ARCHIVED_DESC',
  QuoteByQuoteIdBaseCurrencyAsc = 'QUOTE_BY_QUOTE_ID__BASE_CURRENCY_ASC',
  QuoteByQuoteIdBaseCurrencyDesc = 'QUOTE_BY_QUOTE_ID__BASE_CURRENCY_DESC',
  QuoteByQuoteIdCreatedAsc = 'QUOTE_BY_QUOTE_ID__CREATED_ASC',
  QuoteByQuoteIdCreatedDesc = 'QUOTE_BY_QUOTE_ID__CREATED_DESC',
  QuoteByQuoteIdDepositAsc = 'QUOTE_BY_QUOTE_ID__DEPOSIT_ASC',
  QuoteByQuoteIdDepositDesc = 'QUOTE_BY_QUOTE_ID__DEPOSIT_DESC',
  QuoteByQuoteIdDurationAsc = 'QUOTE_BY_QUOTE_ID__DURATION_ASC',
  QuoteByQuoteIdDurationDesc = 'QUOTE_BY_QUOTE_ID__DURATION_DESC',
  QuoteByQuoteIdExclusionsAsc = 'QUOTE_BY_QUOTE_ID__EXCLUSIONS_ASC',
  QuoteByQuoteIdExclusionsDesc = 'QUOTE_BY_QUOTE_ID__EXCLUSIONS_DESC',
  QuoteByQuoteIdExpiresAsc = 'QUOTE_BY_QUOTE_ID__EXPIRES_ASC',
  QuoteByQuoteIdExpiresDesc = 'QUOTE_BY_QUOTE_ID__EXPIRES_DESC',
  QuoteByQuoteIdHeroIdAsc = 'QUOTE_BY_QUOTE_ID__HERO_ID_ASC',
  QuoteByQuoteIdHeroIdDesc = 'QUOTE_BY_QUOTE_ID__HERO_ID_DESC',
  QuoteByQuoteIdHeroImageIdAsc = 'QUOTE_BY_QUOTE_ID__HERO_IMAGE_ID_ASC',
  QuoteByQuoteIdHeroImageIdDesc = 'QUOTE_BY_QUOTE_ID__HERO_IMAGE_ID_DESC',
  QuoteByQuoteIdIdAsc = 'QUOTE_BY_QUOTE_ID__ID_ASC',
  QuoteByQuoteIdIdDesc = 'QUOTE_BY_QUOTE_ID__ID_DESC',
  QuoteByQuoteIdInclusionsAsc = 'QUOTE_BY_QUOTE_ID__INCLUSIONS_ASC',
  QuoteByQuoteIdInclusionsDesc = 'QUOTE_BY_QUOTE_ID__INCLUSIONS_DESC',
  QuoteByQuoteIdKeyAsc = 'QUOTE_BY_QUOTE_ID__KEY_ASC',
  QuoteByQuoteIdKeyDesc = 'QUOTE_BY_QUOTE_ID__KEY_DESC',
  QuoteByQuoteIdLockedAsc = 'QUOTE_BY_QUOTE_ID__LOCKED_ASC',
  QuoteByQuoteIdLockedDesc = 'QUOTE_BY_QUOTE_ID__LOCKED_DESC',
  QuoteByQuoteIdMarginAsc = 'QUOTE_BY_QUOTE_ID__MARGIN_ASC',
  QuoteByQuoteIdMarginDesc = 'QUOTE_BY_QUOTE_ID__MARGIN_DESC',
  QuoteByQuoteIdModifiedAsc = 'QUOTE_BY_QUOTE_ID__MODIFIED_ASC',
  QuoteByQuoteIdModifiedDesc = 'QUOTE_BY_QUOTE_ID__MODIFIED_DESC',
  QuoteByQuoteIdShortDescriptionAsc = 'QUOTE_BY_QUOTE_ID__SHORT_DESCRIPTION_ASC',
  QuoteByQuoteIdShortDescriptionDesc = 'QUOTE_BY_QUOTE_ID__SHORT_DESCRIPTION_DESC',
  QuoteByQuoteIdStartAsc = 'QUOTE_BY_QUOTE_ID__START_ASC',
  QuoteByQuoteIdStartDesc = 'QUOTE_BY_QUOTE_ID__START_DESC',
  QuoteByQuoteIdStatusAsc = 'QUOTE_BY_QUOTE_ID__STATUS_ASC',
  QuoteByQuoteIdStatusDesc = 'QUOTE_BY_QUOTE_ID__STATUS_DESC',
  QuoteByQuoteIdSummaryAsc = 'QUOTE_BY_QUOTE_ID__SUMMARY_ASC',
  QuoteByQuoteIdSummaryDesc = 'QUOTE_BY_QUOTE_ID__SUMMARY_DESC',
  QuoteByQuoteIdTravellerCountAsc = 'QUOTE_BY_QUOTE_ID__TRAVELLER_COUNT_ASC',
  QuoteByQuoteIdTravellerCountDesc = 'QUOTE_BY_QUOTE_ID__TRAVELLER_COUNT_DESC',
  QuoteByQuoteIdTripIdAsc = 'QUOTE_BY_QUOTE_ID__TRIP_ID_ASC',
  QuoteByQuoteIdTripIdDesc = 'QUOTE_BY_QUOTE_ID__TRIP_ID_DESC',
  QuoteByQuoteIdUserIdAsc = 'QUOTE_BY_QUOTE_ID__USER_ID_ASC',
  QuoteByQuoteIdUserIdDesc = 'QUOTE_BY_QUOTE_ID__USER_ID_DESC',
  QuoteIdAsc = 'QUOTE_ID_ASC',
  QuoteIdDesc = 'QUOTE_ID_DESC',
  TimezoneAsc = 'TIMEZONE_ASC',
  TimezoneDesc = 'TIMEZONE_DESC',
  UserIpAsc = 'USER_IP_ASC',
  UserIpDesc = 'USER_IP_DESC',
  ViewTypeAsc = 'VIEW_TYPE_ASC',
  ViewTypeDesc = 'VIEW_TYPE_DESC'
}

/** A connection to a list of `Quote` values. */
export type QuotesConnection = {
  __typename?: 'QuotesConnection';
  /** A list of edges which contains the `Quote` and cursor to aid in pagination. */
  edges: Array<QuotesEdge>;
  /** A list of `Quote` objects. */
  nodes: Array<Maybe<Quote>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Quote` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Quote` edge in the connection. */
export type QuotesEdge = {
  __typename?: 'QuotesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Quote` at the end of the edge. */
  node?: Maybe<Quote>;
};

/** Methods to use when ordering `Quote`. */
export enum QuotesOrderBy {
  AdjustmentAsc = 'ADJUSTMENT_ASC',
  AdjustmentDesc = 'ADJUSTMENT_DESC',
  AgentMarginAsc = 'AGENT_MARGIN_ASC',
  AgentMarginDesc = 'AGENT_MARGIN_DESC',
  ArchivedAsc = 'ARCHIVED_ASC',
  ArchivedDesc = 'ARCHIVED_DESC',
  BaseCurrencyAsc = 'BASE_CURRENCY_ASC',
  BaseCurrencyDesc = 'BASE_CURRENCY_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  DepositAsc = 'DEPOSIT_ASC',
  DepositDesc = 'DEPOSIT_DESC',
  DurationAsc = 'DURATION_ASC',
  DurationDesc = 'DURATION_DESC',
  EmailsByQuoteIdCountAsc = 'EMAILS_BY_QUOTE_ID__COUNT_ASC',
  EmailsByQuoteIdCountDesc = 'EMAILS_BY_QUOTE_ID__COUNT_DESC',
  ExclusionsAsc = 'EXCLUSIONS_ASC',
  ExclusionsDesc = 'EXCLUSIONS_DESC',
  ExpiresAsc = 'EXPIRES_ASC',
  ExpiresDesc = 'EXPIRES_DESC',
  HeroIdAsc = 'HERO_ID_ASC',
  HeroIdDesc = 'HERO_ID_DESC',
  HeroImageIdAsc = 'HERO_IMAGE_ID_ASC',
  HeroImageIdDesc = 'HERO_IMAGE_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  InclusionsAsc = 'INCLUSIONS_ASC',
  InclusionsDesc = 'INCLUSIONS_DESC',
  InvoicesByQuoteIdCountAsc = 'INVOICES_BY_QUOTE_ID__COUNT_ASC',
  InvoicesByQuoteIdCountDesc = 'INVOICES_BY_QUOTE_ID__COUNT_DESC',
  KeyAsc = 'KEY_ASC',
  KeyDesc = 'KEY_DESC',
  LockedAsc = 'LOCKED_ASC',
  LockedDesc = 'LOCKED_DESC',
  MarginAsc = 'MARGIN_ASC',
  MarginDesc = 'MARGIN_DESC',
  MediaItemByHeroImageIdContentTypeAsc = 'MEDIA_ITEM_BY_HERO_IMAGE_ID__CONTENT_TYPE_ASC',
  MediaItemByHeroImageIdContentTypeDesc = 'MEDIA_ITEM_BY_HERO_IMAGE_ID__CONTENT_TYPE_DESC',
  MediaItemByHeroImageIdCreatedAsc = 'MEDIA_ITEM_BY_HERO_IMAGE_ID__CREATED_ASC',
  MediaItemByHeroImageIdCreatedDesc = 'MEDIA_ITEM_BY_HERO_IMAGE_ID__CREATED_DESC',
  MediaItemByHeroImageIdFileNameAsc = 'MEDIA_ITEM_BY_HERO_IMAGE_ID__FILE_NAME_ASC',
  MediaItemByHeroImageIdFileNameDesc = 'MEDIA_ITEM_BY_HERO_IMAGE_ID__FILE_NAME_DESC',
  MediaItemByHeroImageIdHashAsc = 'MEDIA_ITEM_BY_HERO_IMAGE_ID__HASH_ASC',
  MediaItemByHeroImageIdHashDesc = 'MEDIA_ITEM_BY_HERO_IMAGE_ID__HASH_DESC',
  MediaItemByHeroImageIdIdAsc = 'MEDIA_ITEM_BY_HERO_IMAGE_ID__ID_ASC',
  MediaItemByHeroImageIdIdDesc = 'MEDIA_ITEM_BY_HERO_IMAGE_ID__ID_DESC',
  MediaItemByHeroImageIdModifiedAsc = 'MEDIA_ITEM_BY_HERO_IMAGE_ID__MODIFIED_ASC',
  MediaItemByHeroImageIdModifiedDesc = 'MEDIA_ITEM_BY_HERO_IMAGE_ID__MODIFIED_DESC',
  MediaItemByHeroImageIdNameAsc = 'MEDIA_ITEM_BY_HERO_IMAGE_ID__NAME_ASC',
  MediaItemByHeroImageIdNameDesc = 'MEDIA_ITEM_BY_HERO_IMAGE_ID__NAME_DESC',
  MediaItemByHeroImageIdSummaryAsc = 'MEDIA_ITEM_BY_HERO_IMAGE_ID__SUMMARY_ASC',
  MediaItemByHeroImageIdSummaryDesc = 'MEDIA_ITEM_BY_HERO_IMAGE_ID__SUMMARY_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QuoteAcceptancesByQuoteIdCountAsc = 'QUOTE_ACCEPTANCES_BY_QUOTE_ID__COUNT_ASC',
  QuoteAcceptancesByQuoteIdCountDesc = 'QUOTE_ACCEPTANCES_BY_QUOTE_ID__COUNT_DESC',
  QuoteAccommodationDetailsByQuoteIdCountAsc = 'QUOTE_ACCOMMODATION_DETAILS_BY_QUOTE_ID__COUNT_ASC',
  QuoteAccommodationDetailsByQuoteIdCountDesc = 'QUOTE_ACCOMMODATION_DETAILS_BY_QUOTE_ID__COUNT_DESC',
  QuoteCurrenciesByQuoteIdCountAsc = 'QUOTE_CURRENCIES_BY_QUOTE_ID__COUNT_ASC',
  QuoteCurrenciesByQuoteIdCountDesc = 'QUOTE_CURRENCIES_BY_QUOTE_ID__COUNT_DESC',
  QuoteDaysByQuoteIdCountAsc = 'QUOTE_DAYS_BY_QUOTE_ID__COUNT_ASC',
  QuoteDaysByQuoteIdCountDesc = 'QUOTE_DAYS_BY_QUOTE_ID__COUNT_DESC',
  QuoteFinanceLineItemsByQuoteIdCountAsc = 'QUOTE_FINANCE_LINE_ITEMS_BY_QUOTE_ID__COUNT_ASC',
  QuoteFinanceLineItemsByQuoteIdCountDesc = 'QUOTE_FINANCE_LINE_ITEMS_BY_QUOTE_ID__COUNT_DESC',
  QuoteHeroByHeroIdIdAsc = 'QUOTE_HERO_BY_HERO_ID__ID_ASC',
  QuoteHeroByHeroIdIdDesc = 'QUOTE_HERO_BY_HERO_ID__ID_DESC',
  QuoteHeroByHeroIdImageIdAsc = 'QUOTE_HERO_BY_HERO_ID__IMAGE_ID_ASC',
  QuoteHeroByHeroIdImageIdDesc = 'QUOTE_HERO_BY_HERO_ID__IMAGE_ID_DESC',
  QuoteHeroByHeroIdStyleAsc = 'QUOTE_HERO_BY_HERO_ID__STYLE_ASC',
  QuoteHeroByHeroIdStyleDesc = 'QUOTE_HERO_BY_HERO_ID__STYLE_DESC',
  QuoteHeroByHeroIdSubtitleAsc = 'QUOTE_HERO_BY_HERO_ID__SUBTITLE_ASC',
  QuoteHeroByHeroIdSubtitleDesc = 'QUOTE_HERO_BY_HERO_ID__SUBTITLE_DESC',
  QuoteHeroByHeroIdTitleAsc = 'QUOTE_HERO_BY_HERO_ID__TITLE_ASC',
  QuoteHeroByHeroIdTitleDesc = 'QUOTE_HERO_BY_HERO_ID__TITLE_DESC',
  QuoteLegalDocumentsByQuoteIdCountAsc = 'QUOTE_LEGAL_DOCUMENTS_BY_QUOTE_ID__COUNT_ASC',
  QuoteLegalDocumentsByQuoteIdCountDesc = 'QUOTE_LEGAL_DOCUMENTS_BY_QUOTE_ID__COUNT_DESC',
  QuoteStatusByStatusIdAsc = 'QUOTE_STATUS_BY_STATUS__ID_ASC',
  QuoteStatusByStatusIdDesc = 'QUOTE_STATUS_BY_STATUS__ID_DESC',
  QuoteStatusByStatusNameAsc = 'QUOTE_STATUS_BY_STATUS__NAME_ASC',
  QuoteStatusByStatusNameDesc = 'QUOTE_STATUS_BY_STATUS__NAME_DESC',
  QuoteViewsByQuoteIdCountAsc = 'QUOTE_VIEWS_BY_QUOTE_ID__COUNT_ASC',
  QuoteViewsByQuoteIdCountDesc = 'QUOTE_VIEWS_BY_QUOTE_ID__COUNT_DESC',
  ShortDescriptionAsc = 'SHORT_DESCRIPTION_ASC',
  ShortDescriptionDesc = 'SHORT_DESCRIPTION_DESC',
  StartAsc = 'START_ASC',
  StartDesc = 'START_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  SummaryAsc = 'SUMMARY_ASC',
  SummaryDesc = 'SUMMARY_DESC',
  TravellerCountAsc = 'TRAVELLER_COUNT_ASC',
  TravellerCountDesc = 'TRAVELLER_COUNT_DESC',
  TripsByActiveQuoteIdCountAsc = 'TRIPS_BY_ACTIVE_QUOTE_ID__COUNT_ASC',
  TripsByActiveQuoteIdCountDesc = 'TRIPS_BY_ACTIVE_QUOTE_ID__COUNT_DESC',
  TripByTripIdActiveQuoteIdAsc = 'TRIP_BY_TRIP_ID__ACTIVE_QUOTE_ID_ASC',
  TripByTripIdActiveQuoteIdDesc = 'TRIP_BY_TRIP_ID__ACTIVE_QUOTE_ID_DESC',
  TripByTripIdAgencyIdAsc = 'TRIP_BY_TRIP_ID__AGENCY_ID_ASC',
  TripByTripIdAgencyIdDesc = 'TRIP_BY_TRIP_ID__AGENCY_ID_DESC',
  TripByTripIdAgencyMemberIdAsc = 'TRIP_BY_TRIP_ID__AGENCY_MEMBER_ID_ASC',
  TripByTripIdAgencyMemberIdDesc = 'TRIP_BY_TRIP_ID__AGENCY_MEMBER_ID_DESC',
  TripByTripIdArchivedAsc = 'TRIP_BY_TRIP_ID__ARCHIVED_ASC',
  TripByTripIdArchivedDesc = 'TRIP_BY_TRIP_ID__ARCHIVED_DESC',
  TripByTripIdBaseCurrencyAsc = 'TRIP_BY_TRIP_ID__BASE_CURRENCY_ASC',
  TripByTripIdBaseCurrencyDesc = 'TRIP_BY_TRIP_ID__BASE_CURRENCY_DESC',
  TripByTripIdCreatedAsc = 'TRIP_BY_TRIP_ID__CREATED_ASC',
  TripByTripIdCreatedDesc = 'TRIP_BY_TRIP_ID__CREATED_DESC',
  TripByTripIdCustomerIdAsc = 'TRIP_BY_TRIP_ID__CUSTOMER_ID_ASC',
  TripByTripIdCustomerIdDesc = 'TRIP_BY_TRIP_ID__CUSTOMER_ID_DESC',
  TripByTripIdDatesAsc = 'TRIP_BY_TRIP_ID__DATES_ASC',
  TripByTripIdDatesDesc = 'TRIP_BY_TRIP_ID__DATES_DESC',
  TripByTripIdDestinationAsc = 'TRIP_BY_TRIP_ID__DESTINATION_ASC',
  TripByTripIdDestinationDesc = 'TRIP_BY_TRIP_ID__DESTINATION_DESC',
  TripByTripIdDurationAsc = 'TRIP_BY_TRIP_ID__DURATION_ASC',
  TripByTripIdDurationDesc = 'TRIP_BY_TRIP_ID__DURATION_DESC',
  TripByTripIdIdAsc = 'TRIP_BY_TRIP_ID__ID_ASC',
  TripByTripIdIdDesc = 'TRIP_BY_TRIP_ID__ID_DESC',
  TripByTripIdMediaGalleryIdAsc = 'TRIP_BY_TRIP_ID__MEDIA_GALLERY_ID_ASC',
  TripByTripIdMediaGalleryIdDesc = 'TRIP_BY_TRIP_ID__MEDIA_GALLERY_ID_DESC',
  TripByTripIdModifiedAsc = 'TRIP_BY_TRIP_ID__MODIFIED_ASC',
  TripByTripIdModifiedDesc = 'TRIP_BY_TRIP_ID__MODIFIED_DESC',
  TripByTripIdNameAsc = 'TRIP_BY_TRIP_ID__NAME_ASC',
  TripByTripIdNameDesc = 'TRIP_BY_TRIP_ID__NAME_DESC',
  TripByTripIdStartAsc = 'TRIP_BY_TRIP_ID__START_ASC',
  TripByTripIdStartDesc = 'TRIP_BY_TRIP_ID__START_DESC',
  TripByTripIdStatusAsc = 'TRIP_BY_TRIP_ID__STATUS_ASC',
  TripByTripIdStatusDesc = 'TRIP_BY_TRIP_ID__STATUS_DESC',
  TripByTripIdSummaryAsc = 'TRIP_BY_TRIP_ID__SUMMARY_ASC',
  TripByTripIdSummaryDesc = 'TRIP_BY_TRIP_ID__SUMMARY_DESC',
  TripByTripIdUserIdAsc = 'TRIP_BY_TRIP_ID__USER_ID_ASC',
  TripByTripIdUserIdDesc = 'TRIP_BY_TRIP_ID__USER_ID_DESC',
  TripIdAsc = 'TRIP_ID_ASC',
  TripIdDesc = 'TRIP_ID_DESC',
  UserByUserIdCreatedAsc = 'USER_BY_USER_ID__CREATED_ASC',
  UserByUserIdCreatedDesc = 'USER_BY_USER_ID__CREATED_DESC',
  UserByUserIdEmailAsc = 'USER_BY_USER_ID__EMAIL_ASC',
  UserByUserIdEmailDesc = 'USER_BY_USER_ID__EMAIL_DESC',
  UserByUserIdExternalIdAsc = 'USER_BY_USER_ID__EXTERNAL_ID_ASC',
  UserByUserIdExternalIdDesc = 'USER_BY_USER_ID__EXTERNAL_ID_DESC',
  UserByUserIdFirstNameAsc = 'USER_BY_USER_ID__FIRST_NAME_ASC',
  UserByUserIdFirstNameDesc = 'USER_BY_USER_ID__FIRST_NAME_DESC',
  UserByUserIdGenderPrepositionAsc = 'USER_BY_USER_ID__GENDER_PREPOSITION_ASC',
  UserByUserIdGenderPrepositionDesc = 'USER_BY_USER_ID__GENDER_PREPOSITION_DESC',
  UserByUserIdIdAsc = 'USER_BY_USER_ID__ID_ASC',
  UserByUserIdIdDesc = 'USER_BY_USER_ID__ID_DESC',
  UserByUserIdLastNameAsc = 'USER_BY_USER_ID__LAST_NAME_ASC',
  UserByUserIdLastNameDesc = 'USER_BY_USER_ID__LAST_NAME_DESC',
  UserByUserIdModifiedAsc = 'USER_BY_USER_ID__MODIFIED_ASC',
  UserByUserIdModifiedDesc = 'USER_BY_USER_ID__MODIFIED_DESC',
  UserByUserIdNameAsc = 'USER_BY_USER_ID__NAME_ASC',
  UserByUserIdNameDesc = 'USER_BY_USER_ID__NAME_DESC',
  UserByUserIdPasswordAsc = 'USER_BY_USER_ID__PASSWORD_ASC',
  UserByUserIdPasswordDesc = 'USER_BY_USER_ID__PASSWORD_DESC',
  UserByUserIdPhoneAsc = 'USER_BY_USER_ID__PHONE_ASC',
  UserByUserIdPhoneDesc = 'USER_BY_USER_ID__PHONE_DESC',
  UserByUserIdSkypeAsc = 'USER_BY_USER_ID__SKYPE_ASC',
  UserByUserIdSkypeDesc = 'USER_BY_USER_ID__SKYPE_DESC',
  UserByUserIdTitleAsc = 'USER_BY_USER_ID__TITLE_ASC',
  UserByUserIdTitleDesc = 'USER_BY_USER_ID__TITLE_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

/** All input for the `randomString` mutation. */
export type RandomStringInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  len?: InputMaybe<Scalars['Int']['input']>;
};

/** The output of our `randomString` mutation. */
export type RandomStringPayload = {
  __typename?: 'RandomStringPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  string?: Maybe<Scalars['String']['output']>;
};

export type RatesResponse = {
  __typename?: 'RatesResponse';
  rate: Scalars['BigFloat']['output'];
  source: Scalars['String']['output'];
  target: Scalars['String']['output'];
  time: Scalars['String']['output'];
};

export type Reminder = {
  __typename?: 'Reminder';
  body?: Maybe<Scalars['String']['output']>;
  date: Scalars['Datetime']['output'];
  id: Scalars['UUID']['output'];
  /** Reads a single `User` that is related to this `Reminder`. */
  user?: Maybe<User>;
  userId: Scalars['UUID']['output'];
};

/**
 * A condition to be used against `Reminder` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type ReminderCondition = {
  /** Checks for equality with the object’s `body` field. */
  body?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `date` field. */
  date?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['UUID']['input']>;
};

/** A filter to be used against `Reminder` object types. All fields are combined with a logical ‘and.’ */
export type ReminderFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ReminderFilter>>;
  /** Filter by the object’s `body` field. */
  body?: InputMaybe<StringFilter>;
  /** Filter by the object’s `date` field. */
  date?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ReminderFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ReminderFilter>>;
  /** Filter by the object’s `user` relation. */
  user?: InputMaybe<UserFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<UuidFilter>;
};

/** An input for mutations affecting `Reminder` */
export type ReminderInput = {
  body?: InputMaybe<Scalars['String']['input']>;
  date: Scalars['Datetime']['input'];
  id?: InputMaybe<Scalars['UUID']['input']>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkReminderUserUserIdInput>;
};

/** The fields on `reminder` to look up the row to update. */
export type ReminderOnReminderForFkReminderUserUserIdUsingPkReminderUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `reminder` being updated. */
  patch: UpdateReminderOnReminderForFkReminderUserUserIdPatch;
};

/** Represents an update to a `Reminder`. Fields that are set will be updated. */
export type ReminderPatch = {
  body?: InputMaybe<Scalars['String']['input']>;
  date?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkReminderUserUserIdInput>;
};

/** The fields on `reminder` to look up the row to connect. */
export type ReminderPkReminderConnect = {
  id: Scalars['UUID']['input'];
};

/** The fields on `reminder` to look up the row to delete. */
export type ReminderPkReminderDelete = {
  id: Scalars['UUID']['input'];
};

/** A connection to a list of `Reminder` values. */
export type RemindersConnection = {
  __typename?: 'RemindersConnection';
  /** A list of edges which contains the `Reminder` and cursor to aid in pagination. */
  edges: Array<RemindersEdge>;
  /** A list of `Reminder` objects. */
  nodes: Array<Maybe<Reminder>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Reminder` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Reminder` edge in the connection. */
export type RemindersEdge = {
  __typename?: 'RemindersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Reminder` at the end of the edge. */
  node?: Maybe<Reminder>;
};

/** Methods to use when ordering `Reminder`. */
export enum RemindersOrderBy {
  BodyAsc = 'BODY_ASC',
  BodyDesc = 'BODY_DESC',
  DateAsc = 'DATE_ASC',
  DateDesc = 'DATE_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UserByUserIdCreatedAsc = 'USER_BY_USER_ID__CREATED_ASC',
  UserByUserIdCreatedDesc = 'USER_BY_USER_ID__CREATED_DESC',
  UserByUserIdEmailAsc = 'USER_BY_USER_ID__EMAIL_ASC',
  UserByUserIdEmailDesc = 'USER_BY_USER_ID__EMAIL_DESC',
  UserByUserIdExternalIdAsc = 'USER_BY_USER_ID__EXTERNAL_ID_ASC',
  UserByUserIdExternalIdDesc = 'USER_BY_USER_ID__EXTERNAL_ID_DESC',
  UserByUserIdFirstNameAsc = 'USER_BY_USER_ID__FIRST_NAME_ASC',
  UserByUserIdFirstNameDesc = 'USER_BY_USER_ID__FIRST_NAME_DESC',
  UserByUserIdGenderPrepositionAsc = 'USER_BY_USER_ID__GENDER_PREPOSITION_ASC',
  UserByUserIdGenderPrepositionDesc = 'USER_BY_USER_ID__GENDER_PREPOSITION_DESC',
  UserByUserIdIdAsc = 'USER_BY_USER_ID__ID_ASC',
  UserByUserIdIdDesc = 'USER_BY_USER_ID__ID_DESC',
  UserByUserIdLastNameAsc = 'USER_BY_USER_ID__LAST_NAME_ASC',
  UserByUserIdLastNameDesc = 'USER_BY_USER_ID__LAST_NAME_DESC',
  UserByUserIdModifiedAsc = 'USER_BY_USER_ID__MODIFIED_ASC',
  UserByUserIdModifiedDesc = 'USER_BY_USER_ID__MODIFIED_DESC',
  UserByUserIdNameAsc = 'USER_BY_USER_ID__NAME_ASC',
  UserByUserIdNameDesc = 'USER_BY_USER_ID__NAME_DESC',
  UserByUserIdPasswordAsc = 'USER_BY_USER_ID__PASSWORD_ASC',
  UserByUserIdPasswordDesc = 'USER_BY_USER_ID__PASSWORD_DESC',
  UserByUserIdPhoneAsc = 'USER_BY_USER_ID__PHONE_ASC',
  UserByUserIdPhoneDesc = 'USER_BY_USER_ID__PHONE_DESC',
  UserByUserIdSkypeAsc = 'USER_BY_USER_ID__SKYPE_ASC',
  UserByUserIdSkypeDesc = 'USER_BY_USER_ID__SKYPE_DESC',
  UserByUserIdTitleAsc = 'USER_BY_USER_ID__TITLE_ASC',
  UserByUserIdTitleDesc = 'USER_BY_USER_ID__TITLE_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

/** A filter to be used against String fields. All fields are combined with a logical ‘and.’ */
export type StringFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['String']['input']>;
  /** Not equal to the specified value, treating null like an ordinary value (case-insensitive). */
  distinctFromInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Ends with the specified string (case-sensitive). */
  endsWith?: InputMaybe<Scalars['String']['input']>;
  /** Ends with the specified string (case-insensitive). */
  endsWithInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['String']['input']>;
  /** Equal to the specified value (case-insensitive). */
  equalToInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['String']['input']>;
  /** Greater than the specified value (case-insensitive). */
  greaterThanInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['String']['input']>;
  /** Greater than or equal to the specified value (case-insensitive). */
  greaterThanOrEqualToInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Included in the specified list (case-insensitive). */
  inInsensitive?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Contains the specified string (case-sensitive). */
  includes?: InputMaybe<Scalars['String']['input']>;
  /** Contains the specified string (case-insensitive). */
  includesInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['String']['input']>;
  /** Less than the specified value (case-insensitive). */
  lessThanInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['String']['input']>;
  /** Less than or equal to the specified value (case-insensitive). */
  lessThanOrEqualToInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Matches the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  like?: InputMaybe<Scalars['String']['input']>;
  /** Matches the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  likeInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['String']['input']>;
  /** Equal to the specified value, treating null like an ordinary value (case-insensitive). */
  notDistinctFromInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Does not end with the specified string (case-sensitive). */
  notEndsWith?: InputMaybe<Scalars['String']['input']>;
  /** Does not end with the specified string (case-insensitive). */
  notEndsWithInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['String']['input']>;
  /** Not equal to the specified value (case-insensitive). */
  notEqualToInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Not included in the specified list (case-insensitive). */
  notInInsensitive?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Does not contain the specified string (case-sensitive). */
  notIncludes?: InputMaybe<Scalars['String']['input']>;
  /** Does not contain the specified string (case-insensitive). */
  notIncludesInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Does not match the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLike?: InputMaybe<Scalars['String']['input']>;
  /** Does not match the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLikeInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Does not start with the specified string (case-sensitive). */
  notStartsWith?: InputMaybe<Scalars['String']['input']>;
  /** Does not start with the specified string (case-insensitive). */
  notStartsWithInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Starts with the specified string (case-sensitive). */
  startsWith?: InputMaybe<Scalars['String']['input']>;
  /** Starts with the specified string (case-insensitive). */
  startsWithInsensitive?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against String List fields. All fields are combined with a logical ‘and.’ */
export type StringListFilter = {
  /** Any array item is equal to the specified value. */
  anyEqualTo?: InputMaybe<Scalars['String']['input']>;
  /** Any array item is greater than the specified value. */
  anyGreaterThan?: InputMaybe<Scalars['String']['input']>;
  /** Any array item is greater than or equal to the specified value. */
  anyGreaterThanOrEqualTo?: InputMaybe<Scalars['String']['input']>;
  /** Any array item is less than the specified value. */
  anyLessThan?: InputMaybe<Scalars['String']['input']>;
  /** Any array item is less than or equal to the specified value. */
  anyLessThanOrEqualTo?: InputMaybe<Scalars['String']['input']>;
  /** Any array item is not equal to the specified value. */
  anyNotEqualTo?: InputMaybe<Scalars['String']['input']>;
  /** Contained by the specified list of values. */
  containedBy?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Contains the specified list of values. */
  contains?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Overlaps the specified list of values. */
  overlaps?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

export type SubmitEnquiryInput = {
  area?: InputMaybe<Scalars['String']['input']>;
  company?: InputMaybe<Scalars['String']['input']>;
  email: Scalars['String']['input'];
  firstName: Scalars['String']['input'];
  ip?: InputMaybe<Scalars['String']['input']>;
  lastName: Scalars['String']['input'];
  message?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  source?: InputMaybe<Scalars['String']['input']>;
};

export type Supplier = {
  __typename?: 'Supplier';
  /** Reads and enables pagination through a set of `Agency`. */
  agencies: AgenciesConnection;
  bankDetails?: Maybe<Scalars['String']['output']>;
  contactEmail?: Maybe<Scalars['String']['output']>;
  contactNumber?: Maybe<Scalars['String']['output']>;
  created: Scalars['Datetime']['output'];
  /** Reads and enables pagination through a set of `Expense`. */
  expenses: ExpensesConnection;
  /** Reads a single `MediaGallery` that is related to this `Supplier`. */
  gallery?: Maybe<MediaGallery>;
  galleryId?: Maybe<Scalars['UUID']['output']>;
  id: Scalars['UUID']['output'];
  modified: Scalars['Datetime']['output'];
  name?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `QuoteFinanceLineItem`. */
  quoteFinanceLineItems: QuoteFinanceLineItemsConnection;
  region?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `SupplierInvoice`. */
  supplierInvoices: SupplierInvoicesConnection;
  url?: Maybe<Scalars['String']['output']>;
};


export type SupplierAgenciesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AgencyCondition>;
  filter?: InputMaybe<AgencyFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AgenciesOrderBy>>;
};


export type SupplierExpensesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ExpenseCondition>;
  filter?: InputMaybe<ExpenseFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ExpensesOrderBy>>;
};


export type SupplierQuoteFinanceLineItemsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<QuoteFinanceLineItemCondition>;
  filter?: InputMaybe<QuoteFinanceLineItemFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuoteFinanceLineItemsOrderBy>>;
};


export type SupplierSupplierInvoicesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SupplierInvoiceCondition>;
  filter?: InputMaybe<SupplierInvoiceFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SupplierInvoicesOrderBy>>;
};

/**
 * A condition to be used against `Supplier` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type SupplierCondition = {
  /** Checks for equality with the object’s `bankDetails` field. */
  bankDetails?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `contactEmail` field. */
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `contactNumber` field. */
  contactNumber?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `galleryId` field. */
  galleryId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `region` field. */
  region?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `url` field. */
  url?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `Supplier` object types. All fields are combined with a logical ‘and.’ */
export type SupplierFilter = {
  /** Filter by the object’s `agencies` relation. */
  agencies?: InputMaybe<SupplierToManyAgencyFilter>;
  /** Some related `agencies` exist. */
  agenciesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<SupplierFilter>>;
  /** Filter by the object’s `bankDetails` field. */
  bankDetails?: InputMaybe<StringFilter>;
  /** Filter by the object’s `contactEmail` field. */
  contactEmail?: InputMaybe<StringFilter>;
  /** Filter by the object’s `contactNumber` field. */
  contactNumber?: InputMaybe<StringFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `expenses` relation. */
  expenses?: InputMaybe<SupplierToManyExpenseFilter>;
  /** Some related `expenses` exist. */
  expensesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `gallery` relation. */
  gallery?: InputMaybe<MediaGalleryFilter>;
  /** A related `gallery` exists. */
  galleryExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `galleryId` field. */
  galleryId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<SupplierFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<SupplierFilter>>;
  /** Filter by the object’s `quoteFinanceLineItems` relation. */
  quoteFinanceLineItems?: InputMaybe<SupplierToManyQuoteFinanceLineItemFilter>;
  /** Some related `quoteFinanceLineItems` exist. */
  quoteFinanceLineItemsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `region` field. */
  region?: InputMaybe<StringFilter>;
  /** Filter by the object’s `supplierInvoices` relation. */
  supplierInvoices?: InputMaybe<SupplierToManySupplierInvoiceFilter>;
  /** Some related `supplierInvoices` exist. */
  supplierInvoicesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `url` field. */
  url?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `Supplier` */
export type SupplierInput = {
  agenciesUsingId?: InputMaybe<FkAgencySupplierInverseInput>;
  bankDetails?: InputMaybe<Scalars['String']['input']>;
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  contactNumber?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  expensesUsingId?: InputMaybe<FkExpenseSupplierSupplierIdInverseInput>;
  galleryId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryToGalleryId?: InputMaybe<FkSupplierMediaGalleryGalleryIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  quoteFinanceLineItemsUsingId?: InputMaybe<FkQuoteFinanceLineItemSupplierSupplierIdInverseInput>;
  region?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceSupplierSupplierIdInverseInput>;
  url?: InputMaybe<Scalars['String']['input']>;
};

export type SupplierInvoice = {
  __typename?: 'SupplierInvoice';
  amount: Scalars['BigFloat']['output'];
  amountActual: Scalars['BigFloat']['output'];
  /** Reads a single `FinanceCategory` that is related to this `SupplierInvoice`. */
  category?: Maybe<FinanceCategory>;
  categoryId?: Maybe<Scalars['UUID']['output']>;
  created: Scalars['Datetime']['output'];
  currency?: Maybe<Scalars['String']['output']>;
  due: Scalars['Datetime']['output'];
  /** Reads and enables pagination through a set of `Expense`. */
  expenses: ExpensesConnection;
  id: Scalars['UUID']['output'];
  key?: Maybe<Scalars['String']['output']>;
  /** Reads a single `MediaItem` that is related to this `SupplierInvoice`. */
  mediaItem?: Maybe<MediaItem>;
  mediaItemId?: Maybe<Scalars['UUID']['output']>;
  modified: Scalars['Datetime']['output'];
  number?: Maybe<Scalars['Int']['output']>;
  paid?: Maybe<Scalars['Datetime']['output']>;
  summary?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Supplier` that is related to this `SupplierInvoice`. */
  supplier?: Maybe<Supplier>;
  supplierId: Scalars['UUID']['output'];
  /** Reads and enables pagination through a set of `TransactionLink`. */
  transactionLinks: TransactionLinksConnection;
  /** Reads a single `Trip` that is related to this `SupplierInvoice`. */
  trip?: Maybe<Trip>;
  tripId?: Maybe<Scalars['UUID']['output']>;
  type?: Maybe<Scalars['String']['output']>;
  voided?: Maybe<Scalars['Datetime']['output']>;
};


export type SupplierInvoiceExpensesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ExpenseCondition>;
  filter?: InputMaybe<ExpenseFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ExpensesOrderBy>>;
};


export type SupplierInvoiceTransactionLinksArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TransactionLinkCondition>;
  filter?: InputMaybe<TransactionLinkFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TransactionLinksOrderBy>>;
};

/**
 * A condition to be used against `SupplierInvoice` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type SupplierInvoiceCondition = {
  /** Checks for equality with the object’s `amount` field. */
  amount?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `amountActual` field. */
  amountActual?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `categoryId` field. */
  categoryId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `currency` field. */
  currency?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `due` field. */
  due?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `key` field. */
  key?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `mediaItemId` field. */
  mediaItemId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `number` field. */
  number?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `paid` field. */
  paid?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `summary` field. */
  summary?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `supplierId` field. */
  supplierId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `tripId` field. */
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `type` field. */
  type?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `voided` field. */
  voided?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A filter to be used against `SupplierInvoice` object types. All fields are combined with a logical ‘and.’ */
export type SupplierInvoiceFilter = {
  /** Filter by the object’s `amount` field. */
  amount?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `amountActual` field. */
  amountActual?: InputMaybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<SupplierInvoiceFilter>>;
  /** Filter by the object’s `category` relation. */
  category?: InputMaybe<FinanceCategoryFilter>;
  /** A related `category` exists. */
  categoryExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `categoryId` field. */
  categoryId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `currency` field. */
  currency?: InputMaybe<StringFilter>;
  /** Filter by the object’s `due` field. */
  due?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `expenses` relation. */
  expenses?: InputMaybe<SupplierInvoiceToManyExpenseFilter>;
  /** Some related `expenses` exist. */
  expensesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `key` field. */
  key?: InputMaybe<StringFilter>;
  /** Filter by the object’s `mediaItem` relation. */
  mediaItem?: InputMaybe<MediaItemFilter>;
  /** A related `mediaItem` exists. */
  mediaItemExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `mediaItemId` field. */
  mediaItemId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<SupplierInvoiceFilter>;
  /** Filter by the object’s `number` field. */
  number?: InputMaybe<IntFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<SupplierInvoiceFilter>>;
  /** Filter by the object’s `paid` field. */
  paid?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `summary` field. */
  summary?: InputMaybe<StringFilter>;
  /** Filter by the object’s `supplier` relation. */
  supplier?: InputMaybe<SupplierFilter>;
  /** Filter by the object’s `supplierId` field. */
  supplierId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `transactionLinks` relation. */
  transactionLinks?: InputMaybe<SupplierInvoiceToManyTransactionLinkFilter>;
  /** Some related `transactionLinks` exist. */
  transactionLinksExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `trip` relation. */
  trip?: InputMaybe<TripFilter>;
  /** A related `trip` exists. */
  tripExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `tripId` field. */
  tripId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `type` field. */
  type?: InputMaybe<StringFilter>;
  /** Filter by the object’s `voided` field. */
  voided?: InputMaybe<DatetimeFilter>;
};

/** An input for mutations affecting `SupplierInvoice` */
export type SupplierInvoiceInput = {
  amount: Scalars['BigFloat']['input'];
  amountActual?: InputMaybe<Scalars['BigFloat']['input']>;
  categoryId?: InputMaybe<Scalars['UUID']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  due: Scalars['Datetime']['input'];
  expensesUsingId?: InputMaybe<FkExpenseSupplierInvoiceSupplierInvoiceIdInverseInput>;
  financeCategoryToCategoryId?: InputMaybe<FkSupplierInvoiceFinanceCategoryCategoryIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  mediaItemId?: InputMaybe<Scalars['UUID']['input']>;
  mediaItemToMediaItemId?: InputMaybe<FkSupplierInvoiceMediaItemMediaItemIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  number?: InputMaybe<Scalars['Int']['input']>;
  paid?: InputMaybe<Scalars['Datetime']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierId?: InputMaybe<Scalars['UUID']['input']>;
  supplierToSupplierId?: InputMaybe<FkSupplierInvoiceSupplierSupplierIdInput>;
  transactionLinksUsingId?: InputMaybe<FkTransactionLinkSupplierInvoiceSupplierInvoiceIdInverseInput>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkSupplierInvoiceTripTripIdInput>;
  type?: InputMaybe<Scalars['String']['input']>;
  voided?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The fields on `supplierInvoice` to look up the row to update. */
export type SupplierInvoiceOnExpenseForFkExpenseSupplierInvoiceSupplierInvoiceIdUsingPkSupplierInvoiceUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `supplierInvoice` being updated. */
  patch: UpdateSupplierInvoiceOnExpenseForFkExpenseSupplierInvoiceSupplierInvoiceIdPatch;
};

/** The fields on `supplierInvoice` to look up the row to update. */
export type SupplierInvoiceOnSupplierInvoiceForFkSupplierInvoiceFinanceCategoryCategoryIdUsingPkSupplierInvoiceUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `supplierInvoice` being updated. */
  patch: UpdateSupplierInvoiceOnSupplierInvoiceForFkSupplierInvoiceFinanceCategoryCategoryIdPatch;
};

/** The fields on `supplierInvoice` to look up the row to update. */
export type SupplierInvoiceOnSupplierInvoiceForFkSupplierInvoiceMediaItemMediaItemIdUsingPkSupplierInvoiceUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `supplierInvoice` being updated. */
  patch: UpdateSupplierInvoiceOnSupplierInvoiceForFkSupplierInvoiceMediaItemMediaItemIdPatch;
};

/** The fields on `supplierInvoice` to look up the row to update. */
export type SupplierInvoiceOnSupplierInvoiceForFkSupplierInvoiceSupplierSupplierIdUsingPkSupplierInvoiceUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `supplierInvoice` being updated. */
  patch: UpdateSupplierInvoiceOnSupplierInvoiceForFkSupplierInvoiceSupplierSupplierIdPatch;
};

/** The fields on `supplierInvoice` to look up the row to update. */
export type SupplierInvoiceOnSupplierInvoiceForFkSupplierInvoiceTripTripIdUsingPkSupplierInvoiceUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `supplierInvoice` being updated. */
  patch: UpdateSupplierInvoiceOnSupplierInvoiceForFkSupplierInvoiceTripTripIdPatch;
};

/** The fields on `supplierInvoice` to look up the row to update. */
export type SupplierInvoiceOnTransactionLinkForFkTransactionLinkSupplierInvoiceSupplierInvoiceIdUsingPkSupplierInvoiceUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `supplierInvoice` being updated. */
  patch: UpdateSupplierInvoiceOnTransactionLinkForFkTransactionLinkSupplierInvoiceSupplierInvoiceIdPatch;
};

/** Represents an update to a `SupplierInvoice`. Fields that are set will be updated. */
export type SupplierInvoicePatch = {
  amount?: InputMaybe<Scalars['BigFloat']['input']>;
  amountActual?: InputMaybe<Scalars['BigFloat']['input']>;
  categoryId?: InputMaybe<Scalars['UUID']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  due?: InputMaybe<Scalars['Datetime']['input']>;
  expensesUsingId?: InputMaybe<FkExpenseSupplierInvoiceSupplierInvoiceIdInverseInput>;
  financeCategoryToCategoryId?: InputMaybe<FkSupplierInvoiceFinanceCategoryCategoryIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  mediaItemId?: InputMaybe<Scalars['UUID']['input']>;
  mediaItemToMediaItemId?: InputMaybe<FkSupplierInvoiceMediaItemMediaItemIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  number?: InputMaybe<Scalars['Int']['input']>;
  paid?: InputMaybe<Scalars['Datetime']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierId?: InputMaybe<Scalars['UUID']['input']>;
  supplierToSupplierId?: InputMaybe<FkSupplierInvoiceSupplierSupplierIdInput>;
  transactionLinksUsingId?: InputMaybe<FkTransactionLinkSupplierInvoiceSupplierInvoiceIdInverseInput>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkSupplierInvoiceTripTripIdInput>;
  type?: InputMaybe<Scalars['String']['input']>;
  voided?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The fields on `supplierInvoice` to look up the row to connect. */
export type SupplierInvoicePkSupplierInvoiceConnect = {
  id: Scalars['UUID']['input'];
};

/** The fields on `supplierInvoice` to look up the row to delete. */
export type SupplierInvoicePkSupplierInvoiceDelete = {
  id: Scalars['UUID']['input'];
};

/** A filter to be used against many `Expense` object types. All fields are combined with a logical ‘and.’ */
export type SupplierInvoiceToManyExpenseFilter = {
  /** Every related `Expense` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ExpenseFilter>;
  /** No related `Expense` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ExpenseFilter>;
  /** Some related `Expense` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ExpenseFilter>;
};

/** A filter to be used against many `TransactionLink` object types. All fields are combined with a logical ‘and.’ */
export type SupplierInvoiceToManyTransactionLinkFilter = {
  /** Every related `TransactionLink` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<TransactionLinkFilter>;
  /** No related `TransactionLink` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<TransactionLinkFilter>;
  /** Some related `TransactionLink` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<TransactionLinkFilter>;
};

/** A connection to a list of `SupplierInvoice` values. */
export type SupplierInvoicesConnection = {
  __typename?: 'SupplierInvoicesConnection';
  /** A list of edges which contains the `SupplierInvoice` and cursor to aid in pagination. */
  edges: Array<SupplierInvoicesEdge>;
  /** A list of `SupplierInvoice` objects. */
  nodes: Array<Maybe<SupplierInvoice>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `SupplierInvoice` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `SupplierInvoice` edge in the connection. */
export type SupplierInvoicesEdge = {
  __typename?: 'SupplierInvoicesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `SupplierInvoice` at the end of the edge. */
  node?: Maybe<SupplierInvoice>;
};

/** Methods to use when ordering `SupplierInvoice`. */
export enum SupplierInvoicesOrderBy {
  AmountActualAsc = 'AMOUNT_ACTUAL_ASC',
  AmountActualDesc = 'AMOUNT_ACTUAL_DESC',
  AmountAsc = 'AMOUNT_ASC',
  AmountDesc = 'AMOUNT_DESC',
  CategoryIdAsc = 'CATEGORY_ID_ASC',
  CategoryIdDesc = 'CATEGORY_ID_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  CurrencyAsc = 'CURRENCY_ASC',
  CurrencyDesc = 'CURRENCY_DESC',
  DueAsc = 'DUE_ASC',
  DueDesc = 'DUE_DESC',
  ExpensesBySupplierInvoiceIdCountAsc = 'EXPENSES_BY_SUPPLIER_INVOICE_ID__COUNT_ASC',
  ExpensesBySupplierInvoiceIdCountDesc = 'EXPENSES_BY_SUPPLIER_INVOICE_ID__COUNT_DESC',
  FinanceCategoryByCategoryIdCodeAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__CODE_ASC',
  FinanceCategoryByCategoryIdCodeDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__CODE_DESC',
  FinanceCategoryByCategoryIdCreatedAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__CREATED_ASC',
  FinanceCategoryByCategoryIdCreatedDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__CREATED_DESC',
  FinanceCategoryByCategoryIdIdAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__ID_ASC',
  FinanceCategoryByCategoryIdIdDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__ID_DESC',
  FinanceCategoryByCategoryIdModifiedAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__MODIFIED_ASC',
  FinanceCategoryByCategoryIdModifiedDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__MODIFIED_DESC',
  FinanceCategoryByCategoryIdNameAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__NAME_ASC',
  FinanceCategoryByCategoryIdNameDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__NAME_DESC',
  FinanceCategoryByCategoryIdSummaryAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__SUMMARY_ASC',
  FinanceCategoryByCategoryIdSummaryDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__SUMMARY_DESC',
  FinanceCategoryByCategoryIdTypeAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__TYPE_ASC',
  FinanceCategoryByCategoryIdTypeDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__TYPE_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  KeyAsc = 'KEY_ASC',
  KeyDesc = 'KEY_DESC',
  MediaItemByMediaItemIdContentTypeAsc = 'MEDIA_ITEM_BY_MEDIA_ITEM_ID__CONTENT_TYPE_ASC',
  MediaItemByMediaItemIdContentTypeDesc = 'MEDIA_ITEM_BY_MEDIA_ITEM_ID__CONTENT_TYPE_DESC',
  MediaItemByMediaItemIdCreatedAsc = 'MEDIA_ITEM_BY_MEDIA_ITEM_ID__CREATED_ASC',
  MediaItemByMediaItemIdCreatedDesc = 'MEDIA_ITEM_BY_MEDIA_ITEM_ID__CREATED_DESC',
  MediaItemByMediaItemIdFileNameAsc = 'MEDIA_ITEM_BY_MEDIA_ITEM_ID__FILE_NAME_ASC',
  MediaItemByMediaItemIdFileNameDesc = 'MEDIA_ITEM_BY_MEDIA_ITEM_ID__FILE_NAME_DESC',
  MediaItemByMediaItemIdHashAsc = 'MEDIA_ITEM_BY_MEDIA_ITEM_ID__HASH_ASC',
  MediaItemByMediaItemIdHashDesc = 'MEDIA_ITEM_BY_MEDIA_ITEM_ID__HASH_DESC',
  MediaItemByMediaItemIdIdAsc = 'MEDIA_ITEM_BY_MEDIA_ITEM_ID__ID_ASC',
  MediaItemByMediaItemIdIdDesc = 'MEDIA_ITEM_BY_MEDIA_ITEM_ID__ID_DESC',
  MediaItemByMediaItemIdModifiedAsc = 'MEDIA_ITEM_BY_MEDIA_ITEM_ID__MODIFIED_ASC',
  MediaItemByMediaItemIdModifiedDesc = 'MEDIA_ITEM_BY_MEDIA_ITEM_ID__MODIFIED_DESC',
  MediaItemByMediaItemIdNameAsc = 'MEDIA_ITEM_BY_MEDIA_ITEM_ID__NAME_ASC',
  MediaItemByMediaItemIdNameDesc = 'MEDIA_ITEM_BY_MEDIA_ITEM_ID__NAME_DESC',
  MediaItemByMediaItemIdSummaryAsc = 'MEDIA_ITEM_BY_MEDIA_ITEM_ID__SUMMARY_ASC',
  MediaItemByMediaItemIdSummaryDesc = 'MEDIA_ITEM_BY_MEDIA_ITEM_ID__SUMMARY_DESC',
  MediaItemIdAsc = 'MEDIA_ITEM_ID_ASC',
  MediaItemIdDesc = 'MEDIA_ITEM_ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  Natural = 'NATURAL',
  NumberAsc = 'NUMBER_ASC',
  NumberDesc = 'NUMBER_DESC',
  PaidAsc = 'PAID_ASC',
  PaidDesc = 'PAID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SummaryAsc = 'SUMMARY_ASC',
  SummaryDesc = 'SUMMARY_DESC',
  SupplierBySupplierIdBankDetailsAsc = 'SUPPLIER_BY_SUPPLIER_ID__BANK_DETAILS_ASC',
  SupplierBySupplierIdBankDetailsDesc = 'SUPPLIER_BY_SUPPLIER_ID__BANK_DETAILS_DESC',
  SupplierBySupplierIdContactEmailAsc = 'SUPPLIER_BY_SUPPLIER_ID__CONTACT_EMAIL_ASC',
  SupplierBySupplierIdContactEmailDesc = 'SUPPLIER_BY_SUPPLIER_ID__CONTACT_EMAIL_DESC',
  SupplierBySupplierIdContactNumberAsc = 'SUPPLIER_BY_SUPPLIER_ID__CONTACT_NUMBER_ASC',
  SupplierBySupplierIdContactNumberDesc = 'SUPPLIER_BY_SUPPLIER_ID__CONTACT_NUMBER_DESC',
  SupplierBySupplierIdCreatedAsc = 'SUPPLIER_BY_SUPPLIER_ID__CREATED_ASC',
  SupplierBySupplierIdCreatedDesc = 'SUPPLIER_BY_SUPPLIER_ID__CREATED_DESC',
  SupplierBySupplierIdGalleryIdAsc = 'SUPPLIER_BY_SUPPLIER_ID__GALLERY_ID_ASC',
  SupplierBySupplierIdGalleryIdDesc = 'SUPPLIER_BY_SUPPLIER_ID__GALLERY_ID_DESC',
  SupplierBySupplierIdIdAsc = 'SUPPLIER_BY_SUPPLIER_ID__ID_ASC',
  SupplierBySupplierIdIdDesc = 'SUPPLIER_BY_SUPPLIER_ID__ID_DESC',
  SupplierBySupplierIdModifiedAsc = 'SUPPLIER_BY_SUPPLIER_ID__MODIFIED_ASC',
  SupplierBySupplierIdModifiedDesc = 'SUPPLIER_BY_SUPPLIER_ID__MODIFIED_DESC',
  SupplierBySupplierIdNameAsc = 'SUPPLIER_BY_SUPPLIER_ID__NAME_ASC',
  SupplierBySupplierIdNameDesc = 'SUPPLIER_BY_SUPPLIER_ID__NAME_DESC',
  SupplierBySupplierIdRegionAsc = 'SUPPLIER_BY_SUPPLIER_ID__REGION_ASC',
  SupplierBySupplierIdRegionDesc = 'SUPPLIER_BY_SUPPLIER_ID__REGION_DESC',
  SupplierBySupplierIdUrlAsc = 'SUPPLIER_BY_SUPPLIER_ID__URL_ASC',
  SupplierBySupplierIdUrlDesc = 'SUPPLIER_BY_SUPPLIER_ID__URL_DESC',
  SupplierIdAsc = 'SUPPLIER_ID_ASC',
  SupplierIdDesc = 'SUPPLIER_ID_DESC',
  TransactionLinksBySupplierInvoiceIdCountAsc = 'TRANSACTION_LINKS_BY_SUPPLIER_INVOICE_ID__COUNT_ASC',
  TransactionLinksBySupplierInvoiceIdCountDesc = 'TRANSACTION_LINKS_BY_SUPPLIER_INVOICE_ID__COUNT_DESC',
  TripByTripIdActiveQuoteIdAsc = 'TRIP_BY_TRIP_ID__ACTIVE_QUOTE_ID_ASC',
  TripByTripIdActiveQuoteIdDesc = 'TRIP_BY_TRIP_ID__ACTIVE_QUOTE_ID_DESC',
  TripByTripIdAgencyIdAsc = 'TRIP_BY_TRIP_ID__AGENCY_ID_ASC',
  TripByTripIdAgencyIdDesc = 'TRIP_BY_TRIP_ID__AGENCY_ID_DESC',
  TripByTripIdAgencyMemberIdAsc = 'TRIP_BY_TRIP_ID__AGENCY_MEMBER_ID_ASC',
  TripByTripIdAgencyMemberIdDesc = 'TRIP_BY_TRIP_ID__AGENCY_MEMBER_ID_DESC',
  TripByTripIdArchivedAsc = 'TRIP_BY_TRIP_ID__ARCHIVED_ASC',
  TripByTripIdArchivedDesc = 'TRIP_BY_TRIP_ID__ARCHIVED_DESC',
  TripByTripIdBaseCurrencyAsc = 'TRIP_BY_TRIP_ID__BASE_CURRENCY_ASC',
  TripByTripIdBaseCurrencyDesc = 'TRIP_BY_TRIP_ID__BASE_CURRENCY_DESC',
  TripByTripIdCreatedAsc = 'TRIP_BY_TRIP_ID__CREATED_ASC',
  TripByTripIdCreatedDesc = 'TRIP_BY_TRIP_ID__CREATED_DESC',
  TripByTripIdCustomerIdAsc = 'TRIP_BY_TRIP_ID__CUSTOMER_ID_ASC',
  TripByTripIdCustomerIdDesc = 'TRIP_BY_TRIP_ID__CUSTOMER_ID_DESC',
  TripByTripIdDatesAsc = 'TRIP_BY_TRIP_ID__DATES_ASC',
  TripByTripIdDatesDesc = 'TRIP_BY_TRIP_ID__DATES_DESC',
  TripByTripIdDestinationAsc = 'TRIP_BY_TRIP_ID__DESTINATION_ASC',
  TripByTripIdDestinationDesc = 'TRIP_BY_TRIP_ID__DESTINATION_DESC',
  TripByTripIdDurationAsc = 'TRIP_BY_TRIP_ID__DURATION_ASC',
  TripByTripIdDurationDesc = 'TRIP_BY_TRIP_ID__DURATION_DESC',
  TripByTripIdIdAsc = 'TRIP_BY_TRIP_ID__ID_ASC',
  TripByTripIdIdDesc = 'TRIP_BY_TRIP_ID__ID_DESC',
  TripByTripIdMediaGalleryIdAsc = 'TRIP_BY_TRIP_ID__MEDIA_GALLERY_ID_ASC',
  TripByTripIdMediaGalleryIdDesc = 'TRIP_BY_TRIP_ID__MEDIA_GALLERY_ID_DESC',
  TripByTripIdModifiedAsc = 'TRIP_BY_TRIP_ID__MODIFIED_ASC',
  TripByTripIdModifiedDesc = 'TRIP_BY_TRIP_ID__MODIFIED_DESC',
  TripByTripIdNameAsc = 'TRIP_BY_TRIP_ID__NAME_ASC',
  TripByTripIdNameDesc = 'TRIP_BY_TRIP_ID__NAME_DESC',
  TripByTripIdStartAsc = 'TRIP_BY_TRIP_ID__START_ASC',
  TripByTripIdStartDesc = 'TRIP_BY_TRIP_ID__START_DESC',
  TripByTripIdStatusAsc = 'TRIP_BY_TRIP_ID__STATUS_ASC',
  TripByTripIdStatusDesc = 'TRIP_BY_TRIP_ID__STATUS_DESC',
  TripByTripIdSummaryAsc = 'TRIP_BY_TRIP_ID__SUMMARY_ASC',
  TripByTripIdSummaryDesc = 'TRIP_BY_TRIP_ID__SUMMARY_DESC',
  TripByTripIdUserIdAsc = 'TRIP_BY_TRIP_ID__USER_ID_ASC',
  TripByTripIdUserIdDesc = 'TRIP_BY_TRIP_ID__USER_ID_DESC',
  TripIdAsc = 'TRIP_ID_ASC',
  TripIdDesc = 'TRIP_ID_DESC',
  TypeAsc = 'TYPE_ASC',
  TypeDesc = 'TYPE_DESC',
  VoidedAsc = 'VOIDED_ASC',
  VoidedDesc = 'VOIDED_DESC'
}

/** The fields on `supplier` to look up the row to update. */
export type SupplierOnAgencyForFkAgencySupplierUsingPkSupplierUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `supplier` being updated. */
  patch: UpdateSupplierOnAgencyForFkAgencySupplierPatch;
};

/** The fields on `supplier` to look up the row to update. */
export type SupplierOnExpenseForFkExpenseSupplierSupplierIdUsingPkSupplierUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `supplier` being updated. */
  patch: UpdateSupplierOnExpenseForFkExpenseSupplierSupplierIdPatch;
};

/** The fields on `supplier` to look up the row to update. */
export type SupplierOnQuoteFinanceLineItemForFkQuoteFinanceLineItemSupplierSupplierIdUsingPkSupplierUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `supplier` being updated. */
  patch: UpdateSupplierOnQuoteFinanceLineItemForFkQuoteFinanceLineItemSupplierSupplierIdPatch;
};

/** The fields on `supplier` to look up the row to update. */
export type SupplierOnSupplierForFkSupplierMediaGalleryGalleryIdUsingPkSupplierUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `supplier` being updated. */
  patch: UpdateSupplierOnSupplierForFkSupplierMediaGalleryGalleryIdPatch;
};

/** The fields on `supplier` to look up the row to update. */
export type SupplierOnSupplierInvoiceForFkSupplierInvoiceSupplierSupplierIdUsingPkSupplierUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `supplier` being updated. */
  patch: UpdateSupplierOnSupplierInvoiceForFkSupplierInvoiceSupplierSupplierIdPatch;
};

/** Represents an update to a `Supplier`. Fields that are set will be updated. */
export type SupplierPatch = {
  agenciesUsingId?: InputMaybe<FkAgencySupplierInverseInput>;
  bankDetails?: InputMaybe<Scalars['String']['input']>;
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  contactNumber?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  expensesUsingId?: InputMaybe<FkExpenseSupplierSupplierIdInverseInput>;
  galleryId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryToGalleryId?: InputMaybe<FkSupplierMediaGalleryGalleryIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  quoteFinanceLineItemsUsingId?: InputMaybe<FkQuoteFinanceLineItemSupplierSupplierIdInverseInput>;
  region?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceSupplierSupplierIdInverseInput>;
  url?: InputMaybe<Scalars['String']['input']>;
};

/** The fields on `supplier` to look up the row to connect. */
export type SupplierPkSupplierConnect = {
  id: Scalars['UUID']['input'];
};

/** The fields on `supplier` to look up the row to delete. */
export type SupplierPkSupplierDelete = {
  id: Scalars['UUID']['input'];
};

/** A filter to be used against many `Agency` object types. All fields are combined with a logical ‘and.’ */
export type SupplierToManyAgencyFilter = {
  /** Every related `Agency` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<AgencyFilter>;
  /** No related `Agency` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<AgencyFilter>;
  /** Some related `Agency` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<AgencyFilter>;
};

/** A filter to be used against many `Expense` object types. All fields are combined with a logical ‘and.’ */
export type SupplierToManyExpenseFilter = {
  /** Every related `Expense` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ExpenseFilter>;
  /** No related `Expense` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ExpenseFilter>;
  /** Some related `Expense` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ExpenseFilter>;
};

/** A filter to be used against many `QuoteFinanceLineItem` object types. All fields are combined with a logical ‘and.’ */
export type SupplierToManyQuoteFinanceLineItemFilter = {
  /** Every related `QuoteFinanceLineItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<QuoteFinanceLineItemFilter>;
  /** No related `QuoteFinanceLineItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<QuoteFinanceLineItemFilter>;
  /** Some related `QuoteFinanceLineItem` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<QuoteFinanceLineItemFilter>;
};

/** A filter to be used against many `SupplierInvoice` object types. All fields are combined with a logical ‘and.’ */
export type SupplierToManySupplierInvoiceFilter = {
  /** Every related `SupplierInvoice` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<SupplierInvoiceFilter>;
  /** No related `SupplierInvoice` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<SupplierInvoiceFilter>;
  /** Some related `SupplierInvoice` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<SupplierInvoiceFilter>;
};

/** A connection to a list of `Supplier` values. */
export type SuppliersConnection = {
  __typename?: 'SuppliersConnection';
  /** A list of edges which contains the `Supplier` and cursor to aid in pagination. */
  edges: Array<SuppliersEdge>;
  /** A list of `Supplier` objects. */
  nodes: Array<Maybe<Supplier>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Supplier` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Supplier` edge in the connection. */
export type SuppliersEdge = {
  __typename?: 'SuppliersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Supplier` at the end of the edge. */
  node?: Maybe<Supplier>;
};

/** Methods to use when ordering `Supplier`. */
export enum SuppliersOrderBy {
  AgenciesBySupplierIdCountAsc = 'AGENCIES_BY_SUPPLIER_ID__COUNT_ASC',
  AgenciesBySupplierIdCountDesc = 'AGENCIES_BY_SUPPLIER_ID__COUNT_DESC',
  BankDetailsAsc = 'BANK_DETAILS_ASC',
  BankDetailsDesc = 'BANK_DETAILS_DESC',
  ContactEmailAsc = 'CONTACT_EMAIL_ASC',
  ContactEmailDesc = 'CONTACT_EMAIL_DESC',
  ContactNumberAsc = 'CONTACT_NUMBER_ASC',
  ContactNumberDesc = 'CONTACT_NUMBER_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  ExpensesBySupplierIdCountAsc = 'EXPENSES_BY_SUPPLIER_ID__COUNT_ASC',
  ExpensesBySupplierIdCountDesc = 'EXPENSES_BY_SUPPLIER_ID__COUNT_DESC',
  GalleryIdAsc = 'GALLERY_ID_ASC',
  GalleryIdDesc = 'GALLERY_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  MediaGalleryByGalleryIdCreatedAsc = 'MEDIA_GALLERY_BY_GALLERY_ID__CREATED_ASC',
  MediaGalleryByGalleryIdCreatedDesc = 'MEDIA_GALLERY_BY_GALLERY_ID__CREATED_DESC',
  MediaGalleryByGalleryIdIdAsc = 'MEDIA_GALLERY_BY_GALLERY_ID__ID_ASC',
  MediaGalleryByGalleryIdIdDesc = 'MEDIA_GALLERY_BY_GALLERY_ID__ID_DESC',
  MediaGalleryByGalleryIdIsProtectedAsc = 'MEDIA_GALLERY_BY_GALLERY_ID__IS_PROTECTED_ASC',
  MediaGalleryByGalleryIdIsProtectedDesc = 'MEDIA_GALLERY_BY_GALLERY_ID__IS_PROTECTED_DESC',
  MediaGalleryByGalleryIdModifiedAsc = 'MEDIA_GALLERY_BY_GALLERY_ID__MODIFIED_ASC',
  MediaGalleryByGalleryIdModifiedDesc = 'MEDIA_GALLERY_BY_GALLERY_ID__MODIFIED_DESC',
  MediaGalleryByGalleryIdNameAsc = 'MEDIA_GALLERY_BY_GALLERY_ID__NAME_ASC',
  MediaGalleryByGalleryIdNameDesc = 'MEDIA_GALLERY_BY_GALLERY_ID__NAME_DESC',
  MediaGalleryByGalleryIdParentIdAsc = 'MEDIA_GALLERY_BY_GALLERY_ID__PARENT_ID_ASC',
  MediaGalleryByGalleryIdParentIdDesc = 'MEDIA_GALLERY_BY_GALLERY_ID__PARENT_ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QuoteFinanceLineItemsBySupplierIdCountAsc = 'QUOTE_FINANCE_LINE_ITEMS_BY_SUPPLIER_ID__COUNT_ASC',
  QuoteFinanceLineItemsBySupplierIdCountDesc = 'QUOTE_FINANCE_LINE_ITEMS_BY_SUPPLIER_ID__COUNT_DESC',
  RegionAsc = 'REGION_ASC',
  RegionDesc = 'REGION_DESC',
  SupplierInvoicesBySupplierIdCountAsc = 'SUPPLIER_INVOICES_BY_SUPPLIER_ID__COUNT_ASC',
  SupplierInvoicesBySupplierIdCountDesc = 'SUPPLIER_INVOICES_BY_SUPPLIER_ID__COUNT_DESC',
  UrlAsc = 'URL_ASC',
  UrlDesc = 'URL_DESC'
}

export type Testimonial = {
  __typename?: 'Testimonial';
  body?: Maybe<Scalars['String']['output']>;
  created: Scalars['Datetime']['output'];
  guestName?: Maybe<Scalars['String']['output']>;
  id: Scalars['UUID']['output'];
  modified: Scalars['Datetime']['output'];
  /** Reads a single `Trip` that is related to this `Testimonial`. */
  trip?: Maybe<Trip>;
  tripId?: Maybe<Scalars['UUID']['output']>;
};

/**
 * A condition to be used against `Testimonial` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type TestimonialCondition = {
  /** Checks for equality with the object’s `body` field. */
  body?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `guestName` field. */
  guestName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `tripId` field. */
  tripId?: InputMaybe<Scalars['UUID']['input']>;
};

/** A filter to be used against `Testimonial` object types. All fields are combined with a logical ‘and.’ */
export type TestimonialFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<TestimonialFilter>>;
  /** Filter by the object’s `body` field. */
  body?: InputMaybe<StringFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `guestName` field. */
  guestName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<TestimonialFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<TestimonialFilter>>;
  /** Filter by the object’s `trip` relation. */
  trip?: InputMaybe<TripFilter>;
  /** A related `trip` exists. */
  tripExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `tripId` field. */
  tripId?: InputMaybe<UuidFilter>;
};

/** An input for mutations affecting `Testimonial` */
export type TestimonialInput = {
  body?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  guestName?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkTestimonialTripTripIdInput>;
};

/** The fields on `testimonial` to look up the row to update. */
export type TestimonialOnTestimonialForFkTestimonialTripTripIdUsingPkTestimonialUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `testimonial` being updated. */
  patch: UpdateTestimonialOnTestimonialForFkTestimonialTripTripIdPatch;
};

/** Represents an update to a `Testimonial`. Fields that are set will be updated. */
export type TestimonialPatch = {
  body?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  guestName?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkTestimonialTripTripIdInput>;
};

/** The fields on `testimonial` to look up the row to connect. */
export type TestimonialPkTestimonialConnect = {
  id: Scalars['UUID']['input'];
};

/** The fields on `testimonial` to look up the row to delete. */
export type TestimonialPkTestimonialDelete = {
  id: Scalars['UUID']['input'];
};

/** A connection to a list of `Testimonial` values. */
export type TestimonialsConnection = {
  __typename?: 'TestimonialsConnection';
  /** A list of edges which contains the `Testimonial` and cursor to aid in pagination. */
  edges: Array<TestimonialsEdge>;
  /** A list of `Testimonial` objects. */
  nodes: Array<Maybe<Testimonial>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Testimonial` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Testimonial` edge in the connection. */
export type TestimonialsEdge = {
  __typename?: 'TestimonialsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Testimonial` at the end of the edge. */
  node?: Maybe<Testimonial>;
};

/** Methods to use when ordering `Testimonial`. */
export enum TestimonialsOrderBy {
  BodyAsc = 'BODY_ASC',
  BodyDesc = 'BODY_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  GuestNameAsc = 'GUEST_NAME_ASC',
  GuestNameDesc = 'GUEST_NAME_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TripByTripIdActiveQuoteIdAsc = 'TRIP_BY_TRIP_ID__ACTIVE_QUOTE_ID_ASC',
  TripByTripIdActiveQuoteIdDesc = 'TRIP_BY_TRIP_ID__ACTIVE_QUOTE_ID_DESC',
  TripByTripIdAgencyIdAsc = 'TRIP_BY_TRIP_ID__AGENCY_ID_ASC',
  TripByTripIdAgencyIdDesc = 'TRIP_BY_TRIP_ID__AGENCY_ID_DESC',
  TripByTripIdAgencyMemberIdAsc = 'TRIP_BY_TRIP_ID__AGENCY_MEMBER_ID_ASC',
  TripByTripIdAgencyMemberIdDesc = 'TRIP_BY_TRIP_ID__AGENCY_MEMBER_ID_DESC',
  TripByTripIdArchivedAsc = 'TRIP_BY_TRIP_ID__ARCHIVED_ASC',
  TripByTripIdArchivedDesc = 'TRIP_BY_TRIP_ID__ARCHIVED_DESC',
  TripByTripIdBaseCurrencyAsc = 'TRIP_BY_TRIP_ID__BASE_CURRENCY_ASC',
  TripByTripIdBaseCurrencyDesc = 'TRIP_BY_TRIP_ID__BASE_CURRENCY_DESC',
  TripByTripIdCreatedAsc = 'TRIP_BY_TRIP_ID__CREATED_ASC',
  TripByTripIdCreatedDesc = 'TRIP_BY_TRIP_ID__CREATED_DESC',
  TripByTripIdCustomerIdAsc = 'TRIP_BY_TRIP_ID__CUSTOMER_ID_ASC',
  TripByTripIdCustomerIdDesc = 'TRIP_BY_TRIP_ID__CUSTOMER_ID_DESC',
  TripByTripIdDatesAsc = 'TRIP_BY_TRIP_ID__DATES_ASC',
  TripByTripIdDatesDesc = 'TRIP_BY_TRIP_ID__DATES_DESC',
  TripByTripIdDestinationAsc = 'TRIP_BY_TRIP_ID__DESTINATION_ASC',
  TripByTripIdDestinationDesc = 'TRIP_BY_TRIP_ID__DESTINATION_DESC',
  TripByTripIdDurationAsc = 'TRIP_BY_TRIP_ID__DURATION_ASC',
  TripByTripIdDurationDesc = 'TRIP_BY_TRIP_ID__DURATION_DESC',
  TripByTripIdIdAsc = 'TRIP_BY_TRIP_ID__ID_ASC',
  TripByTripIdIdDesc = 'TRIP_BY_TRIP_ID__ID_DESC',
  TripByTripIdMediaGalleryIdAsc = 'TRIP_BY_TRIP_ID__MEDIA_GALLERY_ID_ASC',
  TripByTripIdMediaGalleryIdDesc = 'TRIP_BY_TRIP_ID__MEDIA_GALLERY_ID_DESC',
  TripByTripIdModifiedAsc = 'TRIP_BY_TRIP_ID__MODIFIED_ASC',
  TripByTripIdModifiedDesc = 'TRIP_BY_TRIP_ID__MODIFIED_DESC',
  TripByTripIdNameAsc = 'TRIP_BY_TRIP_ID__NAME_ASC',
  TripByTripIdNameDesc = 'TRIP_BY_TRIP_ID__NAME_DESC',
  TripByTripIdStartAsc = 'TRIP_BY_TRIP_ID__START_ASC',
  TripByTripIdStartDesc = 'TRIP_BY_TRIP_ID__START_DESC',
  TripByTripIdStatusAsc = 'TRIP_BY_TRIP_ID__STATUS_ASC',
  TripByTripIdStatusDesc = 'TRIP_BY_TRIP_ID__STATUS_DESC',
  TripByTripIdSummaryAsc = 'TRIP_BY_TRIP_ID__SUMMARY_ASC',
  TripByTripIdSummaryDesc = 'TRIP_BY_TRIP_ID__SUMMARY_DESC',
  TripByTripIdUserIdAsc = 'TRIP_BY_TRIP_ID__USER_ID_ASC',
  TripByTripIdUserIdDesc = 'TRIP_BY_TRIP_ID__USER_ID_DESC',
  TripIdAsc = 'TRIP_ID_ASC',
  TripIdDesc = 'TRIP_ID_DESC'
}

export type Timeline = {
  __typename?: 'Timeline';
  actioned?: Maybe<Scalars['Datetime']['output']>;
  date?: Maybe<Scalars['Datetime']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  group?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['UUID']['output']>;
  url?: Maybe<Scalars['String']['output']>;
  week?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `Timeline` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type TimelineCondition = {
  /** Checks for equality with the object’s `actioned` field. */
  actioned?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `date` field. */
  date?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `group` field. */
  group?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `url` field. */
  url?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `week` field. */
  week?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `Timeline` object types. All fields are combined with a logical ‘and.’ */
export type TimelineFilter = {
  /** Filter by the object’s `actioned` field. */
  actioned?: InputMaybe<DatetimeFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<TimelineFilter>>;
  /** Filter by the object’s `date` field. */
  date?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `description` field. */
  description?: InputMaybe<StringFilter>;
  /** Filter by the object’s `group` field. */
  group?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Negates the expression. */
  not?: InputMaybe<TimelineFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<TimelineFilter>>;
  /** Filter by the object’s `url` field. */
  url?: InputMaybe<StringFilter>;
  /** Filter by the object’s `week` field. */
  week?: InputMaybe<StringFilter>;
};

/** A connection to a list of `Timeline` values. */
export type TimelinesConnection = {
  __typename?: 'TimelinesConnection';
  /** A list of edges which contains the `Timeline` and cursor to aid in pagination. */
  edges: Array<TimelinesEdge>;
  /** A list of `Timeline` objects. */
  nodes: Array<Maybe<Timeline>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Timeline` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Timeline` edge in the connection. */
export type TimelinesEdge = {
  __typename?: 'TimelinesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Timeline` at the end of the edge. */
  node?: Maybe<Timeline>;
};

/** Methods to use when ordering `Timeline`. */
export enum TimelinesOrderBy {
  ActionedAsc = 'ACTIONED_ASC',
  ActionedDesc = 'ACTIONED_DESC',
  DateAsc = 'DATE_ASC',
  DateDesc = 'DATE_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  GroupAsc = 'GROUP_ASC',
  GroupDesc = 'GROUP_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  UrlAsc = 'URL_ASC',
  UrlDesc = 'URL_DESC',
  WeekAsc = 'WEEK_ASC',
  WeekDesc = 'WEEK_DESC'
}

export type Timezone = {
  __typename?: 'Timezone';
  ogcFid: Scalars['Int']['output'];
  tzid?: Maybe<Scalars['String']['output']>;
  wkbGeometry?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `Timezone` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type TimezoneCondition = {
  /** Checks for equality with the object’s `ogcFid` field. */
  ogcFid?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `tzid` field. */
  tzid?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `wkbGeometry` field. */
  wkbGeometry?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `Timezone` object types. All fields are combined with a logical ‘and.’ */
export type TimezoneFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<TimezoneFilter>>;
  /** Negates the expression. */
  not?: InputMaybe<TimezoneFilter>;
  /** Filter by the object’s `ogcFid` field. */
  ogcFid?: InputMaybe<IntFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<TimezoneFilter>>;
  /** Filter by the object’s `tzid` field. */
  tzid?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `Timezone` */
export type TimezoneInput = {
  ogcFid?: InputMaybe<Scalars['Int']['input']>;
  tzid?: InputMaybe<Scalars['String']['input']>;
  wkbGeometry?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `Timezone`. Fields that are set will be updated. */
export type TimezonePatch = {
  ogcFid?: InputMaybe<Scalars['Int']['input']>;
  tzid?: InputMaybe<Scalars['String']['input']>;
  wkbGeometry?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `Timezone` values. */
export type TimezonesConnection = {
  __typename?: 'TimezonesConnection';
  /** A list of edges which contains the `Timezone` and cursor to aid in pagination. */
  edges: Array<TimezonesEdge>;
  /** A list of `Timezone` objects. */
  nodes: Array<Maybe<Timezone>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Timezone` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Timezone` edge in the connection. */
export type TimezonesEdge = {
  __typename?: 'TimezonesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Timezone` at the end of the edge. */
  node?: Maybe<Timezone>;
};

/** Methods to use when ordering `Timezone`. */
export enum TimezonesOrderBy {
  Natural = 'NATURAL',
  OgcFidAsc = 'OGC_FID_ASC',
  OgcFidDesc = 'OGC_FID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TzidAsc = 'TZID_ASC',
  TzidDesc = 'TZID_DESC',
  WkbGeometryAsc = 'WKB_GEOMETRY_ASC',
  WkbGeometryDesc = 'WKB_GEOMETRY_DESC'
}

export type TrackQuoteViewInput = {
  ip?: InputMaybe<Scalars['String']['input']>;
  key: Scalars['String']['input'];
  viewType: Scalars['String']['input'];
};

export type Transaction = {
  __typename?: 'Transaction';
  /** Reads a single `Account` that is related to this `Transaction`. */
  account?: Maybe<Account>;
  accountId: Scalars['UUID']['output'];
  amount: Scalars['BigFloat']['output'];
  balance: Scalars['BigFloat']['output'];
  /** Reads a single `FinanceCategory` that is related to this `Transaction`. */
  category?: Maybe<FinanceCategory>;
  categoryId?: Maybe<Scalars['UUID']['output']>;
  created: Scalars['Datetime']['output'];
  currency?: Maybe<Scalars['String']['output']>;
  date: Scalars['Datetime']['output'];
  description?: Maybe<Scalars['String']['output']>;
  externalId?: Maybe<Scalars['String']['output']>;
  id: Scalars['UUID']['output'];
  modified: Scalars['Datetime']['output'];
  /** Reads a single `Transaction` that is related to this `Transaction`. */
  reverseTransaction?: Maybe<Transaction>;
  reverseTransactionId?: Maybe<Scalars['UUID']['output']>;
  source?: Maybe<Scalars['String']['output']>;
  status: Scalars['Int']['output'];
  /** Reads a single `TransactionImportBatch` that is related to this `Transaction`. */
  transactionImportBatch?: Maybe<TransactionImportBatch>;
  transactionImportBatchId?: Maybe<Scalars['UUID']['output']>;
  /** Reads and enables pagination through a set of `TransactionLink`. */
  transactionLinks: TransactionLinksConnection;
  /** Reads and enables pagination through a set of `TransactionNote`. */
  transactionNotes: TransactionNotesConnection;
  /** Reads and enables pagination through a set of `Transaction`. */
  transactionsByReverseTransactionId: TransactionsConnection;
};


export type TransactionTransactionLinksArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TransactionLinkCondition>;
  filter?: InputMaybe<TransactionLinkFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TransactionLinksOrderBy>>;
};


export type TransactionTransactionNotesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TransactionNoteCondition>;
  filter?: InputMaybe<TransactionNoteFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TransactionNotesOrderBy>>;
};


export type TransactionTransactionsByReverseTransactionIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TransactionCondition>;
  filter?: InputMaybe<TransactionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TransactionsOrderBy>>;
};

/**
 * A condition to be used against `Transaction` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type TransactionCondition = {
  /** Checks for equality with the object’s `accountId` field. */
  accountId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `amount` field. */
  amount?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `balance` field. */
  balance?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `categoryId` field. */
  categoryId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `currency` field. */
  currency?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `date` field. */
  date?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `externalId` field. */
  externalId?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `reverseTransactionId` field. */
  reverseTransactionId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `source` field. */
  source?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `transactionImportBatchId` field. */
  transactionImportBatchId?: InputMaybe<Scalars['UUID']['input']>;
};

/** A filter to be used against `Transaction` object types. All fields are combined with a logical ‘and.’ */
export type TransactionFilter = {
  /** Filter by the object’s `account` relation. */
  account?: InputMaybe<AccountFilter>;
  /** Filter by the object’s `accountId` field. */
  accountId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `amount` field. */
  amount?: InputMaybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<TransactionFilter>>;
  /** Filter by the object’s `balance` field. */
  balance?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `category` relation. */
  category?: InputMaybe<FinanceCategoryFilter>;
  /** A related `category` exists. */
  categoryExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `categoryId` field. */
  categoryId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `currency` field. */
  currency?: InputMaybe<StringFilter>;
  /** Filter by the object’s `date` field. */
  date?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `description` field. */
  description?: InputMaybe<StringFilter>;
  /** Filter by the object’s `externalId` field. */
  externalId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<TransactionFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<TransactionFilter>>;
  /** Filter by the object’s `reverseTransaction` relation. */
  reverseTransaction?: InputMaybe<TransactionFilter>;
  /** A related `reverseTransaction` exists. */
  reverseTransactionExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `reverseTransactionId` field. */
  reverseTransactionId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `source` field. */
  source?: InputMaybe<StringFilter>;
  /** Filter by the object’s `status` field. */
  status?: InputMaybe<IntFilter>;
  /** Filter by the object’s `transactionImportBatch` relation. */
  transactionImportBatch?: InputMaybe<TransactionImportBatchFilter>;
  /** A related `transactionImportBatch` exists. */
  transactionImportBatchExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `transactionImportBatchId` field. */
  transactionImportBatchId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `transactionLinks` relation. */
  transactionLinks?: InputMaybe<TransactionToManyTransactionLinkFilter>;
  /** Some related `transactionLinks` exist. */
  transactionLinksExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `transactionNotes` relation. */
  transactionNotes?: InputMaybe<TransactionToManyTransactionNoteFilter>;
  /** Some related `transactionNotes` exist. */
  transactionNotesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `transactionsByReverseTransactionId` relation. */
  transactionsByReverseTransactionId?: InputMaybe<TransactionToManyTransactionFilter>;
  /** Some related `transactionsByReverseTransactionId` exist. */
  transactionsByReverseTransactionIdExist?: InputMaybe<Scalars['Boolean']['input']>;
};

export type TransactionImportBatch = {
  __typename?: 'TransactionImportBatch';
  /** Reads a single `Account` that is related to this `TransactionImportBatch`. */
  account?: Maybe<Account>;
  accountId: Scalars['UUID']['output'];
  created: Scalars['Datetime']['output'];
  dateRangeMax: Scalars['Datetime']['output'];
  dateRangeMin: Scalars['Datetime']['output'];
  id: Scalars['UUID']['output'];
  key?: Maybe<Scalars['String']['output']>;
  modified: Scalars['Datetime']['output'];
  /** Reads and enables pagination through a set of `Transaction`. */
  transactions: TransactionsConnection;
};


export type TransactionImportBatchTransactionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TransactionCondition>;
  filter?: InputMaybe<TransactionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TransactionsOrderBy>>;
};

/**
 * A condition to be used against `TransactionImportBatch` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type TransactionImportBatchCondition = {
  /** Checks for equality with the object’s `accountId` field. */
  accountId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `dateRangeMax` field. */
  dateRangeMax?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `dateRangeMin` field. */
  dateRangeMin?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `key` field. */
  key?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A filter to be used against `TransactionImportBatch` object types. All fields are combined with a logical ‘and.’ */
export type TransactionImportBatchFilter = {
  /** Filter by the object’s `account` relation. */
  account?: InputMaybe<AccountFilter>;
  /** Filter by the object’s `accountId` field. */
  accountId?: InputMaybe<UuidFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<TransactionImportBatchFilter>>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `dateRangeMax` field. */
  dateRangeMax?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `dateRangeMin` field. */
  dateRangeMin?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `key` field. */
  key?: InputMaybe<StringFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<TransactionImportBatchFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<TransactionImportBatchFilter>>;
  /** Filter by the object’s `transactions` relation. */
  transactions?: InputMaybe<TransactionImportBatchToManyTransactionFilter>;
  /** Some related `transactions` exist. */
  transactionsExist?: InputMaybe<Scalars['Boolean']['input']>;
};

/** An input for mutations affecting `TransactionImportBatch` */
export type TransactionImportBatchInput = {
  accountId?: InputMaybe<Scalars['UUID']['input']>;
  accountToAccountId?: InputMaybe<FkTransactionImportBatchAccountAccountIdInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  dateRangeMax: Scalars['Datetime']['input'];
  dateRangeMin: Scalars['Datetime']['input'];
  id?: InputMaybe<Scalars['UUID']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  transactionsUsingId?: InputMaybe<FkTransactionTransactionImportBatchTransactionImportBatchIdInverseInput>;
};

/** The fields on `transactionImportBatch` to look up the row to update. */
export type TransactionImportBatchOnTransactionForFkTransactionTransactionImportBatchTransactionImportBatchIdUsingPkTransactionImportBatchUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `transactionImportBatch` being updated. */
  patch: UpdateTransactionImportBatchOnTransactionForFkTransactionTransactionImportBatchTransactionImportBatchIdPatch;
};

/** The fields on `transactionImportBatch` to look up the row to update. */
export type TransactionImportBatchOnTransactionImportBatchForFkTransactionImportBatchAccountAccountIdUsingPkTransactionImportBatchUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `transactionImportBatch` being updated. */
  patch: UpdateTransactionImportBatchOnTransactionImportBatchForFkTransactionImportBatchAccountAccountIdPatch;
};

/** Represents an update to a `TransactionImportBatch`. Fields that are set will be updated. */
export type TransactionImportBatchPatch = {
  accountId?: InputMaybe<Scalars['UUID']['input']>;
  accountToAccountId?: InputMaybe<FkTransactionImportBatchAccountAccountIdInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  dateRangeMax?: InputMaybe<Scalars['Datetime']['input']>;
  dateRangeMin?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  transactionsUsingId?: InputMaybe<FkTransactionTransactionImportBatchTransactionImportBatchIdInverseInput>;
};

/** The fields on `transactionImportBatch` to look up the row to connect. */
export type TransactionImportBatchPkTransactionImportBatchConnect = {
  id: Scalars['UUID']['input'];
};

/** The fields on `transactionImportBatch` to look up the row to delete. */
export type TransactionImportBatchPkTransactionImportBatchDelete = {
  id: Scalars['UUID']['input'];
};

/** A filter to be used against many `Transaction` object types. All fields are combined with a logical ‘and.’ */
export type TransactionImportBatchToManyTransactionFilter = {
  /** Every related `Transaction` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<TransactionFilter>;
  /** No related `Transaction` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<TransactionFilter>;
  /** Some related `Transaction` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<TransactionFilter>;
};

/** A connection to a list of `TransactionImportBatch` values. */
export type TransactionImportBatchesConnection = {
  __typename?: 'TransactionImportBatchesConnection';
  /** A list of edges which contains the `TransactionImportBatch` and cursor to aid in pagination. */
  edges: Array<TransactionImportBatchesEdge>;
  /** A list of `TransactionImportBatch` objects. */
  nodes: Array<Maybe<TransactionImportBatch>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TransactionImportBatch` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `TransactionImportBatch` edge in the connection. */
export type TransactionImportBatchesEdge = {
  __typename?: 'TransactionImportBatchesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `TransactionImportBatch` at the end of the edge. */
  node?: Maybe<TransactionImportBatch>;
};

/** Methods to use when ordering `TransactionImportBatch`. */
export enum TransactionImportBatchesOrderBy {
  AccountByAccountIdCreatedAsc = 'ACCOUNT_BY_ACCOUNT_ID__CREATED_ASC',
  AccountByAccountIdCreatedDesc = 'ACCOUNT_BY_ACCOUNT_ID__CREATED_DESC',
  AccountByAccountIdDetailsAsc = 'ACCOUNT_BY_ACCOUNT_ID__DETAILS_ASC',
  AccountByAccountIdDetailsDesc = 'ACCOUNT_BY_ACCOUNT_ID__DETAILS_DESC',
  AccountByAccountIdIdAsc = 'ACCOUNT_BY_ACCOUNT_ID__ID_ASC',
  AccountByAccountIdIdDesc = 'ACCOUNT_BY_ACCOUNT_ID__ID_DESC',
  AccountByAccountIdInstitutionAsc = 'ACCOUNT_BY_ACCOUNT_ID__INSTITUTION_ASC',
  AccountByAccountIdInstitutionDesc = 'ACCOUNT_BY_ACCOUNT_ID__INSTITUTION_DESC',
  AccountByAccountIdModifiedAsc = 'ACCOUNT_BY_ACCOUNT_ID__MODIFIED_ASC',
  AccountByAccountIdModifiedDesc = 'ACCOUNT_BY_ACCOUNT_ID__MODIFIED_DESC',
  AccountByAccountIdNameAsc = 'ACCOUNT_BY_ACCOUNT_ID__NAME_ASC',
  AccountByAccountIdNameDesc = 'ACCOUNT_BY_ACCOUNT_ID__NAME_DESC',
  AccountIdAsc = 'ACCOUNT_ID_ASC',
  AccountIdDesc = 'ACCOUNT_ID_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  DateRangeMaxAsc = 'DATE_RANGE_MAX_ASC',
  DateRangeMaxDesc = 'DATE_RANGE_MAX_DESC',
  DateRangeMinAsc = 'DATE_RANGE_MIN_ASC',
  DateRangeMinDesc = 'DATE_RANGE_MIN_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  KeyAsc = 'KEY_ASC',
  KeyDesc = 'KEY_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TransactionsByTransactionImportBatchIdCountAsc = 'TRANSACTIONS_BY_TRANSACTION_IMPORT_BATCH_ID__COUNT_ASC',
  TransactionsByTransactionImportBatchIdCountDesc = 'TRANSACTIONS_BY_TRANSACTION_IMPORT_BATCH_ID__COUNT_DESC'
}

/** An input for mutations affecting `Transaction` */
export type TransactionInput = {
  accountId?: InputMaybe<Scalars['UUID']['input']>;
  accountToAccountId?: InputMaybe<FkTransactionAccountAccountIdInput>;
  amount: Scalars['BigFloat']['input'];
  balance?: InputMaybe<Scalars['BigFloat']['input']>;
  categoryId?: InputMaybe<Scalars['UUID']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  date: Scalars['Datetime']['input'];
  description?: InputMaybe<Scalars['String']['input']>;
  externalId?: InputMaybe<Scalars['String']['input']>;
  financeCategoryToCategoryId?: InputMaybe<FkTransactionFinanceCategoryCategoryIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  reverseTransactionId?: InputMaybe<Scalars['UUID']['input']>;
  source?: InputMaybe<Scalars['String']['input']>;
  status: Scalars['Int']['input'];
  transactionImportBatchId?: InputMaybe<Scalars['UUID']['input']>;
  transactionImportBatchToTransactionImportBatchId?: InputMaybe<FkTransactionTransactionImportBatchTransactionImportBatchIdInput>;
  transactionLinksUsingId?: InputMaybe<FkTransactionLinkTransactionTransactionIdInverseInput>;
  transactionNotesUsingId?: InputMaybe<FkTransactionNoteTransactionTransactionIdInverseInput>;
  transactionToReverseTransactionId?: InputMaybe<FkTransactionTransactionReverseTransactionIdInput>;
};

export type TransactionLink = {
  __typename?: 'TransactionLink';
  created: Scalars['Datetime']['output'];
  /** Reads a single `Expense` that is related to this `TransactionLink`. */
  expense?: Maybe<Expense>;
  expenseId?: Maybe<Scalars['UUID']['output']>;
  id: Scalars['UUID']['output'];
  /** Reads a single `Invoice` that is related to this `TransactionLink`. */
  invoice?: Maybe<Invoice>;
  invoiceId?: Maybe<Scalars['UUID']['output']>;
  modified: Scalars['Datetime']['output'];
  /** Reads a single `Payment` that is related to this `TransactionLink`. */
  payment?: Maybe<Payment>;
  paymentId?: Maybe<Scalars['UUID']['output']>;
  status: Scalars['Int']['output'];
  /** Reads a single `SupplierInvoice` that is related to this `TransactionLink`. */
  supplierInvoice?: Maybe<SupplierInvoice>;
  supplierInvoiceId?: Maybe<Scalars['UUID']['output']>;
  /** Reads a single `Transaction` that is related to this `TransactionLink`. */
  transaction?: Maybe<Transaction>;
  transactionId: Scalars['UUID']['output'];
};

/**
 * A condition to be used against `TransactionLink` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type TransactionLinkCondition = {
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `expenseId` field. */
  expenseId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `invoiceId` field. */
  invoiceId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `paymentId` field. */
  paymentId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `supplierInvoiceId` field. */
  supplierInvoiceId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `transactionId` field. */
  transactionId?: InputMaybe<Scalars['UUID']['input']>;
};

/** A filter to be used against `TransactionLink` object types. All fields are combined with a logical ‘and.’ */
export type TransactionLinkFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<TransactionLinkFilter>>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `expense` relation. */
  expense?: InputMaybe<ExpenseFilter>;
  /** A related `expense` exists. */
  expenseExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `expenseId` field. */
  expenseId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `invoice` relation. */
  invoice?: InputMaybe<InvoiceFilter>;
  /** A related `invoice` exists. */
  invoiceExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `invoiceId` field. */
  invoiceId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<TransactionLinkFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<TransactionLinkFilter>>;
  /** Filter by the object’s `payment` relation. */
  payment?: InputMaybe<PaymentFilter>;
  /** A related `payment` exists. */
  paymentExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `paymentId` field. */
  paymentId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `status` field. */
  status?: InputMaybe<IntFilter>;
  /** Filter by the object’s `supplierInvoice` relation. */
  supplierInvoice?: InputMaybe<SupplierInvoiceFilter>;
  /** A related `supplierInvoice` exists. */
  supplierInvoiceExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `supplierInvoiceId` field. */
  supplierInvoiceId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `transaction` relation. */
  transaction?: InputMaybe<TransactionFilter>;
  /** Filter by the object’s `transactionId` field. */
  transactionId?: InputMaybe<UuidFilter>;
};

/** An input for mutations affecting `TransactionLink` */
export type TransactionLinkInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  expenseId?: InputMaybe<Scalars['UUID']['input']>;
  expenseToExpenseId?: InputMaybe<FkTransactionLinkExpenseExpenseIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoiceId?: InputMaybe<Scalars['UUID']['input']>;
  invoiceToInvoiceId?: InputMaybe<FkTransactionLinkInvoiceInvoiceIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  paymentId?: InputMaybe<Scalars['UUID']['input']>;
  paymentToPaymentId?: InputMaybe<FkTransactionLinkPaymentPaymentIdInput>;
  status?: InputMaybe<Scalars['Int']['input']>;
  supplierInvoiceId?: InputMaybe<Scalars['UUID']['input']>;
  supplierInvoiceToSupplierInvoiceId?: InputMaybe<FkTransactionLinkSupplierInvoiceSupplierInvoiceIdInput>;
  transactionId?: InputMaybe<Scalars['UUID']['input']>;
  transactionToTransactionId?: InputMaybe<FkTransactionLinkTransactionTransactionIdInput>;
};

/** The fields on `transactionLink` to look up the row to update. */
export type TransactionLinkOnTransactionLinkForFkTransactionLinkExpenseExpenseIdUsingPkTransactionLinkUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `transactionLink` being updated. */
  patch: UpdateTransactionLinkOnTransactionLinkForFkTransactionLinkExpenseExpenseIdPatch;
};

/** The fields on `transactionLink` to look up the row to update. */
export type TransactionLinkOnTransactionLinkForFkTransactionLinkInvoiceInvoiceIdUsingPkTransactionLinkUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `transactionLink` being updated. */
  patch: UpdateTransactionLinkOnTransactionLinkForFkTransactionLinkInvoiceInvoiceIdPatch;
};

/** The fields on `transactionLink` to look up the row to update. */
export type TransactionLinkOnTransactionLinkForFkTransactionLinkPaymentPaymentIdUsingPkTransactionLinkUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `transactionLink` being updated. */
  patch: UpdateTransactionLinkOnTransactionLinkForFkTransactionLinkPaymentPaymentIdPatch;
};

/** The fields on `transactionLink` to look up the row to update. */
export type TransactionLinkOnTransactionLinkForFkTransactionLinkSupplierInvoiceSupplierInvoiceIdUsingPkTransactionLinkUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `transactionLink` being updated. */
  patch: UpdateTransactionLinkOnTransactionLinkForFkTransactionLinkSupplierInvoiceSupplierInvoiceIdPatch;
};

/** The fields on `transactionLink` to look up the row to update. */
export type TransactionLinkOnTransactionLinkForFkTransactionLinkTransactionTransactionIdUsingPkTransactionLinkUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `transactionLink` being updated. */
  patch: UpdateTransactionLinkOnTransactionLinkForFkTransactionLinkTransactionTransactionIdPatch;
};

/** Represents an update to a `TransactionLink`. Fields that are set will be updated. */
export type TransactionLinkPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  expenseId?: InputMaybe<Scalars['UUID']['input']>;
  expenseToExpenseId?: InputMaybe<FkTransactionLinkExpenseExpenseIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoiceId?: InputMaybe<Scalars['UUID']['input']>;
  invoiceToInvoiceId?: InputMaybe<FkTransactionLinkInvoiceInvoiceIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  paymentId?: InputMaybe<Scalars['UUID']['input']>;
  paymentToPaymentId?: InputMaybe<FkTransactionLinkPaymentPaymentIdInput>;
  status?: InputMaybe<Scalars['Int']['input']>;
  supplierInvoiceId?: InputMaybe<Scalars['UUID']['input']>;
  supplierInvoiceToSupplierInvoiceId?: InputMaybe<FkTransactionLinkSupplierInvoiceSupplierInvoiceIdInput>;
  transactionId?: InputMaybe<Scalars['UUID']['input']>;
  transactionToTransactionId?: InputMaybe<FkTransactionLinkTransactionTransactionIdInput>;
};

/** The fields on `transactionLink` to look up the row to connect. */
export type TransactionLinkPkTransactionLinkConnect = {
  id: Scalars['UUID']['input'];
};

/** The fields on `transactionLink` to look up the row to delete. */
export type TransactionLinkPkTransactionLinkDelete = {
  id: Scalars['UUID']['input'];
};

/** A connection to a list of `TransactionLink` values. */
export type TransactionLinksConnection = {
  __typename?: 'TransactionLinksConnection';
  /** A list of edges which contains the `TransactionLink` and cursor to aid in pagination. */
  edges: Array<TransactionLinksEdge>;
  /** A list of `TransactionLink` objects. */
  nodes: Array<Maybe<TransactionLink>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TransactionLink` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `TransactionLink` edge in the connection. */
export type TransactionLinksEdge = {
  __typename?: 'TransactionLinksEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `TransactionLink` at the end of the edge. */
  node?: Maybe<TransactionLink>;
};

/** Methods to use when ordering `TransactionLink`. */
export enum TransactionLinksOrderBy {
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  ExpenseByExpenseIdAmountActualAsc = 'EXPENSE_BY_EXPENSE_ID__AMOUNT_ACTUAL_ASC',
  ExpenseByExpenseIdAmountActualDesc = 'EXPENSE_BY_EXPENSE_ID__AMOUNT_ACTUAL_DESC',
  ExpenseByExpenseIdAmountAsc = 'EXPENSE_BY_EXPENSE_ID__AMOUNT_ASC',
  ExpenseByExpenseIdAmountDesc = 'EXPENSE_BY_EXPENSE_ID__AMOUNT_DESC',
  ExpenseByExpenseIdCategoryIdAsc = 'EXPENSE_BY_EXPENSE_ID__CATEGORY_ID_ASC',
  ExpenseByExpenseIdCategoryIdDesc = 'EXPENSE_BY_EXPENSE_ID__CATEGORY_ID_DESC',
  ExpenseByExpenseIdCreatedAsc = 'EXPENSE_BY_EXPENSE_ID__CREATED_ASC',
  ExpenseByExpenseIdCreatedDesc = 'EXPENSE_BY_EXPENSE_ID__CREATED_DESC',
  ExpenseByExpenseIdCurrencyAsc = 'EXPENSE_BY_EXPENSE_ID__CURRENCY_ASC',
  ExpenseByExpenseIdCurrencyDesc = 'EXPENSE_BY_EXPENSE_ID__CURRENCY_DESC',
  ExpenseByExpenseIdIdAsc = 'EXPENSE_BY_EXPENSE_ID__ID_ASC',
  ExpenseByExpenseIdIdDesc = 'EXPENSE_BY_EXPENSE_ID__ID_DESC',
  ExpenseByExpenseIdInvoiceIdAsc = 'EXPENSE_BY_EXPENSE_ID__INVOICE_ID_ASC',
  ExpenseByExpenseIdInvoiceIdDesc = 'EXPENSE_BY_EXPENSE_ID__INVOICE_ID_DESC',
  ExpenseByExpenseIdModifiedAsc = 'EXPENSE_BY_EXPENSE_ID__MODIFIED_ASC',
  ExpenseByExpenseIdModifiedDesc = 'EXPENSE_BY_EXPENSE_ID__MODIFIED_DESC',
  ExpenseByExpenseIdPaidAsc = 'EXPENSE_BY_EXPENSE_ID__PAID_ASC',
  ExpenseByExpenseIdPaidDesc = 'EXPENSE_BY_EXPENSE_ID__PAID_DESC',
  ExpenseByExpenseIdReferenceAsc = 'EXPENSE_BY_EXPENSE_ID__REFERENCE_ASC',
  ExpenseByExpenseIdReferenceDesc = 'EXPENSE_BY_EXPENSE_ID__REFERENCE_DESC',
  ExpenseByExpenseIdSummaryAsc = 'EXPENSE_BY_EXPENSE_ID__SUMMARY_ASC',
  ExpenseByExpenseIdSummaryDesc = 'EXPENSE_BY_EXPENSE_ID__SUMMARY_DESC',
  ExpenseByExpenseIdSupplierIdAsc = 'EXPENSE_BY_EXPENSE_ID__SUPPLIER_ID_ASC',
  ExpenseByExpenseIdSupplierIdDesc = 'EXPENSE_BY_EXPENSE_ID__SUPPLIER_ID_DESC',
  ExpenseByExpenseIdSupplierInvoiceIdAsc = 'EXPENSE_BY_EXPENSE_ID__SUPPLIER_INVOICE_ID_ASC',
  ExpenseByExpenseIdSupplierInvoiceIdDesc = 'EXPENSE_BY_EXPENSE_ID__SUPPLIER_INVOICE_ID_DESC',
  ExpenseByExpenseIdTripIdAsc = 'EXPENSE_BY_EXPENSE_ID__TRIP_ID_ASC',
  ExpenseByExpenseIdTripIdDesc = 'EXPENSE_BY_EXPENSE_ID__TRIP_ID_DESC',
  ExpenseIdAsc = 'EXPENSE_ID_ASC',
  ExpenseIdDesc = 'EXPENSE_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  InvoiceByInvoiceIdAmountAsc = 'INVOICE_BY_INVOICE_ID__AMOUNT_ASC',
  InvoiceByInvoiceIdAmountDesc = 'INVOICE_BY_INVOICE_ID__AMOUNT_DESC',
  InvoiceByInvoiceIdCategoryIdAsc = 'INVOICE_BY_INVOICE_ID__CATEGORY_ID_ASC',
  InvoiceByInvoiceIdCategoryIdDesc = 'INVOICE_BY_INVOICE_ID__CATEGORY_ID_DESC',
  InvoiceByInvoiceIdCreatedAsc = 'INVOICE_BY_INVOICE_ID__CREATED_ASC',
  InvoiceByInvoiceIdCreatedDesc = 'INVOICE_BY_INVOICE_ID__CREATED_DESC',
  InvoiceByInvoiceIdCurrencyAsc = 'INVOICE_BY_INVOICE_ID__CURRENCY_ASC',
  InvoiceByInvoiceIdCurrencyDesc = 'INVOICE_BY_INVOICE_ID__CURRENCY_DESC',
  InvoiceByInvoiceIdDueAsc = 'INVOICE_BY_INVOICE_ID__DUE_ASC',
  InvoiceByInvoiceIdDueDesc = 'INVOICE_BY_INVOICE_ID__DUE_DESC',
  InvoiceByInvoiceIdIdAsc = 'INVOICE_BY_INVOICE_ID__ID_ASC',
  InvoiceByInvoiceIdIdDesc = 'INVOICE_BY_INVOICE_ID__ID_DESC',
  InvoiceByInvoiceIdInvoicedAsc = 'INVOICE_BY_INVOICE_ID__INVOICED_ASC',
  InvoiceByInvoiceIdInvoicedDesc = 'INVOICE_BY_INVOICE_ID__INVOICED_DESC',
  InvoiceByInvoiceIdKeyAsc = 'INVOICE_BY_INVOICE_ID__KEY_ASC',
  InvoiceByInvoiceIdKeyDesc = 'INVOICE_BY_INVOICE_ID__KEY_DESC',
  InvoiceByInvoiceIdLockedAsc = 'INVOICE_BY_INVOICE_ID__LOCKED_ASC',
  InvoiceByInvoiceIdLockedDesc = 'INVOICE_BY_INVOICE_ID__LOCKED_DESC',
  InvoiceByInvoiceIdModifiedAsc = 'INVOICE_BY_INVOICE_ID__MODIFIED_ASC',
  InvoiceByInvoiceIdModifiedDesc = 'INVOICE_BY_INVOICE_ID__MODIFIED_DESC',
  InvoiceByInvoiceIdNoteAsc = 'INVOICE_BY_INVOICE_ID__NOTE_ASC',
  InvoiceByInvoiceIdNoteDesc = 'INVOICE_BY_INVOICE_ID__NOTE_DESC',
  InvoiceByInvoiceIdNumberAsc = 'INVOICE_BY_INVOICE_ID__NUMBER_ASC',
  InvoiceByInvoiceIdNumberDesc = 'INVOICE_BY_INVOICE_ID__NUMBER_DESC',
  InvoiceByInvoiceIdPaidAsc = 'INVOICE_BY_INVOICE_ID__PAID_ASC',
  InvoiceByInvoiceIdPaidDesc = 'INVOICE_BY_INVOICE_ID__PAID_DESC',
  InvoiceByInvoiceIdQuoteIdAsc = 'INVOICE_BY_INVOICE_ID__QUOTE_ID_ASC',
  InvoiceByInvoiceIdQuoteIdDesc = 'INVOICE_BY_INVOICE_ID__QUOTE_ID_DESC',
  InvoiceByInvoiceIdSummaryAsc = 'INVOICE_BY_INVOICE_ID__SUMMARY_ASC',
  InvoiceByInvoiceIdSummaryDesc = 'INVOICE_BY_INVOICE_ID__SUMMARY_DESC',
  InvoiceByInvoiceIdTripIdAsc = 'INVOICE_BY_INVOICE_ID__TRIP_ID_ASC',
  InvoiceByInvoiceIdTripIdDesc = 'INVOICE_BY_INVOICE_ID__TRIP_ID_DESC',
  InvoiceByInvoiceIdTypeAsc = 'INVOICE_BY_INVOICE_ID__TYPE_ASC',
  InvoiceByInvoiceIdTypeDesc = 'INVOICE_BY_INVOICE_ID__TYPE_DESC',
  InvoiceByInvoiceIdVoidedAsc = 'INVOICE_BY_INVOICE_ID__VOIDED_ASC',
  InvoiceByInvoiceIdVoidedDesc = 'INVOICE_BY_INVOICE_ID__VOIDED_DESC',
  InvoiceIdAsc = 'INVOICE_ID_ASC',
  InvoiceIdDesc = 'INVOICE_ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  Natural = 'NATURAL',
  PaymentByPaymentIdAmountActualAsc = 'PAYMENT_BY_PAYMENT_ID__AMOUNT_ACTUAL_ASC',
  PaymentByPaymentIdAmountActualDesc = 'PAYMENT_BY_PAYMENT_ID__AMOUNT_ACTUAL_DESC',
  PaymentByPaymentIdAmountAsc = 'PAYMENT_BY_PAYMENT_ID__AMOUNT_ASC',
  PaymentByPaymentIdAmountDesc = 'PAYMENT_BY_PAYMENT_ID__AMOUNT_DESC',
  PaymentByPaymentIdCategoryIdAsc = 'PAYMENT_BY_PAYMENT_ID__CATEGORY_ID_ASC',
  PaymentByPaymentIdCategoryIdDesc = 'PAYMENT_BY_PAYMENT_ID__CATEGORY_ID_DESC',
  PaymentByPaymentIdCreatedAsc = 'PAYMENT_BY_PAYMENT_ID__CREATED_ASC',
  PaymentByPaymentIdCreatedDesc = 'PAYMENT_BY_PAYMENT_ID__CREATED_DESC',
  PaymentByPaymentIdCurrencyAsc = 'PAYMENT_BY_PAYMENT_ID__CURRENCY_ASC',
  PaymentByPaymentIdCurrencyDesc = 'PAYMENT_BY_PAYMENT_ID__CURRENCY_DESC',
  PaymentByPaymentIdIdAsc = 'PAYMENT_BY_PAYMENT_ID__ID_ASC',
  PaymentByPaymentIdIdDesc = 'PAYMENT_BY_PAYMENT_ID__ID_DESC',
  PaymentByPaymentIdInvoiceIdAsc = 'PAYMENT_BY_PAYMENT_ID__INVOICE_ID_ASC',
  PaymentByPaymentIdInvoiceIdDesc = 'PAYMENT_BY_PAYMENT_ID__INVOICE_ID_DESC',
  PaymentByPaymentIdModifiedAsc = 'PAYMENT_BY_PAYMENT_ID__MODIFIED_ASC',
  PaymentByPaymentIdModifiedDesc = 'PAYMENT_BY_PAYMENT_ID__MODIFIED_DESC',
  PaymentByPaymentIdPaidAsc = 'PAYMENT_BY_PAYMENT_ID__PAID_ASC',
  PaymentByPaymentIdPaidDesc = 'PAYMENT_BY_PAYMENT_ID__PAID_DESC',
  PaymentByPaymentIdReferenceAsc = 'PAYMENT_BY_PAYMENT_ID__REFERENCE_ASC',
  PaymentByPaymentIdReferenceDesc = 'PAYMENT_BY_PAYMENT_ID__REFERENCE_DESC',
  PaymentByPaymentIdSummaryAsc = 'PAYMENT_BY_PAYMENT_ID__SUMMARY_ASC',
  PaymentByPaymentIdSummaryDesc = 'PAYMENT_BY_PAYMENT_ID__SUMMARY_DESC',
  PaymentByPaymentIdTripIdAsc = 'PAYMENT_BY_PAYMENT_ID__TRIP_ID_ASC',
  PaymentByPaymentIdTripIdDesc = 'PAYMENT_BY_PAYMENT_ID__TRIP_ID_DESC',
  PaymentByPaymentIdTypeAsc = 'PAYMENT_BY_PAYMENT_ID__TYPE_ASC',
  PaymentByPaymentIdTypeDesc = 'PAYMENT_BY_PAYMENT_ID__TYPE_DESC',
  PaymentIdAsc = 'PAYMENT_ID_ASC',
  PaymentIdDesc = 'PAYMENT_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  SupplierInvoiceBySupplierInvoiceIdAmountActualAsc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__AMOUNT_ACTUAL_ASC',
  SupplierInvoiceBySupplierInvoiceIdAmountActualDesc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__AMOUNT_ACTUAL_DESC',
  SupplierInvoiceBySupplierInvoiceIdAmountAsc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__AMOUNT_ASC',
  SupplierInvoiceBySupplierInvoiceIdAmountDesc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__AMOUNT_DESC',
  SupplierInvoiceBySupplierInvoiceIdCategoryIdAsc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__CATEGORY_ID_ASC',
  SupplierInvoiceBySupplierInvoiceIdCategoryIdDesc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__CATEGORY_ID_DESC',
  SupplierInvoiceBySupplierInvoiceIdCreatedAsc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__CREATED_ASC',
  SupplierInvoiceBySupplierInvoiceIdCreatedDesc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__CREATED_DESC',
  SupplierInvoiceBySupplierInvoiceIdCurrencyAsc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__CURRENCY_ASC',
  SupplierInvoiceBySupplierInvoiceIdCurrencyDesc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__CURRENCY_DESC',
  SupplierInvoiceBySupplierInvoiceIdDueAsc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__DUE_ASC',
  SupplierInvoiceBySupplierInvoiceIdDueDesc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__DUE_DESC',
  SupplierInvoiceBySupplierInvoiceIdIdAsc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__ID_ASC',
  SupplierInvoiceBySupplierInvoiceIdIdDesc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__ID_DESC',
  SupplierInvoiceBySupplierInvoiceIdKeyAsc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__KEY_ASC',
  SupplierInvoiceBySupplierInvoiceIdKeyDesc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__KEY_DESC',
  SupplierInvoiceBySupplierInvoiceIdMediaItemIdAsc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__MEDIA_ITEM_ID_ASC',
  SupplierInvoiceBySupplierInvoiceIdMediaItemIdDesc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__MEDIA_ITEM_ID_DESC',
  SupplierInvoiceBySupplierInvoiceIdModifiedAsc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__MODIFIED_ASC',
  SupplierInvoiceBySupplierInvoiceIdModifiedDesc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__MODIFIED_DESC',
  SupplierInvoiceBySupplierInvoiceIdNumberAsc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__NUMBER_ASC',
  SupplierInvoiceBySupplierInvoiceIdNumberDesc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__NUMBER_DESC',
  SupplierInvoiceBySupplierInvoiceIdPaidAsc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__PAID_ASC',
  SupplierInvoiceBySupplierInvoiceIdPaidDesc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__PAID_DESC',
  SupplierInvoiceBySupplierInvoiceIdSummaryAsc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__SUMMARY_ASC',
  SupplierInvoiceBySupplierInvoiceIdSummaryDesc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__SUMMARY_DESC',
  SupplierInvoiceBySupplierInvoiceIdSupplierIdAsc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__SUPPLIER_ID_ASC',
  SupplierInvoiceBySupplierInvoiceIdSupplierIdDesc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__SUPPLIER_ID_DESC',
  SupplierInvoiceBySupplierInvoiceIdTripIdAsc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__TRIP_ID_ASC',
  SupplierInvoiceBySupplierInvoiceIdTripIdDesc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__TRIP_ID_DESC',
  SupplierInvoiceBySupplierInvoiceIdTypeAsc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__TYPE_ASC',
  SupplierInvoiceBySupplierInvoiceIdTypeDesc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__TYPE_DESC',
  SupplierInvoiceBySupplierInvoiceIdVoidedAsc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__VOIDED_ASC',
  SupplierInvoiceBySupplierInvoiceIdVoidedDesc = 'SUPPLIER_INVOICE_BY_SUPPLIER_INVOICE_ID__VOIDED_DESC',
  SupplierInvoiceIdAsc = 'SUPPLIER_INVOICE_ID_ASC',
  SupplierInvoiceIdDesc = 'SUPPLIER_INVOICE_ID_DESC',
  TransactionByTransactionIdAccountIdAsc = 'TRANSACTION_BY_TRANSACTION_ID__ACCOUNT_ID_ASC',
  TransactionByTransactionIdAccountIdDesc = 'TRANSACTION_BY_TRANSACTION_ID__ACCOUNT_ID_DESC',
  TransactionByTransactionIdAmountAsc = 'TRANSACTION_BY_TRANSACTION_ID__AMOUNT_ASC',
  TransactionByTransactionIdAmountDesc = 'TRANSACTION_BY_TRANSACTION_ID__AMOUNT_DESC',
  TransactionByTransactionIdBalanceAsc = 'TRANSACTION_BY_TRANSACTION_ID__BALANCE_ASC',
  TransactionByTransactionIdBalanceDesc = 'TRANSACTION_BY_TRANSACTION_ID__BALANCE_DESC',
  TransactionByTransactionIdCategoryIdAsc = 'TRANSACTION_BY_TRANSACTION_ID__CATEGORY_ID_ASC',
  TransactionByTransactionIdCategoryIdDesc = 'TRANSACTION_BY_TRANSACTION_ID__CATEGORY_ID_DESC',
  TransactionByTransactionIdCreatedAsc = 'TRANSACTION_BY_TRANSACTION_ID__CREATED_ASC',
  TransactionByTransactionIdCreatedDesc = 'TRANSACTION_BY_TRANSACTION_ID__CREATED_DESC',
  TransactionByTransactionIdCurrencyAsc = 'TRANSACTION_BY_TRANSACTION_ID__CURRENCY_ASC',
  TransactionByTransactionIdCurrencyDesc = 'TRANSACTION_BY_TRANSACTION_ID__CURRENCY_DESC',
  TransactionByTransactionIdDateAsc = 'TRANSACTION_BY_TRANSACTION_ID__DATE_ASC',
  TransactionByTransactionIdDateDesc = 'TRANSACTION_BY_TRANSACTION_ID__DATE_DESC',
  TransactionByTransactionIdDescriptionAsc = 'TRANSACTION_BY_TRANSACTION_ID__DESCRIPTION_ASC',
  TransactionByTransactionIdDescriptionDesc = 'TRANSACTION_BY_TRANSACTION_ID__DESCRIPTION_DESC',
  TransactionByTransactionIdExternalIdAsc = 'TRANSACTION_BY_TRANSACTION_ID__EXTERNAL_ID_ASC',
  TransactionByTransactionIdExternalIdDesc = 'TRANSACTION_BY_TRANSACTION_ID__EXTERNAL_ID_DESC',
  TransactionByTransactionIdIdAsc = 'TRANSACTION_BY_TRANSACTION_ID__ID_ASC',
  TransactionByTransactionIdIdDesc = 'TRANSACTION_BY_TRANSACTION_ID__ID_DESC',
  TransactionByTransactionIdModifiedAsc = 'TRANSACTION_BY_TRANSACTION_ID__MODIFIED_ASC',
  TransactionByTransactionIdModifiedDesc = 'TRANSACTION_BY_TRANSACTION_ID__MODIFIED_DESC',
  TransactionByTransactionIdReverseTransactionIdAsc = 'TRANSACTION_BY_TRANSACTION_ID__REVERSE_TRANSACTION_ID_ASC',
  TransactionByTransactionIdReverseTransactionIdDesc = 'TRANSACTION_BY_TRANSACTION_ID__REVERSE_TRANSACTION_ID_DESC',
  TransactionByTransactionIdSourceAsc = 'TRANSACTION_BY_TRANSACTION_ID__SOURCE_ASC',
  TransactionByTransactionIdSourceDesc = 'TRANSACTION_BY_TRANSACTION_ID__SOURCE_DESC',
  TransactionByTransactionIdStatusAsc = 'TRANSACTION_BY_TRANSACTION_ID__STATUS_ASC',
  TransactionByTransactionIdStatusDesc = 'TRANSACTION_BY_TRANSACTION_ID__STATUS_DESC',
  TransactionByTransactionIdTransactionImportBatchIdAsc = 'TRANSACTION_BY_TRANSACTION_ID__TRANSACTION_IMPORT_BATCH_ID_ASC',
  TransactionByTransactionIdTransactionImportBatchIdDesc = 'TRANSACTION_BY_TRANSACTION_ID__TRANSACTION_IMPORT_BATCH_ID_DESC',
  TransactionIdAsc = 'TRANSACTION_ID_ASC',
  TransactionIdDesc = 'TRANSACTION_ID_DESC'
}

export type TransactionNote = {
  __typename?: 'TransactionNote';
  created: Scalars['Datetime']['output'];
  id: Scalars['UUID']['output'];
  message?: Maybe<Scalars['String']['output']>;
  modified: Scalars['Datetime']['output'];
  /** Reads a single `Transaction` that is related to this `TransactionNote`. */
  transaction?: Maybe<Transaction>;
  transactionId: Scalars['UUID']['output'];
  /** Reads a single `User` that is related to this `TransactionNote`. */
  user?: Maybe<User>;
  userId: Scalars['UUID']['output'];
};

/**
 * A condition to be used against `TransactionNote` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type TransactionNoteCondition = {
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `message` field. */
  message?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `transactionId` field. */
  transactionId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['UUID']['input']>;
};

/** A filter to be used against `TransactionNote` object types. All fields are combined with a logical ‘and.’ */
export type TransactionNoteFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<TransactionNoteFilter>>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `message` field. */
  message?: InputMaybe<StringFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<TransactionNoteFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<TransactionNoteFilter>>;
  /** Filter by the object’s `transaction` relation. */
  transaction?: InputMaybe<TransactionFilter>;
  /** Filter by the object’s `transactionId` field. */
  transactionId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `user` relation. */
  user?: InputMaybe<UserFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<UuidFilter>;
};

/** An input for mutations affecting `TransactionNote` */
export type TransactionNoteInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  message?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  transactionId?: InputMaybe<Scalars['UUID']['input']>;
  transactionToTransactionId?: InputMaybe<FkTransactionNoteTransactionTransactionIdInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkTransactionNoteUserUserIdInput>;
};

/** The fields on `transactionNote` to look up the row to update. */
export type TransactionNoteOnTransactionNoteForFkTransactionNoteTransactionTransactionIdUsingPkTransactionNoteUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `transactionNote` being updated. */
  patch: UpdateTransactionNoteOnTransactionNoteForFkTransactionNoteTransactionTransactionIdPatch;
};

/** The fields on `transactionNote` to look up the row to update. */
export type TransactionNoteOnTransactionNoteForFkTransactionNoteUserUserIdUsingPkTransactionNoteUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `transactionNote` being updated. */
  patch: UpdateTransactionNoteOnTransactionNoteForFkTransactionNoteUserUserIdPatch;
};

/** Represents an update to a `TransactionNote`. Fields that are set will be updated. */
export type TransactionNotePatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  message?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  transactionId?: InputMaybe<Scalars['UUID']['input']>;
  transactionToTransactionId?: InputMaybe<FkTransactionNoteTransactionTransactionIdInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkTransactionNoteUserUserIdInput>;
};

/** The fields on `transactionNote` to look up the row to connect. */
export type TransactionNotePkTransactionNoteConnect = {
  id: Scalars['UUID']['input'];
};

/** The fields on `transactionNote` to look up the row to delete. */
export type TransactionNotePkTransactionNoteDelete = {
  id: Scalars['UUID']['input'];
};

/** A connection to a list of `TransactionNote` values. */
export type TransactionNotesConnection = {
  __typename?: 'TransactionNotesConnection';
  /** A list of edges which contains the `TransactionNote` and cursor to aid in pagination. */
  edges: Array<TransactionNotesEdge>;
  /** A list of `TransactionNote` objects. */
  nodes: Array<Maybe<TransactionNote>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TransactionNote` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `TransactionNote` edge in the connection. */
export type TransactionNotesEdge = {
  __typename?: 'TransactionNotesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `TransactionNote` at the end of the edge. */
  node?: Maybe<TransactionNote>;
};

/** Methods to use when ordering `TransactionNote`. */
export enum TransactionNotesOrderBy {
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  MessageAsc = 'MESSAGE_ASC',
  MessageDesc = 'MESSAGE_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TransactionByTransactionIdAccountIdAsc = 'TRANSACTION_BY_TRANSACTION_ID__ACCOUNT_ID_ASC',
  TransactionByTransactionIdAccountIdDesc = 'TRANSACTION_BY_TRANSACTION_ID__ACCOUNT_ID_DESC',
  TransactionByTransactionIdAmountAsc = 'TRANSACTION_BY_TRANSACTION_ID__AMOUNT_ASC',
  TransactionByTransactionIdAmountDesc = 'TRANSACTION_BY_TRANSACTION_ID__AMOUNT_DESC',
  TransactionByTransactionIdBalanceAsc = 'TRANSACTION_BY_TRANSACTION_ID__BALANCE_ASC',
  TransactionByTransactionIdBalanceDesc = 'TRANSACTION_BY_TRANSACTION_ID__BALANCE_DESC',
  TransactionByTransactionIdCategoryIdAsc = 'TRANSACTION_BY_TRANSACTION_ID__CATEGORY_ID_ASC',
  TransactionByTransactionIdCategoryIdDesc = 'TRANSACTION_BY_TRANSACTION_ID__CATEGORY_ID_DESC',
  TransactionByTransactionIdCreatedAsc = 'TRANSACTION_BY_TRANSACTION_ID__CREATED_ASC',
  TransactionByTransactionIdCreatedDesc = 'TRANSACTION_BY_TRANSACTION_ID__CREATED_DESC',
  TransactionByTransactionIdCurrencyAsc = 'TRANSACTION_BY_TRANSACTION_ID__CURRENCY_ASC',
  TransactionByTransactionIdCurrencyDesc = 'TRANSACTION_BY_TRANSACTION_ID__CURRENCY_DESC',
  TransactionByTransactionIdDateAsc = 'TRANSACTION_BY_TRANSACTION_ID__DATE_ASC',
  TransactionByTransactionIdDateDesc = 'TRANSACTION_BY_TRANSACTION_ID__DATE_DESC',
  TransactionByTransactionIdDescriptionAsc = 'TRANSACTION_BY_TRANSACTION_ID__DESCRIPTION_ASC',
  TransactionByTransactionIdDescriptionDesc = 'TRANSACTION_BY_TRANSACTION_ID__DESCRIPTION_DESC',
  TransactionByTransactionIdExternalIdAsc = 'TRANSACTION_BY_TRANSACTION_ID__EXTERNAL_ID_ASC',
  TransactionByTransactionIdExternalIdDesc = 'TRANSACTION_BY_TRANSACTION_ID__EXTERNAL_ID_DESC',
  TransactionByTransactionIdIdAsc = 'TRANSACTION_BY_TRANSACTION_ID__ID_ASC',
  TransactionByTransactionIdIdDesc = 'TRANSACTION_BY_TRANSACTION_ID__ID_DESC',
  TransactionByTransactionIdModifiedAsc = 'TRANSACTION_BY_TRANSACTION_ID__MODIFIED_ASC',
  TransactionByTransactionIdModifiedDesc = 'TRANSACTION_BY_TRANSACTION_ID__MODIFIED_DESC',
  TransactionByTransactionIdReverseTransactionIdAsc = 'TRANSACTION_BY_TRANSACTION_ID__REVERSE_TRANSACTION_ID_ASC',
  TransactionByTransactionIdReverseTransactionIdDesc = 'TRANSACTION_BY_TRANSACTION_ID__REVERSE_TRANSACTION_ID_DESC',
  TransactionByTransactionIdSourceAsc = 'TRANSACTION_BY_TRANSACTION_ID__SOURCE_ASC',
  TransactionByTransactionIdSourceDesc = 'TRANSACTION_BY_TRANSACTION_ID__SOURCE_DESC',
  TransactionByTransactionIdStatusAsc = 'TRANSACTION_BY_TRANSACTION_ID__STATUS_ASC',
  TransactionByTransactionIdStatusDesc = 'TRANSACTION_BY_TRANSACTION_ID__STATUS_DESC',
  TransactionByTransactionIdTransactionImportBatchIdAsc = 'TRANSACTION_BY_TRANSACTION_ID__TRANSACTION_IMPORT_BATCH_ID_ASC',
  TransactionByTransactionIdTransactionImportBatchIdDesc = 'TRANSACTION_BY_TRANSACTION_ID__TRANSACTION_IMPORT_BATCH_ID_DESC',
  TransactionIdAsc = 'TRANSACTION_ID_ASC',
  TransactionIdDesc = 'TRANSACTION_ID_DESC',
  UserByUserIdCreatedAsc = 'USER_BY_USER_ID__CREATED_ASC',
  UserByUserIdCreatedDesc = 'USER_BY_USER_ID__CREATED_DESC',
  UserByUserIdEmailAsc = 'USER_BY_USER_ID__EMAIL_ASC',
  UserByUserIdEmailDesc = 'USER_BY_USER_ID__EMAIL_DESC',
  UserByUserIdExternalIdAsc = 'USER_BY_USER_ID__EXTERNAL_ID_ASC',
  UserByUserIdExternalIdDesc = 'USER_BY_USER_ID__EXTERNAL_ID_DESC',
  UserByUserIdFirstNameAsc = 'USER_BY_USER_ID__FIRST_NAME_ASC',
  UserByUserIdFirstNameDesc = 'USER_BY_USER_ID__FIRST_NAME_DESC',
  UserByUserIdGenderPrepositionAsc = 'USER_BY_USER_ID__GENDER_PREPOSITION_ASC',
  UserByUserIdGenderPrepositionDesc = 'USER_BY_USER_ID__GENDER_PREPOSITION_DESC',
  UserByUserIdIdAsc = 'USER_BY_USER_ID__ID_ASC',
  UserByUserIdIdDesc = 'USER_BY_USER_ID__ID_DESC',
  UserByUserIdLastNameAsc = 'USER_BY_USER_ID__LAST_NAME_ASC',
  UserByUserIdLastNameDesc = 'USER_BY_USER_ID__LAST_NAME_DESC',
  UserByUserIdModifiedAsc = 'USER_BY_USER_ID__MODIFIED_ASC',
  UserByUserIdModifiedDesc = 'USER_BY_USER_ID__MODIFIED_DESC',
  UserByUserIdNameAsc = 'USER_BY_USER_ID__NAME_ASC',
  UserByUserIdNameDesc = 'USER_BY_USER_ID__NAME_DESC',
  UserByUserIdPasswordAsc = 'USER_BY_USER_ID__PASSWORD_ASC',
  UserByUserIdPasswordDesc = 'USER_BY_USER_ID__PASSWORD_DESC',
  UserByUserIdPhoneAsc = 'USER_BY_USER_ID__PHONE_ASC',
  UserByUserIdPhoneDesc = 'USER_BY_USER_ID__PHONE_DESC',
  UserByUserIdSkypeAsc = 'USER_BY_USER_ID__SKYPE_ASC',
  UserByUserIdSkypeDesc = 'USER_BY_USER_ID__SKYPE_DESC',
  UserByUserIdTitleAsc = 'USER_BY_USER_ID__TITLE_ASC',
  UserByUserIdTitleDesc = 'USER_BY_USER_ID__TITLE_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

/** The fields on `transaction` to look up the row to update. */
export type TransactionOnTransactionForFkTransactionAccountAccountIdUsingPkTransactionUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `transaction` being updated. */
  patch: UpdateTransactionOnTransactionForFkTransactionAccountAccountIdPatch;
};

/** The fields on `transaction` to look up the row to update. */
export type TransactionOnTransactionForFkTransactionFinanceCategoryCategoryIdUsingPkTransactionUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `transaction` being updated. */
  patch: UpdateTransactionOnTransactionForFkTransactionFinanceCategoryCategoryIdPatch;
};

/** The fields on `transaction` to look up the row to update. */
export type TransactionOnTransactionForFkTransactionTransactionImportBatchTransactionImportBatchIdUsingPkTransactionUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `transaction` being updated. */
  patch: UpdateTransactionOnTransactionForFkTransactionTransactionImportBatchTransactionImportBatchIdPatch;
};

/** The fields on `transaction` to look up the row to update. */
export type TransactionOnTransactionForFkTransactionTransactionReverseTransactionIdUsingPkTransactionUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `transaction` being updated. */
  patch: UpdateTransactionOnTransactionForFkTransactionTransactionReverseTransactionIdPatch;
};

/** The fields on `transaction` to look up the row to update. */
export type TransactionOnTransactionLinkForFkTransactionLinkTransactionTransactionIdUsingPkTransactionUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `transaction` being updated. */
  patch: UpdateTransactionOnTransactionLinkForFkTransactionLinkTransactionTransactionIdPatch;
};

/** The fields on `transaction` to look up the row to update. */
export type TransactionOnTransactionNoteForFkTransactionNoteTransactionTransactionIdUsingPkTransactionUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `transaction` being updated. */
  patch: UpdateTransactionOnTransactionNoteForFkTransactionNoteTransactionTransactionIdPatch;
};

/** Represents an update to a `Transaction`. Fields that are set will be updated. */
export type TransactionPatch = {
  accountId?: InputMaybe<Scalars['UUID']['input']>;
  accountToAccountId?: InputMaybe<FkTransactionAccountAccountIdInput>;
  amount?: InputMaybe<Scalars['BigFloat']['input']>;
  balance?: InputMaybe<Scalars['BigFloat']['input']>;
  categoryId?: InputMaybe<Scalars['UUID']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  date?: InputMaybe<Scalars['Datetime']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  externalId?: InputMaybe<Scalars['String']['input']>;
  financeCategoryToCategoryId?: InputMaybe<FkTransactionFinanceCategoryCategoryIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  reverseTransactionId?: InputMaybe<Scalars['UUID']['input']>;
  source?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  transactionImportBatchId?: InputMaybe<Scalars['UUID']['input']>;
  transactionImportBatchToTransactionImportBatchId?: InputMaybe<FkTransactionTransactionImportBatchTransactionImportBatchIdInput>;
  transactionLinksUsingId?: InputMaybe<FkTransactionLinkTransactionTransactionIdInverseInput>;
  transactionNotesUsingId?: InputMaybe<FkTransactionNoteTransactionTransactionIdInverseInput>;
  transactionToReverseTransactionId?: InputMaybe<FkTransactionTransactionReverseTransactionIdInput>;
};

/** The fields on `transaction` to look up the row to connect. */
export type TransactionPkTransactionConnect = {
  id: Scalars['UUID']['input'];
};

/** The fields on `transaction` to look up the row to delete. */
export type TransactionPkTransactionDelete = {
  id: Scalars['UUID']['input'];
};

/** A filter to be used against many `Transaction` object types. All fields are combined with a logical ‘and.’ */
export type TransactionToManyTransactionFilter = {
  /** Every related `Transaction` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<TransactionFilter>;
  /** No related `Transaction` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<TransactionFilter>;
  /** Some related `Transaction` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<TransactionFilter>;
};

/** A filter to be used against many `TransactionLink` object types. All fields are combined with a logical ‘and.’ */
export type TransactionToManyTransactionLinkFilter = {
  /** Every related `TransactionLink` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<TransactionLinkFilter>;
  /** No related `TransactionLink` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<TransactionLinkFilter>;
  /** Some related `TransactionLink` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<TransactionLinkFilter>;
};

/** A filter to be used against many `TransactionNote` object types. All fields are combined with a logical ‘and.’ */
export type TransactionToManyTransactionNoteFilter = {
  /** Every related `TransactionNote` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<TransactionNoteFilter>;
  /** No related `TransactionNote` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<TransactionNoteFilter>;
  /** Some related `TransactionNote` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<TransactionNoteFilter>;
};

/** A connection to a list of `Transaction` values. */
export type TransactionsConnection = {
  __typename?: 'TransactionsConnection';
  /** A list of edges which contains the `Transaction` and cursor to aid in pagination. */
  edges: Array<TransactionsEdge>;
  /** A list of `Transaction` objects. */
  nodes: Array<Maybe<Transaction>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Transaction` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Transaction` edge in the connection. */
export type TransactionsEdge = {
  __typename?: 'TransactionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Transaction` at the end of the edge. */
  node?: Maybe<Transaction>;
};

/** Methods to use when ordering `Transaction`. */
export enum TransactionsOrderBy {
  AccountByAccountIdCreatedAsc = 'ACCOUNT_BY_ACCOUNT_ID__CREATED_ASC',
  AccountByAccountIdCreatedDesc = 'ACCOUNT_BY_ACCOUNT_ID__CREATED_DESC',
  AccountByAccountIdDetailsAsc = 'ACCOUNT_BY_ACCOUNT_ID__DETAILS_ASC',
  AccountByAccountIdDetailsDesc = 'ACCOUNT_BY_ACCOUNT_ID__DETAILS_DESC',
  AccountByAccountIdIdAsc = 'ACCOUNT_BY_ACCOUNT_ID__ID_ASC',
  AccountByAccountIdIdDesc = 'ACCOUNT_BY_ACCOUNT_ID__ID_DESC',
  AccountByAccountIdInstitutionAsc = 'ACCOUNT_BY_ACCOUNT_ID__INSTITUTION_ASC',
  AccountByAccountIdInstitutionDesc = 'ACCOUNT_BY_ACCOUNT_ID__INSTITUTION_DESC',
  AccountByAccountIdModifiedAsc = 'ACCOUNT_BY_ACCOUNT_ID__MODIFIED_ASC',
  AccountByAccountIdModifiedDesc = 'ACCOUNT_BY_ACCOUNT_ID__MODIFIED_DESC',
  AccountByAccountIdNameAsc = 'ACCOUNT_BY_ACCOUNT_ID__NAME_ASC',
  AccountByAccountIdNameDesc = 'ACCOUNT_BY_ACCOUNT_ID__NAME_DESC',
  AccountIdAsc = 'ACCOUNT_ID_ASC',
  AccountIdDesc = 'ACCOUNT_ID_DESC',
  AmountAsc = 'AMOUNT_ASC',
  AmountDesc = 'AMOUNT_DESC',
  BalanceAsc = 'BALANCE_ASC',
  BalanceDesc = 'BALANCE_DESC',
  CategoryIdAsc = 'CATEGORY_ID_ASC',
  CategoryIdDesc = 'CATEGORY_ID_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  CurrencyAsc = 'CURRENCY_ASC',
  CurrencyDesc = 'CURRENCY_DESC',
  DateAsc = 'DATE_ASC',
  DateDesc = 'DATE_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  ExternalIdAsc = 'EXTERNAL_ID_ASC',
  ExternalIdDesc = 'EXTERNAL_ID_DESC',
  FinanceCategoryByCategoryIdCodeAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__CODE_ASC',
  FinanceCategoryByCategoryIdCodeDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__CODE_DESC',
  FinanceCategoryByCategoryIdCreatedAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__CREATED_ASC',
  FinanceCategoryByCategoryIdCreatedDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__CREATED_DESC',
  FinanceCategoryByCategoryIdIdAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__ID_ASC',
  FinanceCategoryByCategoryIdIdDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__ID_DESC',
  FinanceCategoryByCategoryIdModifiedAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__MODIFIED_ASC',
  FinanceCategoryByCategoryIdModifiedDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__MODIFIED_DESC',
  FinanceCategoryByCategoryIdNameAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__NAME_ASC',
  FinanceCategoryByCategoryIdNameDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__NAME_DESC',
  FinanceCategoryByCategoryIdSummaryAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__SUMMARY_ASC',
  FinanceCategoryByCategoryIdSummaryDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__SUMMARY_DESC',
  FinanceCategoryByCategoryIdTypeAsc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__TYPE_ASC',
  FinanceCategoryByCategoryIdTypeDesc = 'FINANCE_CATEGORY_BY_CATEGORY_ID__TYPE_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ReverseTransactionIdAsc = 'REVERSE_TRANSACTION_ID_ASC',
  ReverseTransactionIdDesc = 'REVERSE_TRANSACTION_ID_DESC',
  SourceAsc = 'SOURCE_ASC',
  SourceDesc = 'SOURCE_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  TransactionsByReverseTransactionIdCountAsc = 'TRANSACTIONS_BY_REVERSE_TRANSACTION_ID__COUNT_ASC',
  TransactionsByReverseTransactionIdCountDesc = 'TRANSACTIONS_BY_REVERSE_TRANSACTION_ID__COUNT_DESC',
  TransactionByReverseTransactionIdAccountIdAsc = 'TRANSACTION_BY_REVERSE_TRANSACTION_ID__ACCOUNT_ID_ASC',
  TransactionByReverseTransactionIdAccountIdDesc = 'TRANSACTION_BY_REVERSE_TRANSACTION_ID__ACCOUNT_ID_DESC',
  TransactionByReverseTransactionIdAmountAsc = 'TRANSACTION_BY_REVERSE_TRANSACTION_ID__AMOUNT_ASC',
  TransactionByReverseTransactionIdAmountDesc = 'TRANSACTION_BY_REVERSE_TRANSACTION_ID__AMOUNT_DESC',
  TransactionByReverseTransactionIdBalanceAsc = 'TRANSACTION_BY_REVERSE_TRANSACTION_ID__BALANCE_ASC',
  TransactionByReverseTransactionIdBalanceDesc = 'TRANSACTION_BY_REVERSE_TRANSACTION_ID__BALANCE_DESC',
  TransactionByReverseTransactionIdCategoryIdAsc = 'TRANSACTION_BY_REVERSE_TRANSACTION_ID__CATEGORY_ID_ASC',
  TransactionByReverseTransactionIdCategoryIdDesc = 'TRANSACTION_BY_REVERSE_TRANSACTION_ID__CATEGORY_ID_DESC',
  TransactionByReverseTransactionIdCreatedAsc = 'TRANSACTION_BY_REVERSE_TRANSACTION_ID__CREATED_ASC',
  TransactionByReverseTransactionIdCreatedDesc = 'TRANSACTION_BY_REVERSE_TRANSACTION_ID__CREATED_DESC',
  TransactionByReverseTransactionIdCurrencyAsc = 'TRANSACTION_BY_REVERSE_TRANSACTION_ID__CURRENCY_ASC',
  TransactionByReverseTransactionIdCurrencyDesc = 'TRANSACTION_BY_REVERSE_TRANSACTION_ID__CURRENCY_DESC',
  TransactionByReverseTransactionIdDateAsc = 'TRANSACTION_BY_REVERSE_TRANSACTION_ID__DATE_ASC',
  TransactionByReverseTransactionIdDateDesc = 'TRANSACTION_BY_REVERSE_TRANSACTION_ID__DATE_DESC',
  TransactionByReverseTransactionIdDescriptionAsc = 'TRANSACTION_BY_REVERSE_TRANSACTION_ID__DESCRIPTION_ASC',
  TransactionByReverseTransactionIdDescriptionDesc = 'TRANSACTION_BY_REVERSE_TRANSACTION_ID__DESCRIPTION_DESC',
  TransactionByReverseTransactionIdExternalIdAsc = 'TRANSACTION_BY_REVERSE_TRANSACTION_ID__EXTERNAL_ID_ASC',
  TransactionByReverseTransactionIdExternalIdDesc = 'TRANSACTION_BY_REVERSE_TRANSACTION_ID__EXTERNAL_ID_DESC',
  TransactionByReverseTransactionIdIdAsc = 'TRANSACTION_BY_REVERSE_TRANSACTION_ID__ID_ASC',
  TransactionByReverseTransactionIdIdDesc = 'TRANSACTION_BY_REVERSE_TRANSACTION_ID__ID_DESC',
  TransactionByReverseTransactionIdModifiedAsc = 'TRANSACTION_BY_REVERSE_TRANSACTION_ID__MODIFIED_ASC',
  TransactionByReverseTransactionIdModifiedDesc = 'TRANSACTION_BY_REVERSE_TRANSACTION_ID__MODIFIED_DESC',
  TransactionByReverseTransactionIdReverseTransactionIdAsc = 'TRANSACTION_BY_REVERSE_TRANSACTION_ID__REVERSE_TRANSACTION_ID_ASC',
  TransactionByReverseTransactionIdReverseTransactionIdDesc = 'TRANSACTION_BY_REVERSE_TRANSACTION_ID__REVERSE_TRANSACTION_ID_DESC',
  TransactionByReverseTransactionIdSourceAsc = 'TRANSACTION_BY_REVERSE_TRANSACTION_ID__SOURCE_ASC',
  TransactionByReverseTransactionIdSourceDesc = 'TRANSACTION_BY_REVERSE_TRANSACTION_ID__SOURCE_DESC',
  TransactionByReverseTransactionIdStatusAsc = 'TRANSACTION_BY_REVERSE_TRANSACTION_ID__STATUS_ASC',
  TransactionByReverseTransactionIdStatusDesc = 'TRANSACTION_BY_REVERSE_TRANSACTION_ID__STATUS_DESC',
  TransactionByReverseTransactionIdTransactionImportBatchIdAsc = 'TRANSACTION_BY_REVERSE_TRANSACTION_ID__TRANSACTION_IMPORT_BATCH_ID_ASC',
  TransactionByReverseTransactionIdTransactionImportBatchIdDesc = 'TRANSACTION_BY_REVERSE_TRANSACTION_ID__TRANSACTION_IMPORT_BATCH_ID_DESC',
  TransactionImportBatchByTransactionImportBatchIdAccountIdAsc = 'TRANSACTION_IMPORT_BATCH_BY_TRANSACTION_IMPORT_BATCH_ID__ACCOUNT_ID_ASC',
  TransactionImportBatchByTransactionImportBatchIdAccountIdDesc = 'TRANSACTION_IMPORT_BATCH_BY_TRANSACTION_IMPORT_BATCH_ID__ACCOUNT_ID_DESC',
  TransactionImportBatchByTransactionImportBatchIdCreatedAsc = 'TRANSACTION_IMPORT_BATCH_BY_TRANSACTION_IMPORT_BATCH_ID__CREATED_ASC',
  TransactionImportBatchByTransactionImportBatchIdCreatedDesc = 'TRANSACTION_IMPORT_BATCH_BY_TRANSACTION_IMPORT_BATCH_ID__CREATED_DESC',
  TransactionImportBatchByTransactionImportBatchIdDateRangeMaxAsc = 'TRANSACTION_IMPORT_BATCH_BY_TRANSACTION_IMPORT_BATCH_ID__DATE_RANGE_MAX_ASC',
  TransactionImportBatchByTransactionImportBatchIdDateRangeMaxDesc = 'TRANSACTION_IMPORT_BATCH_BY_TRANSACTION_IMPORT_BATCH_ID__DATE_RANGE_MAX_DESC',
  TransactionImportBatchByTransactionImportBatchIdDateRangeMinAsc = 'TRANSACTION_IMPORT_BATCH_BY_TRANSACTION_IMPORT_BATCH_ID__DATE_RANGE_MIN_ASC',
  TransactionImportBatchByTransactionImportBatchIdDateRangeMinDesc = 'TRANSACTION_IMPORT_BATCH_BY_TRANSACTION_IMPORT_BATCH_ID__DATE_RANGE_MIN_DESC',
  TransactionImportBatchByTransactionImportBatchIdIdAsc = 'TRANSACTION_IMPORT_BATCH_BY_TRANSACTION_IMPORT_BATCH_ID__ID_ASC',
  TransactionImportBatchByTransactionImportBatchIdIdDesc = 'TRANSACTION_IMPORT_BATCH_BY_TRANSACTION_IMPORT_BATCH_ID__ID_DESC',
  TransactionImportBatchByTransactionImportBatchIdKeyAsc = 'TRANSACTION_IMPORT_BATCH_BY_TRANSACTION_IMPORT_BATCH_ID__KEY_ASC',
  TransactionImportBatchByTransactionImportBatchIdKeyDesc = 'TRANSACTION_IMPORT_BATCH_BY_TRANSACTION_IMPORT_BATCH_ID__KEY_DESC',
  TransactionImportBatchByTransactionImportBatchIdModifiedAsc = 'TRANSACTION_IMPORT_BATCH_BY_TRANSACTION_IMPORT_BATCH_ID__MODIFIED_ASC',
  TransactionImportBatchByTransactionImportBatchIdModifiedDesc = 'TRANSACTION_IMPORT_BATCH_BY_TRANSACTION_IMPORT_BATCH_ID__MODIFIED_DESC',
  TransactionImportBatchIdAsc = 'TRANSACTION_IMPORT_BATCH_ID_ASC',
  TransactionImportBatchIdDesc = 'TRANSACTION_IMPORT_BATCH_ID_DESC',
  TransactionLinksByTransactionIdCountAsc = 'TRANSACTION_LINKS_BY_TRANSACTION_ID__COUNT_ASC',
  TransactionLinksByTransactionIdCountDesc = 'TRANSACTION_LINKS_BY_TRANSACTION_ID__COUNT_DESC',
  TransactionNotesByTransactionIdCountAsc = 'TRANSACTION_NOTES_BY_TRANSACTION_ID__COUNT_ASC',
  TransactionNotesByTransactionIdCountDesc = 'TRANSACTION_NOTES_BY_TRANSACTION_ID__COUNT_DESC'
}

export type Traveller = {
  __typename?: 'Traveller';
  created: Scalars['Datetime']['output'];
  /** Reads and enables pagination through a set of `CustomerTraveller`. */
  customerTravellers: CustomerTravellersConnection;
  dateOfBirth?: Maybe<Scalars['Datetime']['output']>;
  dietaryRequirements?: Maybe<Scalars['String']['output']>;
  email?: Maybe<Scalars['String']['output']>;
  emergencyContact?: Maybe<Scalars['String']['output']>;
  firstName?: Maybe<Scalars['String']['output']>;
  height?: Maybe<Scalars['Int']['output']>;
  id: Scalars['UUID']['output'];
  insuranceDetails?: Maybe<Scalars['String']['output']>;
  lastName?: Maybe<Scalars['String']['output']>;
  medicalConditions?: Maybe<Scalars['String']['output']>;
  middleName?: Maybe<Scalars['String']['output']>;
  modified: Scalars['Datetime']['output'];
  nationality?: Maybe<Scalars['String']['output']>;
  notes?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `Passport`. */
  passports: PassportsConnection;
  phone?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `TripTraveller`. */
  tripTravellers: TripTravellersConnection;
  weight?: Maybe<Scalars['Int']['output']>;
};


export type TravellerCustomerTravellersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CustomerTravellerCondition>;
  filter?: InputMaybe<CustomerTravellerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CustomerTravellersOrderBy>>;
};


export type TravellerPassportsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PassportCondition>;
  filter?: InputMaybe<PassportFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PassportsOrderBy>>;
};


export type TravellerTripTravellersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TripTravellerCondition>;
  filter?: InputMaybe<TripTravellerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TripTravellersOrderBy>>;
};

/**
 * A condition to be used against `Traveller` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type TravellerCondition = {
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `dateOfBirth` field. */
  dateOfBirth?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `dietaryRequirements` field. */
  dietaryRequirements?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `email` field. */
  email?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `emergencyContact` field. */
  emergencyContact?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `firstName` field. */
  firstName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `height` field. */
  height?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `insuranceDetails` field. */
  insuranceDetails?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `lastName` field. */
  lastName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `medicalConditions` field. */
  medicalConditions?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `middleName` field. */
  middleName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `nationality` field. */
  nationality?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `phone` field. */
  phone?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `weight` field. */
  weight?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `Traveller` object types. All fields are combined with a logical ‘and.’ */
export type TravellerFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<TravellerFilter>>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `customerTravellers` relation. */
  customerTravellers?: InputMaybe<TravellerToManyCustomerTravellerFilter>;
  /** Some related `customerTravellers` exist. */
  customerTravellersExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `dateOfBirth` field. */
  dateOfBirth?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `dietaryRequirements` field. */
  dietaryRequirements?: InputMaybe<StringFilter>;
  /** Filter by the object’s `email` field. */
  email?: InputMaybe<StringFilter>;
  /** Filter by the object’s `emergencyContact` field. */
  emergencyContact?: InputMaybe<StringFilter>;
  /** Filter by the object’s `firstName` field. */
  firstName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `height` field. */
  height?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `insuranceDetails` field. */
  insuranceDetails?: InputMaybe<StringFilter>;
  /** Filter by the object’s `lastName` field. */
  lastName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `medicalConditions` field. */
  medicalConditions?: InputMaybe<StringFilter>;
  /** Filter by the object’s `middleName` field. */
  middleName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `nationality` field. */
  nationality?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<TravellerFilter>;
  /** Filter by the object’s `notes` field. */
  notes?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<TravellerFilter>>;
  /** Filter by the object’s `passports` relation. */
  passports?: InputMaybe<TravellerToManyPassportFilter>;
  /** Some related `passports` exist. */
  passportsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `phone` field. */
  phone?: InputMaybe<StringFilter>;
  /** Filter by the object’s `tripTravellers` relation. */
  tripTravellers?: InputMaybe<TravellerToManyTripTravellerFilter>;
  /** Some related `tripTravellers` exist. */
  tripTravellersExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `weight` field. */
  weight?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `Traveller` */
export type TravellerInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerTravellersUsingId?: InputMaybe<FkCustomerTravellerTravellerTravellerIdInverseInput>;
  dateOfBirth?: InputMaybe<Scalars['Datetime']['input']>;
  dietaryRequirements?: InputMaybe<Scalars['String']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  emergencyContact?: InputMaybe<Scalars['String']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  height?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  insuranceDetails?: InputMaybe<Scalars['String']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  medicalConditions?: InputMaybe<Scalars['String']['input']>;
  middleName?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  nationality?: InputMaybe<Scalars['String']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  passportsUsingId?: InputMaybe<FkPassportTravellerTravellerIdInverseInput>;
  phone?: InputMaybe<Scalars['String']['input']>;
  tripTravellersUsingId?: InputMaybe<FkTripTravellerTravellerTravellerIdInverseInput>;
  weight?: InputMaybe<Scalars['Int']['input']>;
};

/** The fields on `traveller` to look up the row to update. */
export type TravellerOnCustomerTravellerForFkCustomerTravellerTravellerTravellerIdUsingPkTravellerUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `traveller` being updated. */
  patch: UpdateTravellerOnCustomerTravellerForFkCustomerTravellerTravellerTravellerIdPatch;
};

/** The fields on `traveller` to look up the row to update. */
export type TravellerOnPassportForFkPassportTravellerTravellerIdUsingPkTravellerUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `traveller` being updated. */
  patch: UpdateTravellerOnPassportForFkPassportTravellerTravellerIdPatch;
};

/** The fields on `traveller` to look up the row to update. */
export type TravellerOnTripTravellerForFkTripTravellerTravellerTravellerIdUsingPkTravellerUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `traveller` being updated. */
  patch: UpdateTravellerOnTripTravellerForFkTripTravellerTravellerTravellerIdPatch;
};

/** Represents an update to a `Traveller`. Fields that are set will be updated. */
export type TravellerPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerTravellersUsingId?: InputMaybe<FkCustomerTravellerTravellerTravellerIdInverseInput>;
  dateOfBirth?: InputMaybe<Scalars['Datetime']['input']>;
  dietaryRequirements?: InputMaybe<Scalars['String']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  emergencyContact?: InputMaybe<Scalars['String']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  height?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  insuranceDetails?: InputMaybe<Scalars['String']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  medicalConditions?: InputMaybe<Scalars['String']['input']>;
  middleName?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  nationality?: InputMaybe<Scalars['String']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  passportsUsingId?: InputMaybe<FkPassportTravellerTravellerIdInverseInput>;
  phone?: InputMaybe<Scalars['String']['input']>;
  tripTravellersUsingId?: InputMaybe<FkTripTravellerTravellerTravellerIdInverseInput>;
  weight?: InputMaybe<Scalars['Int']['input']>;
};

/** The fields on `traveller` to look up the row to connect. */
export type TravellerPkTravellerConnect = {
  id: Scalars['UUID']['input'];
};

/** The fields on `traveller` to look up the row to delete. */
export type TravellerPkTravellerDelete = {
  id: Scalars['UUID']['input'];
};

/** A filter to be used against many `CustomerTraveller` object types. All fields are combined with a logical ‘and.’ */
export type TravellerToManyCustomerTravellerFilter = {
  /** Every related `CustomerTraveller` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<CustomerTravellerFilter>;
  /** No related `CustomerTraveller` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<CustomerTravellerFilter>;
  /** Some related `CustomerTraveller` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<CustomerTravellerFilter>;
};

/** A filter to be used against many `Passport` object types. All fields are combined with a logical ‘and.’ */
export type TravellerToManyPassportFilter = {
  /** Every related `Passport` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<PassportFilter>;
  /** No related `Passport` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<PassportFilter>;
  /** Some related `Passport` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<PassportFilter>;
};

/** A filter to be used against many `TripTraveller` object types. All fields are combined with a logical ‘and.’ */
export type TravellerToManyTripTravellerFilter = {
  /** Every related `TripTraveller` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<TripTravellerFilter>;
  /** No related `TripTraveller` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<TripTravellerFilter>;
  /** Some related `TripTraveller` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<TripTravellerFilter>;
};

/** A connection to a list of `Traveller` values. */
export type TravellersConnection = {
  __typename?: 'TravellersConnection';
  /** A list of edges which contains the `Traveller` and cursor to aid in pagination. */
  edges: Array<TravellersEdge>;
  /** A list of `Traveller` objects. */
  nodes: Array<Maybe<Traveller>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Traveller` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Traveller` edge in the connection. */
export type TravellersEdge = {
  __typename?: 'TravellersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Traveller` at the end of the edge. */
  node?: Maybe<Traveller>;
};

/** Methods to use when ordering `Traveller`. */
export enum TravellersOrderBy {
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  CustomerTravellersByTravellerIdCountAsc = 'CUSTOMER_TRAVELLERS_BY_TRAVELLER_ID__COUNT_ASC',
  CustomerTravellersByTravellerIdCountDesc = 'CUSTOMER_TRAVELLERS_BY_TRAVELLER_ID__COUNT_DESC',
  DateOfBirthAsc = 'DATE_OF_BIRTH_ASC',
  DateOfBirthDesc = 'DATE_OF_BIRTH_DESC',
  DietaryRequirementsAsc = 'DIETARY_REQUIREMENTS_ASC',
  DietaryRequirementsDesc = 'DIETARY_REQUIREMENTS_DESC',
  EmailAsc = 'EMAIL_ASC',
  EmailDesc = 'EMAIL_DESC',
  EmergencyContactAsc = 'EMERGENCY_CONTACT_ASC',
  EmergencyContactDesc = 'EMERGENCY_CONTACT_DESC',
  FirstNameAsc = 'FIRST_NAME_ASC',
  FirstNameDesc = 'FIRST_NAME_DESC',
  HeightAsc = 'HEIGHT_ASC',
  HeightDesc = 'HEIGHT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  InsuranceDetailsAsc = 'INSURANCE_DETAILS_ASC',
  InsuranceDetailsDesc = 'INSURANCE_DETAILS_DESC',
  LastNameAsc = 'LAST_NAME_ASC',
  LastNameDesc = 'LAST_NAME_DESC',
  MedicalConditionsAsc = 'MEDICAL_CONDITIONS_ASC',
  MedicalConditionsDesc = 'MEDICAL_CONDITIONS_DESC',
  MiddleNameAsc = 'MIDDLE_NAME_ASC',
  MiddleNameDesc = 'MIDDLE_NAME_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  NationalityAsc = 'NATIONALITY_ASC',
  NationalityDesc = 'NATIONALITY_DESC',
  Natural = 'NATURAL',
  NotesAsc = 'NOTES_ASC',
  NotesDesc = 'NOTES_DESC',
  PassportsByTravellerIdCountAsc = 'PASSPORTS_BY_TRAVELLER_ID__COUNT_ASC',
  PassportsByTravellerIdCountDesc = 'PASSPORTS_BY_TRAVELLER_ID__COUNT_DESC',
  PhoneAsc = 'PHONE_ASC',
  PhoneDesc = 'PHONE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TripTravellersByTravellerIdCountAsc = 'TRIP_TRAVELLERS_BY_TRAVELLER_ID__COUNT_ASC',
  TripTravellersByTravellerIdCountDesc = 'TRIP_TRAVELLERS_BY_TRAVELLER_ID__COUNT_DESC',
  WeightAsc = 'WEIGHT_ASC',
  WeightDesc = 'WEIGHT_DESC'
}

export type Trip = {
  __typename?: 'Trip';
  /** Reads a single `Quote` that is related to this `Trip`. */
  activeQuote?: Maybe<Quote>;
  activeQuoteId?: Maybe<Scalars['UUID']['output']>;
  /** Reads a single `Agency` that is related to this `Trip`. */
  agency?: Maybe<Agency>;
  agencyId?: Maybe<Scalars['UUID']['output']>;
  /** Reads a single `AgencyMember` that is related to this `Trip`. */
  agencyMember?: Maybe<AgencyMember>;
  agencyMemberId?: Maybe<Scalars['UUID']['output']>;
  archived?: Maybe<Scalars['Datetime']['output']>;
  baseCurrency?: Maybe<Scalars['String']['output']>;
  created: Scalars['Datetime']['output'];
  /** Reads a single `Customer` that is related to this `Trip`. */
  customer?: Maybe<Customer>;
  customerId: Scalars['UUID']['output'];
  dates?: Maybe<Scalars['String']['output']>;
  destination?: Maybe<Scalars['String']['output']>;
  duration?: Maybe<Scalars['Int']['output']>;
  /** Reads and enables pagination through a set of `Email`. */
  emails: EmailsConnection;
  /** Reads and enables pagination through a set of `Enquiry`. */
  enquiries: EnquiriesConnection;
  /** Reads and enables pagination through a set of `Expense`. */
  expenses: ExpensesConnection;
  id: Scalars['UUID']['output'];
  /** Reads and enables pagination through a set of `Invoice`. */
  invoices: InvoicesConnection;
  /** Reads a single `MediaGallery` that is related to this `Trip`. */
  mediaGallery?: Maybe<MediaGallery>;
  mediaGalleryId?: Maybe<Scalars['UUID']['output']>;
  modified: Scalars['Datetime']['output'];
  name?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `Note`. */
  notes: NotesConnection;
  /** Reads and enables pagination through a set of `Payment`. */
  payments: PaymentsConnection;
  /** Reads and enables pagination through a set of `QuotePublic`. */
  quotePublics: QuotePublicsConnection;
  /** Reads and enables pagination through a set of `Quote`. */
  quotes: QuotesConnection;
  start?: Maybe<Scalars['Datetime']['output']>;
  status: Scalars['Int']['output'];
  summary?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `SupplierInvoice`. */
  supplierInvoices: SupplierInvoicesConnection;
  /** Reads and enables pagination through a set of `Testimonial`. */
  testimonials: TestimonialsConnection;
  /** Reads and enables pagination through a set of `TripFlight`. */
  tripFlights: TripFlightsConnection;
  /** Reads and enables pagination through a set of `TripTraveller`. */
  tripTravellers: TripTravellersConnection;
  /** Reads a single `User` that is related to this `Trip`. */
  user?: Maybe<User>;
  userId?: Maybe<Scalars['UUID']['output']>;
};


export type TripEmailsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EmailCondition>;
  filter?: InputMaybe<EmailFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EmailsOrderBy>>;
};


export type TripEnquiriesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EnquiryCondition>;
  filter?: InputMaybe<EnquiryFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EnquiriesOrderBy>>;
};


export type TripExpensesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ExpenseCondition>;
  filter?: InputMaybe<ExpenseFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ExpensesOrderBy>>;
};


export type TripInvoicesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<InvoiceCondition>;
  filter?: InputMaybe<InvoiceFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<InvoicesOrderBy>>;
};


export type TripNotesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<NoteCondition>;
  filter?: InputMaybe<NoteFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<NotesOrderBy>>;
};


export type TripPaymentsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PaymentCondition>;
  filter?: InputMaybe<PaymentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PaymentsOrderBy>>;
};


export type TripQuotePublicsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<QuotePublicCondition>;
  filter?: InputMaybe<QuotePublicFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuotePublicsOrderBy>>;
};


export type TripQuotesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<QuoteCondition>;
  filter?: InputMaybe<QuoteFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuotesOrderBy>>;
};


export type TripSupplierInvoicesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SupplierInvoiceCondition>;
  filter?: InputMaybe<SupplierInvoiceFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SupplierInvoicesOrderBy>>;
};


export type TripTestimonialsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TestimonialCondition>;
  filter?: InputMaybe<TestimonialFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TestimonialsOrderBy>>;
};


export type TripTripFlightsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TripFlightCondition>;
  filter?: InputMaybe<TripFlightFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TripFlightsOrderBy>>;
};


export type TripTripTravellersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TripTravellerCondition>;
  filter?: InputMaybe<TripTravellerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TripTravellersOrderBy>>;
};

/** A condition to be used against `Trip` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type TripCondition = {
  /** Checks for equality with the object’s `activeQuoteId` field. */
  activeQuoteId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `agencyId` field. */
  agencyId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `agencyMemberId` field. */
  agencyMemberId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `archived` field. */
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `baseCurrency` field. */
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `customerId` field. */
  customerId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `dates` field. */
  dates?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `destination` field. */
  destination?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `duration` field. */
  duration?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `mediaGalleryId` field. */
  mediaGalleryId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `start` field. */
  start?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `summary` field. */
  summary?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['UUID']['input']>;
};

/** A filter to be used against `Trip` object types. All fields are combined with a logical ‘and.’ */
export type TripFilter = {
  /** Filter by the object’s `activeQuote` relation. */
  activeQuote?: InputMaybe<QuoteFilter>;
  /** A related `activeQuote` exists. */
  activeQuoteExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `activeQuoteId` field. */
  activeQuoteId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `agency` relation. */
  agency?: InputMaybe<AgencyFilter>;
  /** A related `agency` exists. */
  agencyExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `agencyId` field. */
  agencyId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `agencyMember` relation. */
  agencyMember?: InputMaybe<AgencyMemberFilter>;
  /** A related `agencyMember` exists. */
  agencyMemberExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `agencyMemberId` field. */
  agencyMemberId?: InputMaybe<UuidFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<TripFilter>>;
  /** Filter by the object’s `archived` field. */
  archived?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `baseCurrency` field. */
  baseCurrency?: InputMaybe<StringFilter>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `customer` relation. */
  customer?: InputMaybe<CustomerFilter>;
  /** Filter by the object’s `customerId` field. */
  customerId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `dates` field. */
  dates?: InputMaybe<StringFilter>;
  /** Filter by the object’s `destination` field. */
  destination?: InputMaybe<StringFilter>;
  /** Filter by the object’s `duration` field. */
  duration?: InputMaybe<IntFilter>;
  /** Filter by the object’s `emails` relation. */
  emails?: InputMaybe<TripToManyEmailFilter>;
  /** Some related `emails` exist. */
  emailsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `enquiries` relation. */
  enquiries?: InputMaybe<TripToManyEnquiryFilter>;
  /** Some related `enquiries` exist. */
  enquiriesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `expenses` relation. */
  expenses?: InputMaybe<TripToManyExpenseFilter>;
  /** Some related `expenses` exist. */
  expensesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `invoices` relation. */
  invoices?: InputMaybe<TripToManyInvoiceFilter>;
  /** Some related `invoices` exist. */
  invoicesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `mediaGallery` relation. */
  mediaGallery?: InputMaybe<MediaGalleryFilter>;
  /** A related `mediaGallery` exists. */
  mediaGalleryExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `mediaGalleryId` field. */
  mediaGalleryId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<TripFilter>;
  /** Filter by the object’s `notes` relation. */
  notes?: InputMaybe<TripToManyNoteFilter>;
  /** Some related `notes` exist. */
  notesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<TripFilter>>;
  /** Filter by the object’s `payments` relation. */
  payments?: InputMaybe<TripToManyPaymentFilter>;
  /** Some related `payments` exist. */
  paymentsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `quotePublics` relation. */
  quotePublics?: InputMaybe<TripToManyQuotePublicFilter>;
  /** Some related `quotePublics` exist. */
  quotePublicsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `quotes` relation. */
  quotes?: InputMaybe<TripToManyQuoteFilter>;
  /** Some related `quotes` exist. */
  quotesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `start` field. */
  start?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `status` field. */
  status?: InputMaybe<IntFilter>;
  /** Filter by the object’s `summary` field. */
  summary?: InputMaybe<StringFilter>;
  /** Filter by the object’s `supplierInvoices` relation. */
  supplierInvoices?: InputMaybe<TripToManySupplierInvoiceFilter>;
  /** Some related `supplierInvoices` exist. */
  supplierInvoicesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `testimonials` relation. */
  testimonials?: InputMaybe<TripToManyTestimonialFilter>;
  /** Some related `testimonials` exist. */
  testimonialsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `tripFlights` relation. */
  tripFlights?: InputMaybe<TripToManyTripFlightFilter>;
  /** Some related `tripFlights` exist. */
  tripFlightsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `tripTravellers` relation. */
  tripTravellers?: InputMaybe<TripToManyTripTravellerFilter>;
  /** Some related `tripTravellers` exist. */
  tripTravellersExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `user` relation. */
  user?: InputMaybe<UserFilter>;
  /** A related `user` exists. */
  userExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<UuidFilter>;
};

export type TripFlight = {
  __typename?: 'TripFlight';
  arrival: Scalars['Datetime']['output'];
  /** Reads a single `Airport` that is related to this `TripFlight`. */
  arrivalAirport?: Maybe<Airport>;
  arrivalAirportId?: Maybe<Scalars['UUID']['output']>;
  carrier?: Maybe<Scalars['String']['output']>;
  departure: Scalars['Datetime']['output'];
  /** Reads a single `Airport` that is related to this `TripFlight`. */
  departureAirport?: Maybe<Airport>;
  departureAirportId?: Maybe<Scalars['UUID']['output']>;
  id: Scalars['UUID']['output'];
  notes?: Maybe<Scalars['String']['output']>;
  number?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Trip` that is related to this `TripFlight`. */
  trip?: Maybe<Trip>;
  tripId: Scalars['UUID']['output'];
};

/** The `airport` to be created by this mutation. */
export type TripFlightArrivalAirport2IdFkeyAirportCreateInput = {
  city?: InputMaybe<Scalars['String']['input']>;
  countryId?: InputMaybe<Scalars['UUID']['input']>;
  countryToCountryId?: InputMaybe<FkAirportCountryCountryIdInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  displayName?: InputMaybe<Scalars['String']['input']>;
  iata?: InputMaybe<Scalars['String']['input']>;
  icao?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  latitude: Scalars['Float']['input'];
  longitude: Scalars['Float']['input'];
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  timezone?: InputMaybe<Scalars['String']['input']>;
  tripFlightsToArrivalAirportIdUsingId?: InputMaybe<TripFlightArrivalAirport2IdFkeyInverseInput>;
  tripFlightsToDepartureAirportIdUsingId?: InputMaybe<TripFlightDepartureAirport2IdFkeyInverseInput>;
};

/** Input for the nested mutation of `airport` in the `TripFlightInput` mutation. */
export type TripFlightArrivalAirport2IdFkeyInput = {
  /** The primary key(s) for `airport` for the far side of the relationship. */
  connectById?: InputMaybe<AirportPkAirportConnect>;
  /** A `AirportInput` object that will be created and connected to this object. */
  create?: InputMaybe<TripFlightArrivalAirport2IdFkeyAirportCreateInput>;
  /** The primary key(s) for `airport` for the far side of the relationship. */
  deleteById?: InputMaybe<AirportPkAirportDelete>;
  /** The primary key(s) and patch data for `airport` for the far side of the relationship. */
  updateById?: InputMaybe<AirportOnTripFlightForTripFlightArrivalAirport2IdFkeyUsingPkAirportUpdate>;
};

/** Input for the nested mutation of `tripFlight` in the `AirportInput` mutation. */
export type TripFlightArrivalAirport2IdFkeyInverseInput = {
  /** The primary key(s) for `tripFlight` for the far side of the relationship. */
  connectById?: InputMaybe<Array<TripFlightPkTripFlightConnect>>;
  /** A `TripFlightInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<TripFlightArrivalAirport2IdFkeyTripFlightCreateInput>>;
  /** The primary key(s) for `tripFlight` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<TripFlightPkTripFlightDelete>>;
  /** Flag indicating whether all other `tripFlight` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `tripFlight` for the far side of the relationship. */
  updateById?: InputMaybe<Array<TripFlightOnTripFlightForTripFlightArrivalAirport2IdFkeyUsingPkTripFlightUpdate>>;
};

/** The `tripFlight` to be created by this mutation. */
export type TripFlightArrivalAirport2IdFkeyTripFlightCreateInput = {
  airportToArrivalAirportId?: InputMaybe<TripFlightArrivalAirport2IdFkeyInput>;
  airportToDepartureAirportId?: InputMaybe<TripFlightDepartureAirport2IdFkeyInput>;
  arrival: Scalars['Datetime']['input'];
  carrier?: InputMaybe<Scalars['String']['input']>;
  departure: Scalars['Datetime']['input'];
  departureAirportId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  number?: InputMaybe<Scalars['String']['input']>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkTripFlightTripTripIdInput>;
};

/**
 * A condition to be used against `TripFlight` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type TripFlightCondition = {
  /** Checks for equality with the object’s `arrival` field. */
  arrival?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `arrivalAirportId` field. */
  arrivalAirportId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `carrier` field. */
  carrier?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `departure` field. */
  departure?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `departureAirportId` field. */
  departureAirportId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `number` field. */
  number?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `tripId` field. */
  tripId?: InputMaybe<Scalars['UUID']['input']>;
};

/** The `airport` to be created by this mutation. */
export type TripFlightDepartureAirport2IdFkeyAirportCreateInput = {
  city?: InputMaybe<Scalars['String']['input']>;
  countryId?: InputMaybe<Scalars['UUID']['input']>;
  countryToCountryId?: InputMaybe<FkAirportCountryCountryIdInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  displayName?: InputMaybe<Scalars['String']['input']>;
  iata?: InputMaybe<Scalars['String']['input']>;
  icao?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  latitude: Scalars['Float']['input'];
  longitude: Scalars['Float']['input'];
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  timezone?: InputMaybe<Scalars['String']['input']>;
  tripFlightsToArrivalAirportIdUsingId?: InputMaybe<TripFlightArrivalAirport2IdFkeyInverseInput>;
  tripFlightsToDepartureAirportIdUsingId?: InputMaybe<TripFlightDepartureAirport2IdFkeyInverseInput>;
};

/** Input for the nested mutation of `airport` in the `TripFlightInput` mutation. */
export type TripFlightDepartureAirport2IdFkeyInput = {
  /** The primary key(s) for `airport` for the far side of the relationship. */
  connectById?: InputMaybe<AirportPkAirportConnect>;
  /** A `AirportInput` object that will be created and connected to this object. */
  create?: InputMaybe<TripFlightDepartureAirport2IdFkeyAirportCreateInput>;
  /** The primary key(s) for `airport` for the far side of the relationship. */
  deleteById?: InputMaybe<AirportPkAirportDelete>;
  /** The primary key(s) and patch data for `airport` for the far side of the relationship. */
  updateById?: InputMaybe<AirportOnTripFlightForTripFlightDepartureAirport2IdFkeyUsingPkAirportUpdate>;
};

/** Input for the nested mutation of `tripFlight` in the `AirportInput` mutation. */
export type TripFlightDepartureAirport2IdFkeyInverseInput = {
  /** The primary key(s) for `tripFlight` for the far side of the relationship. */
  connectById?: InputMaybe<Array<TripFlightPkTripFlightConnect>>;
  /** A `TripFlightInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<TripFlightDepartureAirport2IdFkeyTripFlightCreateInput>>;
  /** The primary key(s) for `tripFlight` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<TripFlightPkTripFlightDelete>>;
  /** Flag indicating whether all other `tripFlight` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `tripFlight` for the far side of the relationship. */
  updateById?: InputMaybe<Array<TripFlightOnTripFlightForTripFlightDepartureAirport2IdFkeyUsingPkTripFlightUpdate>>;
};

/** The `tripFlight` to be created by this mutation. */
export type TripFlightDepartureAirport2IdFkeyTripFlightCreateInput = {
  airportToArrivalAirportId?: InputMaybe<TripFlightArrivalAirport2IdFkeyInput>;
  airportToDepartureAirportId?: InputMaybe<TripFlightDepartureAirport2IdFkeyInput>;
  arrival: Scalars['Datetime']['input'];
  arrivalAirportId?: InputMaybe<Scalars['UUID']['input']>;
  carrier?: InputMaybe<Scalars['String']['input']>;
  departure: Scalars['Datetime']['input'];
  id?: InputMaybe<Scalars['UUID']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  number?: InputMaybe<Scalars['String']['input']>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkTripFlightTripTripIdInput>;
};

/** A filter to be used against `TripFlight` object types. All fields are combined with a logical ‘and.’ */
export type TripFlightFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<TripFlightFilter>>;
  /** Filter by the object’s `arrival` field. */
  arrival?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `arrivalAirport` relation. */
  arrivalAirport?: InputMaybe<AirportFilter>;
  /** A related `arrivalAirport` exists. */
  arrivalAirportExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `arrivalAirportId` field. */
  arrivalAirportId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `carrier` field. */
  carrier?: InputMaybe<StringFilter>;
  /** Filter by the object’s `departure` field. */
  departure?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `departureAirport` relation. */
  departureAirport?: InputMaybe<AirportFilter>;
  /** A related `departureAirport` exists. */
  departureAirportExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `departureAirportId` field. */
  departureAirportId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Negates the expression. */
  not?: InputMaybe<TripFlightFilter>;
  /** Filter by the object’s `notes` field. */
  notes?: InputMaybe<StringFilter>;
  /** Filter by the object’s `number` field. */
  number?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<TripFlightFilter>>;
  /** Filter by the object’s `trip` relation. */
  trip?: InputMaybe<TripFilter>;
  /** Filter by the object’s `tripId` field. */
  tripId?: InputMaybe<UuidFilter>;
};

/** An input for mutations affecting `TripFlight` */
export type TripFlightInput = {
  airportToArrivalAirportId?: InputMaybe<TripFlightArrivalAirport2IdFkeyInput>;
  airportToDepartureAirportId?: InputMaybe<TripFlightDepartureAirport2IdFkeyInput>;
  arrival: Scalars['Datetime']['input'];
  arrivalAirportId?: InputMaybe<Scalars['UUID']['input']>;
  carrier?: InputMaybe<Scalars['String']['input']>;
  departure: Scalars['Datetime']['input'];
  departureAirportId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  number?: InputMaybe<Scalars['String']['input']>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkTripFlightTripTripIdInput>;
};

/** The fields on `tripFlight` to look up the row to update. */
export type TripFlightOnTripFlightForFkTripFlightTripTripIdUsingPkTripFlightUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `tripFlight` being updated. */
  patch: UpdateTripFlightOnTripFlightForFkTripFlightTripTripIdPatch;
};

/** The fields on `tripFlight` to look up the row to update. */
export type TripFlightOnTripFlightForTripFlightArrivalAirport2IdFkeyUsingPkTripFlightUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `tripFlight` being updated. */
  patch: UpdateTripFlightOnTripFlightForTripFlightArrivalAirport2IdFkeyPatch;
};

/** The fields on `tripFlight` to look up the row to update. */
export type TripFlightOnTripFlightForTripFlightDepartureAirport2IdFkeyUsingPkTripFlightUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `tripFlight` being updated. */
  patch: UpdateTripFlightOnTripFlightForTripFlightDepartureAirport2IdFkeyPatch;
};

/** Represents an update to a `TripFlight`. Fields that are set will be updated. */
export type TripFlightPatch = {
  airportToArrivalAirportId?: InputMaybe<TripFlightArrivalAirport2IdFkeyInput>;
  airportToDepartureAirportId?: InputMaybe<TripFlightDepartureAirport2IdFkeyInput>;
  arrival?: InputMaybe<Scalars['Datetime']['input']>;
  arrivalAirportId?: InputMaybe<Scalars['UUID']['input']>;
  carrier?: InputMaybe<Scalars['String']['input']>;
  departure?: InputMaybe<Scalars['Datetime']['input']>;
  departureAirportId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  number?: InputMaybe<Scalars['String']['input']>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkTripFlightTripTripIdInput>;
};

/** The fields on `tripFlight` to look up the row to connect. */
export type TripFlightPkTripFlightConnect = {
  id: Scalars['UUID']['input'];
};

/** The fields on `tripFlight` to look up the row to delete. */
export type TripFlightPkTripFlightDelete = {
  id: Scalars['UUID']['input'];
};

/** A connection to a list of `TripFlight` values. */
export type TripFlightsConnection = {
  __typename?: 'TripFlightsConnection';
  /** A list of edges which contains the `TripFlight` and cursor to aid in pagination. */
  edges: Array<TripFlightsEdge>;
  /** A list of `TripFlight` objects. */
  nodes: Array<Maybe<TripFlight>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TripFlight` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `TripFlight` edge in the connection. */
export type TripFlightsEdge = {
  __typename?: 'TripFlightsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `TripFlight` at the end of the edge. */
  node?: Maybe<TripFlight>;
};

/** Methods to use when ordering `TripFlight`. */
export enum TripFlightsOrderBy {
  AirportByArrivalAirportIdCityAsc = 'AIRPORT_BY_ARRIVAL_AIRPORT_ID__CITY_ASC',
  AirportByArrivalAirportIdCityDesc = 'AIRPORT_BY_ARRIVAL_AIRPORT_ID__CITY_DESC',
  AirportByArrivalAirportIdCountryIdAsc = 'AIRPORT_BY_ARRIVAL_AIRPORT_ID__COUNTRY_ID_ASC',
  AirportByArrivalAirportIdCountryIdDesc = 'AIRPORT_BY_ARRIVAL_AIRPORT_ID__COUNTRY_ID_DESC',
  AirportByArrivalAirportIdCreatedAsc = 'AIRPORT_BY_ARRIVAL_AIRPORT_ID__CREATED_ASC',
  AirportByArrivalAirportIdCreatedDesc = 'AIRPORT_BY_ARRIVAL_AIRPORT_ID__CREATED_DESC',
  AirportByArrivalAirportIdDisplayNameAsc = 'AIRPORT_BY_ARRIVAL_AIRPORT_ID__DISPLAY_NAME_ASC',
  AirportByArrivalAirportIdDisplayNameDesc = 'AIRPORT_BY_ARRIVAL_AIRPORT_ID__DISPLAY_NAME_DESC',
  AirportByArrivalAirportIdIataAsc = 'AIRPORT_BY_ARRIVAL_AIRPORT_ID__IATA_ASC',
  AirportByArrivalAirportIdIataDesc = 'AIRPORT_BY_ARRIVAL_AIRPORT_ID__IATA_DESC',
  AirportByArrivalAirportIdIcaoAsc = 'AIRPORT_BY_ARRIVAL_AIRPORT_ID__ICAO_ASC',
  AirportByArrivalAirportIdIcaoDesc = 'AIRPORT_BY_ARRIVAL_AIRPORT_ID__ICAO_DESC',
  AirportByArrivalAirportIdIdAsc = 'AIRPORT_BY_ARRIVAL_AIRPORT_ID__ID_ASC',
  AirportByArrivalAirportIdIdDesc = 'AIRPORT_BY_ARRIVAL_AIRPORT_ID__ID_DESC',
  AirportByArrivalAirportIdLatitudeAsc = 'AIRPORT_BY_ARRIVAL_AIRPORT_ID__LATITUDE_ASC',
  AirportByArrivalAirportIdLatitudeDesc = 'AIRPORT_BY_ARRIVAL_AIRPORT_ID__LATITUDE_DESC',
  AirportByArrivalAirportIdLongitudeAsc = 'AIRPORT_BY_ARRIVAL_AIRPORT_ID__LONGITUDE_ASC',
  AirportByArrivalAirportIdLongitudeDesc = 'AIRPORT_BY_ARRIVAL_AIRPORT_ID__LONGITUDE_DESC',
  AirportByArrivalAirportIdModifiedAsc = 'AIRPORT_BY_ARRIVAL_AIRPORT_ID__MODIFIED_ASC',
  AirportByArrivalAirportIdModifiedDesc = 'AIRPORT_BY_ARRIVAL_AIRPORT_ID__MODIFIED_DESC',
  AirportByArrivalAirportIdNameAsc = 'AIRPORT_BY_ARRIVAL_AIRPORT_ID__NAME_ASC',
  AirportByArrivalAirportIdNameDesc = 'AIRPORT_BY_ARRIVAL_AIRPORT_ID__NAME_DESC',
  AirportByArrivalAirportIdTimezoneAsc = 'AIRPORT_BY_ARRIVAL_AIRPORT_ID__TIMEZONE_ASC',
  AirportByArrivalAirportIdTimezoneDesc = 'AIRPORT_BY_ARRIVAL_AIRPORT_ID__TIMEZONE_DESC',
  AirportByDepartureAirportIdCityAsc = 'AIRPORT_BY_DEPARTURE_AIRPORT_ID__CITY_ASC',
  AirportByDepartureAirportIdCityDesc = 'AIRPORT_BY_DEPARTURE_AIRPORT_ID__CITY_DESC',
  AirportByDepartureAirportIdCountryIdAsc = 'AIRPORT_BY_DEPARTURE_AIRPORT_ID__COUNTRY_ID_ASC',
  AirportByDepartureAirportIdCountryIdDesc = 'AIRPORT_BY_DEPARTURE_AIRPORT_ID__COUNTRY_ID_DESC',
  AirportByDepartureAirportIdCreatedAsc = 'AIRPORT_BY_DEPARTURE_AIRPORT_ID__CREATED_ASC',
  AirportByDepartureAirportIdCreatedDesc = 'AIRPORT_BY_DEPARTURE_AIRPORT_ID__CREATED_DESC',
  AirportByDepartureAirportIdDisplayNameAsc = 'AIRPORT_BY_DEPARTURE_AIRPORT_ID__DISPLAY_NAME_ASC',
  AirportByDepartureAirportIdDisplayNameDesc = 'AIRPORT_BY_DEPARTURE_AIRPORT_ID__DISPLAY_NAME_DESC',
  AirportByDepartureAirportIdIataAsc = 'AIRPORT_BY_DEPARTURE_AIRPORT_ID__IATA_ASC',
  AirportByDepartureAirportIdIataDesc = 'AIRPORT_BY_DEPARTURE_AIRPORT_ID__IATA_DESC',
  AirportByDepartureAirportIdIcaoAsc = 'AIRPORT_BY_DEPARTURE_AIRPORT_ID__ICAO_ASC',
  AirportByDepartureAirportIdIcaoDesc = 'AIRPORT_BY_DEPARTURE_AIRPORT_ID__ICAO_DESC',
  AirportByDepartureAirportIdIdAsc = 'AIRPORT_BY_DEPARTURE_AIRPORT_ID__ID_ASC',
  AirportByDepartureAirportIdIdDesc = 'AIRPORT_BY_DEPARTURE_AIRPORT_ID__ID_DESC',
  AirportByDepartureAirportIdLatitudeAsc = 'AIRPORT_BY_DEPARTURE_AIRPORT_ID__LATITUDE_ASC',
  AirportByDepartureAirportIdLatitudeDesc = 'AIRPORT_BY_DEPARTURE_AIRPORT_ID__LATITUDE_DESC',
  AirportByDepartureAirportIdLongitudeAsc = 'AIRPORT_BY_DEPARTURE_AIRPORT_ID__LONGITUDE_ASC',
  AirportByDepartureAirportIdLongitudeDesc = 'AIRPORT_BY_DEPARTURE_AIRPORT_ID__LONGITUDE_DESC',
  AirportByDepartureAirportIdModifiedAsc = 'AIRPORT_BY_DEPARTURE_AIRPORT_ID__MODIFIED_ASC',
  AirportByDepartureAirportIdModifiedDesc = 'AIRPORT_BY_DEPARTURE_AIRPORT_ID__MODIFIED_DESC',
  AirportByDepartureAirportIdNameAsc = 'AIRPORT_BY_DEPARTURE_AIRPORT_ID__NAME_ASC',
  AirportByDepartureAirportIdNameDesc = 'AIRPORT_BY_DEPARTURE_AIRPORT_ID__NAME_DESC',
  AirportByDepartureAirportIdTimezoneAsc = 'AIRPORT_BY_DEPARTURE_AIRPORT_ID__TIMEZONE_ASC',
  AirportByDepartureAirportIdTimezoneDesc = 'AIRPORT_BY_DEPARTURE_AIRPORT_ID__TIMEZONE_DESC',
  ArrivalAirportIdAsc = 'ARRIVAL_AIRPORT_ID_ASC',
  ArrivalAirportIdDesc = 'ARRIVAL_AIRPORT_ID_DESC',
  ArrivalAsc = 'ARRIVAL_ASC',
  ArrivalDesc = 'ARRIVAL_DESC',
  CarrierAsc = 'CARRIER_ASC',
  CarrierDesc = 'CARRIER_DESC',
  DepartureAirportIdAsc = 'DEPARTURE_AIRPORT_ID_ASC',
  DepartureAirportIdDesc = 'DEPARTURE_AIRPORT_ID_DESC',
  DepartureAsc = 'DEPARTURE_ASC',
  DepartureDesc = 'DEPARTURE_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  NotesAsc = 'NOTES_ASC',
  NotesDesc = 'NOTES_DESC',
  NumberAsc = 'NUMBER_ASC',
  NumberDesc = 'NUMBER_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TripByTripIdActiveQuoteIdAsc = 'TRIP_BY_TRIP_ID__ACTIVE_QUOTE_ID_ASC',
  TripByTripIdActiveQuoteIdDesc = 'TRIP_BY_TRIP_ID__ACTIVE_QUOTE_ID_DESC',
  TripByTripIdAgencyIdAsc = 'TRIP_BY_TRIP_ID__AGENCY_ID_ASC',
  TripByTripIdAgencyIdDesc = 'TRIP_BY_TRIP_ID__AGENCY_ID_DESC',
  TripByTripIdAgencyMemberIdAsc = 'TRIP_BY_TRIP_ID__AGENCY_MEMBER_ID_ASC',
  TripByTripIdAgencyMemberIdDesc = 'TRIP_BY_TRIP_ID__AGENCY_MEMBER_ID_DESC',
  TripByTripIdArchivedAsc = 'TRIP_BY_TRIP_ID__ARCHIVED_ASC',
  TripByTripIdArchivedDesc = 'TRIP_BY_TRIP_ID__ARCHIVED_DESC',
  TripByTripIdBaseCurrencyAsc = 'TRIP_BY_TRIP_ID__BASE_CURRENCY_ASC',
  TripByTripIdBaseCurrencyDesc = 'TRIP_BY_TRIP_ID__BASE_CURRENCY_DESC',
  TripByTripIdCreatedAsc = 'TRIP_BY_TRIP_ID__CREATED_ASC',
  TripByTripIdCreatedDesc = 'TRIP_BY_TRIP_ID__CREATED_DESC',
  TripByTripIdCustomerIdAsc = 'TRIP_BY_TRIP_ID__CUSTOMER_ID_ASC',
  TripByTripIdCustomerIdDesc = 'TRIP_BY_TRIP_ID__CUSTOMER_ID_DESC',
  TripByTripIdDatesAsc = 'TRIP_BY_TRIP_ID__DATES_ASC',
  TripByTripIdDatesDesc = 'TRIP_BY_TRIP_ID__DATES_DESC',
  TripByTripIdDestinationAsc = 'TRIP_BY_TRIP_ID__DESTINATION_ASC',
  TripByTripIdDestinationDesc = 'TRIP_BY_TRIP_ID__DESTINATION_DESC',
  TripByTripIdDurationAsc = 'TRIP_BY_TRIP_ID__DURATION_ASC',
  TripByTripIdDurationDesc = 'TRIP_BY_TRIP_ID__DURATION_DESC',
  TripByTripIdIdAsc = 'TRIP_BY_TRIP_ID__ID_ASC',
  TripByTripIdIdDesc = 'TRIP_BY_TRIP_ID__ID_DESC',
  TripByTripIdMediaGalleryIdAsc = 'TRIP_BY_TRIP_ID__MEDIA_GALLERY_ID_ASC',
  TripByTripIdMediaGalleryIdDesc = 'TRIP_BY_TRIP_ID__MEDIA_GALLERY_ID_DESC',
  TripByTripIdModifiedAsc = 'TRIP_BY_TRIP_ID__MODIFIED_ASC',
  TripByTripIdModifiedDesc = 'TRIP_BY_TRIP_ID__MODIFIED_DESC',
  TripByTripIdNameAsc = 'TRIP_BY_TRIP_ID__NAME_ASC',
  TripByTripIdNameDesc = 'TRIP_BY_TRIP_ID__NAME_DESC',
  TripByTripIdStartAsc = 'TRIP_BY_TRIP_ID__START_ASC',
  TripByTripIdStartDesc = 'TRIP_BY_TRIP_ID__START_DESC',
  TripByTripIdStatusAsc = 'TRIP_BY_TRIP_ID__STATUS_ASC',
  TripByTripIdStatusDesc = 'TRIP_BY_TRIP_ID__STATUS_DESC',
  TripByTripIdSummaryAsc = 'TRIP_BY_TRIP_ID__SUMMARY_ASC',
  TripByTripIdSummaryDesc = 'TRIP_BY_TRIP_ID__SUMMARY_DESC',
  TripByTripIdUserIdAsc = 'TRIP_BY_TRIP_ID__USER_ID_ASC',
  TripByTripIdUserIdDesc = 'TRIP_BY_TRIP_ID__USER_ID_DESC',
  TripIdAsc = 'TRIP_ID_ASC',
  TripIdDesc = 'TRIP_ID_DESC'
}

/** An input for mutations affecting `Trip` */
export type TripInput = {
  activeQuoteId?: InputMaybe<Scalars['UUID']['input']>;
  agencyId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberToAgencyMemberId?: InputMaybe<FkTripAgencyMemberAgencyMemberIdInput>;
  agencyToAgencyId?: InputMaybe<FkTripAgencyAgencyIdInput>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerId?: InputMaybe<Scalars['UUID']['input']>;
  customerToCustomerId?: InputMaybe<FkTripCustomerCustomerIdInput>;
  dates?: InputMaybe<Scalars['String']['input']>;
  destination?: InputMaybe<Scalars['String']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  emailsUsingId?: InputMaybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: InputMaybe<FkEnquiryTripTripIdInverseInput>;
  expensesUsingId?: InputMaybe<FkExpenseTripTripIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceTripTripIdInverseInput>;
  mediaGalleryId?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryToMediaGalleryId?: InputMaybe<FkTripMediaGalleryMediaGalleryIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notesUsingId?: InputMaybe<FkNoteTripTripIdInverseInput>;
  paymentsUsingId?: InputMaybe<FkPaymentTripTripIdInverseInput>;
  quotePublicsUsingId?: InputMaybe<FakePublicQuotePublicForeignKey0InverseInput>;
  quoteToActiveQuoteId?: InputMaybe<FkTripQuoteActiveQuoteIdInput>;
  quotesUsingId?: InputMaybe<FkQuoteTripTripIdInverseInput>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceTripTripIdInverseInput>;
  testimonialsUsingId?: InputMaybe<FkTestimonialTripTripIdInverseInput>;
  tripFlightsUsingId?: InputMaybe<FkTripFlightTripTripIdInverseInput>;
  tripTravellersUsingId?: InputMaybe<FkTripTravellerTripTripIdInverseInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkTripUserUserIdInput>;
};

/** The fields on `trip` to look up the row to update. */
export type TripOnEmailForFkEmailTripTripIdUsingPkTripUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `trip` being updated. */
  patch: UpdateTripOnEmailForFkEmailTripTripIdPatch;
};

/** The fields on `trip` to look up the row to update. */
export type TripOnEnquiryForFkEnquiryTripTripIdUsingPkTripUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `trip` being updated. */
  patch: UpdateTripOnEnquiryForFkEnquiryTripTripIdPatch;
};

/** The fields on `trip` to look up the row to update. */
export type TripOnExpenseForFkExpenseTripTripIdUsingPkTripUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `trip` being updated. */
  patch: UpdateTripOnExpenseForFkExpenseTripTripIdPatch;
};

/** The fields on `trip` to look up the row to update. */
export type TripOnInvoiceForFkInvoiceTripTripIdUsingPkTripUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `trip` being updated. */
  patch: UpdateTripOnInvoiceForFkInvoiceTripTripIdPatch;
};

/** The fields on `trip` to look up the row to update. */
export type TripOnNoteForFkNoteTripTripIdUsingPkTripUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `trip` being updated. */
  patch: UpdateTripOnNoteForFkNoteTripTripIdPatch;
};

/** The fields on `trip` to look up the row to update. */
export type TripOnPaymentForFkPaymentTripTripIdUsingPkTripUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `trip` being updated. */
  patch: UpdateTripOnPaymentForFkPaymentTripTripIdPatch;
};

/** The fields on `trip` to look up the row to update. */
export type TripOnQuoteForFkQuoteTripTripIdUsingPkTripUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `trip` being updated. */
  patch: UpdateTripOnQuoteForFkQuoteTripTripIdPatch;
};

/** The fields on `trip` to look up the row to update. */
export type TripOnQuotePublicForFakePublicQuotePublicForeignKey0UsingPkTripUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `trip` being updated. */
  patch: UpdateTripOnQuotePublicForFakePublicQuotePublicForeignKey0Patch;
};

/** The fields on `trip` to look up the row to update. */
export type TripOnSupplierInvoiceForFkSupplierInvoiceTripTripIdUsingPkTripUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `trip` being updated. */
  patch: UpdateTripOnSupplierInvoiceForFkSupplierInvoiceTripTripIdPatch;
};

/** The fields on `trip` to look up the row to update. */
export type TripOnTestimonialForFkTestimonialTripTripIdUsingPkTripUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `trip` being updated. */
  patch: UpdateTripOnTestimonialForFkTestimonialTripTripIdPatch;
};

/** The fields on `trip` to look up the row to update. */
export type TripOnTripFlightForFkTripFlightTripTripIdUsingPkTripUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `trip` being updated. */
  patch: UpdateTripOnTripFlightForFkTripFlightTripTripIdPatch;
};

/** The fields on `trip` to look up the row to update. */
export type TripOnTripForFkTripAgencyAgencyIdUsingPkTripUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `trip` being updated. */
  patch: UpdateTripOnTripForFkTripAgencyAgencyIdPatch;
};

/** The fields on `trip` to look up the row to update. */
export type TripOnTripForFkTripAgencyMemberAgencyMemberIdUsingPkTripUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `trip` being updated. */
  patch: UpdateTripOnTripForFkTripAgencyMemberAgencyMemberIdPatch;
};

/** The fields on `trip` to look up the row to update. */
export type TripOnTripForFkTripCustomerCustomerIdUsingPkTripUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `trip` being updated. */
  patch: UpdateTripOnTripForFkTripCustomerCustomerIdPatch;
};

/** The fields on `trip` to look up the row to update. */
export type TripOnTripForFkTripMediaGalleryMediaGalleryIdUsingPkTripUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `trip` being updated. */
  patch: UpdateTripOnTripForFkTripMediaGalleryMediaGalleryIdPatch;
};

/** The fields on `trip` to look up the row to update. */
export type TripOnTripForFkTripQuoteActiveQuoteIdUsingPkTripUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `trip` being updated. */
  patch: UpdateTripOnTripForFkTripQuoteActiveQuoteIdPatch;
};

/** The fields on `trip` to look up the row to update. */
export type TripOnTripForFkTripUserUserIdUsingPkTripUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `trip` being updated. */
  patch: UpdateTripOnTripForFkTripUserUserIdPatch;
};

/** The fields on `trip` to look up the row to update. */
export type TripOnTripTravellerForFkTripTravellerTripTripIdUsingPkTripUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `trip` being updated. */
  patch: UpdateTripOnTripTravellerForFkTripTravellerTripTripIdPatch;
};

/** Represents an update to a `Trip`. Fields that are set will be updated. */
export type TripPatch = {
  activeQuoteId?: InputMaybe<Scalars['UUID']['input']>;
  agencyId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberToAgencyMemberId?: InputMaybe<FkTripAgencyMemberAgencyMemberIdInput>;
  agencyToAgencyId?: InputMaybe<FkTripAgencyAgencyIdInput>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerId?: InputMaybe<Scalars['UUID']['input']>;
  customerToCustomerId?: InputMaybe<FkTripCustomerCustomerIdInput>;
  dates?: InputMaybe<Scalars['String']['input']>;
  destination?: InputMaybe<Scalars['String']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  emailsUsingId?: InputMaybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: InputMaybe<FkEnquiryTripTripIdInverseInput>;
  expensesUsingId?: InputMaybe<FkExpenseTripTripIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceTripTripIdInverseInput>;
  mediaGalleryId?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryToMediaGalleryId?: InputMaybe<FkTripMediaGalleryMediaGalleryIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notesUsingId?: InputMaybe<FkNoteTripTripIdInverseInput>;
  paymentsUsingId?: InputMaybe<FkPaymentTripTripIdInverseInput>;
  quotePublicsUsingId?: InputMaybe<FakePublicQuotePublicForeignKey0InverseInput>;
  quoteToActiveQuoteId?: InputMaybe<FkTripQuoteActiveQuoteIdInput>;
  quotesUsingId?: InputMaybe<FkQuoteTripTripIdInverseInput>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceTripTripIdInverseInput>;
  testimonialsUsingId?: InputMaybe<FkTestimonialTripTripIdInverseInput>;
  tripFlightsUsingId?: InputMaybe<FkTripFlightTripTripIdInverseInput>;
  tripTravellersUsingId?: InputMaybe<FkTripTravellerTripTripIdInverseInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkTripUserUserIdInput>;
};

/** The fields on `trip` to look up the row to connect. */
export type TripPkTripConnect = {
  id: Scalars['UUID']['input'];
};

/** The fields on `trip` to look up the row to delete. */
export type TripPkTripDelete = {
  id: Scalars['UUID']['input'];
};

/** A filter to be used against many `Email` object types. All fields are combined with a logical ‘and.’ */
export type TripToManyEmailFilter = {
  /** Every related `Email` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<EmailFilter>;
  /** No related `Email` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<EmailFilter>;
  /** Some related `Email` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<EmailFilter>;
};

/** A filter to be used against many `Enquiry` object types. All fields are combined with a logical ‘and.’ */
export type TripToManyEnquiryFilter = {
  /** Every related `Enquiry` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<EnquiryFilter>;
  /** No related `Enquiry` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<EnquiryFilter>;
  /** Some related `Enquiry` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<EnquiryFilter>;
};

/** A filter to be used against many `Expense` object types. All fields are combined with a logical ‘and.’ */
export type TripToManyExpenseFilter = {
  /** Every related `Expense` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ExpenseFilter>;
  /** No related `Expense` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ExpenseFilter>;
  /** Some related `Expense` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ExpenseFilter>;
};

/** A filter to be used against many `Invoice` object types. All fields are combined with a logical ‘and.’ */
export type TripToManyInvoiceFilter = {
  /** Every related `Invoice` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<InvoiceFilter>;
  /** No related `Invoice` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<InvoiceFilter>;
  /** Some related `Invoice` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<InvoiceFilter>;
};

/** A filter to be used against many `Note` object types. All fields are combined with a logical ‘and.’ */
export type TripToManyNoteFilter = {
  /** Every related `Note` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<NoteFilter>;
  /** No related `Note` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<NoteFilter>;
  /** Some related `Note` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<NoteFilter>;
};

/** A filter to be used against many `Payment` object types. All fields are combined with a logical ‘and.’ */
export type TripToManyPaymentFilter = {
  /** Every related `Payment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<PaymentFilter>;
  /** No related `Payment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<PaymentFilter>;
  /** Some related `Payment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<PaymentFilter>;
};

/** A filter to be used against many `Quote` object types. All fields are combined with a logical ‘and.’ */
export type TripToManyQuoteFilter = {
  /** Every related `Quote` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<QuoteFilter>;
  /** No related `Quote` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<QuoteFilter>;
  /** Some related `Quote` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<QuoteFilter>;
};

/** A filter to be used against many `QuotePublic` object types. All fields are combined with a logical ‘and.’ */
export type TripToManyQuotePublicFilter = {
  /** Every related `QuotePublic` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<QuotePublicFilter>;
  /** No related `QuotePublic` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<QuotePublicFilter>;
  /** Some related `QuotePublic` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<QuotePublicFilter>;
};

/** A filter to be used against many `SupplierInvoice` object types. All fields are combined with a logical ‘and.’ */
export type TripToManySupplierInvoiceFilter = {
  /** Every related `SupplierInvoice` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<SupplierInvoiceFilter>;
  /** No related `SupplierInvoice` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<SupplierInvoiceFilter>;
  /** Some related `SupplierInvoice` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<SupplierInvoiceFilter>;
};

/** A filter to be used against many `Testimonial` object types. All fields are combined with a logical ‘and.’ */
export type TripToManyTestimonialFilter = {
  /** Every related `Testimonial` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<TestimonialFilter>;
  /** No related `Testimonial` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<TestimonialFilter>;
  /** Some related `Testimonial` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<TestimonialFilter>;
};

/** A filter to be used against many `TripFlight` object types. All fields are combined with a logical ‘and.’ */
export type TripToManyTripFlightFilter = {
  /** Every related `TripFlight` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<TripFlightFilter>;
  /** No related `TripFlight` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<TripFlightFilter>;
  /** Some related `TripFlight` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<TripFlightFilter>;
};

/** A filter to be used against many `TripTraveller` object types. All fields are combined with a logical ‘and.’ */
export type TripToManyTripTravellerFilter = {
  /** Every related `TripTraveller` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<TripTravellerFilter>;
  /** No related `TripTraveller` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<TripTravellerFilter>;
  /** Some related `TripTraveller` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<TripTravellerFilter>;
};

export type TripTraveller = {
  __typename?: 'TripTraveller';
  created: Scalars['Datetime']['output'];
  id: Scalars['UUID']['output'];
  modified: Scalars['Datetime']['output'];
  /** Reads a single `Traveller` that is related to this `TripTraveller`. */
  traveller?: Maybe<Traveller>;
  travellerId: Scalars['UUID']['output'];
  /** Reads a single `Trip` that is related to this `TripTraveller`. */
  trip?: Maybe<Trip>;
  tripId: Scalars['UUID']['output'];
};

/**
 * A condition to be used against `TripTraveller` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type TripTravellerCondition = {
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `travellerId` field. */
  travellerId?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `tripId` field. */
  tripId?: InputMaybe<Scalars['UUID']['input']>;
};

/** A filter to be used against `TripTraveller` object types. All fields are combined with a logical ‘and.’ */
export type TripTravellerFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<TripTravellerFilter>>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<TripTravellerFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<TripTravellerFilter>>;
  /** Filter by the object’s `traveller` relation. */
  traveller?: InputMaybe<TravellerFilter>;
  /** Filter by the object’s `travellerId` field. */
  travellerId?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `trip` relation. */
  trip?: InputMaybe<TripFilter>;
  /** Filter by the object’s `tripId` field. */
  tripId?: InputMaybe<UuidFilter>;
};

/** An input for mutations affecting `TripTraveller` */
export type TripTravellerInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  travellerId?: InputMaybe<Scalars['UUID']['input']>;
  travellerToTravellerId?: InputMaybe<FkTripTravellerTravellerTravellerIdInput>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkTripTravellerTripTripIdInput>;
};

/** The fields on `tripTraveller` to look up the row to update. */
export type TripTravellerOnTripTravellerForFkTripTravellerTravellerTravellerIdUsingPkTripTravellerUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `tripTraveller` being updated. */
  patch: UpdateTripTravellerOnTripTravellerForFkTripTravellerTravellerTravellerIdPatch;
};

/** The fields on `tripTraveller` to look up the row to update. */
export type TripTravellerOnTripTravellerForFkTripTravellerTripTripIdUsingPkTripTravellerUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `tripTraveller` being updated. */
  patch: UpdateTripTravellerOnTripTravellerForFkTripTravellerTripTripIdPatch;
};

/** Represents an update to a `TripTraveller`. Fields that are set will be updated. */
export type TripTravellerPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  travellerId?: InputMaybe<Scalars['UUID']['input']>;
  travellerToTravellerId?: InputMaybe<FkTripTravellerTravellerTravellerIdInput>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkTripTravellerTripTripIdInput>;
};

/** The fields on `tripTraveller` to look up the row to connect. */
export type TripTravellerPkTripTravellerConnect = {
  id: Scalars['UUID']['input'];
};

/** The fields on `tripTraveller` to look up the row to delete. */
export type TripTravellerPkTripTravellerDelete = {
  id: Scalars['UUID']['input'];
};

/** A connection to a list of `TripTraveller` values. */
export type TripTravellersConnection = {
  __typename?: 'TripTravellersConnection';
  /** A list of edges which contains the `TripTraveller` and cursor to aid in pagination. */
  edges: Array<TripTravellersEdge>;
  /** A list of `TripTraveller` objects. */
  nodes: Array<Maybe<TripTraveller>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TripTraveller` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `TripTraveller` edge in the connection. */
export type TripTravellersEdge = {
  __typename?: 'TripTravellersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `TripTraveller` at the end of the edge. */
  node?: Maybe<TripTraveller>;
};

/** Methods to use when ordering `TripTraveller`. */
export enum TripTravellersOrderBy {
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TravellerByTravellerIdCreatedAsc = 'TRAVELLER_BY_TRAVELLER_ID__CREATED_ASC',
  TravellerByTravellerIdCreatedDesc = 'TRAVELLER_BY_TRAVELLER_ID__CREATED_DESC',
  TravellerByTravellerIdDateOfBirthAsc = 'TRAVELLER_BY_TRAVELLER_ID__DATE_OF_BIRTH_ASC',
  TravellerByTravellerIdDateOfBirthDesc = 'TRAVELLER_BY_TRAVELLER_ID__DATE_OF_BIRTH_DESC',
  TravellerByTravellerIdDietaryRequirementsAsc = 'TRAVELLER_BY_TRAVELLER_ID__DIETARY_REQUIREMENTS_ASC',
  TravellerByTravellerIdDietaryRequirementsDesc = 'TRAVELLER_BY_TRAVELLER_ID__DIETARY_REQUIREMENTS_DESC',
  TravellerByTravellerIdEmailAsc = 'TRAVELLER_BY_TRAVELLER_ID__EMAIL_ASC',
  TravellerByTravellerIdEmailDesc = 'TRAVELLER_BY_TRAVELLER_ID__EMAIL_DESC',
  TravellerByTravellerIdEmergencyContactAsc = 'TRAVELLER_BY_TRAVELLER_ID__EMERGENCY_CONTACT_ASC',
  TravellerByTravellerIdEmergencyContactDesc = 'TRAVELLER_BY_TRAVELLER_ID__EMERGENCY_CONTACT_DESC',
  TravellerByTravellerIdFirstNameAsc = 'TRAVELLER_BY_TRAVELLER_ID__FIRST_NAME_ASC',
  TravellerByTravellerIdFirstNameDesc = 'TRAVELLER_BY_TRAVELLER_ID__FIRST_NAME_DESC',
  TravellerByTravellerIdHeightAsc = 'TRAVELLER_BY_TRAVELLER_ID__HEIGHT_ASC',
  TravellerByTravellerIdHeightDesc = 'TRAVELLER_BY_TRAVELLER_ID__HEIGHT_DESC',
  TravellerByTravellerIdIdAsc = 'TRAVELLER_BY_TRAVELLER_ID__ID_ASC',
  TravellerByTravellerIdIdDesc = 'TRAVELLER_BY_TRAVELLER_ID__ID_DESC',
  TravellerByTravellerIdInsuranceDetailsAsc = 'TRAVELLER_BY_TRAVELLER_ID__INSURANCE_DETAILS_ASC',
  TravellerByTravellerIdInsuranceDetailsDesc = 'TRAVELLER_BY_TRAVELLER_ID__INSURANCE_DETAILS_DESC',
  TravellerByTravellerIdLastNameAsc = 'TRAVELLER_BY_TRAVELLER_ID__LAST_NAME_ASC',
  TravellerByTravellerIdLastNameDesc = 'TRAVELLER_BY_TRAVELLER_ID__LAST_NAME_DESC',
  TravellerByTravellerIdMedicalConditionsAsc = 'TRAVELLER_BY_TRAVELLER_ID__MEDICAL_CONDITIONS_ASC',
  TravellerByTravellerIdMedicalConditionsDesc = 'TRAVELLER_BY_TRAVELLER_ID__MEDICAL_CONDITIONS_DESC',
  TravellerByTravellerIdMiddleNameAsc = 'TRAVELLER_BY_TRAVELLER_ID__MIDDLE_NAME_ASC',
  TravellerByTravellerIdMiddleNameDesc = 'TRAVELLER_BY_TRAVELLER_ID__MIDDLE_NAME_DESC',
  TravellerByTravellerIdModifiedAsc = 'TRAVELLER_BY_TRAVELLER_ID__MODIFIED_ASC',
  TravellerByTravellerIdModifiedDesc = 'TRAVELLER_BY_TRAVELLER_ID__MODIFIED_DESC',
  TravellerByTravellerIdNationalityAsc = 'TRAVELLER_BY_TRAVELLER_ID__NATIONALITY_ASC',
  TravellerByTravellerIdNationalityDesc = 'TRAVELLER_BY_TRAVELLER_ID__NATIONALITY_DESC',
  TravellerByTravellerIdNotesAsc = 'TRAVELLER_BY_TRAVELLER_ID__NOTES_ASC',
  TravellerByTravellerIdNotesDesc = 'TRAVELLER_BY_TRAVELLER_ID__NOTES_DESC',
  TravellerByTravellerIdPhoneAsc = 'TRAVELLER_BY_TRAVELLER_ID__PHONE_ASC',
  TravellerByTravellerIdPhoneDesc = 'TRAVELLER_BY_TRAVELLER_ID__PHONE_DESC',
  TravellerByTravellerIdWeightAsc = 'TRAVELLER_BY_TRAVELLER_ID__WEIGHT_ASC',
  TravellerByTravellerIdWeightDesc = 'TRAVELLER_BY_TRAVELLER_ID__WEIGHT_DESC',
  TravellerIdAsc = 'TRAVELLER_ID_ASC',
  TravellerIdDesc = 'TRAVELLER_ID_DESC',
  TripByTripIdActiveQuoteIdAsc = 'TRIP_BY_TRIP_ID__ACTIVE_QUOTE_ID_ASC',
  TripByTripIdActiveQuoteIdDesc = 'TRIP_BY_TRIP_ID__ACTIVE_QUOTE_ID_DESC',
  TripByTripIdAgencyIdAsc = 'TRIP_BY_TRIP_ID__AGENCY_ID_ASC',
  TripByTripIdAgencyIdDesc = 'TRIP_BY_TRIP_ID__AGENCY_ID_DESC',
  TripByTripIdAgencyMemberIdAsc = 'TRIP_BY_TRIP_ID__AGENCY_MEMBER_ID_ASC',
  TripByTripIdAgencyMemberIdDesc = 'TRIP_BY_TRIP_ID__AGENCY_MEMBER_ID_DESC',
  TripByTripIdArchivedAsc = 'TRIP_BY_TRIP_ID__ARCHIVED_ASC',
  TripByTripIdArchivedDesc = 'TRIP_BY_TRIP_ID__ARCHIVED_DESC',
  TripByTripIdBaseCurrencyAsc = 'TRIP_BY_TRIP_ID__BASE_CURRENCY_ASC',
  TripByTripIdBaseCurrencyDesc = 'TRIP_BY_TRIP_ID__BASE_CURRENCY_DESC',
  TripByTripIdCreatedAsc = 'TRIP_BY_TRIP_ID__CREATED_ASC',
  TripByTripIdCreatedDesc = 'TRIP_BY_TRIP_ID__CREATED_DESC',
  TripByTripIdCustomerIdAsc = 'TRIP_BY_TRIP_ID__CUSTOMER_ID_ASC',
  TripByTripIdCustomerIdDesc = 'TRIP_BY_TRIP_ID__CUSTOMER_ID_DESC',
  TripByTripIdDatesAsc = 'TRIP_BY_TRIP_ID__DATES_ASC',
  TripByTripIdDatesDesc = 'TRIP_BY_TRIP_ID__DATES_DESC',
  TripByTripIdDestinationAsc = 'TRIP_BY_TRIP_ID__DESTINATION_ASC',
  TripByTripIdDestinationDesc = 'TRIP_BY_TRIP_ID__DESTINATION_DESC',
  TripByTripIdDurationAsc = 'TRIP_BY_TRIP_ID__DURATION_ASC',
  TripByTripIdDurationDesc = 'TRIP_BY_TRIP_ID__DURATION_DESC',
  TripByTripIdIdAsc = 'TRIP_BY_TRIP_ID__ID_ASC',
  TripByTripIdIdDesc = 'TRIP_BY_TRIP_ID__ID_DESC',
  TripByTripIdMediaGalleryIdAsc = 'TRIP_BY_TRIP_ID__MEDIA_GALLERY_ID_ASC',
  TripByTripIdMediaGalleryIdDesc = 'TRIP_BY_TRIP_ID__MEDIA_GALLERY_ID_DESC',
  TripByTripIdModifiedAsc = 'TRIP_BY_TRIP_ID__MODIFIED_ASC',
  TripByTripIdModifiedDesc = 'TRIP_BY_TRIP_ID__MODIFIED_DESC',
  TripByTripIdNameAsc = 'TRIP_BY_TRIP_ID__NAME_ASC',
  TripByTripIdNameDesc = 'TRIP_BY_TRIP_ID__NAME_DESC',
  TripByTripIdStartAsc = 'TRIP_BY_TRIP_ID__START_ASC',
  TripByTripIdStartDesc = 'TRIP_BY_TRIP_ID__START_DESC',
  TripByTripIdStatusAsc = 'TRIP_BY_TRIP_ID__STATUS_ASC',
  TripByTripIdStatusDesc = 'TRIP_BY_TRIP_ID__STATUS_DESC',
  TripByTripIdSummaryAsc = 'TRIP_BY_TRIP_ID__SUMMARY_ASC',
  TripByTripIdSummaryDesc = 'TRIP_BY_TRIP_ID__SUMMARY_DESC',
  TripByTripIdUserIdAsc = 'TRIP_BY_TRIP_ID__USER_ID_ASC',
  TripByTripIdUserIdDesc = 'TRIP_BY_TRIP_ID__USER_ID_DESC',
  TripIdAsc = 'TRIP_ID_ASC',
  TripIdDesc = 'TRIP_ID_DESC'
}

/** A connection to a list of `Trip` values. */
export type TripsConnection = {
  __typename?: 'TripsConnection';
  /** A list of edges which contains the `Trip` and cursor to aid in pagination. */
  edges: Array<TripsEdge>;
  /** A list of `Trip` objects. */
  nodes: Array<Maybe<Trip>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Trip` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Trip` edge in the connection. */
export type TripsEdge = {
  __typename?: 'TripsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Trip` at the end of the edge. */
  node?: Maybe<Trip>;
};

/** Methods to use when ordering `Trip`. */
export enum TripsOrderBy {
  ActiveQuoteIdAsc = 'ACTIVE_QUOTE_ID_ASC',
  ActiveQuoteIdDesc = 'ACTIVE_QUOTE_ID_DESC',
  AgencyByAgencyIdCreatedAsc = 'AGENCY_BY_AGENCY_ID__CREATED_ASC',
  AgencyByAgencyIdCreatedDesc = 'AGENCY_BY_AGENCY_ID__CREATED_DESC',
  AgencyByAgencyIdIdAsc = 'AGENCY_BY_AGENCY_ID__ID_ASC',
  AgencyByAgencyIdIdDesc = 'AGENCY_BY_AGENCY_ID__ID_DESC',
  AgencyByAgencyIdLogoIdAsc = 'AGENCY_BY_AGENCY_ID__LOGO_ID_ASC',
  AgencyByAgencyIdLogoIdDesc = 'AGENCY_BY_AGENCY_ID__LOGO_ID_DESC',
  AgencyByAgencyIdModifiedAsc = 'AGENCY_BY_AGENCY_ID__MODIFIED_ASC',
  AgencyByAgencyIdModifiedDesc = 'AGENCY_BY_AGENCY_ID__MODIFIED_DESC',
  AgencyByAgencyIdNameAsc = 'AGENCY_BY_AGENCY_ID__NAME_ASC',
  AgencyByAgencyIdNameDesc = 'AGENCY_BY_AGENCY_ID__NAME_DESC',
  AgencyByAgencyIdSupplierIdAsc = 'AGENCY_BY_AGENCY_ID__SUPPLIER_ID_ASC',
  AgencyByAgencyIdSupplierIdDesc = 'AGENCY_BY_AGENCY_ID__SUPPLIER_ID_DESC',
  AgencyIdAsc = 'AGENCY_ID_ASC',
  AgencyIdDesc = 'AGENCY_ID_DESC',
  AgencyMemberByAgencyMemberIdAgencyIdAsc = 'AGENCY_MEMBER_BY_AGENCY_MEMBER_ID__AGENCY_ID_ASC',
  AgencyMemberByAgencyMemberIdAgencyIdDesc = 'AGENCY_MEMBER_BY_AGENCY_MEMBER_ID__AGENCY_ID_DESC',
  AgencyMemberByAgencyMemberIdCreatedAsc = 'AGENCY_MEMBER_BY_AGENCY_MEMBER_ID__CREATED_ASC',
  AgencyMemberByAgencyMemberIdCreatedDesc = 'AGENCY_MEMBER_BY_AGENCY_MEMBER_ID__CREATED_DESC',
  AgencyMemberByAgencyMemberIdEmailAsc = 'AGENCY_MEMBER_BY_AGENCY_MEMBER_ID__EMAIL_ASC',
  AgencyMemberByAgencyMemberIdEmailDesc = 'AGENCY_MEMBER_BY_AGENCY_MEMBER_ID__EMAIL_DESC',
  AgencyMemberByAgencyMemberIdFirstNameAsc = 'AGENCY_MEMBER_BY_AGENCY_MEMBER_ID__FIRST_NAME_ASC',
  AgencyMemberByAgencyMemberIdFirstNameDesc = 'AGENCY_MEMBER_BY_AGENCY_MEMBER_ID__FIRST_NAME_DESC',
  AgencyMemberByAgencyMemberIdGenderPrepositionAsc = 'AGENCY_MEMBER_BY_AGENCY_MEMBER_ID__GENDER_PREPOSITION_ASC',
  AgencyMemberByAgencyMemberIdGenderPrepositionDesc = 'AGENCY_MEMBER_BY_AGENCY_MEMBER_ID__GENDER_PREPOSITION_DESC',
  AgencyMemberByAgencyMemberIdIdAsc = 'AGENCY_MEMBER_BY_AGENCY_MEMBER_ID__ID_ASC',
  AgencyMemberByAgencyMemberIdIdDesc = 'AGENCY_MEMBER_BY_AGENCY_MEMBER_ID__ID_DESC',
  AgencyMemberByAgencyMemberIdLastNameAsc = 'AGENCY_MEMBER_BY_AGENCY_MEMBER_ID__LAST_NAME_ASC',
  AgencyMemberByAgencyMemberIdLastNameDesc = 'AGENCY_MEMBER_BY_AGENCY_MEMBER_ID__LAST_NAME_DESC',
  AgencyMemberByAgencyMemberIdModifiedAsc = 'AGENCY_MEMBER_BY_AGENCY_MEMBER_ID__MODIFIED_ASC',
  AgencyMemberByAgencyMemberIdModifiedDesc = 'AGENCY_MEMBER_BY_AGENCY_MEMBER_ID__MODIFIED_DESC',
  AgencyMemberByAgencyMemberIdPhoneAsc = 'AGENCY_MEMBER_BY_AGENCY_MEMBER_ID__PHONE_ASC',
  AgencyMemberByAgencyMemberIdPhoneDesc = 'AGENCY_MEMBER_BY_AGENCY_MEMBER_ID__PHONE_DESC',
  AgencyMemberByAgencyMemberIdSkypeAsc = 'AGENCY_MEMBER_BY_AGENCY_MEMBER_ID__SKYPE_ASC',
  AgencyMemberByAgencyMemberIdSkypeDesc = 'AGENCY_MEMBER_BY_AGENCY_MEMBER_ID__SKYPE_DESC',
  AgencyMemberByAgencyMemberIdTitleAsc = 'AGENCY_MEMBER_BY_AGENCY_MEMBER_ID__TITLE_ASC',
  AgencyMemberByAgencyMemberIdTitleDesc = 'AGENCY_MEMBER_BY_AGENCY_MEMBER_ID__TITLE_DESC',
  AgencyMemberIdAsc = 'AGENCY_MEMBER_ID_ASC',
  AgencyMemberIdDesc = 'AGENCY_MEMBER_ID_DESC',
  ArchivedAsc = 'ARCHIVED_ASC',
  ArchivedDesc = 'ARCHIVED_DESC',
  BaseCurrencyAsc = 'BASE_CURRENCY_ASC',
  BaseCurrencyDesc = 'BASE_CURRENCY_DESC',
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  CustomerByCustomerIdCreatedAsc = 'CUSTOMER_BY_CUSTOMER_ID__CREATED_ASC',
  CustomerByCustomerIdCreatedDesc = 'CUSTOMER_BY_CUSTOMER_ID__CREATED_DESC',
  CustomerByCustomerIdEmailAsc = 'CUSTOMER_BY_CUSTOMER_ID__EMAIL_ASC',
  CustomerByCustomerIdEmailDesc = 'CUSTOMER_BY_CUSTOMER_ID__EMAIL_DESC',
  CustomerByCustomerIdIdAsc = 'CUSTOMER_BY_CUSTOMER_ID__ID_ASC',
  CustomerByCustomerIdIdDesc = 'CUSTOMER_BY_CUSTOMER_ID__ID_DESC',
  CustomerByCustomerIdModifiedAsc = 'CUSTOMER_BY_CUSTOMER_ID__MODIFIED_ASC',
  CustomerByCustomerIdModifiedDesc = 'CUSTOMER_BY_CUSTOMER_ID__MODIFIED_DESC',
  CustomerByCustomerIdNameAsc = 'CUSTOMER_BY_CUSTOMER_ID__NAME_ASC',
  CustomerByCustomerIdNameDesc = 'CUSTOMER_BY_CUSTOMER_ID__NAME_DESC',
  CustomerByCustomerIdPhoneAsc = 'CUSTOMER_BY_CUSTOMER_ID__PHONE_ASC',
  CustomerByCustomerIdPhoneDesc = 'CUSTOMER_BY_CUSTOMER_ID__PHONE_DESC',
  CustomerIdAsc = 'CUSTOMER_ID_ASC',
  CustomerIdDesc = 'CUSTOMER_ID_DESC',
  DatesAsc = 'DATES_ASC',
  DatesDesc = 'DATES_DESC',
  DestinationAsc = 'DESTINATION_ASC',
  DestinationDesc = 'DESTINATION_DESC',
  DurationAsc = 'DURATION_ASC',
  DurationDesc = 'DURATION_DESC',
  EmailsByTripIdCountAsc = 'EMAILS_BY_TRIP_ID__COUNT_ASC',
  EmailsByTripIdCountDesc = 'EMAILS_BY_TRIP_ID__COUNT_DESC',
  EnquiriesByTripIdCountAsc = 'ENQUIRIES_BY_TRIP_ID__COUNT_ASC',
  EnquiriesByTripIdCountDesc = 'ENQUIRIES_BY_TRIP_ID__COUNT_DESC',
  ExpensesByTripIdCountAsc = 'EXPENSES_BY_TRIP_ID__COUNT_ASC',
  ExpensesByTripIdCountDesc = 'EXPENSES_BY_TRIP_ID__COUNT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  InvoicesByTripIdCountAsc = 'INVOICES_BY_TRIP_ID__COUNT_ASC',
  InvoicesByTripIdCountDesc = 'INVOICES_BY_TRIP_ID__COUNT_DESC',
  MediaGalleryByMediaGalleryIdCreatedAsc = 'MEDIA_GALLERY_BY_MEDIA_GALLERY_ID__CREATED_ASC',
  MediaGalleryByMediaGalleryIdCreatedDesc = 'MEDIA_GALLERY_BY_MEDIA_GALLERY_ID__CREATED_DESC',
  MediaGalleryByMediaGalleryIdIdAsc = 'MEDIA_GALLERY_BY_MEDIA_GALLERY_ID__ID_ASC',
  MediaGalleryByMediaGalleryIdIdDesc = 'MEDIA_GALLERY_BY_MEDIA_GALLERY_ID__ID_DESC',
  MediaGalleryByMediaGalleryIdIsProtectedAsc = 'MEDIA_GALLERY_BY_MEDIA_GALLERY_ID__IS_PROTECTED_ASC',
  MediaGalleryByMediaGalleryIdIsProtectedDesc = 'MEDIA_GALLERY_BY_MEDIA_GALLERY_ID__IS_PROTECTED_DESC',
  MediaGalleryByMediaGalleryIdModifiedAsc = 'MEDIA_GALLERY_BY_MEDIA_GALLERY_ID__MODIFIED_ASC',
  MediaGalleryByMediaGalleryIdModifiedDesc = 'MEDIA_GALLERY_BY_MEDIA_GALLERY_ID__MODIFIED_DESC',
  MediaGalleryByMediaGalleryIdNameAsc = 'MEDIA_GALLERY_BY_MEDIA_GALLERY_ID__NAME_ASC',
  MediaGalleryByMediaGalleryIdNameDesc = 'MEDIA_GALLERY_BY_MEDIA_GALLERY_ID__NAME_DESC',
  MediaGalleryByMediaGalleryIdParentIdAsc = 'MEDIA_GALLERY_BY_MEDIA_GALLERY_ID__PARENT_ID_ASC',
  MediaGalleryByMediaGalleryIdParentIdDesc = 'MEDIA_GALLERY_BY_MEDIA_GALLERY_ID__PARENT_ID_DESC',
  MediaGalleryIdAsc = 'MEDIA_GALLERY_ID_ASC',
  MediaGalleryIdDesc = 'MEDIA_GALLERY_ID_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  NotesByTripIdCountAsc = 'NOTES_BY_TRIP_ID__COUNT_ASC',
  NotesByTripIdCountDesc = 'NOTES_BY_TRIP_ID__COUNT_DESC',
  PaymentsByTripIdCountAsc = 'PAYMENTS_BY_TRIP_ID__COUNT_ASC',
  PaymentsByTripIdCountDesc = 'PAYMENTS_BY_TRIP_ID__COUNT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QuotesByTripIdCountAsc = 'QUOTES_BY_TRIP_ID__COUNT_ASC',
  QuotesByTripIdCountDesc = 'QUOTES_BY_TRIP_ID__COUNT_DESC',
  QuoteByActiveQuoteIdAdjustmentAsc = 'QUOTE_BY_ACTIVE_QUOTE_ID__ADJUSTMENT_ASC',
  QuoteByActiveQuoteIdAdjustmentDesc = 'QUOTE_BY_ACTIVE_QUOTE_ID__ADJUSTMENT_DESC',
  QuoteByActiveQuoteIdAgentMarginAsc = 'QUOTE_BY_ACTIVE_QUOTE_ID__AGENT_MARGIN_ASC',
  QuoteByActiveQuoteIdAgentMarginDesc = 'QUOTE_BY_ACTIVE_QUOTE_ID__AGENT_MARGIN_DESC',
  QuoteByActiveQuoteIdArchivedAsc = 'QUOTE_BY_ACTIVE_QUOTE_ID__ARCHIVED_ASC',
  QuoteByActiveQuoteIdArchivedDesc = 'QUOTE_BY_ACTIVE_QUOTE_ID__ARCHIVED_DESC',
  QuoteByActiveQuoteIdBaseCurrencyAsc = 'QUOTE_BY_ACTIVE_QUOTE_ID__BASE_CURRENCY_ASC',
  QuoteByActiveQuoteIdBaseCurrencyDesc = 'QUOTE_BY_ACTIVE_QUOTE_ID__BASE_CURRENCY_DESC',
  QuoteByActiveQuoteIdCreatedAsc = 'QUOTE_BY_ACTIVE_QUOTE_ID__CREATED_ASC',
  QuoteByActiveQuoteIdCreatedDesc = 'QUOTE_BY_ACTIVE_QUOTE_ID__CREATED_DESC',
  QuoteByActiveQuoteIdDepositAsc = 'QUOTE_BY_ACTIVE_QUOTE_ID__DEPOSIT_ASC',
  QuoteByActiveQuoteIdDepositDesc = 'QUOTE_BY_ACTIVE_QUOTE_ID__DEPOSIT_DESC',
  QuoteByActiveQuoteIdDurationAsc = 'QUOTE_BY_ACTIVE_QUOTE_ID__DURATION_ASC',
  QuoteByActiveQuoteIdDurationDesc = 'QUOTE_BY_ACTIVE_QUOTE_ID__DURATION_DESC',
  QuoteByActiveQuoteIdExclusionsAsc = 'QUOTE_BY_ACTIVE_QUOTE_ID__EXCLUSIONS_ASC',
  QuoteByActiveQuoteIdExclusionsDesc = 'QUOTE_BY_ACTIVE_QUOTE_ID__EXCLUSIONS_DESC',
  QuoteByActiveQuoteIdExpiresAsc = 'QUOTE_BY_ACTIVE_QUOTE_ID__EXPIRES_ASC',
  QuoteByActiveQuoteIdExpiresDesc = 'QUOTE_BY_ACTIVE_QUOTE_ID__EXPIRES_DESC',
  QuoteByActiveQuoteIdHeroIdAsc = 'QUOTE_BY_ACTIVE_QUOTE_ID__HERO_ID_ASC',
  QuoteByActiveQuoteIdHeroIdDesc = 'QUOTE_BY_ACTIVE_QUOTE_ID__HERO_ID_DESC',
  QuoteByActiveQuoteIdHeroImageIdAsc = 'QUOTE_BY_ACTIVE_QUOTE_ID__HERO_IMAGE_ID_ASC',
  QuoteByActiveQuoteIdHeroImageIdDesc = 'QUOTE_BY_ACTIVE_QUOTE_ID__HERO_IMAGE_ID_DESC',
  QuoteByActiveQuoteIdIdAsc = 'QUOTE_BY_ACTIVE_QUOTE_ID__ID_ASC',
  QuoteByActiveQuoteIdIdDesc = 'QUOTE_BY_ACTIVE_QUOTE_ID__ID_DESC',
  QuoteByActiveQuoteIdInclusionsAsc = 'QUOTE_BY_ACTIVE_QUOTE_ID__INCLUSIONS_ASC',
  QuoteByActiveQuoteIdInclusionsDesc = 'QUOTE_BY_ACTIVE_QUOTE_ID__INCLUSIONS_DESC',
  QuoteByActiveQuoteIdKeyAsc = 'QUOTE_BY_ACTIVE_QUOTE_ID__KEY_ASC',
  QuoteByActiveQuoteIdKeyDesc = 'QUOTE_BY_ACTIVE_QUOTE_ID__KEY_DESC',
  QuoteByActiveQuoteIdLockedAsc = 'QUOTE_BY_ACTIVE_QUOTE_ID__LOCKED_ASC',
  QuoteByActiveQuoteIdLockedDesc = 'QUOTE_BY_ACTIVE_QUOTE_ID__LOCKED_DESC',
  QuoteByActiveQuoteIdMarginAsc = 'QUOTE_BY_ACTIVE_QUOTE_ID__MARGIN_ASC',
  QuoteByActiveQuoteIdMarginDesc = 'QUOTE_BY_ACTIVE_QUOTE_ID__MARGIN_DESC',
  QuoteByActiveQuoteIdModifiedAsc = 'QUOTE_BY_ACTIVE_QUOTE_ID__MODIFIED_ASC',
  QuoteByActiveQuoteIdModifiedDesc = 'QUOTE_BY_ACTIVE_QUOTE_ID__MODIFIED_DESC',
  QuoteByActiveQuoteIdShortDescriptionAsc = 'QUOTE_BY_ACTIVE_QUOTE_ID__SHORT_DESCRIPTION_ASC',
  QuoteByActiveQuoteIdShortDescriptionDesc = 'QUOTE_BY_ACTIVE_QUOTE_ID__SHORT_DESCRIPTION_DESC',
  QuoteByActiveQuoteIdStartAsc = 'QUOTE_BY_ACTIVE_QUOTE_ID__START_ASC',
  QuoteByActiveQuoteIdStartDesc = 'QUOTE_BY_ACTIVE_QUOTE_ID__START_DESC',
  QuoteByActiveQuoteIdStatusAsc = 'QUOTE_BY_ACTIVE_QUOTE_ID__STATUS_ASC',
  QuoteByActiveQuoteIdStatusDesc = 'QUOTE_BY_ACTIVE_QUOTE_ID__STATUS_DESC',
  QuoteByActiveQuoteIdSummaryAsc = 'QUOTE_BY_ACTIVE_QUOTE_ID__SUMMARY_ASC',
  QuoteByActiveQuoteIdSummaryDesc = 'QUOTE_BY_ACTIVE_QUOTE_ID__SUMMARY_DESC',
  QuoteByActiveQuoteIdTravellerCountAsc = 'QUOTE_BY_ACTIVE_QUOTE_ID__TRAVELLER_COUNT_ASC',
  QuoteByActiveQuoteIdTravellerCountDesc = 'QUOTE_BY_ACTIVE_QUOTE_ID__TRAVELLER_COUNT_DESC',
  QuoteByActiveQuoteIdTripIdAsc = 'QUOTE_BY_ACTIVE_QUOTE_ID__TRIP_ID_ASC',
  QuoteByActiveQuoteIdTripIdDesc = 'QUOTE_BY_ACTIVE_QUOTE_ID__TRIP_ID_DESC',
  QuoteByActiveQuoteIdUserIdAsc = 'QUOTE_BY_ACTIVE_QUOTE_ID__USER_ID_ASC',
  QuoteByActiveQuoteIdUserIdDesc = 'QUOTE_BY_ACTIVE_QUOTE_ID__USER_ID_DESC',
  QuotePublicsByTripIdCountAsc = 'QUOTE_PUBLICS_BY_TRIP_ID__COUNT_ASC',
  QuotePublicsByTripIdCountDesc = 'QUOTE_PUBLICS_BY_TRIP_ID__COUNT_DESC',
  StartAsc = 'START_ASC',
  StartDesc = 'START_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  SummaryAsc = 'SUMMARY_ASC',
  SummaryDesc = 'SUMMARY_DESC',
  SupplierInvoicesByTripIdCountAsc = 'SUPPLIER_INVOICES_BY_TRIP_ID__COUNT_ASC',
  SupplierInvoicesByTripIdCountDesc = 'SUPPLIER_INVOICES_BY_TRIP_ID__COUNT_DESC',
  TestimonialsByTripIdCountAsc = 'TESTIMONIALS_BY_TRIP_ID__COUNT_ASC',
  TestimonialsByTripIdCountDesc = 'TESTIMONIALS_BY_TRIP_ID__COUNT_DESC',
  TripFlightsByTripIdCountAsc = 'TRIP_FLIGHTS_BY_TRIP_ID__COUNT_ASC',
  TripFlightsByTripIdCountDesc = 'TRIP_FLIGHTS_BY_TRIP_ID__COUNT_DESC',
  TripTravellersByTripIdCountAsc = 'TRIP_TRAVELLERS_BY_TRIP_ID__COUNT_ASC',
  TripTravellersByTripIdCountDesc = 'TRIP_TRAVELLERS_BY_TRIP_ID__COUNT_DESC',
  UserByUserIdCreatedAsc = 'USER_BY_USER_ID__CREATED_ASC',
  UserByUserIdCreatedDesc = 'USER_BY_USER_ID__CREATED_DESC',
  UserByUserIdEmailAsc = 'USER_BY_USER_ID__EMAIL_ASC',
  UserByUserIdEmailDesc = 'USER_BY_USER_ID__EMAIL_DESC',
  UserByUserIdExternalIdAsc = 'USER_BY_USER_ID__EXTERNAL_ID_ASC',
  UserByUserIdExternalIdDesc = 'USER_BY_USER_ID__EXTERNAL_ID_DESC',
  UserByUserIdFirstNameAsc = 'USER_BY_USER_ID__FIRST_NAME_ASC',
  UserByUserIdFirstNameDesc = 'USER_BY_USER_ID__FIRST_NAME_DESC',
  UserByUserIdGenderPrepositionAsc = 'USER_BY_USER_ID__GENDER_PREPOSITION_ASC',
  UserByUserIdGenderPrepositionDesc = 'USER_BY_USER_ID__GENDER_PREPOSITION_DESC',
  UserByUserIdIdAsc = 'USER_BY_USER_ID__ID_ASC',
  UserByUserIdIdDesc = 'USER_BY_USER_ID__ID_DESC',
  UserByUserIdLastNameAsc = 'USER_BY_USER_ID__LAST_NAME_ASC',
  UserByUserIdLastNameDesc = 'USER_BY_USER_ID__LAST_NAME_DESC',
  UserByUserIdModifiedAsc = 'USER_BY_USER_ID__MODIFIED_ASC',
  UserByUserIdModifiedDesc = 'USER_BY_USER_ID__MODIFIED_DESC',
  UserByUserIdNameAsc = 'USER_BY_USER_ID__NAME_ASC',
  UserByUserIdNameDesc = 'USER_BY_USER_ID__NAME_DESC',
  UserByUserIdPasswordAsc = 'USER_BY_USER_ID__PASSWORD_ASC',
  UserByUserIdPasswordDesc = 'USER_BY_USER_ID__PASSWORD_DESC',
  UserByUserIdPhoneAsc = 'USER_BY_USER_ID__PHONE_ASC',
  UserByUserIdPhoneDesc = 'USER_BY_USER_ID__PHONE_DESC',
  UserByUserIdSkypeAsc = 'USER_BY_USER_ID__SKYPE_ASC',
  UserByUserIdSkypeDesc = 'USER_BY_USER_ID__SKYPE_DESC',
  UserByUserIdTitleAsc = 'USER_BY_USER_ID__TITLE_ASC',
  UserByUserIdTitleDesc = 'USER_BY_USER_ID__TITLE_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

/** A filter to be used against UUID fields. All fields are combined with a logical ‘and.’ */
export type UuidFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['UUID']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['UUID']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['UUID']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['UUID']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['UUID']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['UUID']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['UUID']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['UUID']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['UUID']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['UUID']['input']>>;
};

/** All input for the `updateAccount` mutation. */
export type UpdateAccountInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `Account` being updated. */
  patch: AccountPatch;
};

/** The output of our update `Account` mutation. */
export type UpdateAccountPayload = {
  __typename?: 'UpdateAccountPayload';
  /** The `Account` that was updated by this mutation. */
  account?: Maybe<Account>;
  /** An edge for our `Account`. May be used by Relay 1. */
  accountEdge?: Maybe<AccountsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `Account` mutation. */
export type UpdateAccountPayloadAccountEdgeArgs = {
  orderBy?: InputMaybe<Array<AccountsOrderBy>>;
};

/** All input for the `updateAgency` mutation. */
export type UpdateAgencyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `Agency` being updated. */
  patch: AgencyPatch;
};

/** All input for the `updateAgencyMember` mutation. */
export type UpdateAgencyMemberInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `AgencyMember` being updated. */
  patch: AgencyMemberPatch;
};

/** The output of our update `AgencyMember` mutation. */
export type UpdateAgencyMemberPayload = {
  __typename?: 'UpdateAgencyMemberPayload';
  /** Reads a single `Agency` that is related to this `AgencyMember`. */
  agency?: Maybe<Agency>;
  /** The `AgencyMember` that was updated by this mutation. */
  agencyMember?: Maybe<AgencyMember>;
  /** An edge for our `AgencyMember`. May be used by Relay 1. */
  agencyMemberEdge?: Maybe<AgencyMembersEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `AgencyMember` mutation. */
export type UpdateAgencyMemberPayloadAgencyMemberEdgeArgs = {
  orderBy?: InputMaybe<Array<AgencyMembersOrderBy>>;
};

/** The output of our update `Agency` mutation. */
export type UpdateAgencyPayload = {
  __typename?: 'UpdateAgencyPayload';
  /** The `Agency` that was updated by this mutation. */
  agency?: Maybe<Agency>;
  /** An edge for our `Agency`. May be used by Relay 1. */
  agencyEdge?: Maybe<AgenciesEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `MediaItem` that is related to this `Agency`. */
  logo?: Maybe<MediaItem>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Supplier` that is related to this `Agency`. */
  supplier?: Maybe<Supplier>;
};


/** The output of our update `Agency` mutation. */
export type UpdateAgencyPayloadAgencyEdgeArgs = {
  orderBy?: InputMaybe<Array<AgenciesOrderBy>>;
};

/** All input for the `updateAirport` mutation. */
export type UpdateAirportInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `Airport` being updated. */
  patch: AirportPatch;
};

/** The output of our update `Airport` mutation. */
export type UpdateAirportPayload = {
  __typename?: 'UpdateAirportPayload';
  /** The `Airport` that was updated by this mutation. */
  airport?: Maybe<Airport>;
  /** An edge for our `Airport`. May be used by Relay 1. */
  airportEdge?: Maybe<AirportsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Country` that is related to this `Airport`. */
  country?: Maybe<Country>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `Airport` mutation. */
export type UpdateAirportPayloadAirportEdgeArgs = {
  orderBy?: InputMaybe<Array<AirportsOrderBy>>;
};

/** All input for the `updateCountry` mutation. */
export type UpdateCountryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `Country` being updated. */
  patch: CountryPatch;
};

/** The output of our update `Country` mutation. */
export type UpdateCountryPayload = {
  __typename?: 'UpdateCountryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Country` that was updated by this mutation. */
  country?: Maybe<Country>;
  /** An edge for our `Country`. May be used by Relay 1. */
  countryEdge?: Maybe<CountriesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `Country` mutation. */
export type UpdateCountryPayloadCountryEdgeArgs = {
  orderBy?: InputMaybe<Array<CountriesOrderBy>>;
};

/** All input for the `updateCustomer` mutation. */
export type UpdateCustomerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `Customer` being updated. */
  patch: CustomerPatch;
};

/** The output of our update `Customer` mutation. */
export type UpdateCustomerPayload = {
  __typename?: 'UpdateCustomerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Customer` that was updated by this mutation. */
  customer?: Maybe<Customer>;
  /** An edge for our `Customer`. May be used by Relay 1. */
  customerEdge?: Maybe<CustomersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `Customer` mutation. */
export type UpdateCustomerPayloadCustomerEdgeArgs = {
  orderBy?: InputMaybe<Array<CustomersOrderBy>>;
};

/** All input for the `updateCustomerTraveller` mutation. */
export type UpdateCustomerTravellerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `CustomerTraveller` being updated. */
  patch: CustomerTravellerPatch;
};

/** The output of our update `CustomerTraveller` mutation. */
export type UpdateCustomerTravellerPayload = {
  __typename?: 'UpdateCustomerTravellerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Customer` that is related to this `CustomerTraveller`. */
  customer?: Maybe<Customer>;
  /** The `CustomerTraveller` that was updated by this mutation. */
  customerTraveller?: Maybe<CustomerTraveller>;
  /** An edge for our `CustomerTraveller`. May be used by Relay 1. */
  customerTravellerEdge?: Maybe<CustomerTravellersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Traveller` that is related to this `CustomerTraveller`. */
  traveller?: Maybe<Traveller>;
};


/** The output of our update `CustomerTraveller` mutation. */
export type UpdateCustomerTravellerPayloadCustomerTravellerEdgeArgs = {
  orderBy?: InputMaybe<Array<CustomerTravellersOrderBy>>;
};

/** All input for the `updateDestinationByCountryIdAndAlias` mutation. */
export type UpdateDestinationByCountryIdAndAliasInput = {
  alias: Scalars['String']['input'];
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  countryId: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `Destination` being updated. */
  patch: DestinationPatch;
};

/** All input for the `updateDestinationFeature` mutation. */
export type UpdateDestinationFeatureInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `DestinationFeature` being updated. */
  patch: DestinationFeaturePatch;
};

/** The output of our update `DestinationFeature` mutation. */
export type UpdateDestinationFeaturePayload = {
  __typename?: 'UpdateDestinationFeaturePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Destination` that is related to this `DestinationFeature`. */
  destination?: Maybe<Destination>;
  /** The `DestinationFeature` that was updated by this mutation. */
  destinationFeature?: Maybe<DestinationFeature>;
  /** An edge for our `DestinationFeature`. May be used by Relay 1. */
  destinationFeatureEdge?: Maybe<DestinationFeaturesEdge>;
  /** Reads a single `MediaGallery` that is related to this `DestinationFeature`. */
  gallery?: Maybe<MediaGallery>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `DestinationFeature` mutation. */
export type UpdateDestinationFeaturePayloadDestinationFeatureEdgeArgs = {
  orderBy?: InputMaybe<Array<DestinationFeaturesOrderBy>>;
};

/** All input for the `updateDestinationGuide` mutation. */
export type UpdateDestinationGuideInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `DestinationGuide` being updated. */
  patch: DestinationGuidePatch;
};

/** The output of our update `DestinationGuide` mutation. */
export type UpdateDestinationGuidePayload = {
  __typename?: 'UpdateDestinationGuidePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Destination` that is related to this `DestinationGuide`. */
  destination?: Maybe<Destination>;
  /** The `DestinationGuide` that was updated by this mutation. */
  destinationGuide?: Maybe<DestinationGuide>;
  /** An edge for our `DestinationGuide`. May be used by Relay 1. */
  destinationGuideEdge?: Maybe<DestinationGuidesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `DestinationGuide` mutation. */
export type UpdateDestinationGuidePayloadDestinationGuideEdgeArgs = {
  orderBy?: InputMaybe<Array<DestinationGuidesOrderBy>>;
};

/** All input for the `updateDestination` mutation. */
export type UpdateDestinationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `Destination` being updated. */
  patch: DestinationPatch;
};

/** The output of our update `Destination` mutation. */
export type UpdateDestinationPayload = {
  __typename?: 'UpdateDestinationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Country` that is related to this `Destination`. */
  country?: Maybe<Country>;
  /** The `Destination` that was updated by this mutation. */
  destination?: Maybe<Destination>;
  /** An edge for our `Destination`. May be used by Relay 1. */
  destinationEdge?: Maybe<DestinationsEdge>;
  /** Reads a single `MediaGallery` that is related to this `Destination`. */
  gallery?: Maybe<MediaGallery>;
  /** Reads a single `MediaItem` that is related to this `Destination`. */
  heroMedia?: Maybe<MediaItem>;
  /** Reads a single `Destination` that is related to this `Destination`. */
  parent?: Maybe<Destination>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `Destination` mutation. */
export type UpdateDestinationPayloadDestinationEdgeArgs = {
  orderBy?: InputMaybe<Array<DestinationsOrderBy>>;
};

/** All input for the `updateEmail` mutation. */
export type UpdateEmailInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `Email` being updated. */
  patch: EmailPatch;
};

/** The output of our update `Email` mutation. */
export type UpdateEmailPayload = {
  __typename?: 'UpdateEmailPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Customer` that is related to this `Email`. */
  customer?: Maybe<Customer>;
  /** The `Email` that was updated by this mutation. */
  email?: Maybe<Email>;
  /** An edge for our `Email`. May be used by Relay 1. */
  emailEdge?: Maybe<EmailsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Quote` that is related to this `Email`. */
  quote?: Maybe<Quote>;
  /** Reads a single `Trip` that is related to this `Email`. */
  trip?: Maybe<Trip>;
  /** Reads a single `User` that is related to this `Email`. */
  user?: Maybe<User>;
};


/** The output of our update `Email` mutation. */
export type UpdateEmailPayloadEmailEdgeArgs = {
  orderBy?: InputMaybe<Array<EmailsOrderBy>>;
};

/** All input for the `updateEnquiry` mutation. */
export type UpdateEnquiryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `Enquiry` being updated. */
  patch: EnquiryPatch;
};

/** The output of our update `Enquiry` mutation. */
export type UpdateEnquiryPayload = {
  __typename?: 'UpdateEnquiryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Customer` that is related to this `Enquiry`. */
  customer?: Maybe<Customer>;
  /** The `Enquiry` that was updated by this mutation. */
  enquiry?: Maybe<Enquiry>;
  /** An edge for our `Enquiry`. May be used by Relay 1. */
  enquiryEdge?: Maybe<EnquiriesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Trip` that is related to this `Enquiry`. */
  trip?: Maybe<Trip>;
};


/** The output of our update `Enquiry` mutation. */
export type UpdateEnquiryPayloadEnquiryEdgeArgs = {
  orderBy?: InputMaybe<Array<EnquiriesOrderBy>>;
};

/** All input for the `updateExpense` mutation. */
export type UpdateExpenseInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `Expense` being updated. */
  patch: ExpensePatch;
};

/** The output of our update `Expense` mutation. */
export type UpdateExpensePayload = {
  __typename?: 'UpdateExpensePayload';
  /** Reads a single `FinanceCategory` that is related to this `Expense`. */
  category?: Maybe<FinanceCategory>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Expense` that was updated by this mutation. */
  expense?: Maybe<Expense>;
  /** An edge for our `Expense`. May be used by Relay 1. */
  expenseEdge?: Maybe<ExpensesEdge>;
  /** Reads a single `Invoice` that is related to this `Expense`. */
  invoice?: Maybe<Invoice>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Supplier` that is related to this `Expense`. */
  supplier?: Maybe<Supplier>;
  /** Reads a single `SupplierInvoice` that is related to this `Expense`. */
  supplierInvoice?: Maybe<SupplierInvoice>;
  /** Reads a single `Trip` that is related to this `Expense`. */
  trip?: Maybe<Trip>;
};


/** The output of our update `Expense` mutation. */
export type UpdateExpensePayloadExpenseEdgeArgs = {
  orderBy?: InputMaybe<Array<ExpensesOrderBy>>;
};

/** All input for the `updateFeature` mutation. */
export type UpdateFeatureInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `Feature` being updated. */
  patch: FeaturePatch;
};

/** The output of our update `Feature` mutation. */
export type UpdateFeaturePayload = {
  __typename?: 'UpdateFeaturePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Feature` that was updated by this mutation. */
  feature?: Maybe<Feature>;
  /** An edge for our `Feature`. May be used by Relay 1. */
  featureEdge?: Maybe<FeaturesEdge>;
  /** Reads a single `MediaGallery` that is related to this `Feature`. */
  gallery?: Maybe<MediaGallery>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `Feature` mutation. */
export type UpdateFeaturePayloadFeatureEdgeArgs = {
  orderBy?: InputMaybe<Array<FeaturesOrderBy>>;
};

/** All input for the `updateFinanceCategory` mutation. */
export type UpdateFinanceCategoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `FinanceCategory` being updated. */
  patch: FinanceCategoryPatch;
};

/** The output of our update `FinanceCategory` mutation. */
export type UpdateFinanceCategoryPayload = {
  __typename?: 'UpdateFinanceCategoryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `FinanceCategory` that was updated by this mutation. */
  financeCategory?: Maybe<FinanceCategory>;
  /** An edge for our `FinanceCategory`. May be used by Relay 1. */
  financeCategoryEdge?: Maybe<FinanceCategoriesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `FinanceCategory` mutation. */
export type UpdateFinanceCategoryPayloadFinanceCategoryEdgeArgs = {
  orderBy?: InputMaybe<Array<FinanceCategoriesOrderBy>>;
};

/** All input for the `updateInvoice` mutation. */
export type UpdateInvoiceInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `Invoice` being updated. */
  patch: InvoicePatch;
};

/** The output of our update `Invoice` mutation. */
export type UpdateInvoicePayload = {
  __typename?: 'UpdateInvoicePayload';
  /** Reads a single `FinanceCategory` that is related to this `Invoice`. */
  category?: Maybe<FinanceCategory>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Invoice` that was updated by this mutation. */
  invoice?: Maybe<Invoice>;
  /** An edge for our `Invoice`. May be used by Relay 1. */
  invoiceEdge?: Maybe<InvoicesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Quote` that is related to this `Invoice`. */
  quote?: Maybe<Quote>;
  /** Reads a single `Trip` that is related to this `Invoice`. */
  trip?: Maybe<Trip>;
};


/** The output of our update `Invoice` mutation. */
export type UpdateInvoicePayloadInvoiceEdgeArgs = {
  orderBy?: InputMaybe<Array<InvoicesOrderBy>>;
};

/** All input for the `updateLegalDocument` mutation. */
export type UpdateLegalDocumentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `LegalDocument` being updated. */
  patch: LegalDocumentPatch;
};

/** The output of our update `LegalDocument` mutation. */
export type UpdateLegalDocumentPayload = {
  __typename?: 'UpdateLegalDocumentPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `LegalFolder` that is related to this `LegalDocument`. */
  folder?: Maybe<LegalFolder>;
  /** The `LegalDocument` that was updated by this mutation. */
  legalDocument?: Maybe<LegalDocument>;
  /** An edge for our `LegalDocument`. May be used by Relay 1. */
  legalDocumentEdge?: Maybe<LegalDocumentsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `LegalDocument` mutation. */
export type UpdateLegalDocumentPayloadLegalDocumentEdgeArgs = {
  orderBy?: InputMaybe<Array<LegalDocumentsOrderBy>>;
};

/** All input for the `updateLegalFolder` mutation. */
export type UpdateLegalFolderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `LegalFolder` being updated. */
  patch: LegalFolderPatch;
};

/** The output of our update `LegalFolder` mutation. */
export type UpdateLegalFolderPayload = {
  __typename?: 'UpdateLegalFolderPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `LegalFolder` that was updated by this mutation. */
  legalFolder?: Maybe<LegalFolder>;
  /** An edge for our `LegalFolder`. May be used by Relay 1. */
  legalFolderEdge?: Maybe<LegalFoldersEdge>;
  /** Reads a single `LegalFolder` that is related to this `LegalFolder`. */
  parent?: Maybe<LegalFolder>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `LegalFolder` mutation. */
export type UpdateLegalFolderPayloadLegalFolderEdgeArgs = {
  orderBy?: InputMaybe<Array<LegalFoldersOrderBy>>;
};

/** All input for the `updateMapPoint` mutation. */
export type UpdateMapPointInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `MapPoint` being updated. */
  patch: MapPointPatch;
};

/** The output of our update `MapPoint` mutation. */
export type UpdateMapPointPayload = {
  __typename?: 'UpdateMapPointPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `MapPoint` that was updated by this mutation. */
  mapPoint?: Maybe<MapPoint>;
  /** An edge for our `MapPoint`. May be used by Relay 1. */
  mapPointEdge?: Maybe<MapPointsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `MapPoint` mutation. */
export type UpdateMapPointPayloadMapPointEdgeArgs = {
  orderBy?: InputMaybe<Array<MapPointsOrderBy>>;
};

/** All input for the `updateMediaGallery` mutation. */
export type UpdateMediaGalleryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `MediaGallery` being updated. */
  patch: MediaGalleryPatch;
};

/** All input for the `updateMediaGalleryItem` mutation. */
export type UpdateMediaGalleryItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `MediaGalleryItem` being updated. */
  patch: MediaGalleryItemPatch;
};

/** The output of our update `MediaGalleryItem` mutation. */
export type UpdateMediaGalleryItemPayload = {
  __typename?: 'UpdateMediaGalleryItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `MediaGallery` that is related to this `MediaGalleryItem`. */
  mediaGallery?: Maybe<MediaGallery>;
  /** The `MediaGalleryItem` that was updated by this mutation. */
  mediaGalleryItem?: Maybe<MediaGalleryItem>;
  /** An edge for our `MediaGalleryItem`. May be used by Relay 1. */
  mediaGalleryItemEdge?: Maybe<MediaGalleryItemsEdge>;
  /** Reads a single `MediaItem` that is related to this `MediaGalleryItem`. */
  mediaItem?: Maybe<MediaItem>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `MediaGalleryItem` mutation. */
export type UpdateMediaGalleryItemPayloadMediaGalleryItemEdgeArgs = {
  orderBy?: InputMaybe<Array<MediaGalleryItemsOrderBy>>;
};

/** The output of our update `MediaGallery` mutation. */
export type UpdateMediaGalleryPayload = {
  __typename?: 'UpdateMediaGalleryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `MediaGallery` that was updated by this mutation. */
  mediaGallery?: Maybe<MediaGallery>;
  /** An edge for our `MediaGallery`. May be used by Relay 1. */
  mediaGalleryEdge?: Maybe<MediaGalleriesEdge>;
  /** Reads a single `MediaGallery` that is related to this `MediaGallery`. */
  parent?: Maybe<MediaGallery>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `MediaGallery` mutation. */
export type UpdateMediaGalleryPayloadMediaGalleryEdgeArgs = {
  orderBy?: InputMaybe<Array<MediaGalleriesOrderBy>>;
};

/** All input for the `updateMediaItem` mutation. */
export type UpdateMediaItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `MediaItem` being updated. */
  patch: MediaItemPatch;
};

/** The output of our update `MediaItem` mutation. */
export type UpdateMediaItemPayload = {
  __typename?: 'UpdateMediaItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `MediaItem` that was updated by this mutation. */
  mediaItem?: Maybe<MediaItem>;
  /** An edge for our `MediaItem`. May be used by Relay 1. */
  mediaItemEdge?: Maybe<MediaItemsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `MediaItem` mutation. */
export type UpdateMediaItemPayloadMediaItemEdgeArgs = {
  orderBy?: InputMaybe<Array<MediaItemsOrderBy>>;
};

/** All input for the `updateNote` mutation. */
export type UpdateNoteInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `Note` being updated. */
  patch: NotePatch;
};

/** The output of our update `Note` mutation. */
export type UpdateNotePayload = {
  __typename?: 'UpdateNotePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Note` that was updated by this mutation. */
  note?: Maybe<Note>;
  /** An edge for our `Note`. May be used by Relay 1. */
  noteEdge?: Maybe<NotesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Trip` that is related to this `Note`. */
  trip?: Maybe<Trip>;
  /** Reads a single `User` that is related to this `Note`. */
  user?: Maybe<User>;
};


/** The output of our update `Note` mutation. */
export type UpdateNotePayloadNoteEdgeArgs = {
  orderBy?: InputMaybe<Array<NotesOrderBy>>;
};

/** All input for the `updatePassport` mutation. */
export type UpdatePassportInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `Passport` being updated. */
  patch: PassportPatch;
};

/** The output of our update `Passport` mutation. */
export type UpdatePassportPayload = {
  __typename?: 'UpdatePassportPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Country` that is related to this `Passport`. */
  country?: Maybe<Country>;
  /** The `Passport` that was updated by this mutation. */
  passport?: Maybe<Passport>;
  /** An edge for our `Passport`. May be used by Relay 1. */
  passportEdge?: Maybe<PassportsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Traveller` that is related to this `Passport`. */
  traveller?: Maybe<Traveller>;
};


/** The output of our update `Passport` mutation. */
export type UpdatePassportPayloadPassportEdgeArgs = {
  orderBy?: InputMaybe<Array<PassportsOrderBy>>;
};

/** All input for the `updatePayment` mutation. */
export type UpdatePaymentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `Payment` being updated. */
  patch: PaymentPatch;
};

/** The output of our update `Payment` mutation. */
export type UpdatePaymentPayload = {
  __typename?: 'UpdatePaymentPayload';
  /** Reads a single `FinanceCategory` that is related to this `Payment`. */
  category?: Maybe<FinanceCategory>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Invoice` that is related to this `Payment`. */
  invoice?: Maybe<Invoice>;
  /** The `Payment` that was updated by this mutation. */
  payment?: Maybe<Payment>;
  /** An edge for our `Payment`. May be used by Relay 1. */
  paymentEdge?: Maybe<PaymentsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Trip` that is related to this `Payment`. */
  trip?: Maybe<Trip>;
};


/** The output of our update `Payment` mutation. */
export type UpdatePaymentPayloadPaymentEdgeArgs = {
  orderBy?: InputMaybe<Array<PaymentsOrderBy>>;
};

/** All input for the `updateProperty` mutation. */
export type UpdatePropertyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `Property` being updated. */
  patch: PropertyPatch;
};

/** The output of our update `Property` mutation. */
export type UpdatePropertyPayload = {
  __typename?: 'UpdatePropertyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Country` that is related to this `Property`. */
  country?: Maybe<Country>;
  /** Reads a single `Destination` that is related to this `Property`. */
  destination?: Maybe<Destination>;
  /** Reads a single `MediaGallery` that is related to this `Property`. */
  gallery?: Maybe<MediaGallery>;
  /** Reads a single `MediaItem` that is related to this `Property`. */
  heroMedia?: Maybe<MediaItem>;
  /** Reads a single `MapPoint` that is related to this `Property`. */
  mapPoint?: Maybe<MapPoint>;
  /** The `Property` that was updated by this mutation. */
  property?: Maybe<Property>;
  /** An edge for our `Property`. May be used by Relay 1. */
  propertyEdge?: Maybe<PropertiesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `Property` mutation. */
export type UpdatePropertyPayloadPropertyEdgeArgs = {
  orderBy?: InputMaybe<Array<PropertiesOrderBy>>;
};

/** All input for the `updateQuoteAcceptance` mutation. */
export type UpdateQuoteAcceptanceInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `QuoteAcceptance` being updated. */
  patch: QuoteAcceptancePatch;
};

/** The output of our update `QuoteAcceptance` mutation. */
export type UpdateQuoteAcceptancePayload = {
  __typename?: 'UpdateQuoteAcceptancePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Quote` that is related to this `QuoteAcceptance`. */
  quote?: Maybe<Quote>;
  /** The `QuoteAcceptance` that was updated by this mutation. */
  quoteAcceptance?: Maybe<QuoteAcceptance>;
  /** An edge for our `QuoteAcceptance`. May be used by Relay 1. */
  quoteAcceptanceEdge?: Maybe<QuoteAcceptancesEdge>;
};


/** The output of our update `QuoteAcceptance` mutation. */
export type UpdateQuoteAcceptancePayloadQuoteAcceptanceEdgeArgs = {
  orderBy?: InputMaybe<Array<QuoteAcceptancesOrderBy>>;
};

/** All input for the `updateQuoteAccommodationDetail` mutation. */
export type UpdateQuoteAccommodationDetailInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `QuoteAccommodationDetail` being updated. */
  patch: QuoteAccommodationDetailPatch;
};

/** The output of our update `QuoteAccommodationDetail` mutation. */
export type UpdateQuoteAccommodationDetailPayload = {
  __typename?: 'UpdateQuoteAccommodationDetailPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Property` that is related to this `QuoteAccommodationDetail`. */
  property?: Maybe<Property>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Quote` that is related to this `QuoteAccommodationDetail`. */
  quote?: Maybe<Quote>;
  /** The `QuoteAccommodationDetail` that was updated by this mutation. */
  quoteAccommodationDetail?: Maybe<QuoteAccommodationDetail>;
  /** An edge for our `QuoteAccommodationDetail`. May be used by Relay 1. */
  quoteAccommodationDetailEdge?: Maybe<QuoteAccommodationDetailsEdge>;
  /** Reads a single `QuotePublic` that is related to this `QuoteAccommodationDetail`. */
  quotePublic?: Maybe<QuotePublic>;
};


/** The output of our update `QuoteAccommodationDetail` mutation. */
export type UpdateQuoteAccommodationDetailPayloadQuoteAccommodationDetailEdgeArgs = {
  orderBy?: InputMaybe<Array<QuoteAccommodationDetailsOrderBy>>;
};

/** All input for the `updateQuoteByKey` mutation. */
export type UpdateQuoteByKeyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  key: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `Quote` being updated. */
  patch: QuotePatch;
};

/** All input for the `updateQuoteCurrency` mutation. */
export type UpdateQuoteCurrencyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `QuoteCurrency` being updated. */
  patch: QuoteCurrencyPatch;
};

/** The output of our update `QuoteCurrency` mutation. */
export type UpdateQuoteCurrencyPayload = {
  __typename?: 'UpdateQuoteCurrencyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Quote` that is related to this `QuoteCurrency`. */
  quote?: Maybe<Quote>;
  /** The `QuoteCurrency` that was updated by this mutation. */
  quoteCurrency?: Maybe<QuoteCurrency>;
  /** An edge for our `QuoteCurrency`. May be used by Relay 1. */
  quoteCurrencyEdge?: Maybe<QuoteCurrenciesEdge>;
};


/** The output of our update `QuoteCurrency` mutation. */
export type UpdateQuoteCurrencyPayloadQuoteCurrencyEdgeArgs = {
  orderBy?: InputMaybe<Array<QuoteCurrenciesOrderBy>>;
};

/** All input for the `updateQuoteDayDestination` mutation. */
export type UpdateQuoteDayDestinationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `QuoteDayDestination` being updated. */
  patch: QuoteDayDestinationPatch;
};

/** The output of our update `QuoteDayDestination` mutation. */
export type UpdateQuoteDayDestinationPayload = {
  __typename?: 'UpdateQuoteDayDestinationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `QuoteDay` that is related to this `QuoteDayDestination`. */
  day?: Maybe<QuoteDay>;
  /** Reads a single `Destination` that is related to this `QuoteDayDestination`. */
  destination?: Maybe<Destination>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `QuoteDayDestination` that was updated by this mutation. */
  quoteDayDestination?: Maybe<QuoteDayDestination>;
  /** An edge for our `QuoteDayDestination`. May be used by Relay 1. */
  quoteDayDestinationEdge?: Maybe<QuoteDayDestinationsEdge>;
};


/** The output of our update `QuoteDayDestination` mutation. */
export type UpdateQuoteDayDestinationPayloadQuoteDayDestinationEdgeArgs = {
  orderBy?: InputMaybe<Array<QuoteDayDestinationsOrderBy>>;
};

/** All input for the `updateQuoteDay` mutation. */
export type UpdateQuoteDayInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `QuoteDay` being updated. */
  patch: QuoteDayPatch;
};

/** The output of our update `QuoteDay` mutation. */
export type UpdateQuoteDayPayload = {
  __typename?: 'UpdateQuoteDayPayload';
  /** Reads a single `QuoteAccommodationDetail` that is related to this `QuoteDay`. */
  accommodation?: Maybe<QuoteAccommodationDetail>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Property` that is related to this `QuoteDay`. */
  property?: Maybe<Property>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Quote` that is related to this `QuoteDay`. */
  quote?: Maybe<Quote>;
  /** The `QuoteDay` that was updated by this mutation. */
  quoteDay?: Maybe<QuoteDay>;
  /** An edge for our `QuoteDay`. May be used by Relay 1. */
  quoteDayEdge?: Maybe<QuoteDaysEdge>;
  /** Reads a single `QuotePublic` that is related to this `QuoteDay`. */
  quotePublic?: Maybe<QuotePublic>;
};


/** The output of our update `QuoteDay` mutation. */
export type UpdateQuoteDayPayloadQuoteDayEdgeArgs = {
  orderBy?: InputMaybe<Array<QuoteDaysOrderBy>>;
};

/** All input for the `updateQuoteFinanceLineItem` mutation. */
export type UpdateQuoteFinanceLineItemInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `QuoteFinanceLineItem` being updated. */
  patch: QuoteFinanceLineItemPatch;
};

/** The output of our update `QuoteFinanceLineItem` mutation. */
export type UpdateQuoteFinanceLineItemPayload = {
  __typename?: 'UpdateQuoteFinanceLineItemPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Quote` that is related to this `QuoteFinanceLineItem`. */
  quote?: Maybe<Quote>;
  /** The `QuoteFinanceLineItem` that was updated by this mutation. */
  quoteFinanceLineItem?: Maybe<QuoteFinanceLineItem>;
  /** An edge for our `QuoteFinanceLineItem`. May be used by Relay 1. */
  quoteFinanceLineItemEdge?: Maybe<QuoteFinanceLineItemsEdge>;
  /** Reads a single `Supplier` that is related to this `QuoteFinanceLineItem`. */
  supplier?: Maybe<Supplier>;
};


/** The output of our update `QuoteFinanceLineItem` mutation. */
export type UpdateQuoteFinanceLineItemPayloadQuoteFinanceLineItemEdgeArgs = {
  orderBy?: InputMaybe<Array<QuoteFinanceLineItemsOrderBy>>;
};

/** All input for the `updateQuoteHero` mutation. */
export type UpdateQuoteHeroInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `QuoteHero` being updated. */
  patch: QuoteHeroPatch;
};

/** The output of our update `QuoteHero` mutation. */
export type UpdateQuoteHeroPayload = {
  __typename?: 'UpdateQuoteHeroPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `MediaItem` that is related to this `QuoteHero`. */
  image?: Maybe<MediaItem>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `QuoteHero` that was updated by this mutation. */
  quoteHero?: Maybe<QuoteHero>;
  /** An edge for our `QuoteHero`. May be used by Relay 1. */
  quoteHeroEdge?: Maybe<QuoteHeroesEdge>;
};


/** The output of our update `QuoteHero` mutation. */
export type UpdateQuoteHeroPayloadQuoteHeroEdgeArgs = {
  orderBy?: InputMaybe<Array<QuoteHeroesOrderBy>>;
};

/** All input for the `updateQuote` mutation. */
export type UpdateQuoteInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `Quote` being updated. */
  patch: QuotePatch;
};

/** All input for the `updateQuoteLegalDocument` mutation. */
export type UpdateQuoteLegalDocumentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `QuoteLegalDocument` being updated. */
  patch: QuoteLegalDocumentPatch;
};

/** The output of our update `QuoteLegalDocument` mutation. */
export type UpdateQuoteLegalDocumentPayload = {
  __typename?: 'UpdateQuoteLegalDocumentPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `LegalDocument` that is related to this `QuoteLegalDocument`. */
  legalDocument?: Maybe<LegalDocument>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Quote` that is related to this `QuoteLegalDocument`. */
  quote?: Maybe<Quote>;
  /** The `QuoteLegalDocument` that was updated by this mutation. */
  quoteLegalDocument?: Maybe<QuoteLegalDocument>;
  /** An edge for our `QuoteLegalDocument`. May be used by Relay 1. */
  quoteLegalDocumentEdge?: Maybe<QuoteLegalDocumentsEdge>;
  /** Reads a single `QuotePublic` that is related to this `QuoteLegalDocument`. */
  quotePublic?: Maybe<QuotePublic>;
};


/** The output of our update `QuoteLegalDocument` mutation. */
export type UpdateQuoteLegalDocumentPayloadQuoteLegalDocumentEdgeArgs = {
  orderBy?: InputMaybe<Array<QuoteLegalDocumentsOrderBy>>;
};

/** The output of our update `Quote` mutation. */
export type UpdateQuotePayload = {
  __typename?: 'UpdateQuotePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `QuoteHero` that is related to this `Quote`. */
  hero?: Maybe<QuoteHero>;
  /** Reads a single `MediaItem` that is related to this `Quote`. */
  heroImage?: Maybe<MediaItem>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Quote` that was updated by this mutation. */
  quote?: Maybe<Quote>;
  /** An edge for our `Quote`. May be used by Relay 1. */
  quoteEdge?: Maybe<QuotesEdge>;
  /** Reads a single `QuoteStatus` that is related to this `Quote`. */
  quoteStatusByStatus?: Maybe<QuoteStatus>;
  /** Reads a single `Trip` that is related to this `Quote`. */
  trip?: Maybe<Trip>;
  /** Reads a single `User` that is related to this `Quote`. */
  user?: Maybe<User>;
};


/** The output of our update `Quote` mutation. */
export type UpdateQuotePayloadQuoteEdgeArgs = {
  orderBy?: InputMaybe<Array<QuotesOrderBy>>;
};

/** All input for the `updateQuotePublic` mutation. */
export type UpdateQuotePublicInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  key: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `QuotePublic` being updated. */
  patch: QuotePublicPatch;
};

/** The output of our update `QuotePublic` mutation. */
export type UpdateQuotePublicPayload = {
  __typename?: 'UpdateQuotePublicPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `QuoteHero` that is related to this `QuotePublic`. */
  hero?: Maybe<QuoteHero>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `QuotePublic` that was updated by this mutation. */
  quotePublic?: Maybe<QuotePublic>;
  /** An edge for our `QuotePublic`. May be used by Relay 1. */
  quotePublicEdge?: Maybe<QuotePublicsEdge>;
  /** Reads a single `Trip` that is related to this `QuotePublic`. */
  trip?: Maybe<Trip>;
  /** Reads a single `User` that is related to this `QuotePublic`. */
  user?: Maybe<User>;
};


/** The output of our update `QuotePublic` mutation. */
export type UpdateQuotePublicPayloadQuotePublicEdgeArgs = {
  orderBy?: InputMaybe<Array<QuotePublicsOrderBy>>;
};

/** All input for the `updateQuoteStatus` mutation. */
export type UpdateQuoteStatusInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `QuoteStatus` being updated. */
  patch: QuoteStatusPatch;
};

/** The output of our update `QuoteStatus` mutation. */
export type UpdateQuoteStatusPayload = {
  __typename?: 'UpdateQuoteStatusPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `QuoteStatus` that was updated by this mutation. */
  quoteStatus?: Maybe<QuoteStatus>;
  /** An edge for our `QuoteStatus`. May be used by Relay 1. */
  quoteStatusEdge?: Maybe<QuoteStatusesEdge>;
};


/** The output of our update `QuoteStatus` mutation. */
export type UpdateQuoteStatusPayloadQuoteStatusEdgeArgs = {
  orderBy?: InputMaybe<Array<QuoteStatusesOrderBy>>;
};

/** All input for the `updateQuoteView` mutation. */
export type UpdateQuoteViewInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `QuoteView` being updated. */
  patch: QuoteViewPatch;
};

/** The output of our update `QuoteView` mutation. */
export type UpdateQuoteViewPayload = {
  __typename?: 'UpdateQuoteViewPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Quote` that is related to this `QuoteView`. */
  quote?: Maybe<Quote>;
  /** The `QuoteView` that was updated by this mutation. */
  quoteView?: Maybe<QuoteView>;
  /** An edge for our `QuoteView`. May be used by Relay 1. */
  quoteViewEdge?: Maybe<QuoteViewsEdge>;
};


/** The output of our update `QuoteView` mutation. */
export type UpdateQuoteViewPayloadQuoteViewEdgeArgs = {
  orderBy?: InputMaybe<Array<QuoteViewsOrderBy>>;
};

/** All input for the `updateReminder` mutation. */
export type UpdateReminderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `Reminder` being updated. */
  patch: ReminderPatch;
};

/** The output of our update `Reminder` mutation. */
export type UpdateReminderPayload = {
  __typename?: 'UpdateReminderPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Reminder` that was updated by this mutation. */
  reminder?: Maybe<Reminder>;
  /** An edge for our `Reminder`. May be used by Relay 1. */
  reminderEdge?: Maybe<RemindersEdge>;
  /** Reads a single `User` that is related to this `Reminder`. */
  user?: Maybe<User>;
};


/** The output of our update `Reminder` mutation. */
export type UpdateReminderPayloadReminderEdgeArgs = {
  orderBy?: InputMaybe<Array<RemindersOrderBy>>;
};

/** All input for the `updateSupplier` mutation. */
export type UpdateSupplierInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `Supplier` being updated. */
  patch: SupplierPatch;
};

/** All input for the `updateSupplierInvoice` mutation. */
export type UpdateSupplierInvoiceInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `SupplierInvoice` being updated. */
  patch: SupplierInvoicePatch;
};

/** The output of our update `SupplierInvoice` mutation. */
export type UpdateSupplierInvoicePayload = {
  __typename?: 'UpdateSupplierInvoicePayload';
  /** Reads a single `FinanceCategory` that is related to this `SupplierInvoice`. */
  category?: Maybe<FinanceCategory>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `MediaItem` that is related to this `SupplierInvoice`. */
  mediaItem?: Maybe<MediaItem>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Supplier` that is related to this `SupplierInvoice`. */
  supplier?: Maybe<Supplier>;
  /** The `SupplierInvoice` that was updated by this mutation. */
  supplierInvoice?: Maybe<SupplierInvoice>;
  /** An edge for our `SupplierInvoice`. May be used by Relay 1. */
  supplierInvoiceEdge?: Maybe<SupplierInvoicesEdge>;
  /** Reads a single `Trip` that is related to this `SupplierInvoice`. */
  trip?: Maybe<Trip>;
};


/** The output of our update `SupplierInvoice` mutation. */
export type UpdateSupplierInvoicePayloadSupplierInvoiceEdgeArgs = {
  orderBy?: InputMaybe<Array<SupplierInvoicesOrderBy>>;
};

/** The output of our update `Supplier` mutation. */
export type UpdateSupplierPayload = {
  __typename?: 'UpdateSupplierPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `MediaGallery` that is related to this `Supplier`. */
  gallery?: Maybe<MediaGallery>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Supplier` that was updated by this mutation. */
  supplier?: Maybe<Supplier>;
  /** An edge for our `Supplier`. May be used by Relay 1. */
  supplierEdge?: Maybe<SuppliersEdge>;
};


/** The output of our update `Supplier` mutation. */
export type UpdateSupplierPayloadSupplierEdgeArgs = {
  orderBy?: InputMaybe<Array<SuppliersOrderBy>>;
};

/** All input for the `updateTestimonial` mutation. */
export type UpdateTestimonialInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `Testimonial` being updated. */
  patch: TestimonialPatch;
};

/** The output of our update `Testimonial` mutation. */
export type UpdateTestimonialPayload = {
  __typename?: 'UpdateTestimonialPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Testimonial` that was updated by this mutation. */
  testimonial?: Maybe<Testimonial>;
  /** An edge for our `Testimonial`. May be used by Relay 1. */
  testimonialEdge?: Maybe<TestimonialsEdge>;
  /** Reads a single `Trip` that is related to this `Testimonial`. */
  trip?: Maybe<Trip>;
};


/** The output of our update `Testimonial` mutation. */
export type UpdateTestimonialPayloadTestimonialEdgeArgs = {
  orderBy?: InputMaybe<Array<TestimonialsOrderBy>>;
};

/** All input for the `updateTimezone` mutation. */
export type UpdateTimezoneInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  ogcFid: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `Timezone` being updated. */
  patch: TimezonePatch;
};

/** The output of our update `Timezone` mutation. */
export type UpdateTimezonePayload = {
  __typename?: 'UpdateTimezonePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Timezone` that was updated by this mutation. */
  timezone?: Maybe<Timezone>;
  /** An edge for our `Timezone`. May be used by Relay 1. */
  timezoneEdge?: Maybe<TimezonesEdge>;
};


/** The output of our update `Timezone` mutation. */
export type UpdateTimezonePayloadTimezoneEdgeArgs = {
  orderBy?: InputMaybe<Array<TimezonesOrderBy>>;
};

/** All input for the `updateTransactionImportBatch` mutation. */
export type UpdateTransactionImportBatchInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `TransactionImportBatch` being updated. */
  patch: TransactionImportBatchPatch;
};

/** The output of our update `TransactionImportBatch` mutation. */
export type UpdateTransactionImportBatchPayload = {
  __typename?: 'UpdateTransactionImportBatchPayload';
  /** Reads a single `Account` that is related to this `TransactionImportBatch`. */
  account?: Maybe<Account>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `TransactionImportBatch` that was updated by this mutation. */
  transactionImportBatch?: Maybe<TransactionImportBatch>;
  /** An edge for our `TransactionImportBatch`. May be used by Relay 1. */
  transactionImportBatchEdge?: Maybe<TransactionImportBatchesEdge>;
};


/** The output of our update `TransactionImportBatch` mutation. */
export type UpdateTransactionImportBatchPayloadTransactionImportBatchEdgeArgs = {
  orderBy?: InputMaybe<Array<TransactionImportBatchesOrderBy>>;
};

/** All input for the `updateTransaction` mutation. */
export type UpdateTransactionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `Transaction` being updated. */
  patch: TransactionPatch;
};

/** All input for the `updateTransactionLink` mutation. */
export type UpdateTransactionLinkInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `TransactionLink` being updated. */
  patch: TransactionLinkPatch;
};

/** The output of our update `TransactionLink` mutation. */
export type UpdateTransactionLinkPayload = {
  __typename?: 'UpdateTransactionLinkPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Expense` that is related to this `TransactionLink`. */
  expense?: Maybe<Expense>;
  /** Reads a single `Invoice` that is related to this `TransactionLink`. */
  invoice?: Maybe<Invoice>;
  /** Reads a single `Payment` that is related to this `TransactionLink`. */
  payment?: Maybe<Payment>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `SupplierInvoice` that is related to this `TransactionLink`. */
  supplierInvoice?: Maybe<SupplierInvoice>;
  /** Reads a single `Transaction` that is related to this `TransactionLink`. */
  transaction?: Maybe<Transaction>;
  /** The `TransactionLink` that was updated by this mutation. */
  transactionLink?: Maybe<TransactionLink>;
  /** An edge for our `TransactionLink`. May be used by Relay 1. */
  transactionLinkEdge?: Maybe<TransactionLinksEdge>;
};


/** The output of our update `TransactionLink` mutation. */
export type UpdateTransactionLinkPayloadTransactionLinkEdgeArgs = {
  orderBy?: InputMaybe<Array<TransactionLinksOrderBy>>;
};

/** All input for the `updateTransactionNote` mutation. */
export type UpdateTransactionNoteInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `TransactionNote` being updated. */
  patch: TransactionNotePatch;
};

/** The output of our update `TransactionNote` mutation. */
export type UpdateTransactionNotePayload = {
  __typename?: 'UpdateTransactionNotePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Transaction` that is related to this `TransactionNote`. */
  transaction?: Maybe<Transaction>;
  /** The `TransactionNote` that was updated by this mutation. */
  transactionNote?: Maybe<TransactionNote>;
  /** An edge for our `TransactionNote`. May be used by Relay 1. */
  transactionNoteEdge?: Maybe<TransactionNotesEdge>;
  /** Reads a single `User` that is related to this `TransactionNote`. */
  user?: Maybe<User>;
};


/** The output of our update `TransactionNote` mutation. */
export type UpdateTransactionNotePayloadTransactionNoteEdgeArgs = {
  orderBy?: InputMaybe<Array<TransactionNotesOrderBy>>;
};

/** The output of our update `Transaction` mutation. */
export type UpdateTransactionPayload = {
  __typename?: 'UpdateTransactionPayload';
  /** Reads a single `Account` that is related to this `Transaction`. */
  account?: Maybe<Account>;
  /** Reads a single `FinanceCategory` that is related to this `Transaction`. */
  category?: Maybe<FinanceCategory>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Transaction` that is related to this `Transaction`. */
  reverseTransaction?: Maybe<Transaction>;
  /** The `Transaction` that was updated by this mutation. */
  transaction?: Maybe<Transaction>;
  /** An edge for our `Transaction`. May be used by Relay 1. */
  transactionEdge?: Maybe<TransactionsEdge>;
  /** Reads a single `TransactionImportBatch` that is related to this `Transaction`. */
  transactionImportBatch?: Maybe<TransactionImportBatch>;
};


/** The output of our update `Transaction` mutation. */
export type UpdateTransactionPayloadTransactionEdgeArgs = {
  orderBy?: InputMaybe<Array<TransactionsOrderBy>>;
};

/** All input for the `updateTraveller` mutation. */
export type UpdateTravellerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `Traveller` being updated. */
  patch: TravellerPatch;
};

/** The output of our update `Traveller` mutation. */
export type UpdateTravellerPayload = {
  __typename?: 'UpdateTravellerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Traveller` that was updated by this mutation. */
  traveller?: Maybe<Traveller>;
  /** An edge for our `Traveller`. May be used by Relay 1. */
  travellerEdge?: Maybe<TravellersEdge>;
};


/** The output of our update `Traveller` mutation. */
export type UpdateTravellerPayloadTravellerEdgeArgs = {
  orderBy?: InputMaybe<Array<TravellersOrderBy>>;
};

/** All input for the `updateTripFlight` mutation. */
export type UpdateTripFlightInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `TripFlight` being updated. */
  patch: TripFlightPatch;
};

/** The output of our update `TripFlight` mutation. */
export type UpdateTripFlightPayload = {
  __typename?: 'UpdateTripFlightPayload';
  /** Reads a single `Airport` that is related to this `TripFlight`. */
  arrivalAirport?: Maybe<Airport>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Airport` that is related to this `TripFlight`. */
  departureAirport?: Maybe<Airport>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Trip` that is related to this `TripFlight`. */
  trip?: Maybe<Trip>;
  /** The `TripFlight` that was updated by this mutation. */
  tripFlight?: Maybe<TripFlight>;
  /** An edge for our `TripFlight`. May be used by Relay 1. */
  tripFlightEdge?: Maybe<TripFlightsEdge>;
};


/** The output of our update `TripFlight` mutation. */
export type UpdateTripFlightPayloadTripFlightEdgeArgs = {
  orderBy?: InputMaybe<Array<TripFlightsOrderBy>>;
};

/** All input for the `updateTrip` mutation. */
export type UpdateTripInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `Trip` being updated. */
  patch: TripPatch;
};

/** The output of our update `Trip` mutation. */
export type UpdateTripPayload = {
  __typename?: 'UpdateTripPayload';
  /** Reads a single `Quote` that is related to this `Trip`. */
  activeQuote?: Maybe<Quote>;
  /** Reads a single `Agency` that is related to this `Trip`. */
  agency?: Maybe<Agency>;
  /** Reads a single `AgencyMember` that is related to this `Trip`. */
  agencyMember?: Maybe<AgencyMember>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Customer` that is related to this `Trip`. */
  customer?: Maybe<Customer>;
  /** Reads a single `MediaGallery` that is related to this `Trip`. */
  mediaGallery?: Maybe<MediaGallery>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Trip` that was updated by this mutation. */
  trip?: Maybe<Trip>;
  /** An edge for our `Trip`. May be used by Relay 1. */
  tripEdge?: Maybe<TripsEdge>;
  /** Reads a single `User` that is related to this `Trip`. */
  user?: Maybe<User>;
};


/** The output of our update `Trip` mutation. */
export type UpdateTripPayloadTripEdgeArgs = {
  orderBy?: InputMaybe<Array<TripsOrderBy>>;
};

/** All input for the `updateTripTraveller` mutation. */
export type UpdateTripTravellerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `TripTraveller` being updated. */
  patch: TripTravellerPatch;
};

/** The output of our update `TripTraveller` mutation. */
export type UpdateTripTravellerPayload = {
  __typename?: 'UpdateTripTravellerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Traveller` that is related to this `TripTraveller`. */
  traveller?: Maybe<Traveller>;
  /** Reads a single `Trip` that is related to this `TripTraveller`. */
  trip?: Maybe<Trip>;
  /** The `TripTraveller` that was updated by this mutation. */
  tripTraveller?: Maybe<TripTraveller>;
  /** An edge for our `TripTraveller`. May be used by Relay 1. */
  tripTravellerEdge?: Maybe<TripTravellersEdge>;
};


/** The output of our update `TripTraveller` mutation. */
export type UpdateTripTravellerPayloadTripTravellerEdgeArgs = {
  orderBy?: InputMaybe<Array<TripTravellersOrderBy>>;
};

/** All input for the `updateUser` mutation. */
export type UpdateUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `User` being updated. */
  patch: UserPatch;
};

/** The output of our update `User` mutation. */
export type UpdateUserPayload = {
  __typename?: 'UpdateUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `User` that was updated by this mutation. */
  user?: Maybe<User>;
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge?: Maybe<UsersEdge>;
};


/** The output of our update `User` mutation. */
export type UpdateUserPayloadUserEdgeArgs = {
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

/** All input for the `updateVisaRequirement` mutation. */
export type UpdateVisaRequirementInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `VisaRequirement` being updated. */
  patch: VisaRequirementPatch;
};

/** The output of our update `VisaRequirement` mutation. */
export type UpdateVisaRequirementPayload = {
  __typename?: 'UpdateVisaRequirementPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `VisaRequirement` that was updated by this mutation. */
  visaRequirement?: Maybe<VisaRequirement>;
  /** An edge for our `VisaRequirement`. May be used by Relay 1. */
  visaRequirementEdge?: Maybe<VisaRequirementsEdge>;
};


/** The output of our update `VisaRequirement` mutation. */
export type UpdateVisaRequirementPayloadVisaRequirementEdgeArgs = {
  orderBy?: InputMaybe<Array<VisaRequirementsOrderBy>>;
};

export type User = {
  __typename?: 'User';
  created: Scalars['Datetime']['output'];
  email?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `Email`. */
  emails: EmailsConnection;
  externalId?: Maybe<Scalars['String']['output']>;
  firstName?: Maybe<Scalars['String']['output']>;
  genderPreposition?: Maybe<Scalars['String']['output']>;
  id: Scalars['UUID']['output'];
  lastName?: Maybe<Scalars['String']['output']>;
  modified: Scalars['Datetime']['output'];
  name: Scalars['String']['output'];
  /** Reads and enables pagination through a set of `Note`. */
  notes: NotesConnection;
  password?: Maybe<Scalars['String']['output']>;
  phone?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `QuotePublic`. */
  quotePublics: QuotePublicsConnection;
  /** Reads and enables pagination through a set of `Quote`. */
  quotes: QuotesConnection;
  /** Reads and enables pagination through a set of `Reminder`. */
  reminders: RemindersConnection;
  skype?: Maybe<Scalars['String']['output']>;
  title?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `TransactionNote`. */
  transactionNotes: TransactionNotesConnection;
  /** Reads and enables pagination through a set of `Trip`. */
  trips: TripsConnection;
};


export type UserEmailsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EmailCondition>;
  filter?: InputMaybe<EmailFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EmailsOrderBy>>;
};


export type UserNotesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<NoteCondition>;
  filter?: InputMaybe<NoteFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<NotesOrderBy>>;
};


export type UserQuotePublicsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<QuotePublicCondition>;
  filter?: InputMaybe<QuotePublicFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuotePublicsOrderBy>>;
};


export type UserQuotesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<QuoteCondition>;
  filter?: InputMaybe<QuoteFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<QuotesOrderBy>>;
};


export type UserRemindersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ReminderCondition>;
  filter?: InputMaybe<ReminderFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<RemindersOrderBy>>;
};


export type UserTransactionNotesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TransactionNoteCondition>;
  filter?: InputMaybe<TransactionNoteFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TransactionNotesOrderBy>>;
};


export type UserTripsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TripCondition>;
  filter?: InputMaybe<TripFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TripsOrderBy>>;
};

/** A condition to be used against `User` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type UserCondition = {
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `email` field. */
  email?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `externalId` field. */
  externalId?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `firstName` field. */
  firstName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `genderPreposition` field. */
  genderPreposition?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `lastName` field. */
  lastName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `password` field. */
  password?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `phone` field. */
  phone?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `skype` field. */
  skype?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `title` field. */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `User` object types. All fields are combined with a logical ‘and.’ */
export type UserFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<UserFilter>>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `email` field. */
  email?: InputMaybe<StringFilter>;
  /** Filter by the object’s `emails` relation. */
  emails?: InputMaybe<UserToManyEmailFilter>;
  /** Some related `emails` exist. */
  emailsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `externalId` field. */
  externalId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `firstName` field. */
  firstName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `genderPreposition` field. */
  genderPreposition?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `lastName` field. */
  lastName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<UserFilter>;
  /** Filter by the object’s `notes` relation. */
  notes?: InputMaybe<UserToManyNoteFilter>;
  /** Some related `notes` exist. */
  notesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<UserFilter>>;
  /** Filter by the object’s `password` field. */
  password?: InputMaybe<StringFilter>;
  /** Filter by the object’s `phone` field. */
  phone?: InputMaybe<StringFilter>;
  /** Filter by the object’s `quotePublics` relation. */
  quotePublics?: InputMaybe<UserToManyQuotePublicFilter>;
  /** Some related `quotePublics` exist. */
  quotePublicsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `quotes` relation. */
  quotes?: InputMaybe<UserToManyQuoteFilter>;
  /** Some related `quotes` exist. */
  quotesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `reminders` relation. */
  reminders?: InputMaybe<UserToManyReminderFilter>;
  /** Some related `reminders` exist. */
  remindersExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `skype` field. */
  skype?: InputMaybe<StringFilter>;
  /** Filter by the object’s `title` field. */
  title?: InputMaybe<StringFilter>;
  /** Filter by the object’s `transactionNotes` relation. */
  transactionNotes?: InputMaybe<UserToManyTransactionNoteFilter>;
  /** Some related `transactionNotes` exist. */
  transactionNotesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `trips` relation. */
  trips?: InputMaybe<UserToManyTripFilter>;
  /** Some related `trips` exist. */
  tripsExist?: InputMaybe<Scalars['Boolean']['input']>;
};

/** An input for mutations affecting `User` */
export type UserInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  emailsUsingId?: InputMaybe<FkEmailUserUserIdInverseInput>;
  externalId?: InputMaybe<Scalars['String']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  genderPreposition?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name: Scalars['String']['input'];
  notesUsingId?: InputMaybe<FkNoteUserUserIdInverseInput>;
  password?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  quotePublicsUsingId?: InputMaybe<FakePublicQuotePublicForeignKey2InverseInput>;
  quotesUsingId?: InputMaybe<FkQuoteUserUserIdInverseInput>;
  remindersUsingId?: InputMaybe<FkReminderUserUserIdInverseInput>;
  skype?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  transactionNotesUsingId?: InputMaybe<FkTransactionNoteUserUserIdInverseInput>;
  tripsUsingId?: InputMaybe<FkTripUserUserIdInverseInput>;
};

/** The fields on `user` to look up the row to update. */
export type UserOnEmailForFkEmailUserUserIdUsingPkUserUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnEmailForFkEmailUserUserIdPatch;
};

/** The fields on `user` to look up the row to update. */
export type UserOnNoteForFkNoteUserUserIdUsingPkUserUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnNoteForFkNoteUserUserIdPatch;
};

/** The fields on `user` to look up the row to update. */
export type UserOnQuoteForFkQuoteUserUserIdUsingPkUserUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnQuoteForFkQuoteUserUserIdPatch;
};

/** The fields on `user` to look up the row to update. */
export type UserOnQuotePublicForFakePublicQuotePublicForeignKey2UsingPkUserUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnQuotePublicForFakePublicQuotePublicForeignKey2Patch;
};

/** The fields on `user` to look up the row to update. */
export type UserOnReminderForFkReminderUserUserIdUsingPkUserUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnReminderForFkReminderUserUserIdPatch;
};

/** The fields on `user` to look up the row to update. */
export type UserOnTransactionNoteForFkTransactionNoteUserUserIdUsingPkUserUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnTransactionNoteForFkTransactionNoteUserUserIdPatch;
};

/** The fields on `user` to look up the row to update. */
export type UserOnTripForFkTripUserUserIdUsingPkUserUpdate = {
  id: Scalars['UUID']['input'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnTripForFkTripUserUserIdPatch;
};

/** Represents an update to a `User`. Fields that are set will be updated. */
export type UserPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  emailsUsingId?: InputMaybe<FkEmailUserUserIdInverseInput>;
  externalId?: InputMaybe<Scalars['String']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  genderPreposition?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notesUsingId?: InputMaybe<FkNoteUserUserIdInverseInput>;
  password?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  quotePublicsUsingId?: InputMaybe<FakePublicQuotePublicForeignKey2InverseInput>;
  quotesUsingId?: InputMaybe<FkQuoteUserUserIdInverseInput>;
  remindersUsingId?: InputMaybe<FkReminderUserUserIdInverseInput>;
  skype?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  transactionNotesUsingId?: InputMaybe<FkTransactionNoteUserUserIdInverseInput>;
  tripsUsingId?: InputMaybe<FkTripUserUserIdInverseInput>;
};

/** The fields on `user` to look up the row to connect. */
export type UserPkUserConnect = {
  id: Scalars['UUID']['input'];
};

/** The fields on `user` to look up the row to delete. */
export type UserPkUserDelete = {
  id: Scalars['UUID']['input'];
};

/** A filter to be used against many `Email` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyEmailFilter = {
  /** Every related `Email` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<EmailFilter>;
  /** No related `Email` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<EmailFilter>;
  /** Some related `Email` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<EmailFilter>;
};

/** A filter to be used against many `Note` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyNoteFilter = {
  /** Every related `Note` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<NoteFilter>;
  /** No related `Note` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<NoteFilter>;
  /** Some related `Note` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<NoteFilter>;
};

/** A filter to be used against many `Quote` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyQuoteFilter = {
  /** Every related `Quote` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<QuoteFilter>;
  /** No related `Quote` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<QuoteFilter>;
  /** Some related `Quote` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<QuoteFilter>;
};

/** A filter to be used against many `QuotePublic` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyQuotePublicFilter = {
  /** Every related `QuotePublic` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<QuotePublicFilter>;
  /** No related `QuotePublic` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<QuotePublicFilter>;
  /** Some related `QuotePublic` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<QuotePublicFilter>;
};

/** A filter to be used against many `Reminder` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyReminderFilter = {
  /** Every related `Reminder` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ReminderFilter>;
  /** No related `Reminder` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ReminderFilter>;
  /** Some related `Reminder` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ReminderFilter>;
};

/** A filter to be used against many `TransactionNote` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyTransactionNoteFilter = {
  /** Every related `TransactionNote` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<TransactionNoteFilter>;
  /** No related `TransactionNote` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<TransactionNoteFilter>;
  /** Some related `TransactionNote` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<TransactionNoteFilter>;
};

/** A filter to be used against many `Trip` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyTripFilter = {
  /** Every related `Trip` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<TripFilter>;
  /** No related `Trip` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<TripFilter>;
  /** Some related `Trip` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<TripFilter>;
};

/** A connection to a list of `User` values. */
export type UsersConnection = {
  __typename?: 'UsersConnection';
  /** A list of edges which contains the `User` and cursor to aid in pagination. */
  edges: Array<UsersEdge>;
  /** A list of `User` objects. */
  nodes: Array<Maybe<User>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `User` edge in the connection. */
export type UsersEdge = {
  __typename?: 'UsersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `User` at the end of the edge. */
  node?: Maybe<User>;
};

/** Methods to use when ordering `User`. */
export enum UsersOrderBy {
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  EmailsByUserIdCountAsc = 'EMAILS_BY_USER_ID__COUNT_ASC',
  EmailsByUserIdCountDesc = 'EMAILS_BY_USER_ID__COUNT_DESC',
  EmailAsc = 'EMAIL_ASC',
  EmailDesc = 'EMAIL_DESC',
  ExternalIdAsc = 'EXTERNAL_ID_ASC',
  ExternalIdDesc = 'EXTERNAL_ID_DESC',
  FirstNameAsc = 'FIRST_NAME_ASC',
  FirstNameDesc = 'FIRST_NAME_DESC',
  GenderPrepositionAsc = 'GENDER_PREPOSITION_ASC',
  GenderPrepositionDesc = 'GENDER_PREPOSITION_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LastNameAsc = 'LAST_NAME_ASC',
  LastNameDesc = 'LAST_NAME_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  NotesByUserIdCountAsc = 'NOTES_BY_USER_ID__COUNT_ASC',
  NotesByUserIdCountDesc = 'NOTES_BY_USER_ID__COUNT_DESC',
  PasswordAsc = 'PASSWORD_ASC',
  PasswordDesc = 'PASSWORD_DESC',
  PhoneAsc = 'PHONE_ASC',
  PhoneDesc = 'PHONE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QuotesByUserIdCountAsc = 'QUOTES_BY_USER_ID__COUNT_ASC',
  QuotesByUserIdCountDesc = 'QUOTES_BY_USER_ID__COUNT_DESC',
  QuotePublicsByUserIdCountAsc = 'QUOTE_PUBLICS_BY_USER_ID__COUNT_ASC',
  QuotePublicsByUserIdCountDesc = 'QUOTE_PUBLICS_BY_USER_ID__COUNT_DESC',
  RemindersByUserIdCountAsc = 'REMINDERS_BY_USER_ID__COUNT_ASC',
  RemindersByUserIdCountDesc = 'REMINDERS_BY_USER_ID__COUNT_DESC',
  SkypeAsc = 'SKYPE_ASC',
  SkypeDesc = 'SKYPE_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC',
  TransactionNotesByUserIdCountAsc = 'TRANSACTION_NOTES_BY_USER_ID__COUNT_ASC',
  TransactionNotesByUserIdCountDesc = 'TRANSACTION_NOTES_BY_USER_ID__COUNT_DESC',
  TripsByUserIdCountAsc = 'TRIPS_BY_USER_ID__COUNT_ASC',
  TripsByUserIdCountDesc = 'TRIPS_BY_USER_ID__COUNT_DESC'
}

export type VisaRequirement = {
  __typename?: 'VisaRequirement';
  created: Scalars['Datetime']['output'];
  destinationCountries?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  detail?: Maybe<Scalars['String']['output']>;
  id: Scalars['UUID']['output'];
  lastVerified: Scalars['Datetime']['output'];
  modified: Scalars['Datetime']['output'];
  passportCountries?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

/**
 * A condition to be used against `VisaRequirement` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type VisaRequirementCondition = {
  /** Checks for equality with the object’s `created` field. */
  created?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `destinationCountries` field. */
  destinationCountries?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Checks for equality with the object’s `detail` field. */
  detail?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Checks for equality with the object’s `lastVerified` field. */
  lastVerified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `modified` field. */
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `passportCountries` field. */
  passportCountries?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** A filter to be used against `VisaRequirement` object types. All fields are combined with a logical ‘and.’ */
export type VisaRequirementFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<VisaRequirementFilter>>;
  /** Filter by the object’s `created` field. */
  created?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `destinationCountries` field. */
  destinationCountries?: InputMaybe<StringListFilter>;
  /** Filter by the object’s `detail` field. */
  detail?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<UuidFilter>;
  /** Filter by the object’s `lastVerified` field. */
  lastVerified?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `modified` field. */
  modified?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<VisaRequirementFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<VisaRequirementFilter>>;
  /** Filter by the object’s `passportCountries` field. */
  passportCountries?: InputMaybe<StringListFilter>;
};

/** An input for mutations affecting `VisaRequirement` */
export type VisaRequirementInput = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationCountries?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  detail?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  lastVerified: Scalars['Datetime']['input'];
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  passportCountries?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** Represents an update to a `VisaRequirement`. Fields that are set will be updated. */
export type VisaRequirementPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationCountries?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  detail?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  lastVerified?: InputMaybe<Scalars['Datetime']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  passportCountries?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** A connection to a list of `VisaRequirement` values. */
export type VisaRequirementsConnection = {
  __typename?: 'VisaRequirementsConnection';
  /** A list of edges which contains the `VisaRequirement` and cursor to aid in pagination. */
  edges: Array<VisaRequirementsEdge>;
  /** A list of `VisaRequirement` objects. */
  nodes: Array<Maybe<VisaRequirement>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `VisaRequirement` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `VisaRequirement` edge in the connection. */
export type VisaRequirementsEdge = {
  __typename?: 'VisaRequirementsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `VisaRequirement` at the end of the edge. */
  node?: Maybe<VisaRequirement>;
};

/** Methods to use when ordering `VisaRequirement`. */
export enum VisaRequirementsOrderBy {
  CreatedAsc = 'CREATED_ASC',
  CreatedDesc = 'CREATED_DESC',
  DestinationCountriesAsc = 'DESTINATION_COUNTRIES_ASC',
  DestinationCountriesDesc = 'DESTINATION_COUNTRIES_DESC',
  DetailAsc = 'DETAIL_ASC',
  DetailDesc = 'DETAIL_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LastVerifiedAsc = 'LAST_VERIFIED_ASC',
  LastVerifiedDesc = 'LAST_VERIFIED_DESC',
  ModifiedAsc = 'MODIFIED_ASC',
  ModifiedDesc = 'MODIFIED_DESC',
  Natural = 'NATURAL',
  PassportCountriesAsc = 'PASSPORT_COUNTRIES_ASC',
  PassportCountriesDesc = 'PASSPORT_COUNTRIES_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** An object where the defined keys will be set on the `account` being updated. */
export type UpdateAccountOnTransactionForFkTransactionAccountAccountIdPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  details?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  institution?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  transactionImportBatchesUsingId?: InputMaybe<FkTransactionImportBatchAccountAccountIdInverseInput>;
  transactionsUsingId?: InputMaybe<FkTransactionAccountAccountIdInverseInput>;
};

/** An object where the defined keys will be set on the `account` being updated. */
export type UpdateAccountOnTransactionImportBatchForFkTransactionImportBatchAccountAccountIdPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  details?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  institution?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  transactionImportBatchesUsingId?: InputMaybe<FkTransactionImportBatchAccountAccountIdInverseInput>;
  transactionsUsingId?: InputMaybe<FkTransactionAccountAccountIdInverseInput>;
};

/** An object where the defined keys will be set on the `agencyMember` being updated. */
export type UpdateAgencyMemberOnAgencyMemberForFkAgencyMemberAgencyAgencyIdPatch = {
  agencyToAgencyId?: InputMaybe<FkAgencyMemberAgencyAgencyIdInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  genderPreposition?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  skype?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  tripsUsingId?: InputMaybe<FkTripAgencyMemberAgencyMemberIdInverseInput>;
};

/** An object where the defined keys will be set on the `agencyMember` being updated. */
export type UpdateAgencyMemberOnTripForFkTripAgencyMemberAgencyMemberIdPatch = {
  agencyId?: InputMaybe<Scalars['UUID']['input']>;
  agencyToAgencyId?: InputMaybe<FkAgencyMemberAgencyAgencyIdInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  genderPreposition?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  skype?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  tripsUsingId?: InputMaybe<FkTripAgencyMemberAgencyMemberIdInverseInput>;
};

/** An object where the defined keys will be set on the `agency` being updated. */
export type UpdateAgencyOnAgencyForFkAgencyMediaItemLogoIdPatch = {
  agencyMembersUsingId?: InputMaybe<FkAgencyMemberAgencyAgencyIdInverseInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  mediaItemToLogoId?: InputMaybe<FkAgencyMediaItemLogoIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  supplierId?: InputMaybe<Scalars['UUID']['input']>;
  supplierToSupplierId?: InputMaybe<FkAgencySupplierInput>;
  tripsUsingId?: InputMaybe<FkTripAgencyAgencyIdInverseInput>;
};

/** An object where the defined keys will be set on the `agency` being updated. */
export type UpdateAgencyOnAgencyForFkAgencySupplierPatch = {
  agencyMembersUsingId?: InputMaybe<FkAgencyMemberAgencyAgencyIdInverseInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  logoId?: InputMaybe<Scalars['UUID']['input']>;
  mediaItemToLogoId?: InputMaybe<FkAgencyMediaItemLogoIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  supplierToSupplierId?: InputMaybe<FkAgencySupplierInput>;
  tripsUsingId?: InputMaybe<FkTripAgencyAgencyIdInverseInput>;
};

/** An object where the defined keys will be set on the `agency` being updated. */
export type UpdateAgencyOnAgencyMemberForFkAgencyMemberAgencyAgencyIdPatch = {
  agencyMembersUsingId?: InputMaybe<FkAgencyMemberAgencyAgencyIdInverseInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  logoId?: InputMaybe<Scalars['UUID']['input']>;
  mediaItemToLogoId?: InputMaybe<FkAgencyMediaItemLogoIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  supplierId?: InputMaybe<Scalars['UUID']['input']>;
  supplierToSupplierId?: InputMaybe<FkAgencySupplierInput>;
  tripsUsingId?: InputMaybe<FkTripAgencyAgencyIdInverseInput>;
};

/** An object where the defined keys will be set on the `agency` being updated. */
export type UpdateAgencyOnTripForFkTripAgencyAgencyIdPatch = {
  agencyMembersUsingId?: InputMaybe<FkAgencyMemberAgencyAgencyIdInverseInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  logoId?: InputMaybe<Scalars['UUID']['input']>;
  mediaItemToLogoId?: InputMaybe<FkAgencyMediaItemLogoIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  supplierId?: InputMaybe<Scalars['UUID']['input']>;
  supplierToSupplierId?: InputMaybe<FkAgencySupplierInput>;
  tripsUsingId?: InputMaybe<FkTripAgencyAgencyIdInverseInput>;
};

/** An object where the defined keys will be set on the `airport` being updated. */
export type UpdateAirportOnAirportForFkAirportCountryCountryIdPatch = {
  city?: InputMaybe<Scalars['String']['input']>;
  countryToCountryId?: InputMaybe<FkAirportCountryCountryIdInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  displayName?: InputMaybe<Scalars['String']['input']>;
  iata?: InputMaybe<Scalars['String']['input']>;
  icao?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  latitude?: InputMaybe<Scalars['Float']['input']>;
  longitude?: InputMaybe<Scalars['Float']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  timezone?: InputMaybe<Scalars['String']['input']>;
  tripFlightsToArrivalAirportIdUsingId?: InputMaybe<TripFlightArrivalAirport2IdFkeyInverseInput>;
  tripFlightsToDepartureAirportIdUsingId?: InputMaybe<TripFlightDepartureAirport2IdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `airport` being updated. */
export type UpdateAirportOnTripFlightForTripFlightArrivalAirport2IdFkeyPatch = {
  city?: InputMaybe<Scalars['String']['input']>;
  countryId?: InputMaybe<Scalars['UUID']['input']>;
  countryToCountryId?: InputMaybe<FkAirportCountryCountryIdInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  displayName?: InputMaybe<Scalars['String']['input']>;
  iata?: InputMaybe<Scalars['String']['input']>;
  icao?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  latitude?: InputMaybe<Scalars['Float']['input']>;
  longitude?: InputMaybe<Scalars['Float']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  timezone?: InputMaybe<Scalars['String']['input']>;
  tripFlightsToArrivalAirportIdUsingId?: InputMaybe<TripFlightArrivalAirport2IdFkeyInverseInput>;
  tripFlightsToDepartureAirportIdUsingId?: InputMaybe<TripFlightDepartureAirport2IdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `airport` being updated. */
export type UpdateAirportOnTripFlightForTripFlightDepartureAirport2IdFkeyPatch = {
  city?: InputMaybe<Scalars['String']['input']>;
  countryId?: InputMaybe<Scalars['UUID']['input']>;
  countryToCountryId?: InputMaybe<FkAirportCountryCountryIdInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  displayName?: InputMaybe<Scalars['String']['input']>;
  iata?: InputMaybe<Scalars['String']['input']>;
  icao?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  latitude?: InputMaybe<Scalars['Float']['input']>;
  longitude?: InputMaybe<Scalars['Float']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  timezone?: InputMaybe<Scalars['String']['input']>;
  tripFlightsToArrivalAirportIdUsingId?: InputMaybe<TripFlightArrivalAirport2IdFkeyInverseInput>;
  tripFlightsToDepartureAirportIdUsingId?: InputMaybe<TripFlightDepartureAirport2IdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `country` being updated. */
export type UpdateCountryOnAirportForFkAirportCountryCountryIdPatch = {
  airportsUsingId?: InputMaybe<FkAirportCountryCountryIdInverseInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationsUsingId?: InputMaybe<FkDestinationCountryCountryIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  iso2?: InputMaybe<Scalars['String']['input']>;
  iso3?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  passportsUsingId?: InputMaybe<PassportCountry2IdFkeyInverseInput>;
  propertiesUsingId?: InputMaybe<FkPropertyCountryCountryIdInverseInput>;
};

/** An object where the defined keys will be set on the `country` being updated. */
export type UpdateCountryOnDestinationForFkDestinationCountryCountryIdPatch = {
  airportsUsingId?: InputMaybe<FkAirportCountryCountryIdInverseInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationsUsingId?: InputMaybe<FkDestinationCountryCountryIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  iso2?: InputMaybe<Scalars['String']['input']>;
  iso3?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  passportsUsingId?: InputMaybe<PassportCountry2IdFkeyInverseInput>;
  propertiesUsingId?: InputMaybe<FkPropertyCountryCountryIdInverseInput>;
};

/** An object where the defined keys will be set on the `country` being updated. */
export type UpdateCountryOnPassportForPassportCountry2IdFkeyPatch = {
  airportsUsingId?: InputMaybe<FkAirportCountryCountryIdInverseInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationsUsingId?: InputMaybe<FkDestinationCountryCountryIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  iso2?: InputMaybe<Scalars['String']['input']>;
  iso3?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  passportsUsingId?: InputMaybe<PassportCountry2IdFkeyInverseInput>;
  propertiesUsingId?: InputMaybe<FkPropertyCountryCountryIdInverseInput>;
};

/** An object where the defined keys will be set on the `country` being updated. */
export type UpdateCountryOnPropertyForFkPropertyCountryCountryIdPatch = {
  airportsUsingId?: InputMaybe<FkAirportCountryCountryIdInverseInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationsUsingId?: InputMaybe<FkDestinationCountryCountryIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  iso2?: InputMaybe<Scalars['String']['input']>;
  iso3?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  passportsUsingId?: InputMaybe<PassportCountry2IdFkeyInverseInput>;
  propertiesUsingId?: InputMaybe<FkPropertyCountryCountryIdInverseInput>;
};

/** An object where the defined keys will be set on the `customer` being updated. */
export type UpdateCustomerOnCustomerTravellerForFkCustomerTravellerCustomerCustomerIdPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerTravellersUsingId?: InputMaybe<FkCustomerTravellerCustomerCustomerIdInverseInput>;
  email?: InputMaybe<Scalars['String']['input']>;
  emailsUsingId?: InputMaybe<FkEmailCustomerCustomerIdInverseInput>;
  enquiriesUsingId?: InputMaybe<FkEnquiryCustomerCustomerIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  tripsUsingId?: InputMaybe<FkTripCustomerCustomerIdInverseInput>;
};

/** An object where the defined keys will be set on the `customer` being updated. */
export type UpdateCustomerOnEmailForFkEmailCustomerCustomerIdPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerTravellersUsingId?: InputMaybe<FkCustomerTravellerCustomerCustomerIdInverseInput>;
  email?: InputMaybe<Scalars['String']['input']>;
  emailsUsingId?: InputMaybe<FkEmailCustomerCustomerIdInverseInput>;
  enquiriesUsingId?: InputMaybe<FkEnquiryCustomerCustomerIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  tripsUsingId?: InputMaybe<FkTripCustomerCustomerIdInverseInput>;
};

/** An object where the defined keys will be set on the `customer` being updated. */
export type UpdateCustomerOnEnquiryForFkEnquiryCustomerCustomerIdPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerTravellersUsingId?: InputMaybe<FkCustomerTravellerCustomerCustomerIdInverseInput>;
  email?: InputMaybe<Scalars['String']['input']>;
  emailsUsingId?: InputMaybe<FkEmailCustomerCustomerIdInverseInput>;
  enquiriesUsingId?: InputMaybe<FkEnquiryCustomerCustomerIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  tripsUsingId?: InputMaybe<FkTripCustomerCustomerIdInverseInput>;
};

/** An object where the defined keys will be set on the `customer` being updated. */
export type UpdateCustomerOnTripForFkTripCustomerCustomerIdPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerTravellersUsingId?: InputMaybe<FkCustomerTravellerCustomerCustomerIdInverseInput>;
  email?: InputMaybe<Scalars['String']['input']>;
  emailsUsingId?: InputMaybe<FkEmailCustomerCustomerIdInverseInput>;
  enquiriesUsingId?: InputMaybe<FkEnquiryCustomerCustomerIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  tripsUsingId?: InputMaybe<FkTripCustomerCustomerIdInverseInput>;
};

/** An object where the defined keys will be set on the `customerTraveller` being updated. */
export type UpdateCustomerTravellerOnCustomerTravellerForFkCustomerTravellerCustomerCustomerIdPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerToCustomerId?: InputMaybe<FkCustomerTravellerCustomerCustomerIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  travellerId?: InputMaybe<Scalars['UUID']['input']>;
  travellerToTravellerId?: InputMaybe<FkCustomerTravellerTravellerTravellerIdInput>;
};

/** An object where the defined keys will be set on the `customerTraveller` being updated. */
export type UpdateCustomerTravellerOnCustomerTravellerForFkCustomerTravellerTravellerTravellerIdPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerId?: InputMaybe<Scalars['UUID']['input']>;
  customerToCustomerId?: InputMaybe<FkCustomerTravellerCustomerCustomerIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  travellerToTravellerId?: InputMaybe<FkCustomerTravellerTravellerTravellerIdInput>;
};

/** An object where the defined keys will be set on the `destinationFeature` being updated. */
export type UpdateDestinationFeatureOnDestinationFeatureForFkDestinationFeatureDestinationDestinationIdPatch = {
  body?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationToDestinationId?: InputMaybe<FkDestinationFeatureDestinationDestinationIdInput>;
  galleryId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryToGalleryId?: InputMaybe<FkDestinationFeatureMediaGalleryGalleryIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** An object where the defined keys will be set on the `destinationFeature` being updated. */
export type UpdateDestinationFeatureOnDestinationFeatureForFkDestinationFeatureMediaGalleryGalleryIdPatch = {
  body?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationId?: InputMaybe<Scalars['UUID']['input']>;
  destinationToDestinationId?: InputMaybe<FkDestinationFeatureDestinationDestinationIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryToGalleryId?: InputMaybe<FkDestinationFeatureMediaGalleryGalleryIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** An object where the defined keys will be set on the `destinationGuide` being updated. */
export type UpdateDestinationGuideOnDestinationGuideForFkDestinationGuideDestinationDestinationIdPatch = {
  body?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationToDestinationId?: InputMaybe<FkDestinationGuideDestinationDestinationIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** An object where the defined keys will be set on the `destination` being updated. */
export type UpdateDestinationOnDestinationFeatureForFkDestinationFeatureDestinationDestinationIdPatch = {
  alias?: InputMaybe<Scalars['String']['input']>;
  body?: InputMaybe<Scalars['String']['input']>;
  countryId?: InputMaybe<Scalars['UUID']['input']>;
  countryToCountryId?: InputMaybe<FkDestinationCountryCountryIdInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationFeaturesUsingId?: InputMaybe<FkDestinationFeatureDestinationDestinationIdInverseInput>;
  destinationGuidesUsingId?: InputMaybe<FkDestinationGuideDestinationDestinationIdInverseInput>;
  destinationToParentId?: InputMaybe<FkDestinationDestinationParentIdInput>;
  galleryId?: InputMaybe<Scalars['UUID']['input']>;
  heroMediaId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  latitude?: InputMaybe<Scalars['Float']['input']>;
  longitude?: InputMaybe<Scalars['Float']['input']>;
  mediaGalleryToGalleryId?: InputMaybe<FkDestinationMediaGalleryGalleryIdInput>;
  mediaItemToHeroMediaId?: InputMaybe<DestinationHeroMediaIdFkeyInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  parentId?: InputMaybe<Scalars['UUID']['input']>;
  propertiesUsingId?: InputMaybe<FkPropertyDestinationInverseInput>;
  quoteDayDestinationsUsingId?: InputMaybe<FkQuoteDayDestinationDestinationDestinationIdInverseInput>;
};

/** An object where the defined keys will be set on the `destination` being updated. */
export type UpdateDestinationOnDestinationForDestinationHeroMediaIdFkeyPatch = {
  alias?: InputMaybe<Scalars['String']['input']>;
  body?: InputMaybe<Scalars['String']['input']>;
  countryId?: InputMaybe<Scalars['UUID']['input']>;
  countryToCountryId?: InputMaybe<FkDestinationCountryCountryIdInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationFeaturesUsingId?: InputMaybe<FkDestinationFeatureDestinationDestinationIdInverseInput>;
  destinationGuidesUsingId?: InputMaybe<FkDestinationGuideDestinationDestinationIdInverseInput>;
  destinationToParentId?: InputMaybe<FkDestinationDestinationParentIdInput>;
  galleryId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  latitude?: InputMaybe<Scalars['Float']['input']>;
  longitude?: InputMaybe<Scalars['Float']['input']>;
  mediaGalleryToGalleryId?: InputMaybe<FkDestinationMediaGalleryGalleryIdInput>;
  mediaItemToHeroMediaId?: InputMaybe<DestinationHeroMediaIdFkeyInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  parentId?: InputMaybe<Scalars['UUID']['input']>;
  propertiesUsingId?: InputMaybe<FkPropertyDestinationInverseInput>;
  quoteDayDestinationsUsingId?: InputMaybe<FkQuoteDayDestinationDestinationDestinationIdInverseInput>;
};

/** An object where the defined keys will be set on the `destination` being updated. */
export type UpdateDestinationOnDestinationForFkDestinationCountryCountryIdPatch = {
  alias?: InputMaybe<Scalars['String']['input']>;
  body?: InputMaybe<Scalars['String']['input']>;
  countryToCountryId?: InputMaybe<FkDestinationCountryCountryIdInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationFeaturesUsingId?: InputMaybe<FkDestinationFeatureDestinationDestinationIdInverseInput>;
  destinationGuidesUsingId?: InputMaybe<FkDestinationGuideDestinationDestinationIdInverseInput>;
  destinationToParentId?: InputMaybe<FkDestinationDestinationParentIdInput>;
  galleryId?: InputMaybe<Scalars['UUID']['input']>;
  heroMediaId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  latitude?: InputMaybe<Scalars['Float']['input']>;
  longitude?: InputMaybe<Scalars['Float']['input']>;
  mediaGalleryToGalleryId?: InputMaybe<FkDestinationMediaGalleryGalleryIdInput>;
  mediaItemToHeroMediaId?: InputMaybe<DestinationHeroMediaIdFkeyInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  parentId?: InputMaybe<Scalars['UUID']['input']>;
  propertiesUsingId?: InputMaybe<FkPropertyDestinationInverseInput>;
  quoteDayDestinationsUsingId?: InputMaybe<FkQuoteDayDestinationDestinationDestinationIdInverseInput>;
};

/** An object where the defined keys will be set on the `destination` being updated. */
export type UpdateDestinationOnDestinationForFkDestinationDestinationParentIdPatch = {
  alias?: InputMaybe<Scalars['String']['input']>;
  body?: InputMaybe<Scalars['String']['input']>;
  countryId?: InputMaybe<Scalars['UUID']['input']>;
  countryToCountryId?: InputMaybe<FkDestinationCountryCountryIdInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationFeaturesUsingId?: InputMaybe<FkDestinationFeatureDestinationDestinationIdInverseInput>;
  destinationGuidesUsingId?: InputMaybe<FkDestinationGuideDestinationDestinationIdInverseInput>;
  destinationToParentId?: InputMaybe<FkDestinationDestinationParentIdInput>;
  galleryId?: InputMaybe<Scalars['UUID']['input']>;
  heroMediaId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  latitude?: InputMaybe<Scalars['Float']['input']>;
  longitude?: InputMaybe<Scalars['Float']['input']>;
  mediaGalleryToGalleryId?: InputMaybe<FkDestinationMediaGalleryGalleryIdInput>;
  mediaItemToHeroMediaId?: InputMaybe<DestinationHeroMediaIdFkeyInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  propertiesUsingId?: InputMaybe<FkPropertyDestinationInverseInput>;
  quoteDayDestinationsUsingId?: InputMaybe<FkQuoteDayDestinationDestinationDestinationIdInverseInput>;
};

/** An object where the defined keys will be set on the `destination` being updated. */
export type UpdateDestinationOnDestinationForFkDestinationMediaGalleryGalleryIdPatch = {
  alias?: InputMaybe<Scalars['String']['input']>;
  body?: InputMaybe<Scalars['String']['input']>;
  countryId?: InputMaybe<Scalars['UUID']['input']>;
  countryToCountryId?: InputMaybe<FkDestinationCountryCountryIdInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationFeaturesUsingId?: InputMaybe<FkDestinationFeatureDestinationDestinationIdInverseInput>;
  destinationGuidesUsingId?: InputMaybe<FkDestinationGuideDestinationDestinationIdInverseInput>;
  destinationToParentId?: InputMaybe<FkDestinationDestinationParentIdInput>;
  heroMediaId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  latitude?: InputMaybe<Scalars['Float']['input']>;
  longitude?: InputMaybe<Scalars['Float']['input']>;
  mediaGalleryToGalleryId?: InputMaybe<FkDestinationMediaGalleryGalleryIdInput>;
  mediaItemToHeroMediaId?: InputMaybe<DestinationHeroMediaIdFkeyInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  parentId?: InputMaybe<Scalars['UUID']['input']>;
  propertiesUsingId?: InputMaybe<FkPropertyDestinationInverseInput>;
  quoteDayDestinationsUsingId?: InputMaybe<FkQuoteDayDestinationDestinationDestinationIdInverseInput>;
};

/** An object where the defined keys will be set on the `destination` being updated. */
export type UpdateDestinationOnDestinationGuideForFkDestinationGuideDestinationDestinationIdPatch = {
  alias?: InputMaybe<Scalars['String']['input']>;
  body?: InputMaybe<Scalars['String']['input']>;
  countryId?: InputMaybe<Scalars['UUID']['input']>;
  countryToCountryId?: InputMaybe<FkDestinationCountryCountryIdInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationFeaturesUsingId?: InputMaybe<FkDestinationFeatureDestinationDestinationIdInverseInput>;
  destinationGuidesUsingId?: InputMaybe<FkDestinationGuideDestinationDestinationIdInverseInput>;
  destinationToParentId?: InputMaybe<FkDestinationDestinationParentIdInput>;
  galleryId?: InputMaybe<Scalars['UUID']['input']>;
  heroMediaId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  latitude?: InputMaybe<Scalars['Float']['input']>;
  longitude?: InputMaybe<Scalars['Float']['input']>;
  mediaGalleryToGalleryId?: InputMaybe<FkDestinationMediaGalleryGalleryIdInput>;
  mediaItemToHeroMediaId?: InputMaybe<DestinationHeroMediaIdFkeyInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  parentId?: InputMaybe<Scalars['UUID']['input']>;
  propertiesUsingId?: InputMaybe<FkPropertyDestinationInverseInput>;
  quoteDayDestinationsUsingId?: InputMaybe<FkQuoteDayDestinationDestinationDestinationIdInverseInput>;
};

/** An object where the defined keys will be set on the `destination` being updated. */
export type UpdateDestinationOnPropertyForFkPropertyDestinationPatch = {
  alias?: InputMaybe<Scalars['String']['input']>;
  body?: InputMaybe<Scalars['String']['input']>;
  countryId?: InputMaybe<Scalars['UUID']['input']>;
  countryToCountryId?: InputMaybe<FkDestinationCountryCountryIdInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationFeaturesUsingId?: InputMaybe<FkDestinationFeatureDestinationDestinationIdInverseInput>;
  destinationGuidesUsingId?: InputMaybe<FkDestinationGuideDestinationDestinationIdInverseInput>;
  destinationToParentId?: InputMaybe<FkDestinationDestinationParentIdInput>;
  galleryId?: InputMaybe<Scalars['UUID']['input']>;
  heroMediaId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  latitude?: InputMaybe<Scalars['Float']['input']>;
  longitude?: InputMaybe<Scalars['Float']['input']>;
  mediaGalleryToGalleryId?: InputMaybe<FkDestinationMediaGalleryGalleryIdInput>;
  mediaItemToHeroMediaId?: InputMaybe<DestinationHeroMediaIdFkeyInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  parentId?: InputMaybe<Scalars['UUID']['input']>;
  propertiesUsingId?: InputMaybe<FkPropertyDestinationInverseInput>;
  quoteDayDestinationsUsingId?: InputMaybe<FkQuoteDayDestinationDestinationDestinationIdInverseInput>;
};

/** An object where the defined keys will be set on the `destination` being updated. */
export type UpdateDestinationOnQuoteDayDestinationForFkQuoteDayDestinationDestinationDestinationIdPatch = {
  alias?: InputMaybe<Scalars['String']['input']>;
  body?: InputMaybe<Scalars['String']['input']>;
  countryId?: InputMaybe<Scalars['UUID']['input']>;
  countryToCountryId?: InputMaybe<FkDestinationCountryCountryIdInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationFeaturesUsingId?: InputMaybe<FkDestinationFeatureDestinationDestinationIdInverseInput>;
  destinationGuidesUsingId?: InputMaybe<FkDestinationGuideDestinationDestinationIdInverseInput>;
  destinationToParentId?: InputMaybe<FkDestinationDestinationParentIdInput>;
  galleryId?: InputMaybe<Scalars['UUID']['input']>;
  heroMediaId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  latitude?: InputMaybe<Scalars['Float']['input']>;
  longitude?: InputMaybe<Scalars['Float']['input']>;
  mediaGalleryToGalleryId?: InputMaybe<FkDestinationMediaGalleryGalleryIdInput>;
  mediaItemToHeroMediaId?: InputMaybe<DestinationHeroMediaIdFkeyInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  parentId?: InputMaybe<Scalars['UUID']['input']>;
  propertiesUsingId?: InputMaybe<FkPropertyDestinationInverseInput>;
  quoteDayDestinationsUsingId?: InputMaybe<FkQuoteDayDestinationDestinationDestinationIdInverseInput>;
};

/** An object where the defined keys will be set on the `email` being updated. */
export type UpdateEmailOnEmailForFkEmailCustomerCustomerIdPatch = {
  body?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerToCustomerId?: InputMaybe<FkEmailCustomerCustomerIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  quoteId?: InputMaybe<Scalars['UUID']['input']>;
  quoteToQuoteId?: InputMaybe<FkEmailQuoteQuoteIdInput>;
  recipients?: InputMaybe<Scalars['String']['input']>;
  subject?: InputMaybe<Scalars['String']['input']>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkEmailTripTripIdInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkEmailUserUserIdInput>;
};

/** An object where the defined keys will be set on the `email` being updated. */
export type UpdateEmailOnEmailForFkEmailQuoteQuoteIdPatch = {
  body?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerId?: InputMaybe<Scalars['UUID']['input']>;
  customerToCustomerId?: InputMaybe<FkEmailCustomerCustomerIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  quoteToQuoteId?: InputMaybe<FkEmailQuoteQuoteIdInput>;
  recipients?: InputMaybe<Scalars['String']['input']>;
  subject?: InputMaybe<Scalars['String']['input']>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkEmailTripTripIdInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkEmailUserUserIdInput>;
};

/** An object where the defined keys will be set on the `email` being updated. */
export type UpdateEmailOnEmailForFkEmailTripTripIdPatch = {
  body?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerId?: InputMaybe<Scalars['UUID']['input']>;
  customerToCustomerId?: InputMaybe<FkEmailCustomerCustomerIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  quoteId?: InputMaybe<Scalars['UUID']['input']>;
  quoteToQuoteId?: InputMaybe<FkEmailQuoteQuoteIdInput>;
  recipients?: InputMaybe<Scalars['String']['input']>;
  subject?: InputMaybe<Scalars['String']['input']>;
  tripToTripId?: InputMaybe<FkEmailTripTripIdInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkEmailUserUserIdInput>;
};

/** An object where the defined keys will be set on the `email` being updated. */
export type UpdateEmailOnEmailForFkEmailUserUserIdPatch = {
  body?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerId?: InputMaybe<Scalars['UUID']['input']>;
  customerToCustomerId?: InputMaybe<FkEmailCustomerCustomerIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  quoteId?: InputMaybe<Scalars['UUID']['input']>;
  quoteToQuoteId?: InputMaybe<FkEmailQuoteQuoteIdInput>;
  recipients?: InputMaybe<Scalars['String']['input']>;
  subject?: InputMaybe<Scalars['String']['input']>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkEmailTripTripIdInput>;
  userToUserId?: InputMaybe<FkEmailUserUserIdInput>;
};

/** An object where the defined keys will be set on the `enquiry` being updated. */
export type UpdateEnquiryOnEnquiryForFkEnquiryCustomerCustomerIdPatch = {
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  comments?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerToCustomerId?: InputMaybe<FkEnquiryCustomerCustomerIdInput>;
  dates?: InputMaybe<Scalars['String']['input']>;
  destination?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  source?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  travellers?: InputMaybe<Scalars['String']['input']>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkEnquiryTripTripIdInput>;
};

/** An object where the defined keys will be set on the `enquiry` being updated. */
export type UpdateEnquiryOnEnquiryForFkEnquiryTripTripIdPatch = {
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  comments?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerId?: InputMaybe<Scalars['UUID']['input']>;
  customerToCustomerId?: InputMaybe<FkEnquiryCustomerCustomerIdInput>;
  dates?: InputMaybe<Scalars['String']['input']>;
  destination?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  source?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  travellers?: InputMaybe<Scalars['String']['input']>;
  tripToTripId?: InputMaybe<FkEnquiryTripTripIdInput>;
};

/** An object where the defined keys will be set on the `expense` being updated. */
export type UpdateExpenseOnExpenseForFkExpenseFinanceCategoryCategoryIdPatch = {
  amount?: InputMaybe<Scalars['BigFloat']['input']>;
  amountActual?: InputMaybe<Scalars['BigFloat']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  financeCategoryToCategoryId?: InputMaybe<FkExpenseFinanceCategoryCategoryIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoiceId?: InputMaybe<Scalars['UUID']['input']>;
  invoiceToInvoiceId?: InputMaybe<FkExpenseInvoiceInvoiceIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  paid?: InputMaybe<Scalars['Datetime']['input']>;
  reference?: InputMaybe<Scalars['String']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierId?: InputMaybe<Scalars['UUID']['input']>;
  supplierInvoiceId?: InputMaybe<Scalars['UUID']['input']>;
  supplierInvoiceToSupplierInvoiceId?: InputMaybe<FkExpenseSupplierInvoiceSupplierInvoiceIdInput>;
  supplierToSupplierId?: InputMaybe<FkExpenseSupplierSupplierIdInput>;
  transactionLinksUsingId?: InputMaybe<FkTransactionLinkExpenseExpenseIdInverseInput>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkExpenseTripTripIdInput>;
};

/** An object where the defined keys will be set on the `expense` being updated. */
export type UpdateExpenseOnExpenseForFkExpenseInvoiceInvoiceIdPatch = {
  amount?: InputMaybe<Scalars['BigFloat']['input']>;
  amountActual?: InputMaybe<Scalars['BigFloat']['input']>;
  categoryId?: InputMaybe<Scalars['UUID']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  financeCategoryToCategoryId?: InputMaybe<FkExpenseFinanceCategoryCategoryIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoiceToInvoiceId?: InputMaybe<FkExpenseInvoiceInvoiceIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  paid?: InputMaybe<Scalars['Datetime']['input']>;
  reference?: InputMaybe<Scalars['String']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierId?: InputMaybe<Scalars['UUID']['input']>;
  supplierInvoiceId?: InputMaybe<Scalars['UUID']['input']>;
  supplierInvoiceToSupplierInvoiceId?: InputMaybe<FkExpenseSupplierInvoiceSupplierInvoiceIdInput>;
  supplierToSupplierId?: InputMaybe<FkExpenseSupplierSupplierIdInput>;
  transactionLinksUsingId?: InputMaybe<FkTransactionLinkExpenseExpenseIdInverseInput>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkExpenseTripTripIdInput>;
};

/** An object where the defined keys will be set on the `expense` being updated. */
export type UpdateExpenseOnExpenseForFkExpenseSupplierInvoiceSupplierInvoiceIdPatch = {
  amount?: InputMaybe<Scalars['BigFloat']['input']>;
  amountActual?: InputMaybe<Scalars['BigFloat']['input']>;
  categoryId?: InputMaybe<Scalars['UUID']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  financeCategoryToCategoryId?: InputMaybe<FkExpenseFinanceCategoryCategoryIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoiceId?: InputMaybe<Scalars['UUID']['input']>;
  invoiceToInvoiceId?: InputMaybe<FkExpenseInvoiceInvoiceIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  paid?: InputMaybe<Scalars['Datetime']['input']>;
  reference?: InputMaybe<Scalars['String']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierId?: InputMaybe<Scalars['UUID']['input']>;
  supplierInvoiceToSupplierInvoiceId?: InputMaybe<FkExpenseSupplierInvoiceSupplierInvoiceIdInput>;
  supplierToSupplierId?: InputMaybe<FkExpenseSupplierSupplierIdInput>;
  transactionLinksUsingId?: InputMaybe<FkTransactionLinkExpenseExpenseIdInverseInput>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkExpenseTripTripIdInput>;
};

/** An object where the defined keys will be set on the `expense` being updated. */
export type UpdateExpenseOnExpenseForFkExpenseSupplierSupplierIdPatch = {
  amount?: InputMaybe<Scalars['BigFloat']['input']>;
  amountActual?: InputMaybe<Scalars['BigFloat']['input']>;
  categoryId?: InputMaybe<Scalars['UUID']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  financeCategoryToCategoryId?: InputMaybe<FkExpenseFinanceCategoryCategoryIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoiceId?: InputMaybe<Scalars['UUID']['input']>;
  invoiceToInvoiceId?: InputMaybe<FkExpenseInvoiceInvoiceIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  paid?: InputMaybe<Scalars['Datetime']['input']>;
  reference?: InputMaybe<Scalars['String']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierInvoiceId?: InputMaybe<Scalars['UUID']['input']>;
  supplierInvoiceToSupplierInvoiceId?: InputMaybe<FkExpenseSupplierInvoiceSupplierInvoiceIdInput>;
  supplierToSupplierId?: InputMaybe<FkExpenseSupplierSupplierIdInput>;
  transactionLinksUsingId?: InputMaybe<FkTransactionLinkExpenseExpenseIdInverseInput>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkExpenseTripTripIdInput>;
};

/** An object where the defined keys will be set on the `expense` being updated. */
export type UpdateExpenseOnExpenseForFkExpenseTripTripIdPatch = {
  amount?: InputMaybe<Scalars['BigFloat']['input']>;
  amountActual?: InputMaybe<Scalars['BigFloat']['input']>;
  categoryId?: InputMaybe<Scalars['UUID']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  financeCategoryToCategoryId?: InputMaybe<FkExpenseFinanceCategoryCategoryIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoiceId?: InputMaybe<Scalars['UUID']['input']>;
  invoiceToInvoiceId?: InputMaybe<FkExpenseInvoiceInvoiceIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  paid?: InputMaybe<Scalars['Datetime']['input']>;
  reference?: InputMaybe<Scalars['String']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierId?: InputMaybe<Scalars['UUID']['input']>;
  supplierInvoiceId?: InputMaybe<Scalars['UUID']['input']>;
  supplierInvoiceToSupplierInvoiceId?: InputMaybe<FkExpenseSupplierInvoiceSupplierInvoiceIdInput>;
  supplierToSupplierId?: InputMaybe<FkExpenseSupplierSupplierIdInput>;
  transactionLinksUsingId?: InputMaybe<FkTransactionLinkExpenseExpenseIdInverseInput>;
  tripToTripId?: InputMaybe<FkExpenseTripTripIdInput>;
};

/** An object where the defined keys will be set on the `expense` being updated. */
export type UpdateExpenseOnTransactionLinkForFkTransactionLinkExpenseExpenseIdPatch = {
  amount?: InputMaybe<Scalars['BigFloat']['input']>;
  amountActual?: InputMaybe<Scalars['BigFloat']['input']>;
  categoryId?: InputMaybe<Scalars['UUID']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  financeCategoryToCategoryId?: InputMaybe<FkExpenseFinanceCategoryCategoryIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoiceId?: InputMaybe<Scalars['UUID']['input']>;
  invoiceToInvoiceId?: InputMaybe<FkExpenseInvoiceInvoiceIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  paid?: InputMaybe<Scalars['Datetime']['input']>;
  reference?: InputMaybe<Scalars['String']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierId?: InputMaybe<Scalars['UUID']['input']>;
  supplierInvoiceId?: InputMaybe<Scalars['UUID']['input']>;
  supplierInvoiceToSupplierInvoiceId?: InputMaybe<FkExpenseSupplierInvoiceSupplierInvoiceIdInput>;
  supplierToSupplierId?: InputMaybe<FkExpenseSupplierSupplierIdInput>;
  transactionLinksUsingId?: InputMaybe<FkTransactionLinkExpenseExpenseIdInverseInput>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkExpenseTripTripIdInput>;
};

/** An object where the defined keys will be set on the `feature` being updated. */
export type UpdateFeatureOnFeatureForFkFeatureMediaGalleryGalleryIdPatch = {
  body?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryToGalleryId?: InputMaybe<FkFeatureMediaGalleryGalleryIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** An object where the defined keys will be set on the `financeCategory` being updated. */
export type UpdateFinanceCategoryOnExpenseForFkExpenseFinanceCategoryCategoryIdPatch = {
  code?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  expensesUsingId?: InputMaybe<FkExpenseFinanceCategoryCategoryIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceFinanceCategoryCategoryIdInverseInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  paymentsUsingId?: InputMaybe<FkPaymentFinanceCategoryCategoryIdInverseInput>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceFinanceCategoryCategoryIdInverseInput>;
  transactionsUsingId?: InputMaybe<FkTransactionFinanceCategoryCategoryIdInverseInput>;
  type?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `financeCategory` being updated. */
export type UpdateFinanceCategoryOnInvoiceForFkInvoiceFinanceCategoryCategoryIdPatch = {
  code?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  expensesUsingId?: InputMaybe<FkExpenseFinanceCategoryCategoryIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceFinanceCategoryCategoryIdInverseInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  paymentsUsingId?: InputMaybe<FkPaymentFinanceCategoryCategoryIdInverseInput>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceFinanceCategoryCategoryIdInverseInput>;
  transactionsUsingId?: InputMaybe<FkTransactionFinanceCategoryCategoryIdInverseInput>;
  type?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `financeCategory` being updated. */
export type UpdateFinanceCategoryOnPaymentForFkPaymentFinanceCategoryCategoryIdPatch = {
  code?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  expensesUsingId?: InputMaybe<FkExpenseFinanceCategoryCategoryIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceFinanceCategoryCategoryIdInverseInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  paymentsUsingId?: InputMaybe<FkPaymentFinanceCategoryCategoryIdInverseInput>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceFinanceCategoryCategoryIdInverseInput>;
  transactionsUsingId?: InputMaybe<FkTransactionFinanceCategoryCategoryIdInverseInput>;
  type?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `financeCategory` being updated. */
export type UpdateFinanceCategoryOnSupplierInvoiceForFkSupplierInvoiceFinanceCategoryCategoryIdPatch = {
  code?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  expensesUsingId?: InputMaybe<FkExpenseFinanceCategoryCategoryIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceFinanceCategoryCategoryIdInverseInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  paymentsUsingId?: InputMaybe<FkPaymentFinanceCategoryCategoryIdInverseInput>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceFinanceCategoryCategoryIdInverseInput>;
  transactionsUsingId?: InputMaybe<FkTransactionFinanceCategoryCategoryIdInverseInput>;
  type?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `financeCategory` being updated. */
export type UpdateFinanceCategoryOnTransactionForFkTransactionFinanceCategoryCategoryIdPatch = {
  code?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  expensesUsingId?: InputMaybe<FkExpenseFinanceCategoryCategoryIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceFinanceCategoryCategoryIdInverseInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  paymentsUsingId?: InputMaybe<FkPaymentFinanceCategoryCategoryIdInverseInput>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceFinanceCategoryCategoryIdInverseInput>;
  transactionsUsingId?: InputMaybe<FkTransactionFinanceCategoryCategoryIdInverseInput>;
  type?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `invoice` being updated. */
export type UpdateInvoiceOnExpenseForFkExpenseInvoiceInvoiceIdPatch = {
  amount?: InputMaybe<Scalars['BigFloat']['input']>;
  categoryId?: InputMaybe<Scalars['UUID']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  due?: InputMaybe<Scalars['Datetime']['input']>;
  expensesUsingId?: InputMaybe<FkExpenseInvoiceInvoiceIdInverseInput>;
  financeCategoryToCategoryId?: InputMaybe<FkInvoiceFinanceCategoryCategoryIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoiced?: InputMaybe<Scalars['Datetime']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  locked?: InputMaybe<Scalars['Datetime']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  note?: InputMaybe<Scalars['String']['input']>;
  number?: InputMaybe<Scalars['Int']['input']>;
  paid?: InputMaybe<Scalars['Datetime']['input']>;
  paymentsUsingId?: InputMaybe<FkPaymentInvoiceInvoiceIdInverseInput>;
  quoteId?: InputMaybe<Scalars['UUID']['input']>;
  quoteToQuoteId?: InputMaybe<FkInvoiceQuoteQuoteIdInput>;
  summary?: InputMaybe<Scalars['String']['input']>;
  transactionLinksUsingId?: InputMaybe<FkTransactionLinkInvoiceInvoiceIdInverseInput>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkInvoiceTripTripIdInput>;
  type?: InputMaybe<Scalars['String']['input']>;
  voided?: InputMaybe<Scalars['Datetime']['input']>;
};

/** An object where the defined keys will be set on the `invoice` being updated. */
export type UpdateInvoiceOnInvoiceForFkInvoiceFinanceCategoryCategoryIdPatch = {
  amount?: InputMaybe<Scalars['BigFloat']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  due?: InputMaybe<Scalars['Datetime']['input']>;
  expensesUsingId?: InputMaybe<FkExpenseInvoiceInvoiceIdInverseInput>;
  financeCategoryToCategoryId?: InputMaybe<FkInvoiceFinanceCategoryCategoryIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoiced?: InputMaybe<Scalars['Datetime']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  locked?: InputMaybe<Scalars['Datetime']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  note?: InputMaybe<Scalars['String']['input']>;
  number?: InputMaybe<Scalars['Int']['input']>;
  paid?: InputMaybe<Scalars['Datetime']['input']>;
  paymentsUsingId?: InputMaybe<FkPaymentInvoiceInvoiceIdInverseInput>;
  quoteId?: InputMaybe<Scalars['UUID']['input']>;
  quoteToQuoteId?: InputMaybe<FkInvoiceQuoteQuoteIdInput>;
  summary?: InputMaybe<Scalars['String']['input']>;
  transactionLinksUsingId?: InputMaybe<FkTransactionLinkInvoiceInvoiceIdInverseInput>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkInvoiceTripTripIdInput>;
  type?: InputMaybe<Scalars['String']['input']>;
  voided?: InputMaybe<Scalars['Datetime']['input']>;
};

/** An object where the defined keys will be set on the `invoice` being updated. */
export type UpdateInvoiceOnInvoiceForFkInvoiceQuoteQuoteIdPatch = {
  amount?: InputMaybe<Scalars['BigFloat']['input']>;
  categoryId?: InputMaybe<Scalars['UUID']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  due?: InputMaybe<Scalars['Datetime']['input']>;
  expensesUsingId?: InputMaybe<FkExpenseInvoiceInvoiceIdInverseInput>;
  financeCategoryToCategoryId?: InputMaybe<FkInvoiceFinanceCategoryCategoryIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoiced?: InputMaybe<Scalars['Datetime']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  locked?: InputMaybe<Scalars['Datetime']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  note?: InputMaybe<Scalars['String']['input']>;
  number?: InputMaybe<Scalars['Int']['input']>;
  paid?: InputMaybe<Scalars['Datetime']['input']>;
  paymentsUsingId?: InputMaybe<FkPaymentInvoiceInvoiceIdInverseInput>;
  quoteToQuoteId?: InputMaybe<FkInvoiceQuoteQuoteIdInput>;
  summary?: InputMaybe<Scalars['String']['input']>;
  transactionLinksUsingId?: InputMaybe<FkTransactionLinkInvoiceInvoiceIdInverseInput>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkInvoiceTripTripIdInput>;
  type?: InputMaybe<Scalars['String']['input']>;
  voided?: InputMaybe<Scalars['Datetime']['input']>;
};

/** An object where the defined keys will be set on the `invoice` being updated. */
export type UpdateInvoiceOnInvoiceForFkInvoiceTripTripIdPatch = {
  amount?: InputMaybe<Scalars['BigFloat']['input']>;
  categoryId?: InputMaybe<Scalars['UUID']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  due?: InputMaybe<Scalars['Datetime']['input']>;
  expensesUsingId?: InputMaybe<FkExpenseInvoiceInvoiceIdInverseInput>;
  financeCategoryToCategoryId?: InputMaybe<FkInvoiceFinanceCategoryCategoryIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoiced?: InputMaybe<Scalars['Datetime']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  locked?: InputMaybe<Scalars['Datetime']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  note?: InputMaybe<Scalars['String']['input']>;
  number?: InputMaybe<Scalars['Int']['input']>;
  paid?: InputMaybe<Scalars['Datetime']['input']>;
  paymentsUsingId?: InputMaybe<FkPaymentInvoiceInvoiceIdInverseInput>;
  quoteId?: InputMaybe<Scalars['UUID']['input']>;
  quoteToQuoteId?: InputMaybe<FkInvoiceQuoteQuoteIdInput>;
  summary?: InputMaybe<Scalars['String']['input']>;
  transactionLinksUsingId?: InputMaybe<FkTransactionLinkInvoiceInvoiceIdInverseInput>;
  tripToTripId?: InputMaybe<FkInvoiceTripTripIdInput>;
  type?: InputMaybe<Scalars['String']['input']>;
  voided?: InputMaybe<Scalars['Datetime']['input']>;
};

/** An object where the defined keys will be set on the `invoice` being updated. */
export type UpdateInvoiceOnPaymentForFkPaymentInvoiceInvoiceIdPatch = {
  amount?: InputMaybe<Scalars['BigFloat']['input']>;
  categoryId?: InputMaybe<Scalars['UUID']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  due?: InputMaybe<Scalars['Datetime']['input']>;
  expensesUsingId?: InputMaybe<FkExpenseInvoiceInvoiceIdInverseInput>;
  financeCategoryToCategoryId?: InputMaybe<FkInvoiceFinanceCategoryCategoryIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoiced?: InputMaybe<Scalars['Datetime']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  locked?: InputMaybe<Scalars['Datetime']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  note?: InputMaybe<Scalars['String']['input']>;
  number?: InputMaybe<Scalars['Int']['input']>;
  paid?: InputMaybe<Scalars['Datetime']['input']>;
  paymentsUsingId?: InputMaybe<FkPaymentInvoiceInvoiceIdInverseInput>;
  quoteId?: InputMaybe<Scalars['UUID']['input']>;
  quoteToQuoteId?: InputMaybe<FkInvoiceQuoteQuoteIdInput>;
  summary?: InputMaybe<Scalars['String']['input']>;
  transactionLinksUsingId?: InputMaybe<FkTransactionLinkInvoiceInvoiceIdInverseInput>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkInvoiceTripTripIdInput>;
  type?: InputMaybe<Scalars['String']['input']>;
  voided?: InputMaybe<Scalars['Datetime']['input']>;
};

/** An object where the defined keys will be set on the `invoice` being updated. */
export type UpdateInvoiceOnTransactionLinkForFkTransactionLinkInvoiceInvoiceIdPatch = {
  amount?: InputMaybe<Scalars['BigFloat']['input']>;
  categoryId?: InputMaybe<Scalars['UUID']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  due?: InputMaybe<Scalars['Datetime']['input']>;
  expensesUsingId?: InputMaybe<FkExpenseInvoiceInvoiceIdInverseInput>;
  financeCategoryToCategoryId?: InputMaybe<FkInvoiceFinanceCategoryCategoryIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoiced?: InputMaybe<Scalars['Datetime']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  locked?: InputMaybe<Scalars['Datetime']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  note?: InputMaybe<Scalars['String']['input']>;
  number?: InputMaybe<Scalars['Int']['input']>;
  paid?: InputMaybe<Scalars['Datetime']['input']>;
  paymentsUsingId?: InputMaybe<FkPaymentInvoiceInvoiceIdInverseInput>;
  quoteId?: InputMaybe<Scalars['UUID']['input']>;
  quoteToQuoteId?: InputMaybe<FkInvoiceQuoteQuoteIdInput>;
  summary?: InputMaybe<Scalars['String']['input']>;
  transactionLinksUsingId?: InputMaybe<FkTransactionLinkInvoiceInvoiceIdInverseInput>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkInvoiceTripTripIdInput>;
  type?: InputMaybe<Scalars['String']['input']>;
  voided?: InputMaybe<Scalars['Datetime']['input']>;
};

/** An object where the defined keys will be set on the `legalDocument` being updated. */
export type UpdateLegalDocumentOnLegalDocumentForFkLegalDocumentFolderPatch = {
  body?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  legalFolderToFolderId?: InputMaybe<FkLegalDocumentFolderInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  quoteLegalDocumentsUsingId?: InputMaybe<FkQuoteLegalDocumentLegalDocumentInverseInput>;
  validFrom?: InputMaybe<Scalars['Datetime']['input']>;
  validTo?: InputMaybe<Scalars['Datetime']['input']>;
};

/** An object where the defined keys will be set on the `legalDocument` being updated. */
export type UpdateLegalDocumentOnQuoteLegalDocumentForFkQuoteLegalDocumentLegalDocumentPatch = {
  body?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  folderId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  legalFolderToFolderId?: InputMaybe<FkLegalDocumentFolderInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  quoteLegalDocumentsUsingId?: InputMaybe<FkQuoteLegalDocumentLegalDocumentInverseInput>;
  validFrom?: InputMaybe<Scalars['Datetime']['input']>;
  validTo?: InputMaybe<Scalars['Datetime']['input']>;
};

/** An object where the defined keys will be set on the `legalFolder` being updated. */
export type UpdateLegalFolderOnLegalDocumentForFkLegalDocumentFolderPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  legalDocumentsUsingId?: InputMaybe<FkLegalDocumentFolderInverseInput>;
  legalFolderToParentId?: InputMaybe<FkLegalFolderParentInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  parentId?: InputMaybe<Scalars['UUID']['input']>;
};

/** An object where the defined keys will be set on the `legalFolder` being updated. */
export type UpdateLegalFolderOnLegalFolderForFkLegalFolderParentPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  legalDocumentsUsingId?: InputMaybe<FkLegalDocumentFolderInverseInput>;
  legalFolderToParentId?: InputMaybe<FkLegalFolderParentInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** An object where the defined keys will be set on the `mapPoint` being updated. */
export type UpdateMapPointOnPropertyForFkPropertyMapPointMapPointIdPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  latitude?: InputMaybe<Scalars['Float']['input']>;
  longitude?: InputMaybe<Scalars['Float']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  propertiesUsingId?: InputMaybe<FkPropertyMapPointMapPointIdInverseInput>;
};

/** An object where the defined keys will be set on the `mediaGalleryItem` being updated. */
export type UpdateMediaGalleryItemOnMediaGalleryItemForFkMediaGalleryItemMediaGalleryMediaGalleryIdPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  isHero?: InputMaybe<Scalars['Boolean']['input']>;
  mediaGalleryToMediaGalleryId?: InputMaybe<FkMediaGalleryItemMediaGalleryMediaGalleryIdInput>;
  mediaItemId?: InputMaybe<Scalars['UUID']['input']>;
  mediaItemToMediaItemId?: InputMaybe<FkMediaGalleryItemMediaItemMediaItemIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
};

/** An object where the defined keys will be set on the `mediaGalleryItem` being updated. */
export type UpdateMediaGalleryItemOnMediaGalleryItemForFkMediaGalleryItemMediaItemMediaItemIdPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  isHero?: InputMaybe<Scalars['Boolean']['input']>;
  mediaGalleryId?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryToMediaGalleryId?: InputMaybe<FkMediaGalleryItemMediaGalleryMediaGalleryIdInput>;
  mediaItemToMediaItemId?: InputMaybe<FkMediaGalleryItemMediaItemMediaItemIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
};

/** An object where the defined keys will be set on the `mediaGallery` being updated. */
export type UpdateMediaGalleryOnDestinationFeatureForFkDestinationFeatureMediaGalleryGalleryIdPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationFeaturesUsingId?: InputMaybe<FkDestinationFeatureMediaGalleryGalleryIdInverseInput>;
  destinationsUsingId?: InputMaybe<FkDestinationMediaGalleryGalleryIdInverseInput>;
  featuresUsingId?: InputMaybe<FkFeatureMediaGalleryGalleryIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  isProtected?: InputMaybe<Scalars['Boolean']['input']>;
  mediaGalleryItemsUsingId?: InputMaybe<FkMediaGalleryItemMediaGalleryMediaGalleryIdInverseInput>;
  mediaGalleryToParentId?: InputMaybe<FkMediaGalleryMediaGalleryParentIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  parentId?: InputMaybe<Scalars['UUID']['input']>;
  propertiesUsingId?: InputMaybe<FkPropertyMediaGalleryGalleryIdInverseInput>;
  suppliersUsingId?: InputMaybe<FkSupplierMediaGalleryGalleryIdInverseInput>;
  tripsUsingId?: InputMaybe<FkTripMediaGalleryMediaGalleryIdInverseInput>;
};

/** An object where the defined keys will be set on the `mediaGallery` being updated. */
export type UpdateMediaGalleryOnDestinationForFkDestinationMediaGalleryGalleryIdPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationFeaturesUsingId?: InputMaybe<FkDestinationFeatureMediaGalleryGalleryIdInverseInput>;
  destinationsUsingId?: InputMaybe<FkDestinationMediaGalleryGalleryIdInverseInput>;
  featuresUsingId?: InputMaybe<FkFeatureMediaGalleryGalleryIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  isProtected?: InputMaybe<Scalars['Boolean']['input']>;
  mediaGalleryItemsUsingId?: InputMaybe<FkMediaGalleryItemMediaGalleryMediaGalleryIdInverseInput>;
  mediaGalleryToParentId?: InputMaybe<FkMediaGalleryMediaGalleryParentIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  parentId?: InputMaybe<Scalars['UUID']['input']>;
  propertiesUsingId?: InputMaybe<FkPropertyMediaGalleryGalleryIdInverseInput>;
  suppliersUsingId?: InputMaybe<FkSupplierMediaGalleryGalleryIdInverseInput>;
  tripsUsingId?: InputMaybe<FkTripMediaGalleryMediaGalleryIdInverseInput>;
};

/** An object where the defined keys will be set on the `mediaGallery` being updated. */
export type UpdateMediaGalleryOnFeatureForFkFeatureMediaGalleryGalleryIdPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationFeaturesUsingId?: InputMaybe<FkDestinationFeatureMediaGalleryGalleryIdInverseInput>;
  destinationsUsingId?: InputMaybe<FkDestinationMediaGalleryGalleryIdInverseInput>;
  featuresUsingId?: InputMaybe<FkFeatureMediaGalleryGalleryIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  isProtected?: InputMaybe<Scalars['Boolean']['input']>;
  mediaGalleryItemsUsingId?: InputMaybe<FkMediaGalleryItemMediaGalleryMediaGalleryIdInverseInput>;
  mediaGalleryToParentId?: InputMaybe<FkMediaGalleryMediaGalleryParentIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  parentId?: InputMaybe<Scalars['UUID']['input']>;
  propertiesUsingId?: InputMaybe<FkPropertyMediaGalleryGalleryIdInverseInput>;
  suppliersUsingId?: InputMaybe<FkSupplierMediaGalleryGalleryIdInverseInput>;
  tripsUsingId?: InputMaybe<FkTripMediaGalleryMediaGalleryIdInverseInput>;
};

/** An object where the defined keys will be set on the `mediaGallery` being updated. */
export type UpdateMediaGalleryOnMediaGalleryForFkMediaGalleryMediaGalleryParentIdPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationFeaturesUsingId?: InputMaybe<FkDestinationFeatureMediaGalleryGalleryIdInverseInput>;
  destinationsUsingId?: InputMaybe<FkDestinationMediaGalleryGalleryIdInverseInput>;
  featuresUsingId?: InputMaybe<FkFeatureMediaGalleryGalleryIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  isProtected?: InputMaybe<Scalars['Boolean']['input']>;
  mediaGalleryItemsUsingId?: InputMaybe<FkMediaGalleryItemMediaGalleryMediaGalleryIdInverseInput>;
  mediaGalleryToParentId?: InputMaybe<FkMediaGalleryMediaGalleryParentIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  propertiesUsingId?: InputMaybe<FkPropertyMediaGalleryGalleryIdInverseInput>;
  suppliersUsingId?: InputMaybe<FkSupplierMediaGalleryGalleryIdInverseInput>;
  tripsUsingId?: InputMaybe<FkTripMediaGalleryMediaGalleryIdInverseInput>;
};

/** An object where the defined keys will be set on the `mediaGallery` being updated. */
export type UpdateMediaGalleryOnMediaGalleryItemForFkMediaGalleryItemMediaGalleryMediaGalleryIdPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationFeaturesUsingId?: InputMaybe<FkDestinationFeatureMediaGalleryGalleryIdInverseInput>;
  destinationsUsingId?: InputMaybe<FkDestinationMediaGalleryGalleryIdInverseInput>;
  featuresUsingId?: InputMaybe<FkFeatureMediaGalleryGalleryIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  isProtected?: InputMaybe<Scalars['Boolean']['input']>;
  mediaGalleryItemsUsingId?: InputMaybe<FkMediaGalleryItemMediaGalleryMediaGalleryIdInverseInput>;
  mediaGalleryToParentId?: InputMaybe<FkMediaGalleryMediaGalleryParentIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  parentId?: InputMaybe<Scalars['UUID']['input']>;
  propertiesUsingId?: InputMaybe<FkPropertyMediaGalleryGalleryIdInverseInput>;
  suppliersUsingId?: InputMaybe<FkSupplierMediaGalleryGalleryIdInverseInput>;
  tripsUsingId?: InputMaybe<FkTripMediaGalleryMediaGalleryIdInverseInput>;
};

/** An object where the defined keys will be set on the `mediaGallery` being updated. */
export type UpdateMediaGalleryOnPropertyForFkPropertyMediaGalleryGalleryIdPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationFeaturesUsingId?: InputMaybe<FkDestinationFeatureMediaGalleryGalleryIdInverseInput>;
  destinationsUsingId?: InputMaybe<FkDestinationMediaGalleryGalleryIdInverseInput>;
  featuresUsingId?: InputMaybe<FkFeatureMediaGalleryGalleryIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  isProtected?: InputMaybe<Scalars['Boolean']['input']>;
  mediaGalleryItemsUsingId?: InputMaybe<FkMediaGalleryItemMediaGalleryMediaGalleryIdInverseInput>;
  mediaGalleryToParentId?: InputMaybe<FkMediaGalleryMediaGalleryParentIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  parentId?: InputMaybe<Scalars['UUID']['input']>;
  propertiesUsingId?: InputMaybe<FkPropertyMediaGalleryGalleryIdInverseInput>;
  suppliersUsingId?: InputMaybe<FkSupplierMediaGalleryGalleryIdInverseInput>;
  tripsUsingId?: InputMaybe<FkTripMediaGalleryMediaGalleryIdInverseInput>;
};

/** An object where the defined keys will be set on the `mediaGallery` being updated. */
export type UpdateMediaGalleryOnSupplierForFkSupplierMediaGalleryGalleryIdPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationFeaturesUsingId?: InputMaybe<FkDestinationFeatureMediaGalleryGalleryIdInverseInput>;
  destinationsUsingId?: InputMaybe<FkDestinationMediaGalleryGalleryIdInverseInput>;
  featuresUsingId?: InputMaybe<FkFeatureMediaGalleryGalleryIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  isProtected?: InputMaybe<Scalars['Boolean']['input']>;
  mediaGalleryItemsUsingId?: InputMaybe<FkMediaGalleryItemMediaGalleryMediaGalleryIdInverseInput>;
  mediaGalleryToParentId?: InputMaybe<FkMediaGalleryMediaGalleryParentIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  parentId?: InputMaybe<Scalars['UUID']['input']>;
  propertiesUsingId?: InputMaybe<FkPropertyMediaGalleryGalleryIdInverseInput>;
  suppliersUsingId?: InputMaybe<FkSupplierMediaGalleryGalleryIdInverseInput>;
  tripsUsingId?: InputMaybe<FkTripMediaGalleryMediaGalleryIdInverseInput>;
};

/** An object where the defined keys will be set on the `mediaGallery` being updated. */
export type UpdateMediaGalleryOnTripForFkTripMediaGalleryMediaGalleryIdPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationFeaturesUsingId?: InputMaybe<FkDestinationFeatureMediaGalleryGalleryIdInverseInput>;
  destinationsUsingId?: InputMaybe<FkDestinationMediaGalleryGalleryIdInverseInput>;
  featuresUsingId?: InputMaybe<FkFeatureMediaGalleryGalleryIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  isProtected?: InputMaybe<Scalars['Boolean']['input']>;
  mediaGalleryItemsUsingId?: InputMaybe<FkMediaGalleryItemMediaGalleryMediaGalleryIdInverseInput>;
  mediaGalleryToParentId?: InputMaybe<FkMediaGalleryMediaGalleryParentIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  parentId?: InputMaybe<Scalars['UUID']['input']>;
  propertiesUsingId?: InputMaybe<FkPropertyMediaGalleryGalleryIdInverseInput>;
  suppliersUsingId?: InputMaybe<FkSupplierMediaGalleryGalleryIdInverseInput>;
  tripsUsingId?: InputMaybe<FkTripMediaGalleryMediaGalleryIdInverseInput>;
};

/** An object where the defined keys will be set on the `mediaItem` being updated. */
export type UpdateMediaItemOnAgencyForFkAgencyMediaItemLogoIdPatch = {
  agenciesUsingId?: InputMaybe<FkAgencyMediaItemLogoIdInverseInput>;
  contentType?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationsUsingId?: InputMaybe<DestinationHeroMediaIdFkeyInverseInput>;
  fileName?: InputMaybe<Scalars['String']['input']>;
  hash?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryItemsUsingId?: InputMaybe<FkMediaGalleryItemMediaItemMediaItemIdInverseInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  propertiesUsingId?: InputMaybe<FkPropertyMediaItemHeroMediaIdInverseInput>;
  quoteHeroesUsingId?: InputMaybe<FkQuoteHeroMediaItemImageIdInverseInput>;
  quotesUsingId?: InputMaybe<FkQuoteMediaItemHeroImageIdInverseInput>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceMediaItemMediaItemIdInverseInput>;
};

/** An object where the defined keys will be set on the `mediaItem` being updated. */
export type UpdateMediaItemOnDestinationForDestinationHeroMediaIdFkeyPatch = {
  agenciesUsingId?: InputMaybe<FkAgencyMediaItemLogoIdInverseInput>;
  contentType?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationsUsingId?: InputMaybe<DestinationHeroMediaIdFkeyInverseInput>;
  fileName?: InputMaybe<Scalars['String']['input']>;
  hash?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryItemsUsingId?: InputMaybe<FkMediaGalleryItemMediaItemMediaItemIdInverseInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  propertiesUsingId?: InputMaybe<FkPropertyMediaItemHeroMediaIdInverseInput>;
  quoteHeroesUsingId?: InputMaybe<FkQuoteHeroMediaItemImageIdInverseInput>;
  quotesUsingId?: InputMaybe<FkQuoteMediaItemHeroImageIdInverseInput>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceMediaItemMediaItemIdInverseInput>;
};

/** An object where the defined keys will be set on the `mediaItem` being updated. */
export type UpdateMediaItemOnMediaGalleryItemForFkMediaGalleryItemMediaItemMediaItemIdPatch = {
  agenciesUsingId?: InputMaybe<FkAgencyMediaItemLogoIdInverseInput>;
  contentType?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationsUsingId?: InputMaybe<DestinationHeroMediaIdFkeyInverseInput>;
  fileName?: InputMaybe<Scalars['String']['input']>;
  hash?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryItemsUsingId?: InputMaybe<FkMediaGalleryItemMediaItemMediaItemIdInverseInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  propertiesUsingId?: InputMaybe<FkPropertyMediaItemHeroMediaIdInverseInput>;
  quoteHeroesUsingId?: InputMaybe<FkQuoteHeroMediaItemImageIdInverseInput>;
  quotesUsingId?: InputMaybe<FkQuoteMediaItemHeroImageIdInverseInput>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceMediaItemMediaItemIdInverseInput>;
};

/** An object where the defined keys will be set on the `mediaItem` being updated. */
export type UpdateMediaItemOnPropertyForFkPropertyMediaItemHeroMediaIdPatch = {
  agenciesUsingId?: InputMaybe<FkAgencyMediaItemLogoIdInverseInput>;
  contentType?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationsUsingId?: InputMaybe<DestinationHeroMediaIdFkeyInverseInput>;
  fileName?: InputMaybe<Scalars['String']['input']>;
  hash?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryItemsUsingId?: InputMaybe<FkMediaGalleryItemMediaItemMediaItemIdInverseInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  propertiesUsingId?: InputMaybe<FkPropertyMediaItemHeroMediaIdInverseInput>;
  quoteHeroesUsingId?: InputMaybe<FkQuoteHeroMediaItemImageIdInverseInput>;
  quotesUsingId?: InputMaybe<FkQuoteMediaItemHeroImageIdInverseInput>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceMediaItemMediaItemIdInverseInput>;
};

/** An object where the defined keys will be set on the `mediaItem` being updated. */
export type UpdateMediaItemOnQuoteForFkQuoteMediaItemHeroImageIdPatch = {
  agenciesUsingId?: InputMaybe<FkAgencyMediaItemLogoIdInverseInput>;
  contentType?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationsUsingId?: InputMaybe<DestinationHeroMediaIdFkeyInverseInput>;
  fileName?: InputMaybe<Scalars['String']['input']>;
  hash?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryItemsUsingId?: InputMaybe<FkMediaGalleryItemMediaItemMediaItemIdInverseInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  propertiesUsingId?: InputMaybe<FkPropertyMediaItemHeroMediaIdInverseInput>;
  quoteHeroesUsingId?: InputMaybe<FkQuoteHeroMediaItemImageIdInverseInput>;
  quotesUsingId?: InputMaybe<FkQuoteMediaItemHeroImageIdInverseInput>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceMediaItemMediaItemIdInverseInput>;
};

/** An object where the defined keys will be set on the `mediaItem` being updated. */
export type UpdateMediaItemOnQuoteHeroForFkQuoteHeroMediaItemImageIdPatch = {
  agenciesUsingId?: InputMaybe<FkAgencyMediaItemLogoIdInverseInput>;
  contentType?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationsUsingId?: InputMaybe<DestinationHeroMediaIdFkeyInverseInput>;
  fileName?: InputMaybe<Scalars['String']['input']>;
  hash?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryItemsUsingId?: InputMaybe<FkMediaGalleryItemMediaItemMediaItemIdInverseInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  propertiesUsingId?: InputMaybe<FkPropertyMediaItemHeroMediaIdInverseInput>;
  quoteHeroesUsingId?: InputMaybe<FkQuoteHeroMediaItemImageIdInverseInput>;
  quotesUsingId?: InputMaybe<FkQuoteMediaItemHeroImageIdInverseInput>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceMediaItemMediaItemIdInverseInput>;
};

/** An object where the defined keys will be set on the `mediaItem` being updated. */
export type UpdateMediaItemOnSupplierInvoiceForFkSupplierInvoiceMediaItemMediaItemIdPatch = {
  agenciesUsingId?: InputMaybe<FkAgencyMediaItemLogoIdInverseInput>;
  contentType?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationsUsingId?: InputMaybe<DestinationHeroMediaIdFkeyInverseInput>;
  fileName?: InputMaybe<Scalars['String']['input']>;
  hash?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryItemsUsingId?: InputMaybe<FkMediaGalleryItemMediaItemMediaItemIdInverseInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  propertiesUsingId?: InputMaybe<FkPropertyMediaItemHeroMediaIdInverseInput>;
  quoteHeroesUsingId?: InputMaybe<FkQuoteHeroMediaItemImageIdInverseInput>;
  quotesUsingId?: InputMaybe<FkQuoteMediaItemHeroImageIdInverseInput>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceMediaItemMediaItemIdInverseInput>;
};

/** An object where the defined keys will be set on the `note` being updated. */
export type UpdateNoteOnNoteForFkNoteTripTripIdPatch = {
  body?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  tripToTripId?: InputMaybe<FkNoteTripTripIdInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkNoteUserUserIdInput>;
};

/** An object where the defined keys will be set on the `note` being updated. */
export type UpdateNoteOnNoteForFkNoteUserUserIdPatch = {
  body?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkNoteTripTripIdInput>;
  userToUserId?: InputMaybe<FkNoteUserUserIdInput>;
};

/** An object where the defined keys will be set on the `passport` being updated. */
export type UpdatePassportOnPassportForFkPassportTravellerTravellerIdPatch = {
  countryId?: InputMaybe<Scalars['UUID']['input']>;
  countryOfIssue?: InputMaybe<Scalars['String']['input']>;
  countryToCountryId?: InputMaybe<PassportCountry2IdFkeyInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  expiry?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  number?: InputMaybe<Scalars['String']['input']>;
  travellerToTravellerId?: InputMaybe<FkPassportTravellerTravellerIdInput>;
};

/** An object where the defined keys will be set on the `passport` being updated. */
export type UpdatePassportOnPassportForPassportCountry2IdFkeyPatch = {
  countryOfIssue?: InputMaybe<Scalars['String']['input']>;
  countryToCountryId?: InputMaybe<PassportCountry2IdFkeyInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  expiry?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  number?: InputMaybe<Scalars['String']['input']>;
  travellerId?: InputMaybe<Scalars['UUID']['input']>;
  travellerToTravellerId?: InputMaybe<FkPassportTravellerTravellerIdInput>;
};

/** An object where the defined keys will be set on the `payment` being updated. */
export type UpdatePaymentOnPaymentForFkPaymentFinanceCategoryCategoryIdPatch = {
  amount?: InputMaybe<Scalars['BigFloat']['input']>;
  amountActual?: InputMaybe<Scalars['BigFloat']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  financeCategoryToCategoryId?: InputMaybe<FkPaymentFinanceCategoryCategoryIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoiceId?: InputMaybe<Scalars['UUID']['input']>;
  invoiceToInvoiceId?: InputMaybe<FkPaymentInvoiceInvoiceIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  paid?: InputMaybe<Scalars['Datetime']['input']>;
  reference?: InputMaybe<Scalars['String']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  transactionLinksUsingId?: InputMaybe<FkTransactionLinkPaymentPaymentIdInverseInput>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkPaymentTripTripIdInput>;
  type?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `payment` being updated. */
export type UpdatePaymentOnPaymentForFkPaymentInvoiceInvoiceIdPatch = {
  amount?: InputMaybe<Scalars['BigFloat']['input']>;
  amountActual?: InputMaybe<Scalars['BigFloat']['input']>;
  categoryId?: InputMaybe<Scalars['UUID']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  financeCategoryToCategoryId?: InputMaybe<FkPaymentFinanceCategoryCategoryIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoiceToInvoiceId?: InputMaybe<FkPaymentInvoiceInvoiceIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  paid?: InputMaybe<Scalars['Datetime']['input']>;
  reference?: InputMaybe<Scalars['String']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  transactionLinksUsingId?: InputMaybe<FkTransactionLinkPaymentPaymentIdInverseInput>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkPaymentTripTripIdInput>;
  type?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `payment` being updated. */
export type UpdatePaymentOnPaymentForFkPaymentTripTripIdPatch = {
  amount?: InputMaybe<Scalars['BigFloat']['input']>;
  amountActual?: InputMaybe<Scalars['BigFloat']['input']>;
  categoryId?: InputMaybe<Scalars['UUID']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  financeCategoryToCategoryId?: InputMaybe<FkPaymentFinanceCategoryCategoryIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoiceId?: InputMaybe<Scalars['UUID']['input']>;
  invoiceToInvoiceId?: InputMaybe<FkPaymentInvoiceInvoiceIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  paid?: InputMaybe<Scalars['Datetime']['input']>;
  reference?: InputMaybe<Scalars['String']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  transactionLinksUsingId?: InputMaybe<FkTransactionLinkPaymentPaymentIdInverseInput>;
  tripToTripId?: InputMaybe<FkPaymentTripTripIdInput>;
  type?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `payment` being updated. */
export type UpdatePaymentOnTransactionLinkForFkTransactionLinkPaymentPaymentIdPatch = {
  amount?: InputMaybe<Scalars['BigFloat']['input']>;
  amountActual?: InputMaybe<Scalars['BigFloat']['input']>;
  categoryId?: InputMaybe<Scalars['UUID']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  financeCategoryToCategoryId?: InputMaybe<FkPaymentFinanceCategoryCategoryIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoiceId?: InputMaybe<Scalars['UUID']['input']>;
  invoiceToInvoiceId?: InputMaybe<FkPaymentInvoiceInvoiceIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  paid?: InputMaybe<Scalars['Datetime']['input']>;
  reference?: InputMaybe<Scalars['String']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  transactionLinksUsingId?: InputMaybe<FkTransactionLinkPaymentPaymentIdInverseInput>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkPaymentTripTripIdInput>;
  type?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `property` being updated. */
export type UpdatePropertyOnPropertyForFkPropertyCountryCountryIdPatch = {
  alias?: InputMaybe<Scalars['String']['input']>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  contactNumber?: InputMaybe<Scalars['String']['input']>;
  countryToCountryId?: InputMaybe<FkPropertyCountryCountryIdInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationId?: InputMaybe<Scalars['UUID']['input']>;
  destinationToDestinationId?: InputMaybe<FkPropertyDestinationInput>;
  externalReference?: InputMaybe<Scalars['String']['input']>;
  featureCopy?: InputMaybe<Scalars['String']['input']>;
  featured?: InputMaybe<Scalars['Datetime']['input']>;
  galleryId?: InputMaybe<Scalars['UUID']['input']>;
  heroMediaId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  latitude?: InputMaybe<Scalars['Float']['input']>;
  longitude?: InputMaybe<Scalars['Float']['input']>;
  mapPointId?: InputMaybe<Scalars['UUID']['input']>;
  mapPointToMapPointId?: InputMaybe<FkPropertyMapPointMapPointIdInput>;
  mediaGalleryToGalleryId?: InputMaybe<FkPropertyMediaGalleryGalleryIdInput>;
  mediaItemToHeroMediaId?: InputMaybe<FkPropertyMediaItemHeroMediaIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  nearestAirport?: InputMaybe<Scalars['String']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  plusCode?: InputMaybe<Scalars['String']['input']>;
  quoteAccommodationDetailsUsingId?: InputMaybe<FkQuoteAccommodationDetailPropertyPropertyIdInverseInput>;
  quoteDaysUsingId?: InputMaybe<QuoteDayPropertyIdFkeyInverseInput>;
  region?: InputMaybe<Scalars['String']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  timezone?: InputMaybe<Scalars['String']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
};

/** An object where the defined keys will be set on the `property` being updated. */
export type UpdatePropertyOnPropertyForFkPropertyDestinationPatch = {
  alias?: InputMaybe<Scalars['String']['input']>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  contactNumber?: InputMaybe<Scalars['String']['input']>;
  countryId?: InputMaybe<Scalars['UUID']['input']>;
  countryToCountryId?: InputMaybe<FkPropertyCountryCountryIdInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationToDestinationId?: InputMaybe<FkPropertyDestinationInput>;
  externalReference?: InputMaybe<Scalars['String']['input']>;
  featureCopy?: InputMaybe<Scalars['String']['input']>;
  featured?: InputMaybe<Scalars['Datetime']['input']>;
  galleryId?: InputMaybe<Scalars['UUID']['input']>;
  heroMediaId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  latitude?: InputMaybe<Scalars['Float']['input']>;
  longitude?: InputMaybe<Scalars['Float']['input']>;
  mapPointId?: InputMaybe<Scalars['UUID']['input']>;
  mapPointToMapPointId?: InputMaybe<FkPropertyMapPointMapPointIdInput>;
  mediaGalleryToGalleryId?: InputMaybe<FkPropertyMediaGalleryGalleryIdInput>;
  mediaItemToHeroMediaId?: InputMaybe<FkPropertyMediaItemHeroMediaIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  nearestAirport?: InputMaybe<Scalars['String']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  plusCode?: InputMaybe<Scalars['String']['input']>;
  quoteAccommodationDetailsUsingId?: InputMaybe<FkQuoteAccommodationDetailPropertyPropertyIdInverseInput>;
  quoteDaysUsingId?: InputMaybe<QuoteDayPropertyIdFkeyInverseInput>;
  region?: InputMaybe<Scalars['String']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  timezone?: InputMaybe<Scalars['String']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
};

/** An object where the defined keys will be set on the `property` being updated. */
export type UpdatePropertyOnPropertyForFkPropertyMapPointMapPointIdPatch = {
  alias?: InputMaybe<Scalars['String']['input']>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  contactNumber?: InputMaybe<Scalars['String']['input']>;
  countryId?: InputMaybe<Scalars['UUID']['input']>;
  countryToCountryId?: InputMaybe<FkPropertyCountryCountryIdInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationId?: InputMaybe<Scalars['UUID']['input']>;
  destinationToDestinationId?: InputMaybe<FkPropertyDestinationInput>;
  externalReference?: InputMaybe<Scalars['String']['input']>;
  featureCopy?: InputMaybe<Scalars['String']['input']>;
  featured?: InputMaybe<Scalars['Datetime']['input']>;
  galleryId?: InputMaybe<Scalars['UUID']['input']>;
  heroMediaId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  latitude?: InputMaybe<Scalars['Float']['input']>;
  longitude?: InputMaybe<Scalars['Float']['input']>;
  mapPointToMapPointId?: InputMaybe<FkPropertyMapPointMapPointIdInput>;
  mediaGalleryToGalleryId?: InputMaybe<FkPropertyMediaGalleryGalleryIdInput>;
  mediaItemToHeroMediaId?: InputMaybe<FkPropertyMediaItemHeroMediaIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  nearestAirport?: InputMaybe<Scalars['String']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  plusCode?: InputMaybe<Scalars['String']['input']>;
  quoteAccommodationDetailsUsingId?: InputMaybe<FkQuoteAccommodationDetailPropertyPropertyIdInverseInput>;
  quoteDaysUsingId?: InputMaybe<QuoteDayPropertyIdFkeyInverseInput>;
  region?: InputMaybe<Scalars['String']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  timezone?: InputMaybe<Scalars['String']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
};

/** An object where the defined keys will be set on the `property` being updated. */
export type UpdatePropertyOnPropertyForFkPropertyMediaGalleryGalleryIdPatch = {
  alias?: InputMaybe<Scalars['String']['input']>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  contactNumber?: InputMaybe<Scalars['String']['input']>;
  countryId?: InputMaybe<Scalars['UUID']['input']>;
  countryToCountryId?: InputMaybe<FkPropertyCountryCountryIdInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationId?: InputMaybe<Scalars['UUID']['input']>;
  destinationToDestinationId?: InputMaybe<FkPropertyDestinationInput>;
  externalReference?: InputMaybe<Scalars['String']['input']>;
  featureCopy?: InputMaybe<Scalars['String']['input']>;
  featured?: InputMaybe<Scalars['Datetime']['input']>;
  heroMediaId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  latitude?: InputMaybe<Scalars['Float']['input']>;
  longitude?: InputMaybe<Scalars['Float']['input']>;
  mapPointId?: InputMaybe<Scalars['UUID']['input']>;
  mapPointToMapPointId?: InputMaybe<FkPropertyMapPointMapPointIdInput>;
  mediaGalleryToGalleryId?: InputMaybe<FkPropertyMediaGalleryGalleryIdInput>;
  mediaItemToHeroMediaId?: InputMaybe<FkPropertyMediaItemHeroMediaIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  nearestAirport?: InputMaybe<Scalars['String']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  plusCode?: InputMaybe<Scalars['String']['input']>;
  quoteAccommodationDetailsUsingId?: InputMaybe<FkQuoteAccommodationDetailPropertyPropertyIdInverseInput>;
  quoteDaysUsingId?: InputMaybe<QuoteDayPropertyIdFkeyInverseInput>;
  region?: InputMaybe<Scalars['String']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  timezone?: InputMaybe<Scalars['String']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
};

/** An object where the defined keys will be set on the `property` being updated. */
export type UpdatePropertyOnPropertyForFkPropertyMediaItemHeroMediaIdPatch = {
  alias?: InputMaybe<Scalars['String']['input']>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  contactNumber?: InputMaybe<Scalars['String']['input']>;
  countryId?: InputMaybe<Scalars['UUID']['input']>;
  countryToCountryId?: InputMaybe<FkPropertyCountryCountryIdInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationId?: InputMaybe<Scalars['UUID']['input']>;
  destinationToDestinationId?: InputMaybe<FkPropertyDestinationInput>;
  externalReference?: InputMaybe<Scalars['String']['input']>;
  featureCopy?: InputMaybe<Scalars['String']['input']>;
  featured?: InputMaybe<Scalars['Datetime']['input']>;
  galleryId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  latitude?: InputMaybe<Scalars['Float']['input']>;
  longitude?: InputMaybe<Scalars['Float']['input']>;
  mapPointId?: InputMaybe<Scalars['UUID']['input']>;
  mapPointToMapPointId?: InputMaybe<FkPropertyMapPointMapPointIdInput>;
  mediaGalleryToGalleryId?: InputMaybe<FkPropertyMediaGalleryGalleryIdInput>;
  mediaItemToHeroMediaId?: InputMaybe<FkPropertyMediaItemHeroMediaIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  nearestAirport?: InputMaybe<Scalars['String']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  plusCode?: InputMaybe<Scalars['String']['input']>;
  quoteAccommodationDetailsUsingId?: InputMaybe<FkQuoteAccommodationDetailPropertyPropertyIdInverseInput>;
  quoteDaysUsingId?: InputMaybe<QuoteDayPropertyIdFkeyInverseInput>;
  region?: InputMaybe<Scalars['String']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  timezone?: InputMaybe<Scalars['String']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
};

/** An object where the defined keys will be set on the `property` being updated. */
export type UpdatePropertyOnQuoteAccommodationDetailForFkQuoteAccommodationDetailPropertyPropertyIdPatch = {
  alias?: InputMaybe<Scalars['String']['input']>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  contactNumber?: InputMaybe<Scalars['String']['input']>;
  countryId?: InputMaybe<Scalars['UUID']['input']>;
  countryToCountryId?: InputMaybe<FkPropertyCountryCountryIdInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationId?: InputMaybe<Scalars['UUID']['input']>;
  destinationToDestinationId?: InputMaybe<FkPropertyDestinationInput>;
  externalReference?: InputMaybe<Scalars['String']['input']>;
  featureCopy?: InputMaybe<Scalars['String']['input']>;
  featured?: InputMaybe<Scalars['Datetime']['input']>;
  galleryId?: InputMaybe<Scalars['UUID']['input']>;
  heroMediaId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  latitude?: InputMaybe<Scalars['Float']['input']>;
  longitude?: InputMaybe<Scalars['Float']['input']>;
  mapPointId?: InputMaybe<Scalars['UUID']['input']>;
  mapPointToMapPointId?: InputMaybe<FkPropertyMapPointMapPointIdInput>;
  mediaGalleryToGalleryId?: InputMaybe<FkPropertyMediaGalleryGalleryIdInput>;
  mediaItemToHeroMediaId?: InputMaybe<FkPropertyMediaItemHeroMediaIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  nearestAirport?: InputMaybe<Scalars['String']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  plusCode?: InputMaybe<Scalars['String']['input']>;
  quoteAccommodationDetailsUsingId?: InputMaybe<FkQuoteAccommodationDetailPropertyPropertyIdInverseInput>;
  quoteDaysUsingId?: InputMaybe<QuoteDayPropertyIdFkeyInverseInput>;
  region?: InputMaybe<Scalars['String']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  timezone?: InputMaybe<Scalars['String']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
};

/** An object where the defined keys will be set on the `property` being updated. */
export type UpdatePropertyOnQuoteDayForQuoteDayPropertyIdFkeyPatch = {
  alias?: InputMaybe<Scalars['String']['input']>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  city?: InputMaybe<Scalars['String']['input']>;
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  contactNumber?: InputMaybe<Scalars['String']['input']>;
  countryId?: InputMaybe<Scalars['UUID']['input']>;
  countryToCountryId?: InputMaybe<FkPropertyCountryCountryIdInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  destinationId?: InputMaybe<Scalars['UUID']['input']>;
  destinationToDestinationId?: InputMaybe<FkPropertyDestinationInput>;
  externalReference?: InputMaybe<Scalars['String']['input']>;
  featureCopy?: InputMaybe<Scalars['String']['input']>;
  featured?: InputMaybe<Scalars['Datetime']['input']>;
  galleryId?: InputMaybe<Scalars['UUID']['input']>;
  heroMediaId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  latitude?: InputMaybe<Scalars['Float']['input']>;
  longitude?: InputMaybe<Scalars['Float']['input']>;
  mapPointId?: InputMaybe<Scalars['UUID']['input']>;
  mapPointToMapPointId?: InputMaybe<FkPropertyMapPointMapPointIdInput>;
  mediaGalleryToGalleryId?: InputMaybe<FkPropertyMediaGalleryGalleryIdInput>;
  mediaItemToHeroMediaId?: InputMaybe<FkPropertyMediaItemHeroMediaIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  nearestAirport?: InputMaybe<Scalars['String']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  plusCode?: InputMaybe<Scalars['String']['input']>;
  quoteAccommodationDetailsUsingId?: InputMaybe<FkQuoteAccommodationDetailPropertyPropertyIdInverseInput>;
  quoteDaysUsingId?: InputMaybe<QuoteDayPropertyIdFkeyInverseInput>;
  region?: InputMaybe<Scalars['String']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  timezone?: InputMaybe<Scalars['String']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
};

/** An object where the defined keys will be set on the `quoteAcceptance` being updated. */
export type UpdateQuoteAcceptanceOnQuoteAcceptanceForFkQuoteAcceptanceQuotePatch = {
  accepted?: InputMaybe<Scalars['Datetime']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  quoteToQuoteId?: InputMaybe<FkQuoteAcceptanceQuoteInput>;
  voided?: InputMaybe<Scalars['Datetime']['input']>;
};

/** An object where the defined keys will be set on the `quoteAccommodationDetail` being updated. */
export type UpdateQuoteAccommodationDetailOnQuoteAccommodationDetailForFakePublicQuoteAccommodationDetailForeignKey0Patch = {
  basis?: InputMaybe<Scalars['String']['input']>;
  beverageInclusions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  confirmation?: InputMaybe<Scalars['String']['input']>;
  foodInclusions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  nights?: InputMaybe<Scalars['Int']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  propertyId?: InputMaybe<Scalars['UUID']['input']>;
  propertyToPropertyId?: InputMaybe<FkQuoteAccommodationDetailPropertyPropertyIdInput>;
  quoteDaysUsingId?: InputMaybe<FkQuoteDayQuoteAccommodationDetailAccommodationIdInverseInput>;
  quotePublic?: InputMaybe<FakePublicQuoteAccommodationDetailForeignKey0Input>;
  quoteToQuoteId?: InputMaybe<FkQuoteAccommodationDetailQuoteQuoteIdInput>;
  roomType?: InputMaybe<Scalars['String']['input']>;
  sortOrder?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
};

/** An object where the defined keys will be set on the `quoteAccommodationDetail` being updated. */
export type UpdateQuoteAccommodationDetailOnQuoteAccommodationDetailForFkQuoteAccommodationDetailPropertyPropertyIdPatch = {
  basis?: InputMaybe<Scalars['String']['input']>;
  beverageInclusions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  confirmation?: InputMaybe<Scalars['String']['input']>;
  foodInclusions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  nights?: InputMaybe<Scalars['Int']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  propertyToPropertyId?: InputMaybe<FkQuoteAccommodationDetailPropertyPropertyIdInput>;
  quoteDaysUsingId?: InputMaybe<FkQuoteDayQuoteAccommodationDetailAccommodationIdInverseInput>;
  quoteId?: InputMaybe<Scalars['UUID']['input']>;
  quotePublic?: InputMaybe<FakePublicQuoteAccommodationDetailForeignKey0Input>;
  quoteToQuoteId?: InputMaybe<FkQuoteAccommodationDetailQuoteQuoteIdInput>;
  roomType?: InputMaybe<Scalars['String']['input']>;
  sortOrder?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
};

/** An object where the defined keys will be set on the `quoteAccommodationDetail` being updated. */
export type UpdateQuoteAccommodationDetailOnQuoteAccommodationDetailForFkQuoteAccommodationDetailQuoteQuoteIdPatch = {
  basis?: InputMaybe<Scalars['String']['input']>;
  beverageInclusions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  confirmation?: InputMaybe<Scalars['String']['input']>;
  foodInclusions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  nights?: InputMaybe<Scalars['Int']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  propertyId?: InputMaybe<Scalars['UUID']['input']>;
  propertyToPropertyId?: InputMaybe<FkQuoteAccommodationDetailPropertyPropertyIdInput>;
  quoteDaysUsingId?: InputMaybe<FkQuoteDayQuoteAccommodationDetailAccommodationIdInverseInput>;
  quotePublic?: InputMaybe<FakePublicQuoteAccommodationDetailForeignKey0Input>;
  quoteToQuoteId?: InputMaybe<FkQuoteAccommodationDetailQuoteQuoteIdInput>;
  roomType?: InputMaybe<Scalars['String']['input']>;
  sortOrder?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
};

/** An object where the defined keys will be set on the `quoteAccommodationDetail` being updated. */
export type UpdateQuoteAccommodationDetailOnQuoteDayForFkQuoteDayQuoteAccommodationDetailAccommodationIdPatch = {
  basis?: InputMaybe<Scalars['String']['input']>;
  beverageInclusions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  confirmation?: InputMaybe<Scalars['String']['input']>;
  foodInclusions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  nights?: InputMaybe<Scalars['Int']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  propertyId?: InputMaybe<Scalars['UUID']['input']>;
  propertyToPropertyId?: InputMaybe<FkQuoteAccommodationDetailPropertyPropertyIdInput>;
  quoteDaysUsingId?: InputMaybe<FkQuoteDayQuoteAccommodationDetailAccommodationIdInverseInput>;
  quoteId?: InputMaybe<Scalars['UUID']['input']>;
  quotePublic?: InputMaybe<FakePublicQuoteAccommodationDetailForeignKey0Input>;
  quoteToQuoteId?: InputMaybe<FkQuoteAccommodationDetailQuoteQuoteIdInput>;
  roomType?: InputMaybe<Scalars['String']['input']>;
  sortOrder?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
};

/** An object where the defined keys will be set on the `quoteCurrency` being updated. */
export type UpdateQuoteCurrencyOnQuoteCurrencyForFkQuoteCurrencyQuoteQuoteIdPatch = {
  code?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  quoteToQuoteId?: InputMaybe<FkQuoteCurrencyQuoteQuoteIdInput>;
  rate?: InputMaybe<Scalars['BigFloat']['input']>;
};

/** An object where the defined keys will be set on the `quoteDayDestination` being updated. */
export type UpdateQuoteDayDestinationOnQuoteDayDestinationForFkQuoteDayDestinationDestinationDestinationIdPatch = {
  dayId?: InputMaybe<Scalars['UUID']['input']>;
  destinationToDestinationId?: InputMaybe<FkQuoteDayDestinationDestinationDestinationIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  quoteDayToDayId?: InputMaybe<FkQuoteDayDestinationQuoteDayDayIdInput>;
  sortOrder?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `quoteDayDestination` being updated. */
export type UpdateQuoteDayDestinationOnQuoteDayDestinationForFkQuoteDayDestinationQuoteDayDayIdPatch = {
  destinationId?: InputMaybe<Scalars['UUID']['input']>;
  destinationToDestinationId?: InputMaybe<FkQuoteDayDestinationDestinationDestinationIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  quoteDayToDayId?: InputMaybe<FkQuoteDayDestinationQuoteDayDayIdInput>;
  sortOrder?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `quoteDay` being updated. */
export type UpdateQuoteDayOnQuoteDayDestinationForFkQuoteDayDestinationQuoteDayDayIdPatch = {
  accommodationId?: InputMaybe<Scalars['UUID']['input']>;
  activityDetail?: InputMaybe<Scalars['String']['input']>;
  activitySummary?: InputMaybe<Scalars['String']['input']>;
  date?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  propertyId?: InputMaybe<Scalars['UUID']['input']>;
  propertyToPropertyId?: InputMaybe<QuoteDayPropertyIdFkeyInput>;
  quoteAccommodationDetailToAccommodationId?: InputMaybe<FkQuoteDayQuoteAccommodationDetailAccommodationIdInput>;
  quoteDayDestinationsUsingId?: InputMaybe<FkQuoteDayDestinationQuoteDayDayIdInverseInput>;
  quoteId?: InputMaybe<Scalars['UUID']['input']>;
  quotePublic?: InputMaybe<FakePublicQuoteDayForeignKey0Input>;
  quoteToQuoteId?: InputMaybe<FkQuoteDayQuoteQuoteIdInput>;
  sortOrder?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `quoteDay` being updated. */
export type UpdateQuoteDayOnQuoteDayForFakePublicQuoteDayForeignKey0Patch = {
  accommodationId?: InputMaybe<Scalars['UUID']['input']>;
  activityDetail?: InputMaybe<Scalars['String']['input']>;
  activitySummary?: InputMaybe<Scalars['String']['input']>;
  date?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  propertyId?: InputMaybe<Scalars['UUID']['input']>;
  propertyToPropertyId?: InputMaybe<QuoteDayPropertyIdFkeyInput>;
  quoteAccommodationDetailToAccommodationId?: InputMaybe<FkQuoteDayQuoteAccommodationDetailAccommodationIdInput>;
  quoteDayDestinationsUsingId?: InputMaybe<FkQuoteDayDestinationQuoteDayDayIdInverseInput>;
  quotePublic?: InputMaybe<FakePublicQuoteDayForeignKey0Input>;
  quoteToQuoteId?: InputMaybe<FkQuoteDayQuoteQuoteIdInput>;
  sortOrder?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `quoteDay` being updated. */
export type UpdateQuoteDayOnQuoteDayForFkQuoteDayQuoteAccommodationDetailAccommodationIdPatch = {
  activityDetail?: InputMaybe<Scalars['String']['input']>;
  activitySummary?: InputMaybe<Scalars['String']['input']>;
  date?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  propertyId?: InputMaybe<Scalars['UUID']['input']>;
  propertyToPropertyId?: InputMaybe<QuoteDayPropertyIdFkeyInput>;
  quoteAccommodationDetailToAccommodationId?: InputMaybe<FkQuoteDayQuoteAccommodationDetailAccommodationIdInput>;
  quoteDayDestinationsUsingId?: InputMaybe<FkQuoteDayDestinationQuoteDayDayIdInverseInput>;
  quoteId?: InputMaybe<Scalars['UUID']['input']>;
  quotePublic?: InputMaybe<FakePublicQuoteDayForeignKey0Input>;
  quoteToQuoteId?: InputMaybe<FkQuoteDayQuoteQuoteIdInput>;
  sortOrder?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `quoteDay` being updated. */
export type UpdateQuoteDayOnQuoteDayForFkQuoteDayQuoteQuoteIdPatch = {
  accommodationId?: InputMaybe<Scalars['UUID']['input']>;
  activityDetail?: InputMaybe<Scalars['String']['input']>;
  activitySummary?: InputMaybe<Scalars['String']['input']>;
  date?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  propertyId?: InputMaybe<Scalars['UUID']['input']>;
  propertyToPropertyId?: InputMaybe<QuoteDayPropertyIdFkeyInput>;
  quoteAccommodationDetailToAccommodationId?: InputMaybe<FkQuoteDayQuoteAccommodationDetailAccommodationIdInput>;
  quoteDayDestinationsUsingId?: InputMaybe<FkQuoteDayDestinationQuoteDayDayIdInverseInput>;
  quotePublic?: InputMaybe<FakePublicQuoteDayForeignKey0Input>;
  quoteToQuoteId?: InputMaybe<FkQuoteDayQuoteQuoteIdInput>;
  sortOrder?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `quoteDay` being updated. */
export type UpdateQuoteDayOnQuoteDayForQuoteDayPropertyIdFkeyPatch = {
  accommodationId?: InputMaybe<Scalars['UUID']['input']>;
  activityDetail?: InputMaybe<Scalars['String']['input']>;
  activitySummary?: InputMaybe<Scalars['String']['input']>;
  date?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  propertyToPropertyId?: InputMaybe<QuoteDayPropertyIdFkeyInput>;
  quoteAccommodationDetailToAccommodationId?: InputMaybe<FkQuoteDayQuoteAccommodationDetailAccommodationIdInput>;
  quoteDayDestinationsUsingId?: InputMaybe<FkQuoteDayDestinationQuoteDayDayIdInverseInput>;
  quoteId?: InputMaybe<Scalars['UUID']['input']>;
  quotePublic?: InputMaybe<FakePublicQuoteDayForeignKey0Input>;
  quoteToQuoteId?: InputMaybe<FkQuoteDayQuoteQuoteIdInput>;
  sortOrder?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `quoteFinanceLineItem` being updated. */
export type UpdateQuoteFinanceLineItemOnQuoteFinanceLineItemForFkQuoteFinanceLineItemQuoteQuoteIdPatch = {
  amount?: InputMaybe<Scalars['BigFloat']['input']>;
  confirmation?: InputMaybe<Scalars['String']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  excludeMargin?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  marginOverride?: InputMaybe<Scalars['BigFloat']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  quoteToQuoteId?: InputMaybe<FkQuoteFinanceLineItemQuoteQuoteIdInput>;
  sortOrder?: InputMaybe<Scalars['Int']['input']>;
  supplierId?: InputMaybe<Scalars['UUID']['input']>;
  supplierToSupplierId?: InputMaybe<FkQuoteFinanceLineItemSupplierSupplierIdInput>;
};

/** An object where the defined keys will be set on the `quoteFinanceLineItem` being updated. */
export type UpdateQuoteFinanceLineItemOnQuoteFinanceLineItemForFkQuoteFinanceLineItemSupplierSupplierIdPatch = {
  amount?: InputMaybe<Scalars['BigFloat']['input']>;
  confirmation?: InputMaybe<Scalars['String']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  excludeMargin?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  marginOverride?: InputMaybe<Scalars['BigFloat']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  quoteId?: InputMaybe<Scalars['UUID']['input']>;
  quoteToQuoteId?: InputMaybe<FkQuoteFinanceLineItemQuoteQuoteIdInput>;
  sortOrder?: InputMaybe<Scalars['Int']['input']>;
  supplierToSupplierId?: InputMaybe<FkQuoteFinanceLineItemSupplierSupplierIdInput>;
};

/** An object where the defined keys will be set on the `quoteHero` being updated. */
export type UpdateQuoteHeroOnQuoteForFkQuoteQuoteHeroHeroIdPatch = {
  id?: InputMaybe<Scalars['UUID']['input']>;
  imageId?: InputMaybe<Scalars['UUID']['input']>;
  mediaItemToImageId?: InputMaybe<FkQuoteHeroMediaItemImageIdInput>;
  quotePublicsUsingId?: InputMaybe<FakePublicQuotePublicForeignKey1InverseInput>;
  quotesUsingId?: InputMaybe<FkQuoteQuoteHeroHeroIdInverseInput>;
  style?: InputMaybe<Scalars['String']['input']>;
  subtitle?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** An object where the defined keys will be set on the `quoteHero` being updated. */
export type UpdateQuoteHeroOnQuoteHeroForFkQuoteHeroMediaItemImageIdPatch = {
  id?: InputMaybe<Scalars['UUID']['input']>;
  mediaItemToImageId?: InputMaybe<FkQuoteHeroMediaItemImageIdInput>;
  quotePublicsUsingId?: InputMaybe<FakePublicQuotePublicForeignKey1InverseInput>;
  quotesUsingId?: InputMaybe<FkQuoteQuoteHeroHeroIdInverseInput>;
  style?: InputMaybe<Scalars['String']['input']>;
  subtitle?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** An object where the defined keys will be set on the `quoteHero` being updated. */
export type UpdateQuoteHeroOnQuotePublicForFakePublicQuotePublicForeignKey1Patch = {
  id?: InputMaybe<Scalars['UUID']['input']>;
  imageId?: InputMaybe<Scalars['UUID']['input']>;
  mediaItemToImageId?: InputMaybe<FkQuoteHeroMediaItemImageIdInput>;
  quotePublicsUsingId?: InputMaybe<FakePublicQuotePublicForeignKey1InverseInput>;
  quotesUsingId?: InputMaybe<FkQuoteQuoteHeroHeroIdInverseInput>;
  style?: InputMaybe<Scalars['String']['input']>;
  subtitle?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** An object where the defined keys will be set on the `quoteLegalDocument` being updated. */
export type UpdateQuoteLegalDocumentOnQuoteLegalDocumentForFakePublicQuoteLegalDocumentForeignKey0Patch = {
  id?: InputMaybe<Scalars['UUID']['input']>;
  legalDocumentId?: InputMaybe<Scalars['UUID']['input']>;
  legalDocumentToLegalDocumentId?: InputMaybe<FkQuoteLegalDocumentLegalDocumentInput>;
  quotePublic?: InputMaybe<FakePublicQuoteLegalDocumentForeignKey0Input>;
  quoteToQuoteId?: InputMaybe<FkQuoteLegalDocumentQuoteInput>;
  sortOrder?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `quoteLegalDocument` being updated. */
export type UpdateQuoteLegalDocumentOnQuoteLegalDocumentForFkQuoteLegalDocumentLegalDocumentPatch = {
  id?: InputMaybe<Scalars['UUID']['input']>;
  legalDocumentToLegalDocumentId?: InputMaybe<FkQuoteLegalDocumentLegalDocumentInput>;
  quoteId?: InputMaybe<Scalars['UUID']['input']>;
  quotePublic?: InputMaybe<FakePublicQuoteLegalDocumentForeignKey0Input>;
  quoteToQuoteId?: InputMaybe<FkQuoteLegalDocumentQuoteInput>;
  sortOrder?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `quoteLegalDocument` being updated. */
export type UpdateQuoteLegalDocumentOnQuoteLegalDocumentForFkQuoteLegalDocumentQuotePatch = {
  id?: InputMaybe<Scalars['UUID']['input']>;
  legalDocumentId?: InputMaybe<Scalars['UUID']['input']>;
  legalDocumentToLegalDocumentId?: InputMaybe<FkQuoteLegalDocumentLegalDocumentInput>;
  quotePublic?: InputMaybe<FakePublicQuoteLegalDocumentForeignKey0Input>;
  quoteToQuoteId?: InputMaybe<FkQuoteLegalDocumentQuoteInput>;
  sortOrder?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `quote` being updated. */
export type UpdateQuoteOnEmailForFkEmailQuoteQuoteIdPatch = {
  adjustment?: InputMaybe<Scalars['BigFloat']['input']>;
  agentMargin?: InputMaybe<Scalars['BigFloat']['input']>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  deposit?: InputMaybe<Scalars['BigFloat']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  emailsUsingId?: InputMaybe<FkEmailQuoteQuoteIdInverseInput>;
  exclusions?: InputMaybe<Scalars['String']['input']>;
  expires?: InputMaybe<Scalars['Datetime']['input']>;
  heroId?: InputMaybe<Scalars['UUID']['input']>;
  heroImageId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  inclusions?: InputMaybe<Scalars['String']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceQuoteQuoteIdInverseInput>;
  key?: InputMaybe<Scalars['String']['input']>;
  locked?: InputMaybe<Scalars['Datetime']['input']>;
  margin?: InputMaybe<Scalars['BigFloat']['input']>;
  mediaItemToHeroImageId?: InputMaybe<FkQuoteMediaItemHeroImageIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  quoteAcceptancesUsingId?: InputMaybe<FkQuoteAcceptanceQuoteInverseInput>;
  quoteAccommodationDetailsUsingId?: InputMaybe<FkQuoteAccommodationDetailQuoteQuoteIdInverseInput>;
  quoteCurrenciesUsingId?: InputMaybe<FkQuoteCurrencyQuoteQuoteIdInverseInput>;
  quoteDaysUsingId?: InputMaybe<FkQuoteDayQuoteQuoteIdInverseInput>;
  quoteFinanceLineItemsUsingId?: InputMaybe<FkQuoteFinanceLineItemQuoteQuoteIdInverseInput>;
  quoteHeroToHeroId?: InputMaybe<FkQuoteQuoteHeroHeroIdInput>;
  quoteLegalDocumentsUsingId?: InputMaybe<FkQuoteLegalDocumentQuoteInverseInput>;
  quoteStatusToStatus?: InputMaybe<FkQuoteStatusInput>;
  quoteViewsUsingId?: InputMaybe<FkQuoteViewQuoteQuoteIdInverseInput>;
  shortDescription?: InputMaybe<Scalars['String']['input']>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  travellerCount?: InputMaybe<Scalars['Int']['input']>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkQuoteTripTripIdInput>;
  tripsUsingId?: InputMaybe<FkTripQuoteActiveQuoteIdInverseInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkQuoteUserUserIdInput>;
};

/** An object where the defined keys will be set on the `quote` being updated. */
export type UpdateQuoteOnInvoiceForFkInvoiceQuoteQuoteIdPatch = {
  adjustment?: InputMaybe<Scalars['BigFloat']['input']>;
  agentMargin?: InputMaybe<Scalars['BigFloat']['input']>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  deposit?: InputMaybe<Scalars['BigFloat']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  emailsUsingId?: InputMaybe<FkEmailQuoteQuoteIdInverseInput>;
  exclusions?: InputMaybe<Scalars['String']['input']>;
  expires?: InputMaybe<Scalars['Datetime']['input']>;
  heroId?: InputMaybe<Scalars['UUID']['input']>;
  heroImageId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  inclusions?: InputMaybe<Scalars['String']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceQuoteQuoteIdInverseInput>;
  key?: InputMaybe<Scalars['String']['input']>;
  locked?: InputMaybe<Scalars['Datetime']['input']>;
  margin?: InputMaybe<Scalars['BigFloat']['input']>;
  mediaItemToHeroImageId?: InputMaybe<FkQuoteMediaItemHeroImageIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  quoteAcceptancesUsingId?: InputMaybe<FkQuoteAcceptanceQuoteInverseInput>;
  quoteAccommodationDetailsUsingId?: InputMaybe<FkQuoteAccommodationDetailQuoteQuoteIdInverseInput>;
  quoteCurrenciesUsingId?: InputMaybe<FkQuoteCurrencyQuoteQuoteIdInverseInput>;
  quoteDaysUsingId?: InputMaybe<FkQuoteDayQuoteQuoteIdInverseInput>;
  quoteFinanceLineItemsUsingId?: InputMaybe<FkQuoteFinanceLineItemQuoteQuoteIdInverseInput>;
  quoteHeroToHeroId?: InputMaybe<FkQuoteQuoteHeroHeroIdInput>;
  quoteLegalDocumentsUsingId?: InputMaybe<FkQuoteLegalDocumentQuoteInverseInput>;
  quoteStatusToStatus?: InputMaybe<FkQuoteStatusInput>;
  quoteViewsUsingId?: InputMaybe<FkQuoteViewQuoteQuoteIdInverseInput>;
  shortDescription?: InputMaybe<Scalars['String']['input']>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  travellerCount?: InputMaybe<Scalars['Int']['input']>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkQuoteTripTripIdInput>;
  tripsUsingId?: InputMaybe<FkTripQuoteActiveQuoteIdInverseInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkQuoteUserUserIdInput>;
};

/** An object where the defined keys will be set on the `quote` being updated. */
export type UpdateQuoteOnQuoteAcceptanceForFkQuoteAcceptanceQuotePatch = {
  adjustment?: InputMaybe<Scalars['BigFloat']['input']>;
  agentMargin?: InputMaybe<Scalars['BigFloat']['input']>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  deposit?: InputMaybe<Scalars['BigFloat']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  emailsUsingId?: InputMaybe<FkEmailQuoteQuoteIdInverseInput>;
  exclusions?: InputMaybe<Scalars['String']['input']>;
  expires?: InputMaybe<Scalars['Datetime']['input']>;
  heroId?: InputMaybe<Scalars['UUID']['input']>;
  heroImageId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  inclusions?: InputMaybe<Scalars['String']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceQuoteQuoteIdInverseInput>;
  key?: InputMaybe<Scalars['String']['input']>;
  locked?: InputMaybe<Scalars['Datetime']['input']>;
  margin?: InputMaybe<Scalars['BigFloat']['input']>;
  mediaItemToHeroImageId?: InputMaybe<FkQuoteMediaItemHeroImageIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  quoteAcceptancesUsingId?: InputMaybe<FkQuoteAcceptanceQuoteInverseInput>;
  quoteAccommodationDetailsUsingId?: InputMaybe<FkQuoteAccommodationDetailQuoteQuoteIdInverseInput>;
  quoteCurrenciesUsingId?: InputMaybe<FkQuoteCurrencyQuoteQuoteIdInverseInput>;
  quoteDaysUsingId?: InputMaybe<FkQuoteDayQuoteQuoteIdInverseInput>;
  quoteFinanceLineItemsUsingId?: InputMaybe<FkQuoteFinanceLineItemQuoteQuoteIdInverseInput>;
  quoteHeroToHeroId?: InputMaybe<FkQuoteQuoteHeroHeroIdInput>;
  quoteLegalDocumentsUsingId?: InputMaybe<FkQuoteLegalDocumentQuoteInverseInput>;
  quoteStatusToStatus?: InputMaybe<FkQuoteStatusInput>;
  quoteViewsUsingId?: InputMaybe<FkQuoteViewQuoteQuoteIdInverseInput>;
  shortDescription?: InputMaybe<Scalars['String']['input']>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  travellerCount?: InputMaybe<Scalars['Int']['input']>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkQuoteTripTripIdInput>;
  tripsUsingId?: InputMaybe<FkTripQuoteActiveQuoteIdInverseInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkQuoteUserUserIdInput>;
};

/** An object where the defined keys will be set on the `quote` being updated. */
export type UpdateQuoteOnQuoteAccommodationDetailForFkQuoteAccommodationDetailQuoteQuoteIdPatch = {
  adjustment?: InputMaybe<Scalars['BigFloat']['input']>;
  agentMargin?: InputMaybe<Scalars['BigFloat']['input']>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  deposit?: InputMaybe<Scalars['BigFloat']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  emailsUsingId?: InputMaybe<FkEmailQuoteQuoteIdInverseInput>;
  exclusions?: InputMaybe<Scalars['String']['input']>;
  expires?: InputMaybe<Scalars['Datetime']['input']>;
  heroId?: InputMaybe<Scalars['UUID']['input']>;
  heroImageId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  inclusions?: InputMaybe<Scalars['String']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceQuoteQuoteIdInverseInput>;
  key?: InputMaybe<Scalars['String']['input']>;
  locked?: InputMaybe<Scalars['Datetime']['input']>;
  margin?: InputMaybe<Scalars['BigFloat']['input']>;
  mediaItemToHeroImageId?: InputMaybe<FkQuoteMediaItemHeroImageIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  quoteAcceptancesUsingId?: InputMaybe<FkQuoteAcceptanceQuoteInverseInput>;
  quoteAccommodationDetailsUsingId?: InputMaybe<FkQuoteAccommodationDetailQuoteQuoteIdInverseInput>;
  quoteCurrenciesUsingId?: InputMaybe<FkQuoteCurrencyQuoteQuoteIdInverseInput>;
  quoteDaysUsingId?: InputMaybe<FkQuoteDayQuoteQuoteIdInverseInput>;
  quoteFinanceLineItemsUsingId?: InputMaybe<FkQuoteFinanceLineItemQuoteQuoteIdInverseInput>;
  quoteHeroToHeroId?: InputMaybe<FkQuoteQuoteHeroHeroIdInput>;
  quoteLegalDocumentsUsingId?: InputMaybe<FkQuoteLegalDocumentQuoteInverseInput>;
  quoteStatusToStatus?: InputMaybe<FkQuoteStatusInput>;
  quoteViewsUsingId?: InputMaybe<FkQuoteViewQuoteQuoteIdInverseInput>;
  shortDescription?: InputMaybe<Scalars['String']['input']>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  travellerCount?: InputMaybe<Scalars['Int']['input']>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkQuoteTripTripIdInput>;
  tripsUsingId?: InputMaybe<FkTripQuoteActiveQuoteIdInverseInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkQuoteUserUserIdInput>;
};

/** An object where the defined keys will be set on the `quote` being updated. */
export type UpdateQuoteOnQuoteCurrencyForFkQuoteCurrencyQuoteQuoteIdPatch = {
  adjustment?: InputMaybe<Scalars['BigFloat']['input']>;
  agentMargin?: InputMaybe<Scalars['BigFloat']['input']>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  deposit?: InputMaybe<Scalars['BigFloat']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  emailsUsingId?: InputMaybe<FkEmailQuoteQuoteIdInverseInput>;
  exclusions?: InputMaybe<Scalars['String']['input']>;
  expires?: InputMaybe<Scalars['Datetime']['input']>;
  heroId?: InputMaybe<Scalars['UUID']['input']>;
  heroImageId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  inclusions?: InputMaybe<Scalars['String']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceQuoteQuoteIdInverseInput>;
  key?: InputMaybe<Scalars['String']['input']>;
  locked?: InputMaybe<Scalars['Datetime']['input']>;
  margin?: InputMaybe<Scalars['BigFloat']['input']>;
  mediaItemToHeroImageId?: InputMaybe<FkQuoteMediaItemHeroImageIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  quoteAcceptancesUsingId?: InputMaybe<FkQuoteAcceptanceQuoteInverseInput>;
  quoteAccommodationDetailsUsingId?: InputMaybe<FkQuoteAccommodationDetailQuoteQuoteIdInverseInput>;
  quoteCurrenciesUsingId?: InputMaybe<FkQuoteCurrencyQuoteQuoteIdInverseInput>;
  quoteDaysUsingId?: InputMaybe<FkQuoteDayQuoteQuoteIdInverseInput>;
  quoteFinanceLineItemsUsingId?: InputMaybe<FkQuoteFinanceLineItemQuoteQuoteIdInverseInput>;
  quoteHeroToHeroId?: InputMaybe<FkQuoteQuoteHeroHeroIdInput>;
  quoteLegalDocumentsUsingId?: InputMaybe<FkQuoteLegalDocumentQuoteInverseInput>;
  quoteStatusToStatus?: InputMaybe<FkQuoteStatusInput>;
  quoteViewsUsingId?: InputMaybe<FkQuoteViewQuoteQuoteIdInverseInput>;
  shortDescription?: InputMaybe<Scalars['String']['input']>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  travellerCount?: InputMaybe<Scalars['Int']['input']>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkQuoteTripTripIdInput>;
  tripsUsingId?: InputMaybe<FkTripQuoteActiveQuoteIdInverseInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkQuoteUserUserIdInput>;
};

/** An object where the defined keys will be set on the `quote` being updated. */
export type UpdateQuoteOnQuoteDayForFkQuoteDayQuoteQuoteIdPatch = {
  adjustment?: InputMaybe<Scalars['BigFloat']['input']>;
  agentMargin?: InputMaybe<Scalars['BigFloat']['input']>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  deposit?: InputMaybe<Scalars['BigFloat']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  emailsUsingId?: InputMaybe<FkEmailQuoteQuoteIdInverseInput>;
  exclusions?: InputMaybe<Scalars['String']['input']>;
  expires?: InputMaybe<Scalars['Datetime']['input']>;
  heroId?: InputMaybe<Scalars['UUID']['input']>;
  heroImageId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  inclusions?: InputMaybe<Scalars['String']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceQuoteQuoteIdInverseInput>;
  key?: InputMaybe<Scalars['String']['input']>;
  locked?: InputMaybe<Scalars['Datetime']['input']>;
  margin?: InputMaybe<Scalars['BigFloat']['input']>;
  mediaItemToHeroImageId?: InputMaybe<FkQuoteMediaItemHeroImageIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  quoteAcceptancesUsingId?: InputMaybe<FkQuoteAcceptanceQuoteInverseInput>;
  quoteAccommodationDetailsUsingId?: InputMaybe<FkQuoteAccommodationDetailQuoteQuoteIdInverseInput>;
  quoteCurrenciesUsingId?: InputMaybe<FkQuoteCurrencyQuoteQuoteIdInverseInput>;
  quoteDaysUsingId?: InputMaybe<FkQuoteDayQuoteQuoteIdInverseInput>;
  quoteFinanceLineItemsUsingId?: InputMaybe<FkQuoteFinanceLineItemQuoteQuoteIdInverseInput>;
  quoteHeroToHeroId?: InputMaybe<FkQuoteQuoteHeroHeroIdInput>;
  quoteLegalDocumentsUsingId?: InputMaybe<FkQuoteLegalDocumentQuoteInverseInput>;
  quoteStatusToStatus?: InputMaybe<FkQuoteStatusInput>;
  quoteViewsUsingId?: InputMaybe<FkQuoteViewQuoteQuoteIdInverseInput>;
  shortDescription?: InputMaybe<Scalars['String']['input']>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  travellerCount?: InputMaybe<Scalars['Int']['input']>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkQuoteTripTripIdInput>;
  tripsUsingId?: InputMaybe<FkTripQuoteActiveQuoteIdInverseInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkQuoteUserUserIdInput>;
};

/** An object where the defined keys will be set on the `quote` being updated. */
export type UpdateQuoteOnQuoteFinanceLineItemForFkQuoteFinanceLineItemQuoteQuoteIdPatch = {
  adjustment?: InputMaybe<Scalars['BigFloat']['input']>;
  agentMargin?: InputMaybe<Scalars['BigFloat']['input']>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  deposit?: InputMaybe<Scalars['BigFloat']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  emailsUsingId?: InputMaybe<FkEmailQuoteQuoteIdInverseInput>;
  exclusions?: InputMaybe<Scalars['String']['input']>;
  expires?: InputMaybe<Scalars['Datetime']['input']>;
  heroId?: InputMaybe<Scalars['UUID']['input']>;
  heroImageId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  inclusions?: InputMaybe<Scalars['String']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceQuoteQuoteIdInverseInput>;
  key?: InputMaybe<Scalars['String']['input']>;
  locked?: InputMaybe<Scalars['Datetime']['input']>;
  margin?: InputMaybe<Scalars['BigFloat']['input']>;
  mediaItemToHeroImageId?: InputMaybe<FkQuoteMediaItemHeroImageIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  quoteAcceptancesUsingId?: InputMaybe<FkQuoteAcceptanceQuoteInverseInput>;
  quoteAccommodationDetailsUsingId?: InputMaybe<FkQuoteAccommodationDetailQuoteQuoteIdInverseInput>;
  quoteCurrenciesUsingId?: InputMaybe<FkQuoteCurrencyQuoteQuoteIdInverseInput>;
  quoteDaysUsingId?: InputMaybe<FkQuoteDayQuoteQuoteIdInverseInput>;
  quoteFinanceLineItemsUsingId?: InputMaybe<FkQuoteFinanceLineItemQuoteQuoteIdInverseInput>;
  quoteHeroToHeroId?: InputMaybe<FkQuoteQuoteHeroHeroIdInput>;
  quoteLegalDocumentsUsingId?: InputMaybe<FkQuoteLegalDocumentQuoteInverseInput>;
  quoteStatusToStatus?: InputMaybe<FkQuoteStatusInput>;
  quoteViewsUsingId?: InputMaybe<FkQuoteViewQuoteQuoteIdInverseInput>;
  shortDescription?: InputMaybe<Scalars['String']['input']>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  travellerCount?: InputMaybe<Scalars['Int']['input']>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkQuoteTripTripIdInput>;
  tripsUsingId?: InputMaybe<FkTripQuoteActiveQuoteIdInverseInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkQuoteUserUserIdInput>;
};

/** An object where the defined keys will be set on the `quote` being updated. */
export type UpdateQuoteOnQuoteForFkQuoteMediaItemHeroImageIdPatch = {
  adjustment?: InputMaybe<Scalars['BigFloat']['input']>;
  agentMargin?: InputMaybe<Scalars['BigFloat']['input']>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  deposit?: InputMaybe<Scalars['BigFloat']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  emailsUsingId?: InputMaybe<FkEmailQuoteQuoteIdInverseInput>;
  exclusions?: InputMaybe<Scalars['String']['input']>;
  expires?: InputMaybe<Scalars['Datetime']['input']>;
  heroId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  inclusions?: InputMaybe<Scalars['String']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceQuoteQuoteIdInverseInput>;
  key?: InputMaybe<Scalars['String']['input']>;
  locked?: InputMaybe<Scalars['Datetime']['input']>;
  margin?: InputMaybe<Scalars['BigFloat']['input']>;
  mediaItemToHeroImageId?: InputMaybe<FkQuoteMediaItemHeroImageIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  quoteAcceptancesUsingId?: InputMaybe<FkQuoteAcceptanceQuoteInverseInput>;
  quoteAccommodationDetailsUsingId?: InputMaybe<FkQuoteAccommodationDetailQuoteQuoteIdInverseInput>;
  quoteCurrenciesUsingId?: InputMaybe<FkQuoteCurrencyQuoteQuoteIdInverseInput>;
  quoteDaysUsingId?: InputMaybe<FkQuoteDayQuoteQuoteIdInverseInput>;
  quoteFinanceLineItemsUsingId?: InputMaybe<FkQuoteFinanceLineItemQuoteQuoteIdInverseInput>;
  quoteHeroToHeroId?: InputMaybe<FkQuoteQuoteHeroHeroIdInput>;
  quoteLegalDocumentsUsingId?: InputMaybe<FkQuoteLegalDocumentQuoteInverseInput>;
  quoteStatusToStatus?: InputMaybe<FkQuoteStatusInput>;
  quoteViewsUsingId?: InputMaybe<FkQuoteViewQuoteQuoteIdInverseInput>;
  shortDescription?: InputMaybe<Scalars['String']['input']>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  travellerCount?: InputMaybe<Scalars['Int']['input']>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkQuoteTripTripIdInput>;
  tripsUsingId?: InputMaybe<FkTripQuoteActiveQuoteIdInverseInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkQuoteUserUserIdInput>;
};

/** An object where the defined keys will be set on the `quote` being updated. */
export type UpdateQuoteOnQuoteForFkQuoteQuoteHeroHeroIdPatch = {
  adjustment?: InputMaybe<Scalars['BigFloat']['input']>;
  agentMargin?: InputMaybe<Scalars['BigFloat']['input']>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  deposit?: InputMaybe<Scalars['BigFloat']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  emailsUsingId?: InputMaybe<FkEmailQuoteQuoteIdInverseInput>;
  exclusions?: InputMaybe<Scalars['String']['input']>;
  expires?: InputMaybe<Scalars['Datetime']['input']>;
  heroImageId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  inclusions?: InputMaybe<Scalars['String']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceQuoteQuoteIdInverseInput>;
  key?: InputMaybe<Scalars['String']['input']>;
  locked?: InputMaybe<Scalars['Datetime']['input']>;
  margin?: InputMaybe<Scalars['BigFloat']['input']>;
  mediaItemToHeroImageId?: InputMaybe<FkQuoteMediaItemHeroImageIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  quoteAcceptancesUsingId?: InputMaybe<FkQuoteAcceptanceQuoteInverseInput>;
  quoteAccommodationDetailsUsingId?: InputMaybe<FkQuoteAccommodationDetailQuoteQuoteIdInverseInput>;
  quoteCurrenciesUsingId?: InputMaybe<FkQuoteCurrencyQuoteQuoteIdInverseInput>;
  quoteDaysUsingId?: InputMaybe<FkQuoteDayQuoteQuoteIdInverseInput>;
  quoteFinanceLineItemsUsingId?: InputMaybe<FkQuoteFinanceLineItemQuoteQuoteIdInverseInput>;
  quoteHeroToHeroId?: InputMaybe<FkQuoteQuoteHeroHeroIdInput>;
  quoteLegalDocumentsUsingId?: InputMaybe<FkQuoteLegalDocumentQuoteInverseInput>;
  quoteStatusToStatus?: InputMaybe<FkQuoteStatusInput>;
  quoteViewsUsingId?: InputMaybe<FkQuoteViewQuoteQuoteIdInverseInput>;
  shortDescription?: InputMaybe<Scalars['String']['input']>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  travellerCount?: InputMaybe<Scalars['Int']['input']>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkQuoteTripTripIdInput>;
  tripsUsingId?: InputMaybe<FkTripQuoteActiveQuoteIdInverseInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkQuoteUserUserIdInput>;
};

/** An object where the defined keys will be set on the `quote` being updated. */
export type UpdateQuoteOnQuoteForFkQuoteStatusPatch = {
  adjustment?: InputMaybe<Scalars['BigFloat']['input']>;
  agentMargin?: InputMaybe<Scalars['BigFloat']['input']>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  deposit?: InputMaybe<Scalars['BigFloat']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  emailsUsingId?: InputMaybe<FkEmailQuoteQuoteIdInverseInput>;
  exclusions?: InputMaybe<Scalars['String']['input']>;
  expires?: InputMaybe<Scalars['Datetime']['input']>;
  heroId?: InputMaybe<Scalars['UUID']['input']>;
  heroImageId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  inclusions?: InputMaybe<Scalars['String']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceQuoteQuoteIdInverseInput>;
  key?: InputMaybe<Scalars['String']['input']>;
  locked?: InputMaybe<Scalars['Datetime']['input']>;
  margin?: InputMaybe<Scalars['BigFloat']['input']>;
  mediaItemToHeroImageId?: InputMaybe<FkQuoteMediaItemHeroImageIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  quoteAcceptancesUsingId?: InputMaybe<FkQuoteAcceptanceQuoteInverseInput>;
  quoteAccommodationDetailsUsingId?: InputMaybe<FkQuoteAccommodationDetailQuoteQuoteIdInverseInput>;
  quoteCurrenciesUsingId?: InputMaybe<FkQuoteCurrencyQuoteQuoteIdInverseInput>;
  quoteDaysUsingId?: InputMaybe<FkQuoteDayQuoteQuoteIdInverseInput>;
  quoteFinanceLineItemsUsingId?: InputMaybe<FkQuoteFinanceLineItemQuoteQuoteIdInverseInput>;
  quoteHeroToHeroId?: InputMaybe<FkQuoteQuoteHeroHeroIdInput>;
  quoteLegalDocumentsUsingId?: InputMaybe<FkQuoteLegalDocumentQuoteInverseInput>;
  quoteStatusToStatus?: InputMaybe<FkQuoteStatusInput>;
  quoteViewsUsingId?: InputMaybe<FkQuoteViewQuoteQuoteIdInverseInput>;
  shortDescription?: InputMaybe<Scalars['String']['input']>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  travellerCount?: InputMaybe<Scalars['Int']['input']>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkQuoteTripTripIdInput>;
  tripsUsingId?: InputMaybe<FkTripQuoteActiveQuoteIdInverseInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkQuoteUserUserIdInput>;
};

/** An object where the defined keys will be set on the `quote` being updated. */
export type UpdateQuoteOnQuoteForFkQuoteTripTripIdPatch = {
  adjustment?: InputMaybe<Scalars['BigFloat']['input']>;
  agentMargin?: InputMaybe<Scalars['BigFloat']['input']>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  deposit?: InputMaybe<Scalars['BigFloat']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  emailsUsingId?: InputMaybe<FkEmailQuoteQuoteIdInverseInput>;
  exclusions?: InputMaybe<Scalars['String']['input']>;
  expires?: InputMaybe<Scalars['Datetime']['input']>;
  heroId?: InputMaybe<Scalars['UUID']['input']>;
  heroImageId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  inclusions?: InputMaybe<Scalars['String']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceQuoteQuoteIdInverseInput>;
  key?: InputMaybe<Scalars['String']['input']>;
  locked?: InputMaybe<Scalars['Datetime']['input']>;
  margin?: InputMaybe<Scalars['BigFloat']['input']>;
  mediaItemToHeroImageId?: InputMaybe<FkQuoteMediaItemHeroImageIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  quoteAcceptancesUsingId?: InputMaybe<FkQuoteAcceptanceQuoteInverseInput>;
  quoteAccommodationDetailsUsingId?: InputMaybe<FkQuoteAccommodationDetailQuoteQuoteIdInverseInput>;
  quoteCurrenciesUsingId?: InputMaybe<FkQuoteCurrencyQuoteQuoteIdInverseInput>;
  quoteDaysUsingId?: InputMaybe<FkQuoteDayQuoteQuoteIdInverseInput>;
  quoteFinanceLineItemsUsingId?: InputMaybe<FkQuoteFinanceLineItemQuoteQuoteIdInverseInput>;
  quoteHeroToHeroId?: InputMaybe<FkQuoteQuoteHeroHeroIdInput>;
  quoteLegalDocumentsUsingId?: InputMaybe<FkQuoteLegalDocumentQuoteInverseInput>;
  quoteStatusToStatus?: InputMaybe<FkQuoteStatusInput>;
  quoteViewsUsingId?: InputMaybe<FkQuoteViewQuoteQuoteIdInverseInput>;
  shortDescription?: InputMaybe<Scalars['String']['input']>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  travellerCount?: InputMaybe<Scalars['Int']['input']>;
  tripToTripId?: InputMaybe<FkQuoteTripTripIdInput>;
  tripsUsingId?: InputMaybe<FkTripQuoteActiveQuoteIdInverseInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkQuoteUserUserIdInput>;
};

/** An object where the defined keys will be set on the `quote` being updated. */
export type UpdateQuoteOnQuoteForFkQuoteUserUserIdPatch = {
  adjustment?: InputMaybe<Scalars['BigFloat']['input']>;
  agentMargin?: InputMaybe<Scalars['BigFloat']['input']>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  deposit?: InputMaybe<Scalars['BigFloat']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  emailsUsingId?: InputMaybe<FkEmailQuoteQuoteIdInverseInput>;
  exclusions?: InputMaybe<Scalars['String']['input']>;
  expires?: InputMaybe<Scalars['Datetime']['input']>;
  heroId?: InputMaybe<Scalars['UUID']['input']>;
  heroImageId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  inclusions?: InputMaybe<Scalars['String']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceQuoteQuoteIdInverseInput>;
  key?: InputMaybe<Scalars['String']['input']>;
  locked?: InputMaybe<Scalars['Datetime']['input']>;
  margin?: InputMaybe<Scalars['BigFloat']['input']>;
  mediaItemToHeroImageId?: InputMaybe<FkQuoteMediaItemHeroImageIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  quoteAcceptancesUsingId?: InputMaybe<FkQuoteAcceptanceQuoteInverseInput>;
  quoteAccommodationDetailsUsingId?: InputMaybe<FkQuoteAccommodationDetailQuoteQuoteIdInverseInput>;
  quoteCurrenciesUsingId?: InputMaybe<FkQuoteCurrencyQuoteQuoteIdInverseInput>;
  quoteDaysUsingId?: InputMaybe<FkQuoteDayQuoteQuoteIdInverseInput>;
  quoteFinanceLineItemsUsingId?: InputMaybe<FkQuoteFinanceLineItemQuoteQuoteIdInverseInput>;
  quoteHeroToHeroId?: InputMaybe<FkQuoteQuoteHeroHeroIdInput>;
  quoteLegalDocumentsUsingId?: InputMaybe<FkQuoteLegalDocumentQuoteInverseInput>;
  quoteStatusToStatus?: InputMaybe<FkQuoteStatusInput>;
  quoteViewsUsingId?: InputMaybe<FkQuoteViewQuoteQuoteIdInverseInput>;
  shortDescription?: InputMaybe<Scalars['String']['input']>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  travellerCount?: InputMaybe<Scalars['Int']['input']>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkQuoteTripTripIdInput>;
  tripsUsingId?: InputMaybe<FkTripQuoteActiveQuoteIdInverseInput>;
  userToUserId?: InputMaybe<FkQuoteUserUserIdInput>;
};

/** An object where the defined keys will be set on the `quote` being updated. */
export type UpdateQuoteOnQuoteLegalDocumentForFkQuoteLegalDocumentQuotePatch = {
  adjustment?: InputMaybe<Scalars['BigFloat']['input']>;
  agentMargin?: InputMaybe<Scalars['BigFloat']['input']>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  deposit?: InputMaybe<Scalars['BigFloat']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  emailsUsingId?: InputMaybe<FkEmailQuoteQuoteIdInverseInput>;
  exclusions?: InputMaybe<Scalars['String']['input']>;
  expires?: InputMaybe<Scalars['Datetime']['input']>;
  heroId?: InputMaybe<Scalars['UUID']['input']>;
  heroImageId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  inclusions?: InputMaybe<Scalars['String']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceQuoteQuoteIdInverseInput>;
  key?: InputMaybe<Scalars['String']['input']>;
  locked?: InputMaybe<Scalars['Datetime']['input']>;
  margin?: InputMaybe<Scalars['BigFloat']['input']>;
  mediaItemToHeroImageId?: InputMaybe<FkQuoteMediaItemHeroImageIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  quoteAcceptancesUsingId?: InputMaybe<FkQuoteAcceptanceQuoteInverseInput>;
  quoteAccommodationDetailsUsingId?: InputMaybe<FkQuoteAccommodationDetailQuoteQuoteIdInverseInput>;
  quoteCurrenciesUsingId?: InputMaybe<FkQuoteCurrencyQuoteQuoteIdInverseInput>;
  quoteDaysUsingId?: InputMaybe<FkQuoteDayQuoteQuoteIdInverseInput>;
  quoteFinanceLineItemsUsingId?: InputMaybe<FkQuoteFinanceLineItemQuoteQuoteIdInverseInput>;
  quoteHeroToHeroId?: InputMaybe<FkQuoteQuoteHeroHeroIdInput>;
  quoteLegalDocumentsUsingId?: InputMaybe<FkQuoteLegalDocumentQuoteInverseInput>;
  quoteStatusToStatus?: InputMaybe<FkQuoteStatusInput>;
  quoteViewsUsingId?: InputMaybe<FkQuoteViewQuoteQuoteIdInverseInput>;
  shortDescription?: InputMaybe<Scalars['String']['input']>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  travellerCount?: InputMaybe<Scalars['Int']['input']>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkQuoteTripTripIdInput>;
  tripsUsingId?: InputMaybe<FkTripQuoteActiveQuoteIdInverseInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkQuoteUserUserIdInput>;
};

/** An object where the defined keys will be set on the `quote` being updated. */
export type UpdateQuoteOnQuoteViewForFkQuoteViewQuoteQuoteIdPatch = {
  adjustment?: InputMaybe<Scalars['BigFloat']['input']>;
  agentMargin?: InputMaybe<Scalars['BigFloat']['input']>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  deposit?: InputMaybe<Scalars['BigFloat']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  emailsUsingId?: InputMaybe<FkEmailQuoteQuoteIdInverseInput>;
  exclusions?: InputMaybe<Scalars['String']['input']>;
  expires?: InputMaybe<Scalars['Datetime']['input']>;
  heroId?: InputMaybe<Scalars['UUID']['input']>;
  heroImageId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  inclusions?: InputMaybe<Scalars['String']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceQuoteQuoteIdInverseInput>;
  key?: InputMaybe<Scalars['String']['input']>;
  locked?: InputMaybe<Scalars['Datetime']['input']>;
  margin?: InputMaybe<Scalars['BigFloat']['input']>;
  mediaItemToHeroImageId?: InputMaybe<FkQuoteMediaItemHeroImageIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  quoteAcceptancesUsingId?: InputMaybe<FkQuoteAcceptanceQuoteInverseInput>;
  quoteAccommodationDetailsUsingId?: InputMaybe<FkQuoteAccommodationDetailQuoteQuoteIdInverseInput>;
  quoteCurrenciesUsingId?: InputMaybe<FkQuoteCurrencyQuoteQuoteIdInverseInput>;
  quoteDaysUsingId?: InputMaybe<FkQuoteDayQuoteQuoteIdInverseInput>;
  quoteFinanceLineItemsUsingId?: InputMaybe<FkQuoteFinanceLineItemQuoteQuoteIdInverseInput>;
  quoteHeroToHeroId?: InputMaybe<FkQuoteQuoteHeroHeroIdInput>;
  quoteLegalDocumentsUsingId?: InputMaybe<FkQuoteLegalDocumentQuoteInverseInput>;
  quoteStatusToStatus?: InputMaybe<FkQuoteStatusInput>;
  quoteViewsUsingId?: InputMaybe<FkQuoteViewQuoteQuoteIdInverseInput>;
  shortDescription?: InputMaybe<Scalars['String']['input']>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  travellerCount?: InputMaybe<Scalars['Int']['input']>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkQuoteTripTripIdInput>;
  tripsUsingId?: InputMaybe<FkTripQuoteActiveQuoteIdInverseInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkQuoteUserUserIdInput>;
};

/** An object where the defined keys will be set on the `quote` being updated. */
export type UpdateQuoteOnTripForFkTripQuoteActiveQuoteIdPatch = {
  adjustment?: InputMaybe<Scalars['BigFloat']['input']>;
  agentMargin?: InputMaybe<Scalars['BigFloat']['input']>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  deposit?: InputMaybe<Scalars['BigFloat']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  emailsUsingId?: InputMaybe<FkEmailQuoteQuoteIdInverseInput>;
  exclusions?: InputMaybe<Scalars['String']['input']>;
  expires?: InputMaybe<Scalars['Datetime']['input']>;
  heroId?: InputMaybe<Scalars['UUID']['input']>;
  heroImageId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  inclusions?: InputMaybe<Scalars['String']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceQuoteQuoteIdInverseInput>;
  key?: InputMaybe<Scalars['String']['input']>;
  locked?: InputMaybe<Scalars['Datetime']['input']>;
  margin?: InputMaybe<Scalars['BigFloat']['input']>;
  mediaItemToHeroImageId?: InputMaybe<FkQuoteMediaItemHeroImageIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  quoteAcceptancesUsingId?: InputMaybe<FkQuoteAcceptanceQuoteInverseInput>;
  quoteAccommodationDetailsUsingId?: InputMaybe<FkQuoteAccommodationDetailQuoteQuoteIdInverseInput>;
  quoteCurrenciesUsingId?: InputMaybe<FkQuoteCurrencyQuoteQuoteIdInverseInput>;
  quoteDaysUsingId?: InputMaybe<FkQuoteDayQuoteQuoteIdInverseInput>;
  quoteFinanceLineItemsUsingId?: InputMaybe<FkQuoteFinanceLineItemQuoteQuoteIdInverseInput>;
  quoteHeroToHeroId?: InputMaybe<FkQuoteQuoteHeroHeroIdInput>;
  quoteLegalDocumentsUsingId?: InputMaybe<FkQuoteLegalDocumentQuoteInverseInput>;
  quoteStatusToStatus?: InputMaybe<FkQuoteStatusInput>;
  quoteViewsUsingId?: InputMaybe<FkQuoteViewQuoteQuoteIdInverseInput>;
  shortDescription?: InputMaybe<Scalars['String']['input']>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  travellerCount?: InputMaybe<Scalars['Int']['input']>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkQuoteTripTripIdInput>;
  tripsUsingId?: InputMaybe<FkTripQuoteActiveQuoteIdInverseInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkQuoteUserUserIdInput>;
};

/** An object where the defined keys will be set on the `quotePublic` being updated. */
export type UpdateQuotePublicOnQuoteAccommodationDetailForFakePublicQuoteAccommodationDetailForeignKey0Patch = {
  accepted?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  deposit?: InputMaybe<Scalars['BigFloat']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  exclusions?: InputMaybe<Scalars['String']['input']>;
  expires?: InputMaybe<Scalars['Datetime']['input']>;
  heroId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  inclusions?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  locked?: InputMaybe<Scalars['Datetime']['input']>;
  quoteAccommodationDetailsUsingId?: InputMaybe<FakePublicQuoteAccommodationDetailForeignKey0InverseInput>;
  quoteDaysUsingId?: InputMaybe<FakePublicQuoteDayForeignKey0InverseInput>;
  quoteHeroToHeroId?: InputMaybe<FakePublicQuotePublicForeignKey1Input>;
  quoteLegalDocumentsUsingId?: InputMaybe<FakePublicQuoteLegalDocumentForeignKey0InverseInput>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  total?: InputMaybe<Scalars['BigFloat']['input']>;
  travellerCount?: InputMaybe<Scalars['Int']['input']>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FakePublicQuotePublicForeignKey0Input>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FakePublicQuotePublicForeignKey2Input>;
};

/** An object where the defined keys will be set on the `quotePublic` being updated. */
export type UpdateQuotePublicOnQuoteDayForFakePublicQuoteDayForeignKey0Patch = {
  accepted?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  deposit?: InputMaybe<Scalars['BigFloat']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  exclusions?: InputMaybe<Scalars['String']['input']>;
  expires?: InputMaybe<Scalars['Datetime']['input']>;
  heroId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  inclusions?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  locked?: InputMaybe<Scalars['Datetime']['input']>;
  quoteAccommodationDetailsUsingId?: InputMaybe<FakePublicQuoteAccommodationDetailForeignKey0InverseInput>;
  quoteDaysUsingId?: InputMaybe<FakePublicQuoteDayForeignKey0InverseInput>;
  quoteHeroToHeroId?: InputMaybe<FakePublicQuotePublicForeignKey1Input>;
  quoteLegalDocumentsUsingId?: InputMaybe<FakePublicQuoteLegalDocumentForeignKey0InverseInput>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  total?: InputMaybe<Scalars['BigFloat']['input']>;
  travellerCount?: InputMaybe<Scalars['Int']['input']>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FakePublicQuotePublicForeignKey0Input>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FakePublicQuotePublicForeignKey2Input>;
};

/** An object where the defined keys will be set on the `quotePublic` being updated. */
export type UpdateQuotePublicOnQuoteLegalDocumentForFakePublicQuoteLegalDocumentForeignKey0Patch = {
  accepted?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  deposit?: InputMaybe<Scalars['BigFloat']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  exclusions?: InputMaybe<Scalars['String']['input']>;
  expires?: InputMaybe<Scalars['Datetime']['input']>;
  heroId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  inclusions?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  locked?: InputMaybe<Scalars['Datetime']['input']>;
  quoteAccommodationDetailsUsingId?: InputMaybe<FakePublicQuoteAccommodationDetailForeignKey0InverseInput>;
  quoteDaysUsingId?: InputMaybe<FakePublicQuoteDayForeignKey0InverseInput>;
  quoteHeroToHeroId?: InputMaybe<FakePublicQuotePublicForeignKey1Input>;
  quoteLegalDocumentsUsingId?: InputMaybe<FakePublicQuoteLegalDocumentForeignKey0InverseInput>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  total?: InputMaybe<Scalars['BigFloat']['input']>;
  travellerCount?: InputMaybe<Scalars['Int']['input']>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FakePublicQuotePublicForeignKey0Input>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FakePublicQuotePublicForeignKey2Input>;
};

/** An object where the defined keys will be set on the `quotePublic` being updated. */
export type UpdateQuotePublicOnQuotePublicForFakePublicQuotePublicForeignKey0Patch = {
  accepted?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  deposit?: InputMaybe<Scalars['BigFloat']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  exclusions?: InputMaybe<Scalars['String']['input']>;
  expires?: InputMaybe<Scalars['Datetime']['input']>;
  heroId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  inclusions?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  locked?: InputMaybe<Scalars['Datetime']['input']>;
  quoteAccommodationDetailsUsingId?: InputMaybe<FakePublicQuoteAccommodationDetailForeignKey0InverseInput>;
  quoteDaysUsingId?: InputMaybe<FakePublicQuoteDayForeignKey0InverseInput>;
  quoteHeroToHeroId?: InputMaybe<FakePublicQuotePublicForeignKey1Input>;
  quoteLegalDocumentsUsingId?: InputMaybe<FakePublicQuoteLegalDocumentForeignKey0InverseInput>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  total?: InputMaybe<Scalars['BigFloat']['input']>;
  travellerCount?: InputMaybe<Scalars['Int']['input']>;
  tripToTripId?: InputMaybe<FakePublicQuotePublicForeignKey0Input>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FakePublicQuotePublicForeignKey2Input>;
};

/** An object where the defined keys will be set on the `quotePublic` being updated. */
export type UpdateQuotePublicOnQuotePublicForFakePublicQuotePublicForeignKey1Patch = {
  accepted?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  deposit?: InputMaybe<Scalars['BigFloat']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  exclusions?: InputMaybe<Scalars['String']['input']>;
  expires?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  inclusions?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  locked?: InputMaybe<Scalars['Datetime']['input']>;
  quoteAccommodationDetailsUsingId?: InputMaybe<FakePublicQuoteAccommodationDetailForeignKey0InverseInput>;
  quoteDaysUsingId?: InputMaybe<FakePublicQuoteDayForeignKey0InverseInput>;
  quoteHeroToHeroId?: InputMaybe<FakePublicQuotePublicForeignKey1Input>;
  quoteLegalDocumentsUsingId?: InputMaybe<FakePublicQuoteLegalDocumentForeignKey0InverseInput>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  total?: InputMaybe<Scalars['BigFloat']['input']>;
  travellerCount?: InputMaybe<Scalars['Int']['input']>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FakePublicQuotePublicForeignKey0Input>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FakePublicQuotePublicForeignKey2Input>;
};

/** An object where the defined keys will be set on the `quotePublic` being updated. */
export type UpdateQuotePublicOnQuotePublicForFakePublicQuotePublicForeignKey2Patch = {
  accepted?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  deposit?: InputMaybe<Scalars['BigFloat']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  exclusions?: InputMaybe<Scalars['String']['input']>;
  expires?: InputMaybe<Scalars['Datetime']['input']>;
  heroId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  inclusions?: InputMaybe<Scalars['String']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  locked?: InputMaybe<Scalars['Datetime']['input']>;
  quoteAccommodationDetailsUsingId?: InputMaybe<FakePublicQuoteAccommodationDetailForeignKey0InverseInput>;
  quoteDaysUsingId?: InputMaybe<FakePublicQuoteDayForeignKey0InverseInput>;
  quoteHeroToHeroId?: InputMaybe<FakePublicQuotePublicForeignKey1Input>;
  quoteLegalDocumentsUsingId?: InputMaybe<FakePublicQuoteLegalDocumentForeignKey0InverseInput>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  total?: InputMaybe<Scalars['BigFloat']['input']>;
  travellerCount?: InputMaybe<Scalars['Int']['input']>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FakePublicQuotePublicForeignKey0Input>;
  userToUserId?: InputMaybe<FakePublicQuotePublicForeignKey2Input>;
};

/** An object where the defined keys will be set on the `quoteStatus` being updated. */
export type UpdateQuoteStatusOnQuoteForFkQuoteStatusPatch = {
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  quotesUsingId?: InputMaybe<FkQuoteStatusInverseInput>;
};

/** An object where the defined keys will be set on the `quoteView` being updated. */
export type UpdateQuoteViewOnQuoteViewForFkQuoteViewQuoteQuoteIdPatch = {
  city?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  quoteToQuoteId?: InputMaybe<FkQuoteViewQuoteQuoteIdInput>;
  timezone?: InputMaybe<Scalars['String']['input']>;
  userIp?: InputMaybe<Scalars['String']['input']>;
  viewType?: InputMaybe<Scalars['String']['input']>;
};

/** An object where the defined keys will be set on the `reminder` being updated. */
export type UpdateReminderOnReminderForFkReminderUserUserIdPatch = {
  body?: InputMaybe<Scalars['String']['input']>;
  date?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkReminderUserUserIdInput>;
};

/** An object where the defined keys will be set on the `supplierInvoice` being updated. */
export type UpdateSupplierInvoiceOnExpenseForFkExpenseSupplierInvoiceSupplierInvoiceIdPatch = {
  amount?: InputMaybe<Scalars['BigFloat']['input']>;
  amountActual?: InputMaybe<Scalars['BigFloat']['input']>;
  categoryId?: InputMaybe<Scalars['UUID']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  due?: InputMaybe<Scalars['Datetime']['input']>;
  expensesUsingId?: InputMaybe<FkExpenseSupplierInvoiceSupplierInvoiceIdInverseInput>;
  financeCategoryToCategoryId?: InputMaybe<FkSupplierInvoiceFinanceCategoryCategoryIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  mediaItemId?: InputMaybe<Scalars['UUID']['input']>;
  mediaItemToMediaItemId?: InputMaybe<FkSupplierInvoiceMediaItemMediaItemIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  number?: InputMaybe<Scalars['Int']['input']>;
  paid?: InputMaybe<Scalars['Datetime']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierId?: InputMaybe<Scalars['UUID']['input']>;
  supplierToSupplierId?: InputMaybe<FkSupplierInvoiceSupplierSupplierIdInput>;
  transactionLinksUsingId?: InputMaybe<FkTransactionLinkSupplierInvoiceSupplierInvoiceIdInverseInput>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkSupplierInvoiceTripTripIdInput>;
  type?: InputMaybe<Scalars['String']['input']>;
  voided?: InputMaybe<Scalars['Datetime']['input']>;
};

/** An object where the defined keys will be set on the `supplierInvoice` being updated. */
export type UpdateSupplierInvoiceOnSupplierInvoiceForFkSupplierInvoiceFinanceCategoryCategoryIdPatch = {
  amount?: InputMaybe<Scalars['BigFloat']['input']>;
  amountActual?: InputMaybe<Scalars['BigFloat']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  due?: InputMaybe<Scalars['Datetime']['input']>;
  expensesUsingId?: InputMaybe<FkExpenseSupplierInvoiceSupplierInvoiceIdInverseInput>;
  financeCategoryToCategoryId?: InputMaybe<FkSupplierInvoiceFinanceCategoryCategoryIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  mediaItemId?: InputMaybe<Scalars['UUID']['input']>;
  mediaItemToMediaItemId?: InputMaybe<FkSupplierInvoiceMediaItemMediaItemIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  number?: InputMaybe<Scalars['Int']['input']>;
  paid?: InputMaybe<Scalars['Datetime']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierId?: InputMaybe<Scalars['UUID']['input']>;
  supplierToSupplierId?: InputMaybe<FkSupplierInvoiceSupplierSupplierIdInput>;
  transactionLinksUsingId?: InputMaybe<FkTransactionLinkSupplierInvoiceSupplierInvoiceIdInverseInput>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkSupplierInvoiceTripTripIdInput>;
  type?: InputMaybe<Scalars['String']['input']>;
  voided?: InputMaybe<Scalars['Datetime']['input']>;
};

/** An object where the defined keys will be set on the `supplierInvoice` being updated. */
export type UpdateSupplierInvoiceOnSupplierInvoiceForFkSupplierInvoiceMediaItemMediaItemIdPatch = {
  amount?: InputMaybe<Scalars['BigFloat']['input']>;
  amountActual?: InputMaybe<Scalars['BigFloat']['input']>;
  categoryId?: InputMaybe<Scalars['UUID']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  due?: InputMaybe<Scalars['Datetime']['input']>;
  expensesUsingId?: InputMaybe<FkExpenseSupplierInvoiceSupplierInvoiceIdInverseInput>;
  financeCategoryToCategoryId?: InputMaybe<FkSupplierInvoiceFinanceCategoryCategoryIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  mediaItemToMediaItemId?: InputMaybe<FkSupplierInvoiceMediaItemMediaItemIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  number?: InputMaybe<Scalars['Int']['input']>;
  paid?: InputMaybe<Scalars['Datetime']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierId?: InputMaybe<Scalars['UUID']['input']>;
  supplierToSupplierId?: InputMaybe<FkSupplierInvoiceSupplierSupplierIdInput>;
  transactionLinksUsingId?: InputMaybe<FkTransactionLinkSupplierInvoiceSupplierInvoiceIdInverseInput>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkSupplierInvoiceTripTripIdInput>;
  type?: InputMaybe<Scalars['String']['input']>;
  voided?: InputMaybe<Scalars['Datetime']['input']>;
};

/** An object where the defined keys will be set on the `supplierInvoice` being updated. */
export type UpdateSupplierInvoiceOnSupplierInvoiceForFkSupplierInvoiceSupplierSupplierIdPatch = {
  amount?: InputMaybe<Scalars['BigFloat']['input']>;
  amountActual?: InputMaybe<Scalars['BigFloat']['input']>;
  categoryId?: InputMaybe<Scalars['UUID']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  due?: InputMaybe<Scalars['Datetime']['input']>;
  expensesUsingId?: InputMaybe<FkExpenseSupplierInvoiceSupplierInvoiceIdInverseInput>;
  financeCategoryToCategoryId?: InputMaybe<FkSupplierInvoiceFinanceCategoryCategoryIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  mediaItemId?: InputMaybe<Scalars['UUID']['input']>;
  mediaItemToMediaItemId?: InputMaybe<FkSupplierInvoiceMediaItemMediaItemIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  number?: InputMaybe<Scalars['Int']['input']>;
  paid?: InputMaybe<Scalars['Datetime']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierToSupplierId?: InputMaybe<FkSupplierInvoiceSupplierSupplierIdInput>;
  transactionLinksUsingId?: InputMaybe<FkTransactionLinkSupplierInvoiceSupplierInvoiceIdInverseInput>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkSupplierInvoiceTripTripIdInput>;
  type?: InputMaybe<Scalars['String']['input']>;
  voided?: InputMaybe<Scalars['Datetime']['input']>;
};

/** An object where the defined keys will be set on the `supplierInvoice` being updated. */
export type UpdateSupplierInvoiceOnSupplierInvoiceForFkSupplierInvoiceTripTripIdPatch = {
  amount?: InputMaybe<Scalars['BigFloat']['input']>;
  amountActual?: InputMaybe<Scalars['BigFloat']['input']>;
  categoryId?: InputMaybe<Scalars['UUID']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  due?: InputMaybe<Scalars['Datetime']['input']>;
  expensesUsingId?: InputMaybe<FkExpenseSupplierInvoiceSupplierInvoiceIdInverseInput>;
  financeCategoryToCategoryId?: InputMaybe<FkSupplierInvoiceFinanceCategoryCategoryIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  mediaItemId?: InputMaybe<Scalars['UUID']['input']>;
  mediaItemToMediaItemId?: InputMaybe<FkSupplierInvoiceMediaItemMediaItemIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  number?: InputMaybe<Scalars['Int']['input']>;
  paid?: InputMaybe<Scalars['Datetime']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierId?: InputMaybe<Scalars['UUID']['input']>;
  supplierToSupplierId?: InputMaybe<FkSupplierInvoiceSupplierSupplierIdInput>;
  transactionLinksUsingId?: InputMaybe<FkTransactionLinkSupplierInvoiceSupplierInvoiceIdInverseInput>;
  tripToTripId?: InputMaybe<FkSupplierInvoiceTripTripIdInput>;
  type?: InputMaybe<Scalars['String']['input']>;
  voided?: InputMaybe<Scalars['Datetime']['input']>;
};

/** An object where the defined keys will be set on the `supplierInvoice` being updated. */
export type UpdateSupplierInvoiceOnTransactionLinkForFkTransactionLinkSupplierInvoiceSupplierInvoiceIdPatch = {
  amount?: InputMaybe<Scalars['BigFloat']['input']>;
  amountActual?: InputMaybe<Scalars['BigFloat']['input']>;
  categoryId?: InputMaybe<Scalars['UUID']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  due?: InputMaybe<Scalars['Datetime']['input']>;
  expensesUsingId?: InputMaybe<FkExpenseSupplierInvoiceSupplierInvoiceIdInverseInput>;
  financeCategoryToCategoryId?: InputMaybe<FkSupplierInvoiceFinanceCategoryCategoryIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  mediaItemId?: InputMaybe<Scalars['UUID']['input']>;
  mediaItemToMediaItemId?: InputMaybe<FkSupplierInvoiceMediaItemMediaItemIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  number?: InputMaybe<Scalars['Int']['input']>;
  paid?: InputMaybe<Scalars['Datetime']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierId?: InputMaybe<Scalars['UUID']['input']>;
  supplierToSupplierId?: InputMaybe<FkSupplierInvoiceSupplierSupplierIdInput>;
  transactionLinksUsingId?: InputMaybe<FkTransactionLinkSupplierInvoiceSupplierInvoiceIdInverseInput>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkSupplierInvoiceTripTripIdInput>;
  type?: InputMaybe<Scalars['String']['input']>;
  voided?: InputMaybe<Scalars['Datetime']['input']>;
};

/** An object where the defined keys will be set on the `supplier` being updated. */
export type UpdateSupplierOnAgencyForFkAgencySupplierPatch = {
  agenciesUsingId?: InputMaybe<FkAgencySupplierInverseInput>;
  bankDetails?: InputMaybe<Scalars['String']['input']>;
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  contactNumber?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  expensesUsingId?: InputMaybe<FkExpenseSupplierSupplierIdInverseInput>;
  galleryId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryToGalleryId?: InputMaybe<FkSupplierMediaGalleryGalleryIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  quoteFinanceLineItemsUsingId?: InputMaybe<FkQuoteFinanceLineItemSupplierSupplierIdInverseInput>;
  region?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceSupplierSupplierIdInverseInput>;
  url?: InputMaybe<Scalars['String']['input']>;
};

/** An object where the defined keys will be set on the `supplier` being updated. */
export type UpdateSupplierOnExpenseForFkExpenseSupplierSupplierIdPatch = {
  agenciesUsingId?: InputMaybe<FkAgencySupplierInverseInput>;
  bankDetails?: InputMaybe<Scalars['String']['input']>;
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  contactNumber?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  expensesUsingId?: InputMaybe<FkExpenseSupplierSupplierIdInverseInput>;
  galleryId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryToGalleryId?: InputMaybe<FkSupplierMediaGalleryGalleryIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  quoteFinanceLineItemsUsingId?: InputMaybe<FkQuoteFinanceLineItemSupplierSupplierIdInverseInput>;
  region?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceSupplierSupplierIdInverseInput>;
  url?: InputMaybe<Scalars['String']['input']>;
};

/** An object where the defined keys will be set on the `supplier` being updated. */
export type UpdateSupplierOnQuoteFinanceLineItemForFkQuoteFinanceLineItemSupplierSupplierIdPatch = {
  agenciesUsingId?: InputMaybe<FkAgencySupplierInverseInput>;
  bankDetails?: InputMaybe<Scalars['String']['input']>;
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  contactNumber?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  expensesUsingId?: InputMaybe<FkExpenseSupplierSupplierIdInverseInput>;
  galleryId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryToGalleryId?: InputMaybe<FkSupplierMediaGalleryGalleryIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  quoteFinanceLineItemsUsingId?: InputMaybe<FkQuoteFinanceLineItemSupplierSupplierIdInverseInput>;
  region?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceSupplierSupplierIdInverseInput>;
  url?: InputMaybe<Scalars['String']['input']>;
};

/** An object where the defined keys will be set on the `supplier` being updated. */
export type UpdateSupplierOnSupplierForFkSupplierMediaGalleryGalleryIdPatch = {
  agenciesUsingId?: InputMaybe<FkAgencySupplierInverseInput>;
  bankDetails?: InputMaybe<Scalars['String']['input']>;
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  contactNumber?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  expensesUsingId?: InputMaybe<FkExpenseSupplierSupplierIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryToGalleryId?: InputMaybe<FkSupplierMediaGalleryGalleryIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  quoteFinanceLineItemsUsingId?: InputMaybe<FkQuoteFinanceLineItemSupplierSupplierIdInverseInput>;
  region?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceSupplierSupplierIdInverseInput>;
  url?: InputMaybe<Scalars['String']['input']>;
};

/** An object where the defined keys will be set on the `supplier` being updated. */
export type UpdateSupplierOnSupplierInvoiceForFkSupplierInvoiceSupplierSupplierIdPatch = {
  agenciesUsingId?: InputMaybe<FkAgencySupplierInverseInput>;
  bankDetails?: InputMaybe<Scalars['String']['input']>;
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  contactNumber?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  expensesUsingId?: InputMaybe<FkExpenseSupplierSupplierIdInverseInput>;
  galleryId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryToGalleryId?: InputMaybe<FkSupplierMediaGalleryGalleryIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  quoteFinanceLineItemsUsingId?: InputMaybe<FkQuoteFinanceLineItemSupplierSupplierIdInverseInput>;
  region?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceSupplierSupplierIdInverseInput>;
  url?: InputMaybe<Scalars['String']['input']>;
};

/** An object where the defined keys will be set on the `testimonial` being updated. */
export type UpdateTestimonialOnTestimonialForFkTestimonialTripTripIdPatch = {
  body?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  guestName?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  tripToTripId?: InputMaybe<FkTestimonialTripTripIdInput>;
};

/** An object where the defined keys will be set on the `transactionImportBatch` being updated. */
export type UpdateTransactionImportBatchOnTransactionForFkTransactionTransactionImportBatchTransactionImportBatchIdPatch = {
  accountId?: InputMaybe<Scalars['UUID']['input']>;
  accountToAccountId?: InputMaybe<FkTransactionImportBatchAccountAccountIdInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  dateRangeMax?: InputMaybe<Scalars['Datetime']['input']>;
  dateRangeMin?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  transactionsUsingId?: InputMaybe<FkTransactionTransactionImportBatchTransactionImportBatchIdInverseInput>;
};

/** An object where the defined keys will be set on the `transactionImportBatch` being updated. */
export type UpdateTransactionImportBatchOnTransactionImportBatchForFkTransactionImportBatchAccountAccountIdPatch = {
  accountToAccountId?: InputMaybe<FkTransactionImportBatchAccountAccountIdInput>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  dateRangeMax?: InputMaybe<Scalars['Datetime']['input']>;
  dateRangeMin?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  transactionsUsingId?: InputMaybe<FkTransactionTransactionImportBatchTransactionImportBatchIdInverseInput>;
};

/** An object where the defined keys will be set on the `transactionLink` being updated. */
export type UpdateTransactionLinkOnTransactionLinkForFkTransactionLinkExpenseExpenseIdPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  expenseToExpenseId?: InputMaybe<FkTransactionLinkExpenseExpenseIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoiceId?: InputMaybe<Scalars['UUID']['input']>;
  invoiceToInvoiceId?: InputMaybe<FkTransactionLinkInvoiceInvoiceIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  paymentId?: InputMaybe<Scalars['UUID']['input']>;
  paymentToPaymentId?: InputMaybe<FkTransactionLinkPaymentPaymentIdInput>;
  status?: InputMaybe<Scalars['Int']['input']>;
  supplierInvoiceId?: InputMaybe<Scalars['UUID']['input']>;
  supplierInvoiceToSupplierInvoiceId?: InputMaybe<FkTransactionLinkSupplierInvoiceSupplierInvoiceIdInput>;
  transactionId?: InputMaybe<Scalars['UUID']['input']>;
  transactionToTransactionId?: InputMaybe<FkTransactionLinkTransactionTransactionIdInput>;
};

/** An object where the defined keys will be set on the `transactionLink` being updated. */
export type UpdateTransactionLinkOnTransactionLinkForFkTransactionLinkInvoiceInvoiceIdPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  expenseId?: InputMaybe<Scalars['UUID']['input']>;
  expenseToExpenseId?: InputMaybe<FkTransactionLinkExpenseExpenseIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoiceToInvoiceId?: InputMaybe<FkTransactionLinkInvoiceInvoiceIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  paymentId?: InputMaybe<Scalars['UUID']['input']>;
  paymentToPaymentId?: InputMaybe<FkTransactionLinkPaymentPaymentIdInput>;
  status?: InputMaybe<Scalars['Int']['input']>;
  supplierInvoiceId?: InputMaybe<Scalars['UUID']['input']>;
  supplierInvoiceToSupplierInvoiceId?: InputMaybe<FkTransactionLinkSupplierInvoiceSupplierInvoiceIdInput>;
  transactionId?: InputMaybe<Scalars['UUID']['input']>;
  transactionToTransactionId?: InputMaybe<FkTransactionLinkTransactionTransactionIdInput>;
};

/** An object where the defined keys will be set on the `transactionLink` being updated. */
export type UpdateTransactionLinkOnTransactionLinkForFkTransactionLinkPaymentPaymentIdPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  expenseId?: InputMaybe<Scalars['UUID']['input']>;
  expenseToExpenseId?: InputMaybe<FkTransactionLinkExpenseExpenseIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoiceId?: InputMaybe<Scalars['UUID']['input']>;
  invoiceToInvoiceId?: InputMaybe<FkTransactionLinkInvoiceInvoiceIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  paymentToPaymentId?: InputMaybe<FkTransactionLinkPaymentPaymentIdInput>;
  status?: InputMaybe<Scalars['Int']['input']>;
  supplierInvoiceId?: InputMaybe<Scalars['UUID']['input']>;
  supplierInvoiceToSupplierInvoiceId?: InputMaybe<FkTransactionLinkSupplierInvoiceSupplierInvoiceIdInput>;
  transactionId?: InputMaybe<Scalars['UUID']['input']>;
  transactionToTransactionId?: InputMaybe<FkTransactionLinkTransactionTransactionIdInput>;
};

/** An object where the defined keys will be set on the `transactionLink` being updated. */
export type UpdateTransactionLinkOnTransactionLinkForFkTransactionLinkSupplierInvoiceSupplierInvoiceIdPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  expenseId?: InputMaybe<Scalars['UUID']['input']>;
  expenseToExpenseId?: InputMaybe<FkTransactionLinkExpenseExpenseIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoiceId?: InputMaybe<Scalars['UUID']['input']>;
  invoiceToInvoiceId?: InputMaybe<FkTransactionLinkInvoiceInvoiceIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  paymentId?: InputMaybe<Scalars['UUID']['input']>;
  paymentToPaymentId?: InputMaybe<FkTransactionLinkPaymentPaymentIdInput>;
  status?: InputMaybe<Scalars['Int']['input']>;
  supplierInvoiceToSupplierInvoiceId?: InputMaybe<FkTransactionLinkSupplierInvoiceSupplierInvoiceIdInput>;
  transactionId?: InputMaybe<Scalars['UUID']['input']>;
  transactionToTransactionId?: InputMaybe<FkTransactionLinkTransactionTransactionIdInput>;
};

/** An object where the defined keys will be set on the `transactionLink` being updated. */
export type UpdateTransactionLinkOnTransactionLinkForFkTransactionLinkTransactionTransactionIdPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  expenseId?: InputMaybe<Scalars['UUID']['input']>;
  expenseToExpenseId?: InputMaybe<FkTransactionLinkExpenseExpenseIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoiceId?: InputMaybe<Scalars['UUID']['input']>;
  invoiceToInvoiceId?: InputMaybe<FkTransactionLinkInvoiceInvoiceIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  paymentId?: InputMaybe<Scalars['UUID']['input']>;
  paymentToPaymentId?: InputMaybe<FkTransactionLinkPaymentPaymentIdInput>;
  status?: InputMaybe<Scalars['Int']['input']>;
  supplierInvoiceId?: InputMaybe<Scalars['UUID']['input']>;
  supplierInvoiceToSupplierInvoiceId?: InputMaybe<FkTransactionLinkSupplierInvoiceSupplierInvoiceIdInput>;
  transactionToTransactionId?: InputMaybe<FkTransactionLinkTransactionTransactionIdInput>;
};

/** An object where the defined keys will be set on the `transactionNote` being updated. */
export type UpdateTransactionNoteOnTransactionNoteForFkTransactionNoteTransactionTransactionIdPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  message?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  transactionToTransactionId?: InputMaybe<FkTransactionNoteTransactionTransactionIdInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkTransactionNoteUserUserIdInput>;
};

/** An object where the defined keys will be set on the `transactionNote` being updated. */
export type UpdateTransactionNoteOnTransactionNoteForFkTransactionNoteUserUserIdPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  message?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  transactionId?: InputMaybe<Scalars['UUID']['input']>;
  transactionToTransactionId?: InputMaybe<FkTransactionNoteTransactionTransactionIdInput>;
  userToUserId?: InputMaybe<FkTransactionNoteUserUserIdInput>;
};

/** An object where the defined keys will be set on the `transaction` being updated. */
export type UpdateTransactionOnTransactionForFkTransactionAccountAccountIdPatch = {
  accountToAccountId?: InputMaybe<FkTransactionAccountAccountIdInput>;
  amount?: InputMaybe<Scalars['BigFloat']['input']>;
  balance?: InputMaybe<Scalars['BigFloat']['input']>;
  categoryId?: InputMaybe<Scalars['UUID']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  date?: InputMaybe<Scalars['Datetime']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  externalId?: InputMaybe<Scalars['String']['input']>;
  financeCategoryToCategoryId?: InputMaybe<FkTransactionFinanceCategoryCategoryIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  reverseTransactionId?: InputMaybe<Scalars['UUID']['input']>;
  source?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  transactionImportBatchId?: InputMaybe<Scalars['UUID']['input']>;
  transactionImportBatchToTransactionImportBatchId?: InputMaybe<FkTransactionTransactionImportBatchTransactionImportBatchIdInput>;
  transactionLinksUsingId?: InputMaybe<FkTransactionLinkTransactionTransactionIdInverseInput>;
  transactionNotesUsingId?: InputMaybe<FkTransactionNoteTransactionTransactionIdInverseInput>;
  transactionToReverseTransactionId?: InputMaybe<FkTransactionTransactionReverseTransactionIdInput>;
};

/** An object where the defined keys will be set on the `transaction` being updated. */
export type UpdateTransactionOnTransactionForFkTransactionFinanceCategoryCategoryIdPatch = {
  accountId?: InputMaybe<Scalars['UUID']['input']>;
  accountToAccountId?: InputMaybe<FkTransactionAccountAccountIdInput>;
  amount?: InputMaybe<Scalars['BigFloat']['input']>;
  balance?: InputMaybe<Scalars['BigFloat']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  date?: InputMaybe<Scalars['Datetime']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  externalId?: InputMaybe<Scalars['String']['input']>;
  financeCategoryToCategoryId?: InputMaybe<FkTransactionFinanceCategoryCategoryIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  reverseTransactionId?: InputMaybe<Scalars['UUID']['input']>;
  source?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  transactionImportBatchId?: InputMaybe<Scalars['UUID']['input']>;
  transactionImportBatchToTransactionImportBatchId?: InputMaybe<FkTransactionTransactionImportBatchTransactionImportBatchIdInput>;
  transactionLinksUsingId?: InputMaybe<FkTransactionLinkTransactionTransactionIdInverseInput>;
  transactionNotesUsingId?: InputMaybe<FkTransactionNoteTransactionTransactionIdInverseInput>;
  transactionToReverseTransactionId?: InputMaybe<FkTransactionTransactionReverseTransactionIdInput>;
};

/** An object where the defined keys will be set on the `transaction` being updated. */
export type UpdateTransactionOnTransactionForFkTransactionTransactionImportBatchTransactionImportBatchIdPatch = {
  accountId?: InputMaybe<Scalars['UUID']['input']>;
  accountToAccountId?: InputMaybe<FkTransactionAccountAccountIdInput>;
  amount?: InputMaybe<Scalars['BigFloat']['input']>;
  balance?: InputMaybe<Scalars['BigFloat']['input']>;
  categoryId?: InputMaybe<Scalars['UUID']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  date?: InputMaybe<Scalars['Datetime']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  externalId?: InputMaybe<Scalars['String']['input']>;
  financeCategoryToCategoryId?: InputMaybe<FkTransactionFinanceCategoryCategoryIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  reverseTransactionId?: InputMaybe<Scalars['UUID']['input']>;
  source?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  transactionImportBatchToTransactionImportBatchId?: InputMaybe<FkTransactionTransactionImportBatchTransactionImportBatchIdInput>;
  transactionLinksUsingId?: InputMaybe<FkTransactionLinkTransactionTransactionIdInverseInput>;
  transactionNotesUsingId?: InputMaybe<FkTransactionNoteTransactionTransactionIdInverseInput>;
  transactionToReverseTransactionId?: InputMaybe<FkTransactionTransactionReverseTransactionIdInput>;
};

/** An object where the defined keys will be set on the `transaction` being updated. */
export type UpdateTransactionOnTransactionForFkTransactionTransactionReverseTransactionIdPatch = {
  accountId?: InputMaybe<Scalars['UUID']['input']>;
  accountToAccountId?: InputMaybe<FkTransactionAccountAccountIdInput>;
  amount?: InputMaybe<Scalars['BigFloat']['input']>;
  balance?: InputMaybe<Scalars['BigFloat']['input']>;
  categoryId?: InputMaybe<Scalars['UUID']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  date?: InputMaybe<Scalars['Datetime']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  externalId?: InputMaybe<Scalars['String']['input']>;
  financeCategoryToCategoryId?: InputMaybe<FkTransactionFinanceCategoryCategoryIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  source?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  transactionImportBatchId?: InputMaybe<Scalars['UUID']['input']>;
  transactionImportBatchToTransactionImportBatchId?: InputMaybe<FkTransactionTransactionImportBatchTransactionImportBatchIdInput>;
  transactionLinksUsingId?: InputMaybe<FkTransactionLinkTransactionTransactionIdInverseInput>;
  transactionNotesUsingId?: InputMaybe<FkTransactionNoteTransactionTransactionIdInverseInput>;
  transactionToReverseTransactionId?: InputMaybe<FkTransactionTransactionReverseTransactionIdInput>;
};

/** An object where the defined keys will be set on the `transaction` being updated. */
export type UpdateTransactionOnTransactionLinkForFkTransactionLinkTransactionTransactionIdPatch = {
  accountId?: InputMaybe<Scalars['UUID']['input']>;
  accountToAccountId?: InputMaybe<FkTransactionAccountAccountIdInput>;
  amount?: InputMaybe<Scalars['BigFloat']['input']>;
  balance?: InputMaybe<Scalars['BigFloat']['input']>;
  categoryId?: InputMaybe<Scalars['UUID']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  date?: InputMaybe<Scalars['Datetime']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  externalId?: InputMaybe<Scalars['String']['input']>;
  financeCategoryToCategoryId?: InputMaybe<FkTransactionFinanceCategoryCategoryIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  reverseTransactionId?: InputMaybe<Scalars['UUID']['input']>;
  source?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  transactionImportBatchId?: InputMaybe<Scalars['UUID']['input']>;
  transactionImportBatchToTransactionImportBatchId?: InputMaybe<FkTransactionTransactionImportBatchTransactionImportBatchIdInput>;
  transactionLinksUsingId?: InputMaybe<FkTransactionLinkTransactionTransactionIdInverseInput>;
  transactionNotesUsingId?: InputMaybe<FkTransactionNoteTransactionTransactionIdInverseInput>;
  transactionToReverseTransactionId?: InputMaybe<FkTransactionTransactionReverseTransactionIdInput>;
};

/** An object where the defined keys will be set on the `transaction` being updated. */
export type UpdateTransactionOnTransactionNoteForFkTransactionNoteTransactionTransactionIdPatch = {
  accountId?: InputMaybe<Scalars['UUID']['input']>;
  accountToAccountId?: InputMaybe<FkTransactionAccountAccountIdInput>;
  amount?: InputMaybe<Scalars['BigFloat']['input']>;
  balance?: InputMaybe<Scalars['BigFloat']['input']>;
  categoryId?: InputMaybe<Scalars['UUID']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  currency?: InputMaybe<Scalars['String']['input']>;
  date?: InputMaybe<Scalars['Datetime']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  externalId?: InputMaybe<Scalars['String']['input']>;
  financeCategoryToCategoryId?: InputMaybe<FkTransactionFinanceCategoryCategoryIdInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  reverseTransactionId?: InputMaybe<Scalars['UUID']['input']>;
  source?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  transactionImportBatchId?: InputMaybe<Scalars['UUID']['input']>;
  transactionImportBatchToTransactionImportBatchId?: InputMaybe<FkTransactionTransactionImportBatchTransactionImportBatchIdInput>;
  transactionLinksUsingId?: InputMaybe<FkTransactionLinkTransactionTransactionIdInverseInput>;
  transactionNotesUsingId?: InputMaybe<FkTransactionNoteTransactionTransactionIdInverseInput>;
  transactionToReverseTransactionId?: InputMaybe<FkTransactionTransactionReverseTransactionIdInput>;
};

/** An object where the defined keys will be set on the `traveller` being updated. */
export type UpdateTravellerOnCustomerTravellerForFkCustomerTravellerTravellerTravellerIdPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerTravellersUsingId?: InputMaybe<FkCustomerTravellerTravellerTravellerIdInverseInput>;
  dateOfBirth?: InputMaybe<Scalars['Datetime']['input']>;
  dietaryRequirements?: InputMaybe<Scalars['String']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  emergencyContact?: InputMaybe<Scalars['String']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  height?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  insuranceDetails?: InputMaybe<Scalars['String']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  medicalConditions?: InputMaybe<Scalars['String']['input']>;
  middleName?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  nationality?: InputMaybe<Scalars['String']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  passportsUsingId?: InputMaybe<FkPassportTravellerTravellerIdInverseInput>;
  phone?: InputMaybe<Scalars['String']['input']>;
  tripTravellersUsingId?: InputMaybe<FkTripTravellerTravellerTravellerIdInverseInput>;
  weight?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `traveller` being updated. */
export type UpdateTravellerOnPassportForFkPassportTravellerTravellerIdPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerTravellersUsingId?: InputMaybe<FkCustomerTravellerTravellerTravellerIdInverseInput>;
  dateOfBirth?: InputMaybe<Scalars['Datetime']['input']>;
  dietaryRequirements?: InputMaybe<Scalars['String']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  emergencyContact?: InputMaybe<Scalars['String']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  height?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  insuranceDetails?: InputMaybe<Scalars['String']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  medicalConditions?: InputMaybe<Scalars['String']['input']>;
  middleName?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  nationality?: InputMaybe<Scalars['String']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  passportsUsingId?: InputMaybe<FkPassportTravellerTravellerIdInverseInput>;
  phone?: InputMaybe<Scalars['String']['input']>;
  tripTravellersUsingId?: InputMaybe<FkTripTravellerTravellerTravellerIdInverseInput>;
  weight?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `traveller` being updated. */
export type UpdateTravellerOnTripTravellerForFkTripTravellerTravellerTravellerIdPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerTravellersUsingId?: InputMaybe<FkCustomerTravellerTravellerTravellerIdInverseInput>;
  dateOfBirth?: InputMaybe<Scalars['Datetime']['input']>;
  dietaryRequirements?: InputMaybe<Scalars['String']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  emergencyContact?: InputMaybe<Scalars['String']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  height?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  insuranceDetails?: InputMaybe<Scalars['String']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  medicalConditions?: InputMaybe<Scalars['String']['input']>;
  middleName?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  nationality?: InputMaybe<Scalars['String']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  passportsUsingId?: InputMaybe<FkPassportTravellerTravellerIdInverseInput>;
  phone?: InputMaybe<Scalars['String']['input']>;
  tripTravellersUsingId?: InputMaybe<FkTripTravellerTravellerTravellerIdInverseInput>;
  weight?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `tripFlight` being updated. */
export type UpdateTripFlightOnTripFlightForFkTripFlightTripTripIdPatch = {
  airportToArrivalAirportId?: InputMaybe<TripFlightArrivalAirport2IdFkeyInput>;
  airportToDepartureAirportId?: InputMaybe<TripFlightDepartureAirport2IdFkeyInput>;
  arrival?: InputMaybe<Scalars['Datetime']['input']>;
  arrivalAirportId?: InputMaybe<Scalars['UUID']['input']>;
  carrier?: InputMaybe<Scalars['String']['input']>;
  departure?: InputMaybe<Scalars['Datetime']['input']>;
  departureAirportId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  number?: InputMaybe<Scalars['String']['input']>;
  tripToTripId?: InputMaybe<FkTripFlightTripTripIdInput>;
};

/** An object where the defined keys will be set on the `tripFlight` being updated. */
export type UpdateTripFlightOnTripFlightForTripFlightArrivalAirport2IdFkeyPatch = {
  airportToArrivalAirportId?: InputMaybe<TripFlightArrivalAirport2IdFkeyInput>;
  airportToDepartureAirportId?: InputMaybe<TripFlightDepartureAirport2IdFkeyInput>;
  arrival?: InputMaybe<Scalars['Datetime']['input']>;
  carrier?: InputMaybe<Scalars['String']['input']>;
  departure?: InputMaybe<Scalars['Datetime']['input']>;
  departureAirportId?: InputMaybe<Scalars['UUID']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  number?: InputMaybe<Scalars['String']['input']>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkTripFlightTripTripIdInput>;
};

/** An object where the defined keys will be set on the `tripFlight` being updated. */
export type UpdateTripFlightOnTripFlightForTripFlightDepartureAirport2IdFkeyPatch = {
  airportToArrivalAirportId?: InputMaybe<TripFlightArrivalAirport2IdFkeyInput>;
  airportToDepartureAirportId?: InputMaybe<TripFlightDepartureAirport2IdFkeyInput>;
  arrival?: InputMaybe<Scalars['Datetime']['input']>;
  arrivalAirportId?: InputMaybe<Scalars['UUID']['input']>;
  carrier?: InputMaybe<Scalars['String']['input']>;
  departure?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  number?: InputMaybe<Scalars['String']['input']>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkTripFlightTripTripIdInput>;
};

/** An object where the defined keys will be set on the `trip` being updated. */
export type UpdateTripOnEmailForFkEmailTripTripIdPatch = {
  activeQuoteId?: InputMaybe<Scalars['UUID']['input']>;
  agencyId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberToAgencyMemberId?: InputMaybe<FkTripAgencyMemberAgencyMemberIdInput>;
  agencyToAgencyId?: InputMaybe<FkTripAgencyAgencyIdInput>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerId?: InputMaybe<Scalars['UUID']['input']>;
  customerToCustomerId?: InputMaybe<FkTripCustomerCustomerIdInput>;
  dates?: InputMaybe<Scalars['String']['input']>;
  destination?: InputMaybe<Scalars['String']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  emailsUsingId?: InputMaybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: InputMaybe<FkEnquiryTripTripIdInverseInput>;
  expensesUsingId?: InputMaybe<FkExpenseTripTripIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceTripTripIdInverseInput>;
  mediaGalleryId?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryToMediaGalleryId?: InputMaybe<FkTripMediaGalleryMediaGalleryIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notesUsingId?: InputMaybe<FkNoteTripTripIdInverseInput>;
  paymentsUsingId?: InputMaybe<FkPaymentTripTripIdInverseInput>;
  quotePublicsUsingId?: InputMaybe<FakePublicQuotePublicForeignKey0InverseInput>;
  quoteToActiveQuoteId?: InputMaybe<FkTripQuoteActiveQuoteIdInput>;
  quotesUsingId?: InputMaybe<FkQuoteTripTripIdInverseInput>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceTripTripIdInverseInput>;
  testimonialsUsingId?: InputMaybe<FkTestimonialTripTripIdInverseInput>;
  tripFlightsUsingId?: InputMaybe<FkTripFlightTripTripIdInverseInput>;
  tripTravellersUsingId?: InputMaybe<FkTripTravellerTripTripIdInverseInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkTripUserUserIdInput>;
};

/** An object where the defined keys will be set on the `trip` being updated. */
export type UpdateTripOnEnquiryForFkEnquiryTripTripIdPatch = {
  activeQuoteId?: InputMaybe<Scalars['UUID']['input']>;
  agencyId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberToAgencyMemberId?: InputMaybe<FkTripAgencyMemberAgencyMemberIdInput>;
  agencyToAgencyId?: InputMaybe<FkTripAgencyAgencyIdInput>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerId?: InputMaybe<Scalars['UUID']['input']>;
  customerToCustomerId?: InputMaybe<FkTripCustomerCustomerIdInput>;
  dates?: InputMaybe<Scalars['String']['input']>;
  destination?: InputMaybe<Scalars['String']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  emailsUsingId?: InputMaybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: InputMaybe<FkEnquiryTripTripIdInverseInput>;
  expensesUsingId?: InputMaybe<FkExpenseTripTripIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceTripTripIdInverseInput>;
  mediaGalleryId?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryToMediaGalleryId?: InputMaybe<FkTripMediaGalleryMediaGalleryIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notesUsingId?: InputMaybe<FkNoteTripTripIdInverseInput>;
  paymentsUsingId?: InputMaybe<FkPaymentTripTripIdInverseInput>;
  quotePublicsUsingId?: InputMaybe<FakePublicQuotePublicForeignKey0InverseInput>;
  quoteToActiveQuoteId?: InputMaybe<FkTripQuoteActiveQuoteIdInput>;
  quotesUsingId?: InputMaybe<FkQuoteTripTripIdInverseInput>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceTripTripIdInverseInput>;
  testimonialsUsingId?: InputMaybe<FkTestimonialTripTripIdInverseInput>;
  tripFlightsUsingId?: InputMaybe<FkTripFlightTripTripIdInverseInput>;
  tripTravellersUsingId?: InputMaybe<FkTripTravellerTripTripIdInverseInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkTripUserUserIdInput>;
};

/** An object where the defined keys will be set on the `trip` being updated. */
export type UpdateTripOnExpenseForFkExpenseTripTripIdPatch = {
  activeQuoteId?: InputMaybe<Scalars['UUID']['input']>;
  agencyId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberToAgencyMemberId?: InputMaybe<FkTripAgencyMemberAgencyMemberIdInput>;
  agencyToAgencyId?: InputMaybe<FkTripAgencyAgencyIdInput>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerId?: InputMaybe<Scalars['UUID']['input']>;
  customerToCustomerId?: InputMaybe<FkTripCustomerCustomerIdInput>;
  dates?: InputMaybe<Scalars['String']['input']>;
  destination?: InputMaybe<Scalars['String']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  emailsUsingId?: InputMaybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: InputMaybe<FkEnquiryTripTripIdInverseInput>;
  expensesUsingId?: InputMaybe<FkExpenseTripTripIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceTripTripIdInverseInput>;
  mediaGalleryId?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryToMediaGalleryId?: InputMaybe<FkTripMediaGalleryMediaGalleryIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notesUsingId?: InputMaybe<FkNoteTripTripIdInverseInput>;
  paymentsUsingId?: InputMaybe<FkPaymentTripTripIdInverseInput>;
  quotePublicsUsingId?: InputMaybe<FakePublicQuotePublicForeignKey0InverseInput>;
  quoteToActiveQuoteId?: InputMaybe<FkTripQuoteActiveQuoteIdInput>;
  quotesUsingId?: InputMaybe<FkQuoteTripTripIdInverseInput>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceTripTripIdInverseInput>;
  testimonialsUsingId?: InputMaybe<FkTestimonialTripTripIdInverseInput>;
  tripFlightsUsingId?: InputMaybe<FkTripFlightTripTripIdInverseInput>;
  tripTravellersUsingId?: InputMaybe<FkTripTravellerTripTripIdInverseInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkTripUserUserIdInput>;
};

/** An object where the defined keys will be set on the `trip` being updated. */
export type UpdateTripOnInvoiceForFkInvoiceTripTripIdPatch = {
  activeQuoteId?: InputMaybe<Scalars['UUID']['input']>;
  agencyId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberToAgencyMemberId?: InputMaybe<FkTripAgencyMemberAgencyMemberIdInput>;
  agencyToAgencyId?: InputMaybe<FkTripAgencyAgencyIdInput>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerId?: InputMaybe<Scalars['UUID']['input']>;
  customerToCustomerId?: InputMaybe<FkTripCustomerCustomerIdInput>;
  dates?: InputMaybe<Scalars['String']['input']>;
  destination?: InputMaybe<Scalars['String']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  emailsUsingId?: InputMaybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: InputMaybe<FkEnquiryTripTripIdInverseInput>;
  expensesUsingId?: InputMaybe<FkExpenseTripTripIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceTripTripIdInverseInput>;
  mediaGalleryId?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryToMediaGalleryId?: InputMaybe<FkTripMediaGalleryMediaGalleryIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notesUsingId?: InputMaybe<FkNoteTripTripIdInverseInput>;
  paymentsUsingId?: InputMaybe<FkPaymentTripTripIdInverseInput>;
  quotePublicsUsingId?: InputMaybe<FakePublicQuotePublicForeignKey0InverseInput>;
  quoteToActiveQuoteId?: InputMaybe<FkTripQuoteActiveQuoteIdInput>;
  quotesUsingId?: InputMaybe<FkQuoteTripTripIdInverseInput>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceTripTripIdInverseInput>;
  testimonialsUsingId?: InputMaybe<FkTestimonialTripTripIdInverseInput>;
  tripFlightsUsingId?: InputMaybe<FkTripFlightTripTripIdInverseInput>;
  tripTravellersUsingId?: InputMaybe<FkTripTravellerTripTripIdInverseInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkTripUserUserIdInput>;
};

/** An object where the defined keys will be set on the `trip` being updated. */
export type UpdateTripOnNoteForFkNoteTripTripIdPatch = {
  activeQuoteId?: InputMaybe<Scalars['UUID']['input']>;
  agencyId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberToAgencyMemberId?: InputMaybe<FkTripAgencyMemberAgencyMemberIdInput>;
  agencyToAgencyId?: InputMaybe<FkTripAgencyAgencyIdInput>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerId?: InputMaybe<Scalars['UUID']['input']>;
  customerToCustomerId?: InputMaybe<FkTripCustomerCustomerIdInput>;
  dates?: InputMaybe<Scalars['String']['input']>;
  destination?: InputMaybe<Scalars['String']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  emailsUsingId?: InputMaybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: InputMaybe<FkEnquiryTripTripIdInverseInput>;
  expensesUsingId?: InputMaybe<FkExpenseTripTripIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceTripTripIdInverseInput>;
  mediaGalleryId?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryToMediaGalleryId?: InputMaybe<FkTripMediaGalleryMediaGalleryIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notesUsingId?: InputMaybe<FkNoteTripTripIdInverseInput>;
  paymentsUsingId?: InputMaybe<FkPaymentTripTripIdInverseInput>;
  quotePublicsUsingId?: InputMaybe<FakePublicQuotePublicForeignKey0InverseInput>;
  quoteToActiveQuoteId?: InputMaybe<FkTripQuoteActiveQuoteIdInput>;
  quotesUsingId?: InputMaybe<FkQuoteTripTripIdInverseInput>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceTripTripIdInverseInput>;
  testimonialsUsingId?: InputMaybe<FkTestimonialTripTripIdInverseInput>;
  tripFlightsUsingId?: InputMaybe<FkTripFlightTripTripIdInverseInput>;
  tripTravellersUsingId?: InputMaybe<FkTripTravellerTripTripIdInverseInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkTripUserUserIdInput>;
};

/** An object where the defined keys will be set on the `trip` being updated. */
export type UpdateTripOnPaymentForFkPaymentTripTripIdPatch = {
  activeQuoteId?: InputMaybe<Scalars['UUID']['input']>;
  agencyId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberToAgencyMemberId?: InputMaybe<FkTripAgencyMemberAgencyMemberIdInput>;
  agencyToAgencyId?: InputMaybe<FkTripAgencyAgencyIdInput>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerId?: InputMaybe<Scalars['UUID']['input']>;
  customerToCustomerId?: InputMaybe<FkTripCustomerCustomerIdInput>;
  dates?: InputMaybe<Scalars['String']['input']>;
  destination?: InputMaybe<Scalars['String']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  emailsUsingId?: InputMaybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: InputMaybe<FkEnquiryTripTripIdInverseInput>;
  expensesUsingId?: InputMaybe<FkExpenseTripTripIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceTripTripIdInverseInput>;
  mediaGalleryId?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryToMediaGalleryId?: InputMaybe<FkTripMediaGalleryMediaGalleryIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notesUsingId?: InputMaybe<FkNoteTripTripIdInverseInput>;
  paymentsUsingId?: InputMaybe<FkPaymentTripTripIdInverseInput>;
  quotePublicsUsingId?: InputMaybe<FakePublicQuotePublicForeignKey0InverseInput>;
  quoteToActiveQuoteId?: InputMaybe<FkTripQuoteActiveQuoteIdInput>;
  quotesUsingId?: InputMaybe<FkQuoteTripTripIdInverseInput>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceTripTripIdInverseInput>;
  testimonialsUsingId?: InputMaybe<FkTestimonialTripTripIdInverseInput>;
  tripFlightsUsingId?: InputMaybe<FkTripFlightTripTripIdInverseInput>;
  tripTravellersUsingId?: InputMaybe<FkTripTravellerTripTripIdInverseInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkTripUserUserIdInput>;
};

/** An object where the defined keys will be set on the `trip` being updated. */
export type UpdateTripOnQuoteForFkQuoteTripTripIdPatch = {
  activeQuoteId?: InputMaybe<Scalars['UUID']['input']>;
  agencyId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberToAgencyMemberId?: InputMaybe<FkTripAgencyMemberAgencyMemberIdInput>;
  agencyToAgencyId?: InputMaybe<FkTripAgencyAgencyIdInput>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerId?: InputMaybe<Scalars['UUID']['input']>;
  customerToCustomerId?: InputMaybe<FkTripCustomerCustomerIdInput>;
  dates?: InputMaybe<Scalars['String']['input']>;
  destination?: InputMaybe<Scalars['String']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  emailsUsingId?: InputMaybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: InputMaybe<FkEnquiryTripTripIdInverseInput>;
  expensesUsingId?: InputMaybe<FkExpenseTripTripIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceTripTripIdInverseInput>;
  mediaGalleryId?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryToMediaGalleryId?: InputMaybe<FkTripMediaGalleryMediaGalleryIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notesUsingId?: InputMaybe<FkNoteTripTripIdInverseInput>;
  paymentsUsingId?: InputMaybe<FkPaymentTripTripIdInverseInput>;
  quotePublicsUsingId?: InputMaybe<FakePublicQuotePublicForeignKey0InverseInput>;
  quoteToActiveQuoteId?: InputMaybe<FkTripQuoteActiveQuoteIdInput>;
  quotesUsingId?: InputMaybe<FkQuoteTripTripIdInverseInput>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceTripTripIdInverseInput>;
  testimonialsUsingId?: InputMaybe<FkTestimonialTripTripIdInverseInput>;
  tripFlightsUsingId?: InputMaybe<FkTripFlightTripTripIdInverseInput>;
  tripTravellersUsingId?: InputMaybe<FkTripTravellerTripTripIdInverseInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkTripUserUserIdInput>;
};

/** An object where the defined keys will be set on the `trip` being updated. */
export type UpdateTripOnQuotePublicForFakePublicQuotePublicForeignKey0Patch = {
  activeQuoteId?: InputMaybe<Scalars['UUID']['input']>;
  agencyId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberToAgencyMemberId?: InputMaybe<FkTripAgencyMemberAgencyMemberIdInput>;
  agencyToAgencyId?: InputMaybe<FkTripAgencyAgencyIdInput>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerId?: InputMaybe<Scalars['UUID']['input']>;
  customerToCustomerId?: InputMaybe<FkTripCustomerCustomerIdInput>;
  dates?: InputMaybe<Scalars['String']['input']>;
  destination?: InputMaybe<Scalars['String']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  emailsUsingId?: InputMaybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: InputMaybe<FkEnquiryTripTripIdInverseInput>;
  expensesUsingId?: InputMaybe<FkExpenseTripTripIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceTripTripIdInverseInput>;
  mediaGalleryId?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryToMediaGalleryId?: InputMaybe<FkTripMediaGalleryMediaGalleryIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notesUsingId?: InputMaybe<FkNoteTripTripIdInverseInput>;
  paymentsUsingId?: InputMaybe<FkPaymentTripTripIdInverseInput>;
  quotePublicsUsingId?: InputMaybe<FakePublicQuotePublicForeignKey0InverseInput>;
  quoteToActiveQuoteId?: InputMaybe<FkTripQuoteActiveQuoteIdInput>;
  quotesUsingId?: InputMaybe<FkQuoteTripTripIdInverseInput>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceTripTripIdInverseInput>;
  testimonialsUsingId?: InputMaybe<FkTestimonialTripTripIdInverseInput>;
  tripFlightsUsingId?: InputMaybe<FkTripFlightTripTripIdInverseInput>;
  tripTravellersUsingId?: InputMaybe<FkTripTravellerTripTripIdInverseInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkTripUserUserIdInput>;
};

/** An object where the defined keys will be set on the `trip` being updated. */
export type UpdateTripOnSupplierInvoiceForFkSupplierInvoiceTripTripIdPatch = {
  activeQuoteId?: InputMaybe<Scalars['UUID']['input']>;
  agencyId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberToAgencyMemberId?: InputMaybe<FkTripAgencyMemberAgencyMemberIdInput>;
  agencyToAgencyId?: InputMaybe<FkTripAgencyAgencyIdInput>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerId?: InputMaybe<Scalars['UUID']['input']>;
  customerToCustomerId?: InputMaybe<FkTripCustomerCustomerIdInput>;
  dates?: InputMaybe<Scalars['String']['input']>;
  destination?: InputMaybe<Scalars['String']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  emailsUsingId?: InputMaybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: InputMaybe<FkEnquiryTripTripIdInverseInput>;
  expensesUsingId?: InputMaybe<FkExpenseTripTripIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceTripTripIdInverseInput>;
  mediaGalleryId?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryToMediaGalleryId?: InputMaybe<FkTripMediaGalleryMediaGalleryIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notesUsingId?: InputMaybe<FkNoteTripTripIdInverseInput>;
  paymentsUsingId?: InputMaybe<FkPaymentTripTripIdInverseInput>;
  quotePublicsUsingId?: InputMaybe<FakePublicQuotePublicForeignKey0InverseInput>;
  quoteToActiveQuoteId?: InputMaybe<FkTripQuoteActiveQuoteIdInput>;
  quotesUsingId?: InputMaybe<FkQuoteTripTripIdInverseInput>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceTripTripIdInverseInput>;
  testimonialsUsingId?: InputMaybe<FkTestimonialTripTripIdInverseInput>;
  tripFlightsUsingId?: InputMaybe<FkTripFlightTripTripIdInverseInput>;
  tripTravellersUsingId?: InputMaybe<FkTripTravellerTripTripIdInverseInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkTripUserUserIdInput>;
};

/** An object where the defined keys will be set on the `trip` being updated. */
export type UpdateTripOnTestimonialForFkTestimonialTripTripIdPatch = {
  activeQuoteId?: InputMaybe<Scalars['UUID']['input']>;
  agencyId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberToAgencyMemberId?: InputMaybe<FkTripAgencyMemberAgencyMemberIdInput>;
  agencyToAgencyId?: InputMaybe<FkTripAgencyAgencyIdInput>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerId?: InputMaybe<Scalars['UUID']['input']>;
  customerToCustomerId?: InputMaybe<FkTripCustomerCustomerIdInput>;
  dates?: InputMaybe<Scalars['String']['input']>;
  destination?: InputMaybe<Scalars['String']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  emailsUsingId?: InputMaybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: InputMaybe<FkEnquiryTripTripIdInverseInput>;
  expensesUsingId?: InputMaybe<FkExpenseTripTripIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceTripTripIdInverseInput>;
  mediaGalleryId?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryToMediaGalleryId?: InputMaybe<FkTripMediaGalleryMediaGalleryIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notesUsingId?: InputMaybe<FkNoteTripTripIdInverseInput>;
  paymentsUsingId?: InputMaybe<FkPaymentTripTripIdInverseInput>;
  quotePublicsUsingId?: InputMaybe<FakePublicQuotePublicForeignKey0InverseInput>;
  quoteToActiveQuoteId?: InputMaybe<FkTripQuoteActiveQuoteIdInput>;
  quotesUsingId?: InputMaybe<FkQuoteTripTripIdInverseInput>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceTripTripIdInverseInput>;
  testimonialsUsingId?: InputMaybe<FkTestimonialTripTripIdInverseInput>;
  tripFlightsUsingId?: InputMaybe<FkTripFlightTripTripIdInverseInput>;
  tripTravellersUsingId?: InputMaybe<FkTripTravellerTripTripIdInverseInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkTripUserUserIdInput>;
};

/** An object where the defined keys will be set on the `trip` being updated. */
export type UpdateTripOnTripFlightForFkTripFlightTripTripIdPatch = {
  activeQuoteId?: InputMaybe<Scalars['UUID']['input']>;
  agencyId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberToAgencyMemberId?: InputMaybe<FkTripAgencyMemberAgencyMemberIdInput>;
  agencyToAgencyId?: InputMaybe<FkTripAgencyAgencyIdInput>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerId?: InputMaybe<Scalars['UUID']['input']>;
  customerToCustomerId?: InputMaybe<FkTripCustomerCustomerIdInput>;
  dates?: InputMaybe<Scalars['String']['input']>;
  destination?: InputMaybe<Scalars['String']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  emailsUsingId?: InputMaybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: InputMaybe<FkEnquiryTripTripIdInverseInput>;
  expensesUsingId?: InputMaybe<FkExpenseTripTripIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceTripTripIdInverseInput>;
  mediaGalleryId?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryToMediaGalleryId?: InputMaybe<FkTripMediaGalleryMediaGalleryIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notesUsingId?: InputMaybe<FkNoteTripTripIdInverseInput>;
  paymentsUsingId?: InputMaybe<FkPaymentTripTripIdInverseInput>;
  quotePublicsUsingId?: InputMaybe<FakePublicQuotePublicForeignKey0InverseInput>;
  quoteToActiveQuoteId?: InputMaybe<FkTripQuoteActiveQuoteIdInput>;
  quotesUsingId?: InputMaybe<FkQuoteTripTripIdInverseInput>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceTripTripIdInverseInput>;
  testimonialsUsingId?: InputMaybe<FkTestimonialTripTripIdInverseInput>;
  tripFlightsUsingId?: InputMaybe<FkTripFlightTripTripIdInverseInput>;
  tripTravellersUsingId?: InputMaybe<FkTripTravellerTripTripIdInverseInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkTripUserUserIdInput>;
};

/** An object where the defined keys will be set on the `trip` being updated. */
export type UpdateTripOnTripForFkTripAgencyAgencyIdPatch = {
  activeQuoteId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberToAgencyMemberId?: InputMaybe<FkTripAgencyMemberAgencyMemberIdInput>;
  agencyToAgencyId?: InputMaybe<FkTripAgencyAgencyIdInput>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerId?: InputMaybe<Scalars['UUID']['input']>;
  customerToCustomerId?: InputMaybe<FkTripCustomerCustomerIdInput>;
  dates?: InputMaybe<Scalars['String']['input']>;
  destination?: InputMaybe<Scalars['String']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  emailsUsingId?: InputMaybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: InputMaybe<FkEnquiryTripTripIdInverseInput>;
  expensesUsingId?: InputMaybe<FkExpenseTripTripIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceTripTripIdInverseInput>;
  mediaGalleryId?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryToMediaGalleryId?: InputMaybe<FkTripMediaGalleryMediaGalleryIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notesUsingId?: InputMaybe<FkNoteTripTripIdInverseInput>;
  paymentsUsingId?: InputMaybe<FkPaymentTripTripIdInverseInput>;
  quotePublicsUsingId?: InputMaybe<FakePublicQuotePublicForeignKey0InverseInput>;
  quoteToActiveQuoteId?: InputMaybe<FkTripQuoteActiveQuoteIdInput>;
  quotesUsingId?: InputMaybe<FkQuoteTripTripIdInverseInput>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceTripTripIdInverseInput>;
  testimonialsUsingId?: InputMaybe<FkTestimonialTripTripIdInverseInput>;
  tripFlightsUsingId?: InputMaybe<FkTripFlightTripTripIdInverseInput>;
  tripTravellersUsingId?: InputMaybe<FkTripTravellerTripTripIdInverseInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkTripUserUserIdInput>;
};

/** An object where the defined keys will be set on the `trip` being updated. */
export type UpdateTripOnTripForFkTripAgencyMemberAgencyMemberIdPatch = {
  activeQuoteId?: InputMaybe<Scalars['UUID']['input']>;
  agencyId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberToAgencyMemberId?: InputMaybe<FkTripAgencyMemberAgencyMemberIdInput>;
  agencyToAgencyId?: InputMaybe<FkTripAgencyAgencyIdInput>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerId?: InputMaybe<Scalars['UUID']['input']>;
  customerToCustomerId?: InputMaybe<FkTripCustomerCustomerIdInput>;
  dates?: InputMaybe<Scalars['String']['input']>;
  destination?: InputMaybe<Scalars['String']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  emailsUsingId?: InputMaybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: InputMaybe<FkEnquiryTripTripIdInverseInput>;
  expensesUsingId?: InputMaybe<FkExpenseTripTripIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceTripTripIdInverseInput>;
  mediaGalleryId?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryToMediaGalleryId?: InputMaybe<FkTripMediaGalleryMediaGalleryIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notesUsingId?: InputMaybe<FkNoteTripTripIdInverseInput>;
  paymentsUsingId?: InputMaybe<FkPaymentTripTripIdInverseInput>;
  quotePublicsUsingId?: InputMaybe<FakePublicQuotePublicForeignKey0InverseInput>;
  quoteToActiveQuoteId?: InputMaybe<FkTripQuoteActiveQuoteIdInput>;
  quotesUsingId?: InputMaybe<FkQuoteTripTripIdInverseInput>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceTripTripIdInverseInput>;
  testimonialsUsingId?: InputMaybe<FkTestimonialTripTripIdInverseInput>;
  tripFlightsUsingId?: InputMaybe<FkTripFlightTripTripIdInverseInput>;
  tripTravellersUsingId?: InputMaybe<FkTripTravellerTripTripIdInverseInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkTripUserUserIdInput>;
};

/** An object where the defined keys will be set on the `trip` being updated. */
export type UpdateTripOnTripForFkTripCustomerCustomerIdPatch = {
  activeQuoteId?: InputMaybe<Scalars['UUID']['input']>;
  agencyId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberToAgencyMemberId?: InputMaybe<FkTripAgencyMemberAgencyMemberIdInput>;
  agencyToAgencyId?: InputMaybe<FkTripAgencyAgencyIdInput>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerToCustomerId?: InputMaybe<FkTripCustomerCustomerIdInput>;
  dates?: InputMaybe<Scalars['String']['input']>;
  destination?: InputMaybe<Scalars['String']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  emailsUsingId?: InputMaybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: InputMaybe<FkEnquiryTripTripIdInverseInput>;
  expensesUsingId?: InputMaybe<FkExpenseTripTripIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceTripTripIdInverseInput>;
  mediaGalleryId?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryToMediaGalleryId?: InputMaybe<FkTripMediaGalleryMediaGalleryIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notesUsingId?: InputMaybe<FkNoteTripTripIdInverseInput>;
  paymentsUsingId?: InputMaybe<FkPaymentTripTripIdInverseInput>;
  quotePublicsUsingId?: InputMaybe<FakePublicQuotePublicForeignKey0InverseInput>;
  quoteToActiveQuoteId?: InputMaybe<FkTripQuoteActiveQuoteIdInput>;
  quotesUsingId?: InputMaybe<FkQuoteTripTripIdInverseInput>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceTripTripIdInverseInput>;
  testimonialsUsingId?: InputMaybe<FkTestimonialTripTripIdInverseInput>;
  tripFlightsUsingId?: InputMaybe<FkTripFlightTripTripIdInverseInput>;
  tripTravellersUsingId?: InputMaybe<FkTripTravellerTripTripIdInverseInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkTripUserUserIdInput>;
};

/** An object where the defined keys will be set on the `trip` being updated. */
export type UpdateTripOnTripForFkTripMediaGalleryMediaGalleryIdPatch = {
  activeQuoteId?: InputMaybe<Scalars['UUID']['input']>;
  agencyId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberToAgencyMemberId?: InputMaybe<FkTripAgencyMemberAgencyMemberIdInput>;
  agencyToAgencyId?: InputMaybe<FkTripAgencyAgencyIdInput>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerId?: InputMaybe<Scalars['UUID']['input']>;
  customerToCustomerId?: InputMaybe<FkTripCustomerCustomerIdInput>;
  dates?: InputMaybe<Scalars['String']['input']>;
  destination?: InputMaybe<Scalars['String']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  emailsUsingId?: InputMaybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: InputMaybe<FkEnquiryTripTripIdInverseInput>;
  expensesUsingId?: InputMaybe<FkExpenseTripTripIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceTripTripIdInverseInput>;
  mediaGalleryToMediaGalleryId?: InputMaybe<FkTripMediaGalleryMediaGalleryIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notesUsingId?: InputMaybe<FkNoteTripTripIdInverseInput>;
  paymentsUsingId?: InputMaybe<FkPaymentTripTripIdInverseInput>;
  quotePublicsUsingId?: InputMaybe<FakePublicQuotePublicForeignKey0InverseInput>;
  quoteToActiveQuoteId?: InputMaybe<FkTripQuoteActiveQuoteIdInput>;
  quotesUsingId?: InputMaybe<FkQuoteTripTripIdInverseInput>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceTripTripIdInverseInput>;
  testimonialsUsingId?: InputMaybe<FkTestimonialTripTripIdInverseInput>;
  tripFlightsUsingId?: InputMaybe<FkTripFlightTripTripIdInverseInput>;
  tripTravellersUsingId?: InputMaybe<FkTripTravellerTripTripIdInverseInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkTripUserUserIdInput>;
};

/** An object where the defined keys will be set on the `trip` being updated. */
export type UpdateTripOnTripForFkTripQuoteActiveQuoteIdPatch = {
  agencyId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberToAgencyMemberId?: InputMaybe<FkTripAgencyMemberAgencyMemberIdInput>;
  agencyToAgencyId?: InputMaybe<FkTripAgencyAgencyIdInput>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerId?: InputMaybe<Scalars['UUID']['input']>;
  customerToCustomerId?: InputMaybe<FkTripCustomerCustomerIdInput>;
  dates?: InputMaybe<Scalars['String']['input']>;
  destination?: InputMaybe<Scalars['String']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  emailsUsingId?: InputMaybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: InputMaybe<FkEnquiryTripTripIdInverseInput>;
  expensesUsingId?: InputMaybe<FkExpenseTripTripIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceTripTripIdInverseInput>;
  mediaGalleryId?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryToMediaGalleryId?: InputMaybe<FkTripMediaGalleryMediaGalleryIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notesUsingId?: InputMaybe<FkNoteTripTripIdInverseInput>;
  paymentsUsingId?: InputMaybe<FkPaymentTripTripIdInverseInput>;
  quotePublicsUsingId?: InputMaybe<FakePublicQuotePublicForeignKey0InverseInput>;
  quoteToActiveQuoteId?: InputMaybe<FkTripQuoteActiveQuoteIdInput>;
  quotesUsingId?: InputMaybe<FkQuoteTripTripIdInverseInput>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceTripTripIdInverseInput>;
  testimonialsUsingId?: InputMaybe<FkTestimonialTripTripIdInverseInput>;
  tripFlightsUsingId?: InputMaybe<FkTripFlightTripTripIdInverseInput>;
  tripTravellersUsingId?: InputMaybe<FkTripTravellerTripTripIdInverseInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkTripUserUserIdInput>;
};

/** An object where the defined keys will be set on the `trip` being updated. */
export type UpdateTripOnTripForFkTripUserUserIdPatch = {
  activeQuoteId?: InputMaybe<Scalars['UUID']['input']>;
  agencyId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberToAgencyMemberId?: InputMaybe<FkTripAgencyMemberAgencyMemberIdInput>;
  agencyToAgencyId?: InputMaybe<FkTripAgencyAgencyIdInput>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerId?: InputMaybe<Scalars['UUID']['input']>;
  customerToCustomerId?: InputMaybe<FkTripCustomerCustomerIdInput>;
  dates?: InputMaybe<Scalars['String']['input']>;
  destination?: InputMaybe<Scalars['String']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  emailsUsingId?: InputMaybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: InputMaybe<FkEnquiryTripTripIdInverseInput>;
  expensesUsingId?: InputMaybe<FkExpenseTripTripIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceTripTripIdInverseInput>;
  mediaGalleryId?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryToMediaGalleryId?: InputMaybe<FkTripMediaGalleryMediaGalleryIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notesUsingId?: InputMaybe<FkNoteTripTripIdInverseInput>;
  paymentsUsingId?: InputMaybe<FkPaymentTripTripIdInverseInput>;
  quotePublicsUsingId?: InputMaybe<FakePublicQuotePublicForeignKey0InverseInput>;
  quoteToActiveQuoteId?: InputMaybe<FkTripQuoteActiveQuoteIdInput>;
  quotesUsingId?: InputMaybe<FkQuoteTripTripIdInverseInput>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceTripTripIdInverseInput>;
  testimonialsUsingId?: InputMaybe<FkTestimonialTripTripIdInverseInput>;
  tripFlightsUsingId?: InputMaybe<FkTripFlightTripTripIdInverseInput>;
  tripTravellersUsingId?: InputMaybe<FkTripTravellerTripTripIdInverseInput>;
  userToUserId?: InputMaybe<FkTripUserUserIdInput>;
};

/** An object where the defined keys will be set on the `trip` being updated. */
export type UpdateTripOnTripTravellerForFkTripTravellerTripTripIdPatch = {
  activeQuoteId?: InputMaybe<Scalars['UUID']['input']>;
  agencyId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberId?: InputMaybe<Scalars['UUID']['input']>;
  agencyMemberToAgencyMemberId?: InputMaybe<FkTripAgencyMemberAgencyMemberIdInput>;
  agencyToAgencyId?: InputMaybe<FkTripAgencyAgencyIdInput>;
  archived?: InputMaybe<Scalars['Datetime']['input']>;
  baseCurrency?: InputMaybe<Scalars['String']['input']>;
  created?: InputMaybe<Scalars['Datetime']['input']>;
  customerId?: InputMaybe<Scalars['UUID']['input']>;
  customerToCustomerId?: InputMaybe<FkTripCustomerCustomerIdInput>;
  dates?: InputMaybe<Scalars['String']['input']>;
  destination?: InputMaybe<Scalars['String']['input']>;
  duration?: InputMaybe<Scalars['Int']['input']>;
  emailsUsingId?: InputMaybe<FkEmailTripTripIdInverseInput>;
  enquiriesUsingId?: InputMaybe<FkEnquiryTripTripIdInverseInput>;
  expensesUsingId?: InputMaybe<FkExpenseTripTripIdInverseInput>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  invoicesUsingId?: InputMaybe<FkInvoiceTripTripIdInverseInput>;
  mediaGalleryId?: InputMaybe<Scalars['UUID']['input']>;
  mediaGalleryToMediaGalleryId?: InputMaybe<FkTripMediaGalleryMediaGalleryIdInput>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notesUsingId?: InputMaybe<FkNoteTripTripIdInverseInput>;
  paymentsUsingId?: InputMaybe<FkPaymentTripTripIdInverseInput>;
  quotePublicsUsingId?: InputMaybe<FakePublicQuotePublicForeignKey0InverseInput>;
  quoteToActiveQuoteId?: InputMaybe<FkTripQuoteActiveQuoteIdInput>;
  quotesUsingId?: InputMaybe<FkQuoteTripTripIdInverseInput>;
  start?: InputMaybe<Scalars['Datetime']['input']>;
  status?: InputMaybe<Scalars['Int']['input']>;
  summary?: InputMaybe<Scalars['String']['input']>;
  supplierInvoicesUsingId?: InputMaybe<FkSupplierInvoiceTripTripIdInverseInput>;
  testimonialsUsingId?: InputMaybe<FkTestimonialTripTripIdInverseInput>;
  tripFlightsUsingId?: InputMaybe<FkTripFlightTripTripIdInverseInput>;
  tripTravellersUsingId?: InputMaybe<FkTripTravellerTripTripIdInverseInput>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userToUserId?: InputMaybe<FkTripUserUserIdInput>;
};

/** An object where the defined keys will be set on the `tripTraveller` being updated. */
export type UpdateTripTravellerOnTripTravellerForFkTripTravellerTravellerTravellerIdPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  travellerToTravellerId?: InputMaybe<FkTripTravellerTravellerTravellerIdInput>;
  tripId?: InputMaybe<Scalars['UUID']['input']>;
  tripToTripId?: InputMaybe<FkTripTravellerTripTripIdInput>;
};

/** An object where the defined keys will be set on the `tripTraveller` being updated. */
export type UpdateTripTravellerOnTripTravellerForFkTripTravellerTripTripIdPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  travellerId?: InputMaybe<Scalars['UUID']['input']>;
  travellerToTravellerId?: InputMaybe<FkTripTravellerTravellerTravellerIdInput>;
  tripToTripId?: InputMaybe<FkTripTravellerTripTripIdInput>;
};

/** An object where the defined keys will be set on the `user` being updated. */
export type UpdateUserOnEmailForFkEmailUserUserIdPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  emailsUsingId?: InputMaybe<FkEmailUserUserIdInverseInput>;
  externalId?: InputMaybe<Scalars['String']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  genderPreposition?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notesUsingId?: InputMaybe<FkNoteUserUserIdInverseInput>;
  password?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  quotePublicsUsingId?: InputMaybe<FakePublicQuotePublicForeignKey2InverseInput>;
  quotesUsingId?: InputMaybe<FkQuoteUserUserIdInverseInput>;
  remindersUsingId?: InputMaybe<FkReminderUserUserIdInverseInput>;
  skype?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  transactionNotesUsingId?: InputMaybe<FkTransactionNoteUserUserIdInverseInput>;
  tripsUsingId?: InputMaybe<FkTripUserUserIdInverseInput>;
};

/** An object where the defined keys will be set on the `user` being updated. */
export type UpdateUserOnNoteForFkNoteUserUserIdPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  emailsUsingId?: InputMaybe<FkEmailUserUserIdInverseInput>;
  externalId?: InputMaybe<Scalars['String']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  genderPreposition?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notesUsingId?: InputMaybe<FkNoteUserUserIdInverseInput>;
  password?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  quotePublicsUsingId?: InputMaybe<FakePublicQuotePublicForeignKey2InverseInput>;
  quotesUsingId?: InputMaybe<FkQuoteUserUserIdInverseInput>;
  remindersUsingId?: InputMaybe<FkReminderUserUserIdInverseInput>;
  skype?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  transactionNotesUsingId?: InputMaybe<FkTransactionNoteUserUserIdInverseInput>;
  tripsUsingId?: InputMaybe<FkTripUserUserIdInverseInput>;
};

/** An object where the defined keys will be set on the `user` being updated. */
export type UpdateUserOnQuoteForFkQuoteUserUserIdPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  emailsUsingId?: InputMaybe<FkEmailUserUserIdInverseInput>;
  externalId?: InputMaybe<Scalars['String']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  genderPreposition?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notesUsingId?: InputMaybe<FkNoteUserUserIdInverseInput>;
  password?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  quotePublicsUsingId?: InputMaybe<FakePublicQuotePublicForeignKey2InverseInput>;
  quotesUsingId?: InputMaybe<FkQuoteUserUserIdInverseInput>;
  remindersUsingId?: InputMaybe<FkReminderUserUserIdInverseInput>;
  skype?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  transactionNotesUsingId?: InputMaybe<FkTransactionNoteUserUserIdInverseInput>;
  tripsUsingId?: InputMaybe<FkTripUserUserIdInverseInput>;
};

/** An object where the defined keys will be set on the `user` being updated. */
export type UpdateUserOnQuotePublicForFakePublicQuotePublicForeignKey2Patch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  emailsUsingId?: InputMaybe<FkEmailUserUserIdInverseInput>;
  externalId?: InputMaybe<Scalars['String']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  genderPreposition?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notesUsingId?: InputMaybe<FkNoteUserUserIdInverseInput>;
  password?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  quotePublicsUsingId?: InputMaybe<FakePublicQuotePublicForeignKey2InverseInput>;
  quotesUsingId?: InputMaybe<FkQuoteUserUserIdInverseInput>;
  remindersUsingId?: InputMaybe<FkReminderUserUserIdInverseInput>;
  skype?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  transactionNotesUsingId?: InputMaybe<FkTransactionNoteUserUserIdInverseInput>;
  tripsUsingId?: InputMaybe<FkTripUserUserIdInverseInput>;
};

/** An object where the defined keys will be set on the `user` being updated. */
export type UpdateUserOnReminderForFkReminderUserUserIdPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  emailsUsingId?: InputMaybe<FkEmailUserUserIdInverseInput>;
  externalId?: InputMaybe<Scalars['String']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  genderPreposition?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notesUsingId?: InputMaybe<FkNoteUserUserIdInverseInput>;
  password?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  quotePublicsUsingId?: InputMaybe<FakePublicQuotePublicForeignKey2InverseInput>;
  quotesUsingId?: InputMaybe<FkQuoteUserUserIdInverseInput>;
  remindersUsingId?: InputMaybe<FkReminderUserUserIdInverseInput>;
  skype?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  transactionNotesUsingId?: InputMaybe<FkTransactionNoteUserUserIdInverseInput>;
  tripsUsingId?: InputMaybe<FkTripUserUserIdInverseInput>;
};

/** An object where the defined keys will be set on the `user` being updated. */
export type UpdateUserOnTransactionNoteForFkTransactionNoteUserUserIdPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  emailsUsingId?: InputMaybe<FkEmailUserUserIdInverseInput>;
  externalId?: InputMaybe<Scalars['String']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  genderPreposition?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notesUsingId?: InputMaybe<FkNoteUserUserIdInverseInput>;
  password?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  quotePublicsUsingId?: InputMaybe<FakePublicQuotePublicForeignKey2InverseInput>;
  quotesUsingId?: InputMaybe<FkQuoteUserUserIdInverseInput>;
  remindersUsingId?: InputMaybe<FkReminderUserUserIdInverseInput>;
  skype?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  transactionNotesUsingId?: InputMaybe<FkTransactionNoteUserUserIdInverseInput>;
  tripsUsingId?: InputMaybe<FkTripUserUserIdInverseInput>;
};

/** An object where the defined keys will be set on the `user` being updated. */
export type UpdateUserOnTripForFkTripUserUserIdPatch = {
  created?: InputMaybe<Scalars['Datetime']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  emailsUsingId?: InputMaybe<FkEmailUserUserIdInverseInput>;
  externalId?: InputMaybe<Scalars['String']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  genderPreposition?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['UUID']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  modified?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notesUsingId?: InputMaybe<FkNoteUserUserIdInverseInput>;
  password?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  quotePublicsUsingId?: InputMaybe<FakePublicQuotePublicForeignKey2InverseInput>;
  quotesUsingId?: InputMaybe<FkQuoteUserUserIdInverseInput>;
  remindersUsingId?: InputMaybe<FkReminderUserUserIdInverseInput>;
  skype?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  transactionNotesUsingId?: InputMaybe<FkTransactionNoteUserUserIdInverseInput>;
  tripsUsingId?: InputMaybe<FkTripUserUserIdInverseInput>;
};

export type GetDestinationQueryVariables = Exact<{
  id: Scalars['UUID']['input'];
}>;


export type GetDestinationQuery = { __typename?: 'Query', destination?: { __typename?: 'Destination', id: any, name?: string | null, body?: string | null, latitude?: number | null, longitude?: number | null, country?: { __typename?: 'Country', id: any, name?: string | null } | null, heroMedia?: { __typename?: 'MediaItem', id: any, hash?: string | null } | null, gallery?: { __typename?: 'MediaGallery', id: any, mediaGalleryItems: { __typename?: 'MediaGalleryItemsConnection', nodes: Array<{ __typename?: 'MediaGalleryItem', id: any, mediaItem?: { __typename?: 'MediaItem', hash?: string | null, name?: string | null } | null } | null> }, childMediaGalleries: { __typename?: 'MediaGalleriesConnection', nodes: Array<{ __typename?: 'MediaGallery', id: any, name?: string | null, mediaGalleryItems: { __typename?: 'MediaGalleryItemsConnection', nodes: Array<{ __typename?: 'MediaGalleryItem', id: any, mediaItem?: { __typename?: 'MediaItem', name?: string | null, hash?: string | null } | null } | null> } } | null> } } | null } | null };

export type SubmitEnquiryMutationVariables = Exact<{
  input: SubmitEnquiryInput;
}>;


export type SubmitEnquiryMutation = { __typename?: 'Mutation', submitEnquiry?: { __typename?: 'GenericResponse', success: boolean } | null };

export type GetInvoiceQueryVariables = Exact<{
  id: Scalars['UUID']['input'];
}>;


export type GetInvoiceQuery = { __typename?: 'Query', invoice?: { __typename?: 'InvoicePublic', amount?: any | null, amountDue?: any | null, amountPaid?: any | null, currency?: string | null, due?: string | null, id: any, invoiced?: string | null, number?: number | null, paid?: string | null, summary?: string | null, trip?: string | null } | null };

export type PayInvoiceMutationVariables = Exact<{
  invoice: Scalars['UUID']['input'];
  token: Scalars['String']['input'];
  amount?: InputMaybe<Scalars['BigFloat']['input']>;
}>;


export type PayInvoiceMutation = { __typename?: 'Mutation', executePayment?: { __typename?: 'GenericResponse', success: boolean, message?: string | null } | null };

export type GetLegalDocumentQueryVariables = Exact<{
  id: Scalars['UUID']['input'];
}>;


export type GetLegalDocumentQuery = { __typename?: 'Query', entity?: { __typename?: 'LegalDocument', id: any, name: string, body: string } | null };

export type GetPropertyQueryVariables = Exact<{
  id: Scalars['UUID']['input'];
}>;


export type GetPropertyQuery = { __typename?: 'Query', property?: { __typename?: 'Property', id: any, name?: string | null, city?: string | null, summary?: string | null, nearestAirport?: string | null, latitude?: number | null, longitude?: number | null, country?: { __typename?: 'Country', id: any, name?: string | null } | null, heroMedia?: { __typename?: 'MediaItem', id: any, hash?: string | null } | null, gallery?: { __typename?: 'MediaGallery', id: any, mediaGalleryItems: { __typename?: 'MediaGalleryItemsConnection', nodes: Array<{ __typename?: 'MediaGalleryItem', id: any, mediaItem?: { __typename?: 'MediaItem', hash?: string | null, name?: string | null } | null } | null> }, childMediaGalleries: { __typename?: 'MediaGalleriesConnection', nodes: Array<{ __typename?: 'MediaGallery', id: any, name?: string | null, mediaGalleryItems: { __typename?: 'MediaGalleryItemsConnection', nodes: Array<{ __typename?: 'MediaGalleryItem', id: any, mediaItem?: { __typename?: 'MediaItem', name?: string | null, hash?: string | null } | null } | null> } } | null> } } | null } | null };

export type GetFeaturedPropertyQueryVariables = Exact<{ [key: string]: never; }>;


export type GetFeaturedPropertyQuery = { __typename?: 'Query', featuredProperty?: { __typename?: 'Property', id: any, name?: string | null, featureCopy?: string | null, heroMedia?: { __typename?: 'MediaItem', hash?: string | null, fileName?: string | null } | null } | null };

export type AcceptQuoteMutationVariables = Exact<{
  key: Scalars['String']['input'];
  name: Scalars['String']['input'];
  email: Scalars['String']['input'];
  date: Scalars['String']['input'];
  source: Scalars['String']['input'];
}>;


export type AcceptQuoteMutation = { __typename?: 'Mutation', acceptQuote?: { __typename?: 'GenericResponse', success: boolean, message?: string | null } | null };

export type GetQuoteQueryVariables = Exact<{
  key: Scalars['String']['input'];
}>;


export type GetQuoteQuery = { __typename?: 'Query', quote?: { __typename?: 'QuotePublic', id?: any | null, status?: number | null, start?: string | null, duration?: number | null, travellerCount?: number | null, total?: any | null, baseCurrency?: string | null, inclusions?: string | null, exclusions?: string | null, expires?: string | null, locked?: string | null, hero?: { __typename?: 'QuoteHero', title?: string | null, subtitle?: string | null, image?: { __typename?: 'MediaItem', hash?: string | null } | null } | null, user?: { __typename?: 'User', lastName?: string | null, firstName?: string | null, email?: string | null, phone?: string | null, genderPreposition?: string | null } | null, trip?: { __typename?: 'Trip', name?: string | null, agency?: { __typename?: 'Agency', name?: string | null, logo?: { __typename?: 'MediaItem', hash?: string | null } | null } | null, agencyMember?: { __typename?: 'AgencyMember', lastName?: string | null, firstName?: string | null, phone?: string | null, email?: string | null, genderPreposition?: string | null } | null, tripFlights: { __typename?: 'TripFlightsConnection', nodes: Array<{ __typename?: 'TripFlight', id: any, arrival: string, carrier?: string | null, departure: string, number?: string | null, notes?: string | null, departureAirport?: { __typename?: 'Airport', id: any, latitude: number, longitude: number, iata?: string | null, icao?: string | null, timezone?: string | null, city?: string | null, country?: { __typename?: 'Country', name?: string | null } | null } | null, arrivalAirport?: { __typename?: 'Airport', id: any, latitude: number, longitude: number, iata?: string | null, icao?: string | null, timezone?: string | null, city?: string | null, country?: { __typename?: 'Country', name?: string | null } | null } | null } | null> } } | null, days: { __typename?: 'QuoteDaysConnection', nodes: Array<{ __typename?: 'QuoteDay', id: any, date?: string | null, sortOrder: number, activitySummary?: string | null, activityDetail?: string | null, accommodationId?: any | null, quoteDayDestinationsByDayId: { __typename?: 'QuoteDayDestinationsConnection', nodes: Array<{ __typename?: 'QuoteDayDestination', sortOrder: number, destination?: { __typename?: 'Destination', id: any, name?: string | null } | null } | null> } } | null> }, accommodation: { __typename?: 'QuoteAccommodationDetailsConnection', nodes: Array<{ __typename?: 'QuoteAccommodationDetail', id: any, sortOrder: number, basis?: string | null, confirmation?: string | null, beverageInclusions?: Array<string | null> | null, foodInclusions?: Array<string | null> | null, roomType?: string | null, property?: { __typename?: 'Property', id: any, name?: string | null, summary?: string | null, latitude?: number | null, longitude?: number | null, heroMedia?: { __typename?: 'MediaItem', hash?: string | null } | null } | null } | null> }, legalDocuments: { __typename?: 'QuoteLegalDocumentsConnection', nodes: Array<{ __typename?: 'QuoteLegalDocument', id: any, sortOrder: number, legalDocument?: { __typename?: 'LegalDocument', id: any, name: string } | null } | null> } } | null };

export type TrackQuoteViewMutationVariables = Exact<{
  ip: Scalars['String']['input'];
  key: Scalars['String']['input'];
  viewType: Scalars['String']['input'];
}>;


export type TrackQuoteViewMutation = { __typename?: 'Mutation', trackQuoteView?: { __typename?: 'GenericResponse', success: boolean } | null };


export const GetDestinationDocument = gql`
    query GetDestination($id: UUID!) {
  destination(id: $id) {
    id
    name
    body
    country {
      id
      name
    }
    latitude
    longitude
    heroMedia {
      id
      hash
    }
    gallery {
      id
      mediaGalleryItems {
        nodes {
          id
          mediaItem {
            hash
            name
          }
        }
      }
      childMediaGalleries {
        nodes {
          id
          name
          mediaGalleryItems {
            nodes {
              id
              mediaItem {
                name
                hash
              }
            }
          }
        }
      }
    }
  }
}
    `;

/**
 * __useGetDestinationQuery__
 *
 * To run a query within a React component, call `useGetDestinationQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetDestinationQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetDestinationQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetDestinationQuery(baseOptions: Apollo.QueryHookOptions<GetDestinationQuery, GetDestinationQueryVariables> & ({ variables: GetDestinationQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetDestinationQuery, GetDestinationQueryVariables>(GetDestinationDocument, options);
      }
export function useGetDestinationLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetDestinationQuery, GetDestinationQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetDestinationQuery, GetDestinationQueryVariables>(GetDestinationDocument, options);
        }
export function useGetDestinationSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetDestinationQuery, GetDestinationQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetDestinationQuery, GetDestinationQueryVariables>(GetDestinationDocument, options);
        }
export type GetDestinationQueryHookResult = ReturnType<typeof useGetDestinationQuery>;
export type GetDestinationLazyQueryHookResult = ReturnType<typeof useGetDestinationLazyQuery>;
export type GetDestinationSuspenseQueryHookResult = ReturnType<typeof useGetDestinationSuspenseQuery>;
export type GetDestinationQueryResult = Apollo.QueryResult<GetDestinationQuery, GetDestinationQueryVariables>;
export const SubmitEnquiryDocument = gql`
    mutation SubmitEnquiry($input: SubmitEnquiryInput!) {
  submitEnquiry(input: $input) {
    success
  }
}
    `;
export type SubmitEnquiryMutationFn = Apollo.MutationFunction<SubmitEnquiryMutation, SubmitEnquiryMutationVariables>;

/**
 * __useSubmitEnquiryMutation__
 *
 * To run a mutation, you first call `useSubmitEnquiryMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSubmitEnquiryMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [submitEnquiryMutation, { data, loading, error }] = useSubmitEnquiryMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useSubmitEnquiryMutation(baseOptions?: Apollo.MutationHookOptions<SubmitEnquiryMutation, SubmitEnquiryMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SubmitEnquiryMutation, SubmitEnquiryMutationVariables>(SubmitEnquiryDocument, options);
      }
export type SubmitEnquiryMutationHookResult = ReturnType<typeof useSubmitEnquiryMutation>;
export type SubmitEnquiryMutationResult = Apollo.MutationResult<SubmitEnquiryMutation>;
export type SubmitEnquiryMutationOptions = Apollo.BaseMutationOptions<SubmitEnquiryMutation, SubmitEnquiryMutationVariables>;
export const GetInvoiceDocument = gql`
    query GetInvoice($id: UUID!) {
  invoice: invoicePublic(id: $id) {
    amount
    amountDue
    amountPaid
    currency
    due
    id
    invoiced
    number
    paid
    summary
    trip
  }
}
    `;

/**
 * __useGetInvoiceQuery__
 *
 * To run a query within a React component, call `useGetInvoiceQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetInvoiceQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetInvoiceQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetInvoiceQuery(baseOptions: Apollo.QueryHookOptions<GetInvoiceQuery, GetInvoiceQueryVariables> & ({ variables: GetInvoiceQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetInvoiceQuery, GetInvoiceQueryVariables>(GetInvoiceDocument, options);
      }
export function useGetInvoiceLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetInvoiceQuery, GetInvoiceQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetInvoiceQuery, GetInvoiceQueryVariables>(GetInvoiceDocument, options);
        }
export function useGetInvoiceSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetInvoiceQuery, GetInvoiceQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetInvoiceQuery, GetInvoiceQueryVariables>(GetInvoiceDocument, options);
        }
export type GetInvoiceQueryHookResult = ReturnType<typeof useGetInvoiceQuery>;
export type GetInvoiceLazyQueryHookResult = ReturnType<typeof useGetInvoiceLazyQuery>;
export type GetInvoiceSuspenseQueryHookResult = ReturnType<typeof useGetInvoiceSuspenseQuery>;
export type GetInvoiceQueryResult = Apollo.QueryResult<GetInvoiceQuery, GetInvoiceQueryVariables>;
export const PayInvoiceDocument = gql`
    mutation PayInvoice($invoice: UUID!, $token: String!, $amount: BigFloat) {
  executePayment(input: {invoice: $invoice, token: $token, amount: $amount}) {
    success
    message
  }
}
    `;
export type PayInvoiceMutationFn = Apollo.MutationFunction<PayInvoiceMutation, PayInvoiceMutationVariables>;

/**
 * __usePayInvoiceMutation__
 *
 * To run a mutation, you first call `usePayInvoiceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `usePayInvoiceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [payInvoiceMutation, { data, loading, error }] = usePayInvoiceMutation({
 *   variables: {
 *      invoice: // value for 'invoice'
 *      token: // value for 'token'
 *      amount: // value for 'amount'
 *   },
 * });
 */
export function usePayInvoiceMutation(baseOptions?: Apollo.MutationHookOptions<PayInvoiceMutation, PayInvoiceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<PayInvoiceMutation, PayInvoiceMutationVariables>(PayInvoiceDocument, options);
      }
export type PayInvoiceMutationHookResult = ReturnType<typeof usePayInvoiceMutation>;
export type PayInvoiceMutationResult = Apollo.MutationResult<PayInvoiceMutation>;
export type PayInvoiceMutationOptions = Apollo.BaseMutationOptions<PayInvoiceMutation, PayInvoiceMutationVariables>;
export const GetLegalDocumentDocument = gql`
    query GetLegalDocument($id: UUID!) {
  entity: legalDocument(id: $id) {
    id
    name
    body
  }
}
    `;

/**
 * __useGetLegalDocumentQuery__
 *
 * To run a query within a React component, call `useGetLegalDocumentQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetLegalDocumentQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetLegalDocumentQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetLegalDocumentQuery(baseOptions: Apollo.QueryHookOptions<GetLegalDocumentQuery, GetLegalDocumentQueryVariables> & ({ variables: GetLegalDocumentQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetLegalDocumentQuery, GetLegalDocumentQueryVariables>(GetLegalDocumentDocument, options);
      }
export function useGetLegalDocumentLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetLegalDocumentQuery, GetLegalDocumentQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetLegalDocumentQuery, GetLegalDocumentQueryVariables>(GetLegalDocumentDocument, options);
        }
export function useGetLegalDocumentSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetLegalDocumentQuery, GetLegalDocumentQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetLegalDocumentQuery, GetLegalDocumentQueryVariables>(GetLegalDocumentDocument, options);
        }
export type GetLegalDocumentQueryHookResult = ReturnType<typeof useGetLegalDocumentQuery>;
export type GetLegalDocumentLazyQueryHookResult = ReturnType<typeof useGetLegalDocumentLazyQuery>;
export type GetLegalDocumentSuspenseQueryHookResult = ReturnType<typeof useGetLegalDocumentSuspenseQuery>;
export type GetLegalDocumentQueryResult = Apollo.QueryResult<GetLegalDocumentQuery, GetLegalDocumentQueryVariables>;
export const GetPropertyDocument = gql`
    query GetProperty($id: UUID!) {
  property(id: $id) {
    id
    name
    city
    summary
    nearestAirport
    country {
      id
      name
    }
    latitude
    longitude
    heroMedia {
      id
      hash
    }
    gallery {
      id
      mediaGalleryItems {
        nodes {
          id
          mediaItem {
            hash
            name
          }
        }
      }
      childMediaGalleries {
        nodes {
          id
          name
          mediaGalleryItems {
            nodes {
              id
              mediaItem {
                name
                hash
              }
            }
          }
        }
      }
    }
  }
}
    `;

/**
 * __useGetPropertyQuery__
 *
 * To run a query within a React component, call `useGetPropertyQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPropertyQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPropertyQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetPropertyQuery(baseOptions: Apollo.QueryHookOptions<GetPropertyQuery, GetPropertyQueryVariables> & ({ variables: GetPropertyQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetPropertyQuery, GetPropertyQueryVariables>(GetPropertyDocument, options);
      }
export function useGetPropertyLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPropertyQuery, GetPropertyQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetPropertyQuery, GetPropertyQueryVariables>(GetPropertyDocument, options);
        }
export function useGetPropertySuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetPropertyQuery, GetPropertyQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetPropertyQuery, GetPropertyQueryVariables>(GetPropertyDocument, options);
        }
export type GetPropertyQueryHookResult = ReturnType<typeof useGetPropertyQuery>;
export type GetPropertyLazyQueryHookResult = ReturnType<typeof useGetPropertyLazyQuery>;
export type GetPropertySuspenseQueryHookResult = ReturnType<typeof useGetPropertySuspenseQuery>;
export type GetPropertyQueryResult = Apollo.QueryResult<GetPropertyQuery, GetPropertyQueryVariables>;
export const GetFeaturedPropertyDocument = gql`
    query GetFeaturedProperty {
  featuredProperty {
    id
    name
    featureCopy
    heroMedia {
      hash
      fileName
    }
  }
}
    `;

/**
 * __useGetFeaturedPropertyQuery__
 *
 * To run a query within a React component, call `useGetFeaturedPropertyQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetFeaturedPropertyQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetFeaturedPropertyQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetFeaturedPropertyQuery(baseOptions?: Apollo.QueryHookOptions<GetFeaturedPropertyQuery, GetFeaturedPropertyQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetFeaturedPropertyQuery, GetFeaturedPropertyQueryVariables>(GetFeaturedPropertyDocument, options);
      }
export function useGetFeaturedPropertyLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetFeaturedPropertyQuery, GetFeaturedPropertyQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetFeaturedPropertyQuery, GetFeaturedPropertyQueryVariables>(GetFeaturedPropertyDocument, options);
        }
export function useGetFeaturedPropertySuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetFeaturedPropertyQuery, GetFeaturedPropertyQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetFeaturedPropertyQuery, GetFeaturedPropertyQueryVariables>(GetFeaturedPropertyDocument, options);
        }
export type GetFeaturedPropertyQueryHookResult = ReturnType<typeof useGetFeaturedPropertyQuery>;
export type GetFeaturedPropertyLazyQueryHookResult = ReturnType<typeof useGetFeaturedPropertyLazyQuery>;
export type GetFeaturedPropertySuspenseQueryHookResult = ReturnType<typeof useGetFeaturedPropertySuspenseQuery>;
export type GetFeaturedPropertyQueryResult = Apollo.QueryResult<GetFeaturedPropertyQuery, GetFeaturedPropertyQueryVariables>;
export const AcceptQuoteDocument = gql`
    mutation AcceptQuote($key: String!, $name: String!, $email: String!, $date: String!, $source: String!) {
  acceptQuote(
    input: {key: $key, name: $name, email: $email, source: $source, date: $date}
  ) {
    success
    message
  }
}
    `;
export type AcceptQuoteMutationFn = Apollo.MutationFunction<AcceptQuoteMutation, AcceptQuoteMutationVariables>;

/**
 * __useAcceptQuoteMutation__
 *
 * To run a mutation, you first call `useAcceptQuoteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAcceptQuoteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [acceptQuoteMutation, { data, loading, error }] = useAcceptQuoteMutation({
 *   variables: {
 *      key: // value for 'key'
 *      name: // value for 'name'
 *      email: // value for 'email'
 *      date: // value for 'date'
 *      source: // value for 'source'
 *   },
 * });
 */
export function useAcceptQuoteMutation(baseOptions?: Apollo.MutationHookOptions<AcceptQuoteMutation, AcceptQuoteMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AcceptQuoteMutation, AcceptQuoteMutationVariables>(AcceptQuoteDocument, options);
      }
export type AcceptQuoteMutationHookResult = ReturnType<typeof useAcceptQuoteMutation>;
export type AcceptQuoteMutationResult = Apollo.MutationResult<AcceptQuoteMutation>;
export type AcceptQuoteMutationOptions = Apollo.BaseMutationOptions<AcceptQuoteMutation, AcceptQuoteMutationVariables>;
export const GetQuoteDocument = gql`
    query GetQuote($key: String!) {
  quote: quotePublic(key: $key) {
    id
    status
    start
    duration
    travellerCount
    total
    baseCurrency
    inclusions
    exclusions
    expires
    locked
    hero {
      title
      subtitle
      image {
        hash
      }
    }
    user {
      lastName
      firstName
      email
      phone
      genderPreposition
    }
    trip {
      name
      agency {
        name
        logo {
          hash
        }
      }
      agencyMember {
        lastName
        firstName
        phone
        email
        genderPreposition
      }
      tripFlights(orderBy: DEPARTURE_ASC) {
        nodes {
          id
          arrival
          carrier
          departure
          number
          notes
          departureAirport {
            id
            latitude
            longitude
            iata
            icao
            timezone
            city
            country {
              name
            }
          }
          arrivalAirport {
            id
            latitude
            longitude
            iata
            icao
            timezone
            city
            country {
              name
            }
          }
        }
      }
    }
    days: quoteDaysByQuoteId(orderBy: SORT_ORDER_ASC) {
      nodes {
        id
        date
        sortOrder
        activitySummary
        activityDetail
        accommodationId
        quoteDayDestinationsByDayId(orderBy: SORT_ORDER_ASC) {
          nodes {
            sortOrder
            destination {
              id
              name
            }
          }
        }
      }
    }
    accommodation: quoteAccommodationDetailsByQuoteId(orderBy: SORT_ORDER_ASC) {
      nodes {
        id
        sortOrder
        basis
        confirmation
        beverageInclusions
        foodInclusions
        roomType
        property {
          id
          name
          summary
          latitude
          longitude
          heroMedia {
            hash
          }
        }
      }
    }
    legalDocuments: quoteLegalDocumentsByQuoteId(orderBy: SORT_ORDER_ASC) {
      nodes {
        id
        sortOrder
        legalDocument {
          id
          name
        }
      }
    }
  }
}
    `;

/**
 * __useGetQuoteQuery__
 *
 * To run a query within a React component, call `useGetQuoteQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetQuoteQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetQuoteQuery({
 *   variables: {
 *      key: // value for 'key'
 *   },
 * });
 */
export function useGetQuoteQuery(baseOptions: Apollo.QueryHookOptions<GetQuoteQuery, GetQuoteQueryVariables> & ({ variables: GetQuoteQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetQuoteQuery, GetQuoteQueryVariables>(GetQuoteDocument, options);
      }
export function useGetQuoteLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetQuoteQuery, GetQuoteQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetQuoteQuery, GetQuoteQueryVariables>(GetQuoteDocument, options);
        }
export function useGetQuoteSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetQuoteQuery, GetQuoteQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetQuoteQuery, GetQuoteQueryVariables>(GetQuoteDocument, options);
        }
export type GetQuoteQueryHookResult = ReturnType<typeof useGetQuoteQuery>;
export type GetQuoteLazyQueryHookResult = ReturnType<typeof useGetQuoteLazyQuery>;
export type GetQuoteSuspenseQueryHookResult = ReturnType<typeof useGetQuoteSuspenseQuery>;
export type GetQuoteQueryResult = Apollo.QueryResult<GetQuoteQuery, GetQuoteQueryVariables>;
export const TrackQuoteViewDocument = gql`
    mutation TrackQuoteView($ip: String!, $key: String!, $viewType: String!) {
  trackQuoteView(input: {ip: $ip, key: $key, viewType: $viewType}) {
    success
  }
}
    `;
export type TrackQuoteViewMutationFn = Apollo.MutationFunction<TrackQuoteViewMutation, TrackQuoteViewMutationVariables>;

/**
 * __useTrackQuoteViewMutation__
 *
 * To run a mutation, you first call `useTrackQuoteViewMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useTrackQuoteViewMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [trackQuoteViewMutation, { data, loading, error }] = useTrackQuoteViewMutation({
 *   variables: {
 *      ip: // value for 'ip'
 *      key: // value for 'key'
 *      viewType: // value for 'viewType'
 *   },
 * });
 */
export function useTrackQuoteViewMutation(baseOptions?: Apollo.MutationHookOptions<TrackQuoteViewMutation, TrackQuoteViewMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<TrackQuoteViewMutation, TrackQuoteViewMutationVariables>(TrackQuoteViewDocument, options);
      }
export type TrackQuoteViewMutationHookResult = ReturnType<typeof useTrackQuoteViewMutation>;
export type TrackQuoteViewMutationResult = Apollo.MutationResult<TrackQuoteViewMutation>;
export type TrackQuoteViewMutationOptions = Apollo.BaseMutationOptions<TrackQuoteViewMutation, TrackQuoteViewMutationVariables>;

      export interface PossibleTypesResultData {
        possibleTypes: {
          [key: string]: string[]
        }
      }
      const result: PossibleTypesResultData = {
  "possibleTypes": {}
};
      export default result;
    